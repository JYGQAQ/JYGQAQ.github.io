

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="JVM学习一、什么是JVM定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 好处   一次编写，到处运行   自动内存管理，垃圾回收机制   数组下标越界检查（比如C语言本身不提供数组下标越界检查，可能会导致覆盖其他代码的内存，这是十分严重的）   多态（虚方法表）  比较JDK &#x3D; (JRE + 编译工具(javac、javap)) &#x3D; (J">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习">
<meta property="og:url" content="http://example.com/2023/05/04/JVM%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="贾勇刚的博客">
<meta property="og:description" content="JVM学习一、什么是JVM定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 好处   一次编写，到处运行   自动内存管理，垃圾回收机制   数组下标越界检查（比如C语言本身不提供数组下标越界检查，可能会导致覆盖其他代码的内存，这是十分严重的）   多态（虚方法表）  比较JDK &#x3D; (JRE + 编译工具(javac、javap)) &#x3D; (J">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/6AFlth.png">
<meta property="article:published_time" content="2023-05-04T11:57:59.000Z">
<meta property="article:modified_time" content="2023-05-04T12:01:24.542Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/6AFlth.png">
  
  
  <title>JVM学习 - 贾勇刚的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>贾勇刚的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-05-04 19:57" pubdate>
        May 4, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      145k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1208 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM学习</h1>
            
            <div class="markdown-body">
              <h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>  一次编写，到处运行</li>
<li>  自动内存管理，垃圾回收机制</li>
<li>  数组下标越界检查（比如C语言本身不提供数组下标越界检查，可能会导致覆盖其他代码的内存，这是十分严重的）</li>
<li>  多态（虚方法表）</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong><code>JDK = (JRE + 编译工具(javac、javap)) = (JVM + 基础类库(java.util..) + 编译工具(javac、javap))</code></strong></p>
<p><strong><code>JavaEE = (JavaSE + 应用服务器(tomcat ...)) = (JDK + ID工具(IDEA...) + 应用服务器(tomcat ...))</code></strong></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150422.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="常见JVM"><a href="#常见JVM" class="headerlink" title="常见JVM"></a>常见JVM</h3><p><code>JVM</code>是一套规范，只要符合这一套规范就可以称为<code>JVM</code>。比较常用的是<code>Sun</code>或<code>Oracle</code>公司的<code>HotSpot</code>的<code>JVM</code>。并且本篇博客以<code>HotSpot</code>为准。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220827153133041.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><code>JVM</code>整体结构主要有类加载器模块、内存架构以及执行引擎。执行流程是，java源代码编译为java二进制字节码文件，然后通过类加载器加载进<code>JVM    </code>去运行，类放在方法区，类创建的实例对象放在堆里，而堆里的实例对象调用方法时又会用到虚拟机栈、程序计数器和本地方法栈。方法运行时每一行代码是由执行引擎中的解释器逐行执行，方法里的热点代码（也就是频繁调用的代码）会被<code>JIT Compiler</code>即时编译器进行编译执行（优化后的执行）。而垃圾回收模块会对堆里面不再引用的对象进行垃圾回收。当然还有一些java代码不方便实现的功能，必须调用底层操作系统的功能，所以需要通过本地方法接口来调用操作系统调用。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150440.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>Program Counter Register程序计数器（寄存器)，程序计数器是java对于物理硬件的屏蔽和抽象，在物理上是通过寄存器来实现的。寄存器是CPU里读取速度最快的单元，又因为读取指令地址是非常频繁的，所以JVM在设计时就把寄存器当做了程序计数器用它来存储地址。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM指令中下一条所要执行的指令的地址，比如下图所示二进制字节码文件中jvm指令前的数字就是jvm指令的地址。当解释器将当前jvm指令编译成机器码之后，会去程序计数器获得下一条jvm指令的地址，当解释器获得了jvm指令地址时，程序计数器会加载在下一条jvm指令地址，以此类推。</p>
<blockquote>
<p>Java是解释执行还是编译执行？</p>
<p>这个问题并没有统一的答案，JVM规范并没有强制要求JVM实现应该使用哪种方式来执行程序，只能说不同的JVM实现的方式不一样。有纯解释执行的、纯编译执行的（JRockit）、还有解释+编译两者混用的（HotSpot）</p>
<p>解释器与编译器两者各有优势：</p>
<ol>
<li>当程序需要迅速启动时，解释器可以发挥优势，省去编译的时间，立即执行。</li>
<li>程序启动后，随着时间的推移，编译器开始发挥作用，JVM会将越来越多的热点代码编译成本地代码，减少解释器的中间损耗，获得更高的执行效率。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220827162459828.png" srcset="/img/loading.gif" lazyload></p>
<p>java源代码会被先编译成二进制字节码文件，然后通过解释器再编译为机器码，最后机器码被CPU运行。<code>二进制字节码（也叫jvm指令）</code>和<code>java源代码</code>在所有平台是一样的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>线程私有</p>
<ul>
<li>  当多个线程运行时，CPU的调度器组件会为每个线程分配时间片，当当前线程的时间片使用完以后，并且当前线程没有执行结束那么会把当前线程的状态进行一个暂存，CPU就会去执行另一个线程中的代码。</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令。</li>
</ul>
</li>
<li><p>在JVM规范中唯一一个不会存在内存溢出的区，其他的区都可能会出现内存溢出。</p>
<blockquote>
<p>首先，我们熟悉的栈和堆，都是可以通过运行时对内存需求的扩增导致内存不够用的情况。比如某个线程递归调用，随着调用层次的加深，可能会出现栈空间不足的情况，这时候如果可以动态扩增，jvm就会向申请更多的内存空间来扩充栈，当没有更多的内存空间得以申请的时候，就会发生OutOfMemoryError。</p>
<p>但是，程序计算器仅仅只是一个运行指示器，它所需要存储的内容仅仅就是下一个需要待执行的命令的地址，无论代码有多少，最坏情况下死循环也不会让这块内存区域超限，因为程序计算器所维护的就是下一条待执行的命令的地址，所以不存在OutOfMemoryError。只存下一个字节码指令的地址，消耗内存小且固定，无论方法多深，他只存一条。只针对一个线程，随着线程的结束而销毁。</p>
</blockquote>
</li>
</ul>
<h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存（参数，局部变量，返回地址（当前方法执行结束后，需要返回到的代码地址）等等）</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>（虚拟机栈栈顶的栈帧），对应着<strong>当前正在执行的方法</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220828132812433.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method1();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>		method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> c = a + b;<br>		<span class="hljs-keyword">return</span> c;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150534.png" srcset="/img/loading.gif" lazyload></p>
<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。<blockquote>
<p>通过-Xsssize 设置线程栈大小(以字节为单位)。用字母k或K表示KB、m或M表示MB，用G表示GB。默认值取决于平台(windows默认值取决于虚拟内存)。需要注意的是-Xss和size之间不允许有空格。</p>
<p>在使用javac Xxx.java生成字节码文件后，java -Xss 1m Xxx就可以指定栈大小运行程序。</p>
</blockquote>
</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了（堆里的）对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">4</span>);<br>        sb.append(<span class="hljs-number">5</span>);<br>        sb.append(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            m2(sb);<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面例子中，m1()一定是线程安全的；m2()不一定是线程安全的，因为sb是作为参数传进来的，sb可以被其他线程访问，又因为StringBuilder本身就不是线程安全的，所以m2()不是线程安全的；m3()不一定是线程安全的，因为sb是作为返回值返回了，sb可以被其他线程访问，又因为StringBuilder本身就不是线程安全的，所以m3()不是线程安全的</p>
</blockquote>
m2()发生了线程逃逸；而m3()发生了方法逃逸。方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</li>
</ul>
</li>
</ul>
<h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong>异常， 栈内存溢出</p>
<p><strong>发生原因</strong></p>
<ul>
<li><p>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method1();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>        method1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在IDEA的<code>VM options</code>中，通过<code>-Xss</code>减小栈大小，可以观察到count减小了。</strong></p>
</li>
<li><p>每个栈帧<strong>所占用过大</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dept d = <span class="hljs-keyword">new</span> Dept();<br>        d.setName(<span class="hljs-string">&quot;market&quot;</span>);<br><br>        Emp e1 = <span class="hljs-keyword">new</span> Emp();<br>        e1.setName(<span class="hljs-string">&quot;zhang&quot;</span>);<br>        e1.setDept(d);<br><br>        Emp e2 = <span class="hljs-keyword">new</span> Emp();<br>        e2.setName(<span class="hljs-string">&quot;li&quot;</span>);<br>        e2.setDept(d);<br><br>        d.setEmps(Arrays.asList(e1, e2));<br><br>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        System.out.println(mapper.writeValueAsString(d));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Dept dept;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">getDept</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dept;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept</span><span class="hljs-params">(Dept dept)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dept = dept;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">getEmps</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> emps;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmps</span><span class="hljs-params">(List&lt;Emp&gt; emps)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.emps = emps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不写<code>@JsonIgnore</code>那么，员工类和部门类之间存在循环引用，那么在转换成json时，会导致栈内存溢出。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220828150042752.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>案例1：CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程  <code>nohup java 某个二进制字节码文件 &amp;</code> <strong>&amp; ： 指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出。 nohup ： 不挂断的运行，注意并没有后台运行的功能，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行。</strong><ul>
<li>  <strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高，然后通过<strong>ps -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高（-e 打印正在运行的所有进程相关信息，-o格式化输出）</li>
<li>  <strong>jstack 进程id</strong> 可以列出该进程中所有线程，通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong>。然后查看是哪一个类中的哪一行代码出现了问题。<strong>需要注意的是，jstack列出的tid指的是jvm中java线程id，nid才是操作系统映射的线程id，每一个java线程都有一个对应的操作系统线程。</strong></li>
</ul>
</li>
</ul>
<p>案例2：程序运行很长时间没有结果</p>
<p><code>nohup java 某个二进制字节码文件 &amp;</code> 会返回进程id，然后使用<code>jstack pid</code>列出该进程中所有线程，如果有死锁，会在最后显示在哪几行代码出现死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Object a = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> Object b = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (a) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (b) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;get a and b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (b) &#123;<br>                <span class="hljs-keyword">synchronized</span> (a) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;get a and b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829131244745.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法（不是由java编写的方法）就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。这些本地方法运行时，使用的内存就是本地方法栈。本地方法是非常多的，不管是java类库里，还是执行引擎里都会频繁调用本地方法。</p>
<h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><p>上面讲解的程序计数器、虚拟机栈以及本地方法栈都是线程私有的，且没有垃圾回收机制；而堆和方法区都是线程共有的，而且有垃圾回收机制。</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>  <strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>  有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError : java heap space</strong>. 堆内存溢出。被引用的对象过多导致堆内存溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                list.add(str);<br>                str += str;<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过<code>-Xmxsize</code>指定最大堆内存空间；<code>-Xmssize</code>初始的堆内存空间的大小。</strong></p>
<h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul>
<li><p><strong>jps</strong>，查看当前系统中有哪些java进程。</p>
<p><code>jps</code>直接查看有哪些java进程。</p>
</li>
<li><p><strong>jmap</strong>，查看堆内存占用情况，不过只能查看某一时刻的堆内存占用情况，但是有一个缺点就是在debug模式下抓不到变量个数。</p>
<p><code>jmap -heap pid</code>查看该进行堆信息。<code>-heap 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;1... jmap -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">30000</span>);<br>        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]; <span class="hljs-comment">//10MB</span><br>        System.out.println(<span class="hljs-string">&quot;2... jmap -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">30000</span>);<br>        array = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;3... jamp -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到堆内存的新生代内存占用从1的低点上升到2的高点，最后又下降3的低点。</p>
<p><code>jmap -dump:format=b,live,file=filename.bin pid</code>，<code>-dump</code>选项是将当前堆内存转储，<code>format=b</code>是指储存格式为二进制，<code>live</code>是指在存储前主动做一次GC，<code>file=filename.bin</code>是指存储的文件名。存储的文件可以使用<code>eclipse</code>的工具<code>MAT</code>查看。</p>
</li>
<li><p><strong>jconsole</strong>，图形界面的，多功能的检测工具，可以连续检测</p>
<p><code>jconsole</code>然后连接对应进程，就可以看到图形界面的堆内存使用情况。</p>
<p>仍然使用上面的<code>Test2</code>代码，可以看到下图中的上升和下降，分别对应分配10MB数组内存和手动gc。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132016293.png" srcset="/img/loading.gif" lazyload></p>
<p>同样的，在<code>线程</code>的详细信息里，可以检测死锁，查看死锁具体情况。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132356930.png" srcset="/img/loading.gif" lazyload></p>
<p>此外，<code>jconsole</code>图形界面，还可以手动执行gc，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132805285.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><strong>jvisualvm</strong></p>
<p>案例：垃圾回收后，内存占用仍然很高。</p>
<p><code>jvisualvm</code>命令，可以像jconsole一样可视化堆内存等等，但是功能更加强大，使用<code>堆dump</code>保存当前堆的快照也就是堆转储功能，但是jdk8以上已经不自动安装了。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829135339529.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829135734035.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><strong>jinfo</strong>:实时查看指定Java pid 进程的虚拟机指定参数情况。</p>
<p><code>jinfo -flag option pid</code>会返回指定参数的情况，[+|-]name 或者 name=value。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo -flag CMSInitiatingOccupancyFraction 1444<br>输出<br>-XX:CMSInitialtingOccupancyFraction=85<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Oraclejdk1.8文档</a></p>
<p><code>JVM</code>方法区是所有java虚拟机线程共享的区域。方法区类似于用于传统语言的编译代码的存储区，或者类似于操作系统进程中的“text”段。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p>
<p>方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但还是要看各厂商的具体实现，各厂商不一定遵从。<code>HotSpot</code>在JDK1.8之前，方法区是在堆内存中使用永久代作为具体实现，而在JDK1.8及以后，使用在本地内存的元空间作为具体实现。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194635728.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Java7及以前版本的Hotspot中方法区位于永久代中</strong>。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829141802064.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jdk.internal.org.objectweb.asm.ClassWriter;<br><span class="hljs-keyword">import</span> jdk.internal.org.objectweb.asm.Opcodes;<br><br><span class="hljs-comment">//设置元空间内存大小 -XX:MaxMetaspaceSize=size</span><br><span class="hljs-comment">//设置永久代内存大小 -XX:MaxPermSize=size</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<span class="hljs-comment">//可以用来加载类的二进制字节码</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Test2 test = <span class="hljs-keyword">new</span> Test2();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;<br>                <span class="hljs-comment">//ClassWriter 作用是生成类的二进制字节码</span><br>                ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//jdk版本号，public，类名，包名，父类，接口</span><br>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//返回byte[]</span><br>                <span class="hljs-keyword">byte</span>[] code = cw.toByteArray();<br>                <span class="hljs-comment">//执行类加载</span><br>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">//Class对象</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>//设置元空间内存大小 -XX:MaxMetaspaceSize=size<br>//设置永久代内存大小 -XX:MaxPermSize=size</p>
</blockquote>
<p>方法区内存溢出，也会抛出<code>OutofMemoryError</code>异常。</p>
<ul>
<li>  1.8以前会导致<strong>永久代</strong>内存溢出<code>OutofMemoryError : PermGen space </code></li>
<li>  1.8及以后会导致<strong>元空间</strong>内存溢出<code>OutofMemoryError : Metaspace</code></li>
</ul>
<p>实际场景：Spring和Mybatis框架都使用了大量的字节码技术，都会使用到cglib都会动态加载类，可能会导致方法区内存溢出。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p><strong>通过反编译来查看类的信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>获得对应类的.class文件  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java ./Test.java<br></code></pre></td></tr></table></figure>
</li>
<li>在控制台输入 javap -v 类的绝对路径，-v参数显示反编译的详细信息。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javap -v ./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test2</span>.</span></span><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure>
</li>
<li>然后能在控制台看到反编译以后类的信息了<ul>
<li>类的基本信息  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153349173.png" srcset="/img/loading.gif" lazyload></li>
<li>常量池  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153415363.png" srcset="/img/loading.gif" lazyload></li>
<li>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153316170.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>常量池<ul>
<li>  就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量（如字符串、整数、布尔值等等）信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>  常量池是.class文件中的，当该类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址（#num）变为真实地址</li>
</ul>
</li>
</ul>
<h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p>
<ul>
<li><p>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p>
</li>
<li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p>
</li>
<li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
</li>
<li><p>只有字节码命令<code>ldc</code>加载字符串，如果该字符串对象在串池中没有，才会将字符串对象放入串池。只有在代码里，存在的字符串常量（包括拼接形成的字符串常量，或者主动Intern()的字符串）才会被加载入串池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个代码总共形成了五个对象，串池中的<code>[&quot;a&quot;, &quot;b&quot;]</code>，以及堆中的<code>new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)</code></p>
</li>
<li><p>  <strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p>
</li>
</ul>
<p>用来放字符串对象且里面的<strong>元素不重复</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String s1 = <span class="hljs-string">&quot;a&quot;</span>; <br>		String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>		String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当运行二进制字节码文件时，常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串对象</strong>。只有执行到那一行字节码指令时，才会被加载入串池并成为对象，这是一个懒惰的行为。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String a</span><br><span class="hljs-attr">2:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String b</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">astore_2</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">astore_3</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>去串池中查找是否存在“a”对象，如果没有则放入串池(StringTable)中</strong>（hashtable结构且不可扩容）</p>
<p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，去串池中查找是否存在“b”对象，如果没有则放入串池中</p>
<p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，去串池中查找是否存在“ab”对象，如果没有则放入串池中</p>
<p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><code>astore_1</code>、<code>astore_2</code>和<code>astore_3</code>分别是将加载的字符串放入局部变量表<code>LocalVaribleTable</code>中槽<code>Slot</code>1、2和3中。</p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>		String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>		String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>		String s4 = s1 + s2; <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">	 Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a 在串池中寻找&quot;a&quot;，如果没有放入串池</span><br>         <span class="hljs-number">2</span>: astore_1							把串池对象<span class="hljs-string">&quot;a&quot;</span>的地址放入局部变量表中的<span class="hljs-number">1</span>位置<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b 在串池中寻找&quot;b&quot;，如果没有放入串池</span><br>         <span class="hljs-number">5</span>: astore_2							把串池对象<span class="hljs-string">&quot;b&quot;</span>的地址放入局部变量表中的<span class="hljs-number">2</span>位置<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab 在串池中寻找&quot;ab&quot;，如果没有放入串池</span><br>         <span class="hljs-number">8</span>: astore_3							把串池对象<span class="hljs-string">&quot;ab&quot;</span>的地址放入局部变量表中的<span class="hljs-number">3</span>位置<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 无参构造器</span><br>        <span class="hljs-number">16</span>: aload_1								从局部变量表中的<span class="hljs-number">1</span>位置获得变量<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;						调用append()<br>        <span class="hljs-number">20</span>: aload_2								从局部变量表中的<span class="hljs-number">2</span>位置获得变量<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;						调用append()<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;											调用toString()<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>						把toString()的结果放入局部变量表中的<span class="hljs-number">4</span>位置<br>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，是使用<code>new String()</code>创建的字符串对象，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s4 = a+b;<br><span class="hljs-comment">//结果为false,因为s3是存在于串池之中，s4是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(s3 == s4);<br></code></pre></td></tr></table></figure>

<p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>		String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>		String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		String s4 = a+b;<br>		<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>		String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"> 	  Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>						<br>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab s5初始化时直接从常量池中获取字符串，并在串池中寻找&quot;ab&quot;,如果没有将&quot;ab&quot;对象加入串池</span><br>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>						将上一步的返回结果放入局部变量表中Slot为<span class="hljs-number">5</span>的位置<br>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<ul>
<li>  使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac命令在编译期会进行优化，结果已在编译期确定为ab</strong>，而在串池中创建”ab”对象的时候已经在串池中放入了“ab”，所以s5直接从串池中获取值，所以进行的操作和 s3 = “ab” 一致。</li>
<li>  使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>
</ul>
<h5 id="字符串对象创建是懒惰的"><a href="#字符串对象创建是懒惰的" class="headerlink" title="字符串对象创建是懒惰的"></a>字符串对象创建是懒惰的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1 + s2;<br>        String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在第三行和第四行打上端点，然后利用debug工具进行调试，发现字符串对象的创建确实是懒惰的。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829163948853.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="JDK1-8中，String-intern-方法"><a href="#JDK1-8中，String-intern-方法" class="headerlink" title="JDK1.8中，String.intern()方法"></a>JDK1.8中，String.intern()方法</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中。<strong>注意，这个放入动作是指，将字符串对象的地址放入串池，而不是说在串池这个地方放入字符串对象。</strong></p>
<ul>
<li>  如果串池中没有该字符串对象，则放入成功</li>
<li>  如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象。大致含义是，当调用intern方法时，如果池中已经包含了一个由equals(Object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>
<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>		<span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>		String str2 = str.intern();<br>		<span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>		System.out.println(str == st2);<br>		System.out.println(str == str3);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>		String str2 = str.intern();<br>        <span class="hljs-comment">//false</span><br>		System.out.println(str == str2);<br>        <span class="hljs-comment">//false</span><br>		System.out.println(str == str3);<br>        <span class="hljs-comment">//true</span><br>		System.out.println(str2 == str3);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="JDK1-6中String-intern-方法"><a href="#JDK1-6中String-intern-方法" class="headerlink" title="JDK1.6中String.intern()方法"></a>JDK1.6中String.intern()方法</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>  如果串池中没有该字符串对象，会将该字符串对象复制一份，再将新对象的地址放入到串池中</li>
<li>  如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>		<span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会创建一个新的&quot;ab&quot;并将该新对象地址放入串池中，此时堆内存与串池中的&quot;ab&quot;不是同一个对象</span><br>		String str2 = str.intern();<br>		<span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;不是同一个对象，所以以下两条语句打印的都为false</span><br>		System.out.println(str == st2);<br>		System.out.println(str == str3);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829195956469.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829195406274.png" srcset="/img/loading.gif" lazyload></p>
<p>为什么JDK1.8要把StringTable从永久代中移到堆中呢？因为永久代的内存回收效率很低，需要fullGC时，才会触发垃圾回收。fullGC需要等到老年代的内存不足，才会触发，触发时机比较晚，但是StringTable的使用效率很频繁，如果StringTable的回收效率不高会导致占用大量内存，进而导致永久代的内存不足。故而从JDK1.7开始，StringTable被移到了堆中，只需要minorGC就可以触发垃圾回收。</p>
<p>那么如何通过实验来证明上述的观点呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">260000</span>; j++) &#123;<br>                list.add((<span class="hljs-string">&quot;&quot;</span> + j).intern());<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>然后在jdk1.8中设置最大堆内存 -Xmx10m 和 打开GC频率限制 -UseGCOverheadlimit（防止频繁发生GC而发生异常<code>OutOfMemoryError:GC overhead limit exceeded</code>。然后运行程序会发生，<code>java.lang.OutOfMemoryError: Java heap space</code></p>
<p>在jdk1.6中设置最大永久代内存 -XX：MaxPermSize=10m，然后运行会发生<code>OutofMemoryError : PermGen space</code></p>
</blockquote>
<h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，StringTable中那些没有被引用的字符串常量会被垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;<br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>设置最大堆内存-Xmx10m；在jvm进程退出时会输出SymbolTable statistics及StringTable statistics  -XX:+PrintStringTableStatistics； 在每次GC时打印详细消息 -XX:+PrintGCDetails；  显示有关每个垃圾收集(GC)事件的信息。 -verbose:gc </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829210227410.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul>
<li>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，那么哈希碰撞的概率就会减小，查找的速度也会变快。如果桶的个数比较少，那么哈希碰撞的概率增大，链表（红黑树）的长度变长，查找和增删的效率变慢。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, UnsupportedEncodingException </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;linux.words&quot;</span>), <span class="hljs-string">&quot;utf-8&quot;</span>)))&#123;<br>            <span class="hljs-comment">//try()中的代码一般放的是对资源的声明，try代码块执行完后，()中的资源就会自动关闭；如果&#123;&#125;中的代码出项了异常，()中的资源也会自动关闭。jdk1.7以上可用</span><br>            String line = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                line = reader.readLine();<br>                <span class="hljs-keyword">if</span> (line == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                line.intern();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>-XX:StringTableSize=xx 设置StringTable桶的个数 Number of buckets in the interned String table</p>
<p>-XX:+PrintStringTableStatistic 在jvm进程退出时会输出SymbolTable statistics及StringTable statistics  </p>
<p>可以观察到，当StringTable的数量减少时，耗费的总时间增大。</p>
</blockquote>
</li>
<li>考虑是否需要将字符串对象入池，可以通过<strong>intern()方法返回串池对象，防止大量重复字符串占用堆内存。</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        List&lt;String&gt; address = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        System.in.read(); <span class="hljs-comment">//从标准输入读入一个字节，起到停顿作用</span><br>        <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;linux.words&quot;</span>), <span class="hljs-string">&quot;utf-8&quot;</span>)))&#123;<br>            <span class="hljs-comment">//try()中的代码一般放的是对资源的声明，try代码块执行完后，()中的资源就会自动关闭；如果&#123;&#125;中的代码出项了异常，()中的资源也会自动关闭。jdk1.7以上可用</span><br>            String line = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                line = reader.readLine();<br>                <span class="hljs-keyword">if</span> (line == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                address.add(line.intern());<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1000000</span>);<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
  使用<code>visualvm</code>查看，使用串池对象和堆内对象占用内存比较，发现使用串池对象大大减小了内存占用。  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829213427702.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul>
<li>  不属于JVM内存，而属于操作系统内存，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>  <strong>分配回收成本较高，但读写性能高</strong></li>
<li>  <strong>不受JVM内存回收管理</strong></li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p>java代码本身不具备读取文件的能力，需要调用操作系统提供的接口。所以需要切换到从用户态切换到内核态去读取文件，但是为了高效利用内存，所以需要多次调用操作系统函数来完成整个文件的读取。同样，内存方面也是需要先从磁盘读取到系统缓存区（操作系统内存中），但是系统内存Java代码也不能直接使用，故而需要再读到Java堆内存的缓冲区中。为了高效利用内存，也需要多次重复这个过程。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194744288.png" srcset="/img/loading.gif" lazyload></p>
<p>使用<strong>DirectBuffer</strong>之后，</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194811783.png" srcset="/img/loading.gif" lazyload></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而<strong>成倍</strong>提高了效率。例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 ByteBuffer 作用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_9</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FROM = <span class="hljs-string">&quot;./bigFile.zip&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TO = <span class="hljs-string">&quot;./bigFileCopy.zip&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        io(); <span class="hljs-comment">// io 用时：1535.586957 1766.963399 1359.240226</span><br>        directBuffer(); <span class="hljs-comment">// directBuffer 用时：479.295165 702.291454 562.56592</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();<br>             FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();<br>        ) &#123;<br>            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb); <span class="hljs-comment">//分配直接内存</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = from.read(bb);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                bb.flip();<br>                to.write(bb);<br>                bb.clear();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileInputStream from = <span class="hljs-keyword">new</span> FileInputStream(FROM);<br>             FileOutputStream to = <span class="hljs-keyword">new</span> FileOutputStream(TO);<br>        ) &#123;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1Mb];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = from.read(buf);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                to.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h4><p>会抛出<code>java.lang.OutOfMemoryError : Direct buffer memory</code>异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示直接内存溢出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_10</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _100Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);<br>                list.add(byteBuffer);<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-comment">// 方法区是jvm规范， jdk6 中对方法区的实现称为永久代</span><br>        <span class="hljs-comment">//                  jdk8 对方法区的实现称为元空间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p><strong>直接内存不是由JVM管理的，故而不能使用那些检测JVM的工具来观察，需要使用操作系统的监控程序来观察。</strong>直接内存的回收不是通过JVM的垃圾回收来释放的，而是必须通过<strong>unsafe.freeMemory</strong>来手动释放（不推荐普通程序员直接使用Unsafe类，都是JDK内部使用）。</p>
<p><strong>但是我们观察到，调用System.gc()会释放掉直接内存。不是说JVM的垃圾回收不会释放直接内存吗？这是为什么。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，Full GC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面展示，<code>Unsafe</code>类申请和释放直接内存的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直接内存分配的底层原理：Unsafe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_27</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Unsafe unsafe = getUnsafe();<br>        <span class="hljs-comment">// 分配内存</span><br>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1Gb); <span class="hljs-comment">//返回直接内存的地址</span><br>        unsafe.setMemory(base, _1Gb, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>        System.in.read();<br><br>        <span class="hljs-comment">// 释放内存</span><br>        unsafe.freeMemory(base);<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field f = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            Unsafe unsafe = (Unsafe) f.get(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> unsafe;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="直接内存回收机制"><a href="#直接内存回收机制" class="headerlink" title="直接内存回收机制"></a>直接内存回收机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Cleaner</code>类继承了<code>PhantomReference&lt;Object&gt;</code>类，它是一个虚引用类，<code>Cleaner</code>类的<code>create</code>方法会将后面的回调任务对象（<code>Deallocator</code>类对象，因为该类实现了<code>Runnable</code>接口，所以叫任务对象）关联到前面的<code>DirectByteBuffer</code>类对象上，同时回调任务对象在初始化时就收到了直接内存的地址。</p>
<p>虚引用类的特点是，当它关联的对象被垃圾回收时，会触发虚引用类对象的<code>clean()</code>方法，当然这个<code>clean()</code>方法不是在主线程执行的，而是在<code>ReferenceHandler</code>线程上执行的（<code>ReferenceHandler</code>是一个守护线程，<code>ReferenceHandler</code>线程专门在后台检测这些虚引用对象，一旦虚引用对象关联的实际对象被垃圾回收了，就会调用虚引用对象的<code>clean()</code>方法，<code>clean()</code>方法中会去执行回调任务对象的<code>run()</code>方法）。</p>
<blockquote>
<p> 解读：这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存。</p>
</blockquote>
<p><code>Cleaner</code>虚引用类的<code>clean()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法，thuck对象就是Deallocator类的回调任务对象</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure>

<p><code>Deallocator</code>类的回调任务对象的run方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>直接内存的回收机制总结</strong></p>
<ul>
<li>  使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用Unsafe类的freeMemory()方法</li>
<li>  ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler线程来调用Cleaner的clean方法调用回调任务对象的run方法来使用freeMemory方法释放内存。</li>
</ul>
<h4 id="禁用显示垃圾回收对直接内存的影响"><a href="#禁用显示垃圾回收对直接内存的影响" class="headerlink" title="禁用显示垃圾回收对直接内存的影响"></a>禁用显示垃圾回收对直接内存的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁用显式回收对直接内存的影响</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * -XX:+DisableExplicitGC 显式的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，触发Full GC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-XX:+DisableExplicitGC 禁用显式的垃圾回收</p>
<p>显式垃圾回收，即System.gc()，会触发Full GC。而Full GC不光要回收新生代，也会回收老年代，会造成程序暂停时间比较长，影响程序性能。为了防止一些程序员不小心在自己代码里经常显式垃圾回收影响程序性能，需要加上这个虚拟机参数来进行JVM调优。</p>
</blockquote>
<p>因为禁用了显式垃圾回收，可能会出现当前内存比较充裕，使得ByteBuffer对象得不到垃圾回收，直接内存也不会被释放，导致直到下次JVM自动垃圾回收之前直接内存长时间的占用系统内存。这种情况下，需要利用反射得到Unsafe对象，来直接调用freeMemory方法来手动释放直接内存。</p>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><p>这里有两种方法可以判断对象是否可回收，分别是引用计数法和可达性分析算法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法，就是如果一个对象如果被一个变量引用，那么这个对象的引用计数就加1。如果一个变量不再引用该对象了，就将该对象的引用计数减1。那么如果一个对象的引用计数变为0，那么就意味着没有变量引用该对象了，可以作为垃圾进行回收了。</p>
<p>弊端：循环引用时，两个对象的计数都为1，且这两个对象没有其他变量引用，导致两个对象都无法被释放。这就导致垃圾得不到及时的回收。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194839880.png" srcset="/img/loading.gif" lazyload></p>
<p>因为这种循环引用的弊端，JVM并没有采用引用计数法来判断对象是否可以垃圾回收。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>  JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>  扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象<ul>
<li>  虚拟机栈（栈帧中的本地变量表）中引用的对象。譬如当前正在运行的方法所使用到的参数、局部变量、临时变量等。　</li>
<li>  方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>  方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li>
<li>  本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
<li>  Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointerException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>  所有被同步锁（synchronized关键字）持有的对象。</li>
<li>  反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
<li>  除了上面这些固定的GC Roots集合外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</li>
</ul>
</li>
</ul>
<h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p>下图中实线是强引用，虚线为其他引用。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194859237.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>强引用是最传统的“引用”定义，是指在程序代码之中普遍存在的引用赋值，即类似于<code>Object obj = new Object()</code>这种引用关系，只要沿着GC Root的强引用关系能够找到该对象，那么无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>只有GC Root<strong>都不引用（包括间接强引用）</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<ul>
<li>  如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2版之后提供了<code>SoftReference</code>类来实现软引用。</p>
<p>当GC Root指向（包括间接指向）软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<ul>
<li>  如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用软引用对象 list和SoftReference之间是强引用关系，而SoftReference和byte数组之间则是软引用关系</span><br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get()); <span class="hljs-comment">//获得软引用对象指向的实际对象</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">null<br>null<br>null<br>null<br>[B@2503dbd3<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831211502938.png" srcset="/img/loading.gif" lazyload></p>
<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong>。软引用对象本身也是需要占用内存的，虽然占用内存少，如果想要<strong>清理软引用</strong>，需要使用<strong>引用队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.Reference;<br><span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;<br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用, 配合引用队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 引用队列的泛型需要和软引用指向的对象一致。</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 在创建软引用对象时，在软引用类构造器传入引用队列对象，代表关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>( poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; reference : list) &#123;<br>            System.out.println(reference.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（<strong>即切断软引用对象的强引用关系，使得软引用对象可以被回收</strong>）。</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会收回掉只被弱引用关联的对象。在JDK1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</p>
<p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<ul>
<li>  如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<blockquote>
<p>需要注意的是，弱引用是指发生GC就可以被回收，但不意味着发生GC一定被回收，但是Full GC一定会清除所有弱引用指向的对象。比如：</p>
<p>JAVA内存模型中，弱引用对象在发生GC的时候就会被GC线程回收，但并不意味着在年轻代就会被回收，当JVM垃圾回收器的GC thread还没有执行到回收垃到时刻，如果此时被修饰为弱引用的对象已经通过某个途径copy到了老年代（如：该弱引用对象占独立内存块比较大，首次放入堆内存的时候，由于年轻代的Eden和From zone无足够连续内存空间存放，在老年代的担保策略下，直接存入old generation），此时此刻，这个弱引用对象就存在于老年代，当下一次full GC发生时，被GC线程回收掉，所以不能说弱引用是在young GC回收。</p>
<p>软引用对象一般会经历多次GC，自然晋升到old generation，一般情况下，当内存不足时，才会在GC线程运行时，经由标记算法，一次回收此类对象，因此可以说，软引用对象一般都在full gc过程中被回收。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示弱引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//  list --&gt; WeakReference --&gt; byte[]</span><br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(ref);<br>            <span class="hljs-keyword">for</span> (WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; w : list) &#123;<br>                System.out.print(w.get()+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831213726035.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用也被称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2班之后提供了<code>PhantomReference</code>类来实现虚引用。</p>
<p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，虚引用对象所在的引用队列会由<code>ReferenceHandler</code>线程定时查看是否有新入队的<code>Cleaner</code>(该类继承自<code>PhantomReference</code>)对象，如果有那么调用<code>Cleaner</code>对象的<code>clean()</code>方法。</p>
<ul>
<li>  虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>  如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，虚拟机会创建该对象的终结器引用对象，并会先将终结器引用对象放入引用队列中，再由一个优先级很低的<code>finalizeHandler</code>线程在某些时机查看引用队列中是否存在终结器引用对象，如果有，则根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，<strong>等到下一次垃圾回收时该对象所占用的内存就可以真正地被垃圾回收了</strong>。<strong>需要注意的是，这种方式效率很低，第一次垃圾回收时需要先将终结器引用对象加入引用队列，并且<code>finalizeHandler</code>线程优先级很低，可能要等很久才能等到<code>finalizeHandler</code>线程，之后finalize方法被调用，下一次垃圾回收才能真正回收对象的内存。finalize方法已经过时，不推荐使用，同样也不推荐使用终结器引用，<code>try-finally</code>或者其他方式可以做的更好。</strong></p>
<ul>
<li>  如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><p><code>ReferenceQueue</code>是用来配合引用工作的，没有ReferenceQueue 一样可以运行。<code>ReferenceQueue</code>是专门用来存放引用的, 当软引用,弱引用,虚引用对应的那个对象被回收后的同时,该引用会自动加入到你所定义的<code>ReferenceQueue</code>中。<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference </code>都有一个可以传递 <code>ReferenceQueue </code>的构造器。创建引用的时候，可以指定关联的队列，当 GC 释放对象内存的时候，会将引用加入到引用队列。 <del>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。为什么所引用对象还没被回收，虚引用对象已经加入引用队列了，这句话不确定是否正确。</del>当关联的引用队列中有数据的时候，意味着指向的堆内存中的对象被回收。通过这种方式，JVM 允许我们在对象被销毁后，做一些我们自己想做的事情。<br>软引用和弱引用<strong>可以配合也可以不配合</strong>引用队列使用</p>
<ul>
<li><ul>
<li>  在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列使用<ul>
<li>  虚引用对象和终结器引用对象在创建时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h5 id="强软弱虚引用总结"><a href="#强软弱虚引用总结" class="headerlink" title="强软弱虚引用总结"></a>强软弱虚引用总结</h5><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831201540595.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><p>比如现在有如下一段内存，看看三种垃圾回收算法的处理方式：</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220901164958025.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="标记-清除-Mark-Sweep"><a href="#标记-清除-Mark-Sweep" class="headerlink" title="标记-清除(Mark Sweep)"></a>标记-清除(Mark Sweep)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194927582.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，分两个阶段，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间（这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址并放入空闲地址列表里，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存）</p>
<p><strong>优点</strong>：速度快，清除操作只需要将垃圾对象的起始结束地址放入空闲地址列表里做一个记录就可以。</p>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="标记-整理（Mark-Compact"><a href="#标记-整理（Mark-Compact" class="headerlink" title="标记-整理（Mark Compact)"></a>标记-整理（Mark Compact)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194948373.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>定义</strong>标记-整理，会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低。</p>
<p><strong>优点</strong>：没有内存碎片。</p>
<p><strong>缺点</strong>：整理阶段涉及到对象的复制移动和引用地址的改变（<strong>比如，其他的变量引用了要移动的对象，需要改变该变量的引用地址</strong>），效率较低。</p>
<h4 id="标记-复制-Copy"><a href="#标记-复制-Copy" class="headerlink" title="标记-复制(Copy)"></a>标记-复制(Copy)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220901170254664.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195030732.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195102772.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>定义</strong>：标记-复制算法，将内存分为等大小的两个区域，FROM和TO（TO中为空）。首先先做一次标记找到那些不被引用的对象，然后将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<p><strong>优点</strong>：不会产生内存碎片。</p>
<p><strong>缺点</strong>：需要占用双倍的内存空间，造成空间浪费。如果对象存活率较高时，需要进行较多的复制操作，效率降低。<strong>所以JVM大多优先使用这种收集算法去回收新生代。</strong></p>
<h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><strong>定义：</strong>分代垃圾回收机制，把整个堆内存分为两块，新生代和老年代。其中新生代又划分为伊甸园、幸存区From和幸存区To。新生代处理的大多是朝生夕死的对象，而老年代处理的是存活时间更长，更有价值的对象。针对不同区域，采取不同的垃圾回收算法，可以更有效的管理内存。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195146303.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195202087.png" srcset="/img/loading.gif" lazyload></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong>。Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong>。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195230457.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195253790.png" srcset="/img/loading.gif" lazyload></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong>。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903132254785.png" srcset="/img/loading.gif" lazyload></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151018.png" srcset="/img/loading.gif" lazyload></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收。</p>
<p><strong>总结：</strong></p>
<ul>
<li>对象有限分配在伊甸园区域 </li>
<li>新生代空间不足时，触发minor gc，伊甸园和 from存活的对象使用copy复制到to中，存活的对象年龄加 1并且交换 from和to </li>
<li>minor gc 会引发 stop the world（暂停其他用户线程，只让垃圾回收线程工作，直到垃圾回收完成，用户线程才会恢复工作。因为这里牵扯到对象的移动，对象的引用地址在发生变化，所以如果不停止用户线程，会发生混乱）。不过由于新生代大部分对象都是朝生夕死的，标记和复制过程是比较短的，STW也是比较短的。</li>
<li>当对象寿命超过阈值（阈值不一定是最大值15）时，会晋升至老年代，最大寿命是15（寿命存放在每个对象的对象头中，占4bit，故而最大就是15）</li>
<li>大对象直接进入老年区，<code>-XX:PretenureSizeThreshold指定大于设置值的对象直接在老年代分配</code>防止大对象在Eden区和两个Survivor区之间来回复制，产生大量的内存复制操作。当老年代空间不足，会先尝试触发 minor gc， 如果之后空间仍不足，那么触发 full gc（Full GC也会触发STW，但是相比于minor GC产生的STW的暂停时间要长。因为老年代大部分是存活对象，并且使用标记-清除和标记-整理算法，STW的暂停时间要更长。）</li>
</ul>
<h4 id="各个GC定义"><a href="#各个GC定义" class="headerlink" title="各个GC定义"></a>各个GC定义</h4><ul>
<li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：只目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意”Major GC“这个说法现在有点混淆，在不同资料上常有不同所指，读者需按照上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：<del>收集整个Java堆和方法区的垃圾收集。深入理解jvm里面的概念，个人认为不准确</del>针对老年代的GC行为。</li>
</ul>
<h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h4><blockquote>
<p>含义                            参数</p>
<p>堆初始大小                -Xms</p>
<p>堆最大大小                -Xmx 等价 -XX:MaxHeapSize=size</p>
<p>新生代大小                -Xmn 等价 （-XX:NewSize=size 加 -XX:MaxNewSize=size）</p>
<p>幸存区比例（动态）-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</p>
<p>幸存区比例                -XX:SurvivorRatio=ratio(设置伊甸园空间大小和幸存者空间大小之间的比率。默认情况下，此选项设置为8。例如，新生代一共有10MB，伊甸园占8MB，两个幸存区分别占用1MB)</p>
<p>晋升阈值                    -XX:MaxTenuringThreshold=threshold</p>
<p>晋升详情                    -XX:+PrintTenuringDistribution</p>
<p>GC详情                        -XX:+PrintGCDetails -verbose:gc</p>
<p>FullGC 前 MinorGC    -XX:+ScavengeBeforeFullGC（在每次完全GC之前启用年轻一代的GC。默认情况下，此选项处于启用状态。Oracle建议您不要禁用它，因为在Full GC之前清理年轻一代可以减少从老一代空间到年轻一代空间可访问的对象数量，加速Full GC。） </p>
</blockquote>
<h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903155531563.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903161016488.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903161949798.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903162310476.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903162637673.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;sleep....&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903163155133.png" srcset="/img/loading.gif" lazyload></p>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h4 id="第一类：串行"><a href="#第一类：串行" class="headerlink" title="第一类：串行"></a>第一类：串行</h4><ul>
<li>  单线程</li>
<li>  堆内存较小，个人电脑（CPU核数较少）</li>
</ul>
<blockquote>
<p>开启串行垃圾回收器 -XX:+UseSerialGC  等于Serial（新生代里面的复制算法）加SerialOld（老年代里的标记-整理算法）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151027.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
<h4 id="第二类：吞吐量优先"><a href="#第二类：吞吐量优先" class="headerlink" title="第二类：吞吐量优先"></a>第二类：吞吐量优先</h4><ul>
<li>  多线程</li>
<li>  堆内存较大，多核CPU</li>
<li>  单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短。<strong>吞吐量是指一定时间内回收垃圾的多少。</strong></li>
<li>  <strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<blockquote>
<p>-XX:+UseParallelGC 和 -XX:+UseParallelOldGC：分别开启新生代和老年代的并行垃圾回收器。JDK1.8默认开启。这两个开关，只要开启任意一个，另外一个也会自动开启。一般都会把CPU里的所有线程都占满，尽快完成垃圾回收。</p>
<p>-XX:+UseAdaptiveSizePolicy 启用自适应新生代调整，比如eden区和两个幸存区的比例，以及晋升老年代的阈值等。</p>
<p>-XX:GCTimeRatio=ratio 调整垃圾回收的时间相对于总时间的占比。ratio默认值99，垃圾回收器占用总时间的比率不能超过1/(1 + radio)，如果超过了，那么JVM会动态增大堆内存大小，以减少垃圾回收。</p>
<p>-XX:MaxGCPauseMillis=ms 最大暂停毫秒时间。默认值是200ms。GCTimeRatio和这个参数是相反的，需要折中。因为想要降低垃圾回收的时间占比，需要将堆内存变大，但是堆内存变大，每次暂停时间会变长。</p>
<p>-XX:ParallelGCThreads=n 设置垃圾回收器可以调用的线程数。默认值取决于JVM可用的CPU数量。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151039.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>  XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>  XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h5 id="JDK8默认是什么垃圾回收器？"><a href="#JDK8默认是什么垃圾回收器？" class="headerlink" title="JDK8默认是什么垃圾回收器？"></a><strong>JDK8默认是什么垃圾回收器？</strong></h5><blockquote>
<p>-XX:+PrintCommandLineFlags 参数可查看默认设置收集器类型<br>-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922202412989.png" srcset="/img/loading.gif" lazyload></p>
<p>UseParallelGC = Parallel Scavenge + Parallel Old。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922203820862.png" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th>新生代（别名）</th>
<th>老年代（别名）</th>
<th>JVM参数</th>
</tr>
</thead>
<tbody><tr>
<td>Serial (DefNew)</td>
<td>Serial Old(PSOldGen或Tenured)</td>
<td>-XX:+UseSerialGC</td>
</tr>
<tr>
<td>Parallel Scavenge (PSYoungGen)</td>
<td>Parallel Old (ParOldGen)</td>
<td>-XX:+UseParallelOldGC 或者 -XX:+UseParallelGC</td>
</tr>
<tr>
<td>ParNew (ParNew)</td>
<td>Serial Old(PSOldGen或Tenured)</td>
<td>-XX:-UseParNewGC同时打开ParNew GC和Serial Old JDK9之后不再支持</td>
</tr>
<tr>
<td>ParNew (ParNew)</td>
<td>CMS+Serial Old(PSOldGen或Tenured)</td>
<td>-XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>G1</td>
<td>G1</td>
<td>-XX:+UseG1GC</td>
</tr>
</tbody></table>
<h4 id="第三类：响应时间优先"><a href="#第三类：响应时间优先" class="headerlink" title="第三类：响应时间优先"></a>第三类：响应时间优先</h4><ul>
<li>  多线程</li>
<li>  堆内存较大，多核CPU</li>
<li>  尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<blockquote>
<p>-XX:+UseConcMarkSweepGC 打开并发的（垃圾回收线程和用户线程并发）标记-清除垃圾收集器，它工作再老年代（标记-清除算法，适合于长时间存活的区域） 和老年代的CMS垃圾收集器配的是新生代的ParNewGC，ParNewGC采用并发的复制算法，使用-XX:+UseParNewGC打开新生代ParNewGC垃圾收集器。一般CMS和ParNewGC是一对组合，分别工作在老年代和新生代。</p>
<p>对于CMS，如果老年代内存触发的GC的内存占比设置的过大，以致于无法满足浮动垃圾（或者说并发清理过程中新产生的对象），那么会出现<code>并发失败</code>，这时CMS的并发清理就会退化为 SerialOld，一边冻结用户线程的执行，一边SerialOld重新进行老年代的垃圾收集，不过这样STW的时间就十分长了。       但是如果老年代内存触发的GC的内存占比设置的过小，GC的频率会比较高。故而老年代内存触发的GC的内存占比需要折中选择。</p>
<p>-XX:ParallelGCThreads=n 垃圾回收器并行线程数，默认值是JVM可调用CPU数量 ~ -XX:ConcGCThreads=threads 垃圾回收器并发线程数，一般推荐设置为并行线程数的1/4（留出用户线程），默认值是JVM可调用CPU数量</p>
<p>-XX:CMSInitiatingOccupancyFraction=percent 老年代占用百分比(0到100)的阈值，触发CMS。</p>
<p>-XX:+CMSScavengeBeforeRemark    重新标记阶段之前，由于用户线程在并发标记阶段产生了一些新生代里的对象并且引用了老年代里的对象，在重新标记阶段，需要通过新生代的对象到老年代里的对象做一次可达性分析。由于新产生的新生代对象是比较多的，并且很大一部分是朝生夕死的，从新生代到老年代做可达性分析，就算找到了一些老年代，这些新生代有很大一部分也会马上被回收，做了很多无用的查找工作。这个开关就是在重新标记阶段之前，对新生代做一次ParNewGC，先清理一次新生代，减小重新标记的工作量。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151052.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>一种以获取<strong>最短回收停顿时间</strong>为目标的收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<ul>
<li><p><strong>初始标记</strong>：标记GC Roots能<strong>直接</strong>到的对象。速度很快但是<strong>仍存在Stop The World问题(很短暂)</strong></p>
</li>
<li><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
</li>
<li><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
</li>
<li><p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>由于<strong>并发清除</strong>过程中，其他用户线程仍会不断产生新的垃圾，这些新的垃圾需要等到下一次垃圾回收时才能清理，这些垃圾被称为<strong>浮动垃圾</strong>，由于CMS在垃圾回收的过程中会产生浮动垃圾，这样导致CMS不能像其他垃圾回收器一样等到堆内存不足了再做垃圾回收。故而需要预留一些来存放浮动垃圾。</li>
<li>由于CMS是标记-清除算法，会导致在老年代产生大量内存碎片。如果发生<code>并发失败</code>，那么CMS会想浮动垃圾过多产生<code>并发失败</code>一样，CMS退化为单线程的SerialOld（标记-整理算法）进行整理碎片，这STW时间会很长。</li>
</ul>
<p><strong>关于为什么CMS会退化成SerialOld，而不是Parallel Old。我个人认为是，<code>并发失败</code>发生的两个原因来的都比较突然，无法到达Parallel Old要求的安全点，故而只能采用Serial Old彻底阻塞用户线程，进行老年代的标记-整理算法。</strong></p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>  同时注重吞吐量和低延迟（低响应时间），默认的暂停目标是200ms</li>
<li>  超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的Region区域（每个区域大小在1MB—32MB之间，且应为2的N次幂，每个区域都可以独立的做为Eden、幸存区和老年代。堆内存过大，回收速度会变慢，这种化整为零的思想，可以进行优化，加快标记和拷贝的速度）（当内存较小时，G1和CMS的暂停时间基本一致，但是当内存越大时，G1的暂停时间会比CMS的暂停时间越来越小。G1比CMS更适合大内存的服务器场景。）</li>
<li>  整体上是<strong>标记-整理</strong>算法（避免了CMS的内存碎片问题），两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p><strong>相关参数</strong>：</p>
<blockquote>
<p>-XX:MaxGCPauseMillis=time 设置GC暂停目标时间</p>
<p>-XX:+UseG1GC JDK8 并不是默认开启的，所需要参数开启，JDK9默认开启</p>
<p>-XX:G1HeapRegionSize=size 设置每个区域大小在1MB—32MB之间，且应为2的N次幂</p>
</blockquote>
<h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p>第一个阶段：Young Collection</p>
<p>第二个阶段：Young Collection + Concurrent Mark</p>
<p>第三个阶段：Mixed Collection</p>
<p>以上三个阶段循环执行，刚开始是新生代的垃圾收集，如果经过一段时间老年代的内存超过阈值了，那么它会在新生代的垃圾收集的同时进行并发标记，等这个阶段完成后，会进行混合收集，混合收集会对整个新生代和部分老年代都进行一次比较大的收集。如此循环往复。</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151109.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个区域都可以独立的做为伊甸园、幸存区和老年代，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间。<strong>G1的垃圾回收是以区域为单位的。</strong></p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li>  会STW（新生代垃圾回收的复制算法引起的，时间较短）</li>
</ul>
<p>刚开始都是伊甸园区，当伊甸园逐渐被占满，触发新生代垃圾回收。</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151119.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>新生代垃圾回收的复制算法，会将存活的对象放入幸存区。</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151129.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>在工作一段时间，当幸存区的存活对象年龄超过阈值或幸存区内存比较满，又会触发新生代的垃圾回收，一部分年龄超过阈值的会晋升到老年代，在幸存区里不够年龄的对象和伊甸园这一轮存活的对象会。复制到另外一块幸存区区域。</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151140.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="Young-Collection-CM（Concurrent-Mark并发标记）"><a href="#Young-Collection-CM（Concurrent-Mark并发标记）" class="headerlink" title="Young Collection + CM（Concurrent Mark并发标记）"></a>Young Collection + CM（Concurrent Mark并发标记）</h5><ul>
<li>不会STW</li>
</ul>
<ul>
<li><p>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong>。就是说在Young GC的STW时，进行初始标记，不会占用并发标记的时间，相当于这个阶段没有STW。</p>
<ul>
<li>  初始标记：对GC Root进行标记</li>
<li>  并发标记：顺着GC Root对其引用的对象进行标记</li>
</ul>
</li>
<li><p>  当老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</p>
</li>
</ul>
<blockquote>
<p>-XX:InitiatingHeapOccupancyPercent=percent 默认45%</p>
</blockquote>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151150.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong>。</p>
<ul>
<li>  最终标记（Remark）会STW，之前并发标记时，用户线程在工作可能会产生新的垃圾和改变一些对象的引用，造成漏标和错标，所以需要STW，进行最终标记。</li>
<li>  <strong>拷贝</strong>存活（Evacuation）会STW，在不超过暂停时间的前提下，选出一部分价值最高的老年代区域进行回收。</li>
</ul>
<blockquote>
<p> -XX:MaxGCPauseMills:ms 用于指定最长的停顿时间</p>
</blockquote>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，老年代中存活的对象很多，有大量的老年代存活对象需要从一个区域复制到另一个区域，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）。因为每次清理块的时间时一样的,所以在用户设置的时间内尽可能回收性价比比较高的块。在垃圾清理时,并不需要一下清理所有的新生代老年代区域,只需要清理哪些需要清理的小块。</p>
<p>Mixed Collection中的新生代垃圾回收：Eden中的存活对象和幸存区中不够晋升年龄的存活对象，复制到另外一块幸存区。幸存区符合晋升年龄的存活对象复制到老年区。</p>
<p>Mixed Collection中的老年代垃圾回收：选出回收价值和暂停时间，选出一批回收价值最高且不超过暂停时间，进行老年代的垃圾回收，将存活的老年代对象复制到另一个区域。</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151201.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="为什么叫Garbage-first？"><a href="#为什么叫Garbage-first？" class="headerlink" title="为什么叫Garbage first？"></a>为什么叫Garbage first？</h5><p>因为要优先回收价值高的区域，目的是达到暂停时间短的目标。</p>
<h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul>
<li>  新生代回收的跨代引用（老年代引用新生代）问题。但是老年代存活的对象是比较多的且存活的GC Root也多，这些GC Root引用新生代对象也比较少，如果遍历整个老年代，然后通过可达性分析算法从GC Root找那些新生代对象被引用，这是比较耗时的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151211.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域有一个老年代的对象引用了新生代对象，则该区域被称为脏卡。这样只需要从脏卡中的GC Root对象开始可达性分析，对新生代对象进行标记，效率比较高。</li>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡。每个Region内都会维护一个,因此G1收集器相对而言比较消耗内存的原因就在这里,它需要约5~10%的空间维护记忆集。这样做新生代垃圾回收时，先通过Remenbered set得到脏卡位置，到这些脏卡遍历GC Root，做可达性分析，提高了效率。</li>
<li><strong>Remembered Set保存脏卡，脏卡就是一段含有指向内存地址的数据。</strong><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906111542863.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>  在引用变更时通过post-write barried<strong>写屏障</strong> + dirty card queue<strong>脏卡队列</strong>（通过写屏障，在每次对象的引用发生变更时，都要更新脏卡，这是一个异步操作不会立刻完成脏卡的更新，把更新的指令放入脏卡队列之中，将来脏卡队列size到达阈值之后由一个线程完成脏卡的更新操作）</li>
<li>  concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151222.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="Remark（重新标记阶段）"><a href="#Remark（重新标记阶段）" class="headerlink" title="Remark（重新标记阶段）"></a>Remark（重新标记阶段）</h5><p>在垃圾回收时，收集器处理对象的过程中。</p>
<h4 id="G1总结"><a href="#G1总结" class="headerlink" title="G1总结"></a>G1总结</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922213348397.png" srcset="/img/loading.gif" lazyload></p>
<p>总体上来说，G1垃圾收集器一共有四个步骤：</p>
<ul>
<li><strong>初始标记（Initial Marking）：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，并修改TAMS指针的值，让下一个阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li><strong>并发标记（Concurrent Marking）：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>**最终标记（Final Marking):**对用户线程做另外一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>**筛选回收（Live Data Counting and Evacuation):**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region种，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</li>
</ul>
<p><strong>三色标记法</strong></p>
<ul>
<li>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</li>
<li>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC需要从此对象中去寻找垃圾）</li>
<li>白色：该对象没有被标记过。（垃圾对象）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906103622566.png" srcset="/img/loading.gif" lazyload></p>
<p>下图是并发标记阶段，对象的处理状态：</p>
<img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906102435159.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>但是在<strong>并发标记过程中</strong>，有可能C被处理了(此时没有对象引用C)，但该处理过程还未结束，在处理过程结束之前A引用了C，这是C就被漏掉了，这时就会用到remark。</p>
<p>过程如下</p>
<ul>
<li>  之前C未被引用，这时A引用了C，就会给C加一个**<code>pre-write barrier</code><strong>写屏障，写屏障的指令会被执行，将C放入一个</strong><code>satb_mark_queue</code>**队列当中，并将C变为 处理中 状态</li>
<li>  在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151239.png" srcset="/img/loading.gif" lazyload></p>
<p>原理：当对象的引用发生改变时，JVM就会加入一个写屏障（只要对象的引用发生改变，写屏障代码就会被执行），写屏障代码会将该对象加入一个队列当中并且会将该对象改为灰色（正在处理状态）。等到并发标记阶段结束后，进入remark阶段，此时发生STW，此时重新标记线程从队列中逐个取出对象，如果对象是灰色的则需要再做一次可达性分析。</p>
<h5 id="G1从JDK8到JDK9的优化"><a href="#G1从JDK8到JDK9的优化" class="headerlink" title="G1从JDK8到JDK9的优化"></a>G1从JDK8到JDK9的优化</h5><ul>
<li>JDK 8u20 字符串去重</li>
<li>JDK 8u40 并发标记类卸载</li>
<li>JDK 8u60 回收巨型对象</li>
<li>JDK 9并发标记起始时间的调整</li>
</ul>
<h5 id="JDK-8u20版本中-字符串去重"><a href="#JDK-8u20版本中-字符串去重" class="headerlink" title="JDK 8u20版本中 字符串去重"></a>JDK 8u20版本中 字符串去重</h5><blockquote>
<p>-XX:+UseStringDeduplication 打开字符串char数组去重，默认是打开</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span><br></code></pre></td></tr></table></figure>

<p>观察上面代码，我们发现，虽然两个字符串的值相同，但是却是两个堆对象，分别指向两个char数组。这种空间浪费的情况可以使用intern()来解决，使其引用串池中共同的一个字符串对象。但是这对于程序员的要求比较高。所以JDK 8u20版本中，优化了这种空间浪费，使得两个堆字符串对象的成员变量char数组引用同一个，减少了空间浪费。</p>
<p>过程</p>
<ul>
<li>  将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>  当新生代回收时，G1并发检查是否有重复的字符串（和intern()使用的字符串表不同，个人理解只检查在队列里面的字符串）</li>
<li>  如果字符串的值一样，就让他们<strong>引用同一个char数组</strong></li>
<li>注意，其与String.intern的区别<ul>
<li>  intern关注的是字符串对象</li>
<li>  字符串去重关注的是char[]</li>
<li>  在JVM内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>  节省了大量内存</li>
<li>  新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在JDK 8u40的之前版本中，类一般是没办法卸载的，只要加载了之后会一直占用内存。尤其是一些自定义的类加载器创建和加载的类，使用一段时间后就没有人再用了，一直占用内存，对垃圾回收是不利的。</p>
<p><strong>过程：</strong></p>
<p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类。一般卸载的是自定义的类，JVM的启动类加载器、扩展类加载器和应用程序类加载器会始终存在，对于自定义的类加载器才会有卸载的需求和功能。</p>
<p><strong>类卸载的条件：</strong></p>
<ul>
<li>类的实例都被回收掉了</li>
<li>类所在的类加载器的所有类都不在使用了</li>
</ul>
<blockquote>
<p>-XX:+ClassUnloadingWithConcurrentMark 打开并发标记类卸载，默认开启</p>
</blockquote>
<h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><p>其实G1中有四种区域：Eden区、幸存区、老年代区、<strong>巨型对象区</strong></p>
<p>巨型对象：</p>
<ul>
<li><p>一个对象大于region的一半时，当然也可以占用多个区，就称为巨型对象</p>
</li>
<li><p>G1不会对巨型对象进行拷贝，因为拷贝的代价十分大</p>
</li>
<li><p>回收时被优先考虑巨型对象</p>
</li>
<li><p>G1会跟踪从老年代到巨型对象所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉（G1希望巨型对象越早回收越好，最好在新生代垃圾回收时就回收掉）。</p>
<p><strong>为什么只需要跟踪老年代到巨型对象的引用呢？</strong></p>
<p><strong>这是因为新生代存活对象少，很快就可以遍历分析可达性完成；而老年代存活对象多，遍历分析可达性代价大，这也是为什么要引用脏卡和记忆表的原因。</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151249.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="JDK9-并发标记起始时间的调整"><a href="#JDK9-并发标记起始时间的调整" class="headerlink" title="JDK9 并发标记起始时间的调整"></a>JDK9 并发标记起始时间的调整</h5><p>并发标记必须在堆空间占满前完成,否则退化为FullGC(之前是使用Serial GC清理老年代，现在也变为多线程清理老年代了，但是也不好，因为STW时间长)。故而应该提前开始并发收集老年代。</p>
<blockquote>
<p> JDK9之前需要使用-XX:InitiatingHeapOccupancyPercent 设置老年代占比阈值，如果大于这个值，并发的老年代垃圾回收就会开始了。 但是比较麻烦，阈值大了，退化为FullGC的概率大，STW时间长；阈值小了，并发垃圾回收老年代的频率高，同样影响程序。</p>
</blockquote>
<p>JDK9可以动态调整了，只用设置一个初始阈值，不需要人为调整。</p>
<ul>
<li><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值 </p>
</li>
<li><p>进行数据采样并动态调整 </p>
</li>
<li><p>总会添加一个安全的空档空间</p>
</li>
</ul>
<h4 id="各种类型GC总结"><a href="#各种类型GC总结" class="headerlink" title="各种类型GC总结"></a>各种类型GC总结</h4><ul>
<li>Serial GC<ul>
<li>新生代内存不足发生的垃圾收集 minor gc </li>
<li>老年代内存不足发生的垃圾收集 full gc（Major gc）</li>
</ul>
</li>
<li>Parallel GC<ul>
<li>新生代内存不足发生的垃圾收集 minor gc </li>
<li>老年代内存不足发生的垃圾收集 full gc（Major gc）</li>
</ul>
</li>
<li>CMS<ul>
<li>新生代内存不足发生的垃圾收集 minor gc </li>
<li>老年代内存不足。如果没有并发失败就继续并发清理，否则Serial GC。</li>
</ul>
</li>
<li>G1<ul>
<li>新生代内存不足发生的垃圾收集 minor gc </li>
<li>老年代内存不足</li>
</ul>
</li>
</ul>
<p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>  如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC(老年代进行Serial GC)，还是并发地进行清理</li>
<li>  如果垃圾产生速度快于垃圾回收速度，便会触发Serial GC（现在的版本，即使是Full GC，也是多线程的老年代回收器，但是也不好，STW的时间长）</li>
</ul>
<h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning">各个JDK版本调优的官方文档</a></p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h4><ul>
<li><p>掌握GC相关的VM参数，会基本的空间调整 </p>
<blockquote>
<p>“F:\JAVA\JDK8.0\bin\java” -XX:+PrintFlagsFinal -version | findstr “GC” 查看与GC相关的参数设置情况，可以根据参数去查询具体的信息。</p>
</blockquote>
</li>
<li><p>掌握相关工具 </p>
<p><code>jmap</code>,<code>jconsole</code>等等工具。</p>
</li>
<li><p>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</p>
</li>
</ul>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS（jdk9已经不推荐）, G1（jdk9默认，大堆内存下工作比CMS要好，可以通过调参平衡低延迟和高吞吐量目标）, ZGC（JDK12体验垃圾回收器，目标是超低延迟） （低延迟）</li>
<li>ParallelGC (高吞吐量)</li>
<li>Zing（对外宣称几乎零STW，同时可以管理超大堆内存）</li>
</ul>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？<ul>
<li>  JDBC中，resultSet = statement.executeQuery(“select * from 大表”)。把表中数据都从mysql加载入堆内存。</li>
</ul>
</li>
<li>数据表示是否太臃肿<ul>
<li>  对象图</li>
<li>  对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏<ul>
<li>  有一些缓存数据，比如static Map map不断向它put对象，导致堆内存吃紧，不断发生GC。缓存数据不建议使用Java中的实现，因为他们不是专业做缓存的。可以考虑使用第三方缓存实现，如Redis，他们都会考虑缓存数据的过期，Redis自己做内存管理不会对JVM堆内存造成压力。如果不想使用第三方缓存实现，可以使用软、弱引用，及时回收缓存数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p>GC调优一般从新生代调优开始，因为新生代调优优化空间大一些。</p>
<ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的，在Eden区分配内存。<ul>
<li>  TLAB（thread-local allocation buffer），即对于每个线程都会在Eden区给它分配一块私有的区域。当new一个对象时，会优先检查TLAB是否有可用内存，如果有则优先在这块内存进行分配，保证线程并发安全保护。</li>
</ul>
</li>
<li>  死亡对象回收零代价。因为新生代采用标记-复制算法，故而死亡对象回收代价为零。</li>
<li>  大部分新生代对象用过即死（朝生夕死）</li>
<li>由于使用标记-复制算法且大部分新生代对象朝生夕死，MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是，Oracle推荐新生代内存占用堆内存的四分之一到二分之一。  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220921140004033.png" srcset="/img/loading.gif" lazyload><ul>
<li>  新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC，Full GC的STW要比新生代时间长得多，因为老年代存活对象多，且采用一般需要采用标记-整理算法。而且触发Minor GC时，清理新生代所花费的时间会更长。</li>
</ul>
</li>
<li>新生代内存设置为内容纳[并发量*(请求到响应过程中产生对象的总内存)]的数据为宜。因为这段时间后，这一段时间产生的大部分对象会被回收，只要新生代内存大于[并发量*(请求到响应过程中产生对象的总内存)]，就可以较少的触发Minor GC，保证并发量。</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul>
<li><p>幸存区需要能够保存 <strong>当前活跃对象（正在使用，可能下次Minor GC会回收）</strong>+<strong>需要晋升的对象（年龄不够，但是是存活时间较长的对象，将来会晋升到老年代）</strong></p>
</li>
<li><p>晋升阈值配置得当。一方面希望存活时间短的新生代对象留在新生代中，以便下次Minor GC能够回收掉，不想让它晋升到老年代，如果晋升到老年代，需要等到下次Full GC才能回收，占用空间。另一方面希望让长时间存活的对象尽快晋升，不要在Minor GC过程中每次都要在From 和 To区之间来回复制。</p>
<blockquote>
<p>-XX:MaxTenuringThreshold=threshold  设置晋升阈值</p>
<p>-XX:+PrintTenuringDistribution 打印幸存区各年龄段内存信息</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220921142649953.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以 CMS 为例 </p>
<ul>
<li><p>CMS 的老年代内存越大越好 </p>
</li>
<li><p>先尝试不做调优，如果没有Full GC那么已经很ok。即使发生了Full GC，也应该先尝试调优新生代。 </p>
</li>
<li><p>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3 ，减少Full GC的发生频率。</p>
<blockquote>
<p> -XX：CMSInitiatingOccupancyFraction=percent 设置老年代内存占比触发CMS垃圾回收器的比率，若过大，可能会导致在老年代垃圾回收过程中产生过多浮动垃圾，使得CMS垃圾回收器在老年代上从并发垃圾回收变为Serial Old垃圾回收，大幅增大STW时间。一般来说，该值设置为0.75 ~ 0.80，剩下的空间预留给浮动垃圾。</p>
</blockquote>
</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li><p>案例1 Full GC和 Minor GC频繁 </p>
<p>首先，Minor GC和Full GC都频繁触发，说明空间不足。排除代码写的有比较严重的内存浪费的情况，有一种情况就是，当业务高峰期时，又使用的是新生代和老年代的并行垃圾回收器，那么打开自适应新生代调整。当大量的对象在新生代被创建，幸存区内存紧张，不仅频繁触发Minor GC，晋升老年代的阈值下调，使得大量朝生夕死的新生代对象晋升到老年代，使得老年代内存也紧张，进而频繁触发Full GC。</p>
<p>解决方法：增大新生代空间，幸存区内存紧张得到缓解，不会频繁触发Minor GC。同时，晋升老年代的阈值也会自适应提高，不会使得大量朝生夕死对象进入老年代，Full GC也不会频繁被触发。</p>
<blockquote>
<p>-XX:+UseParallelGC 和 -XX:+UseParallelOldGC：分别开启新生代和老年代的并行垃圾回收器。JDK1.8默认开启。这两个开关，只要开启任意一个，另外一个也会自动开启。一般都会把CPU里的所有线程都占满，尽快完成垃圾回收。</p>
<p>-XX:+UseAdaptiveSizePolicy 启用自适应新生代调整，比如eden区和两个幸存区的比例，以及晋升老年代的阈值等。</p>
</blockquote>
</li>
<li><p>案例2 请求高峰期发生Full GC，单次暂停时间特别长(采用CMS垃圾回收器) </p>
<p>首先，应当查看GC日志，查看究竟是CMS垃圾回收器哪个阶段耗时比较长。</p>
<ul>
<li>如果是重新标记时间过长，那么应当打开<code>-XX:+CMSScavengeBeforeRemark</code>,重新标记阶段之前做一次新生代的垃圾回收ParNewGC，因为新生代对象是比较多的，很大一部分是朝生夕死的。重新标记阶段需要从新生代对象到老年代对象做一次可达性分析，从新生代到老年代做可达性分析，就算找到了一些老年代，这些新生代有很大一部分也会马上被回收，做了很多无用的查找工作。这个开关就是在重新标记阶段之前，对新生代做一次ParNewGC，先清理一次新生代，减小重新标记的工作量。</li>
<li>如果是并发清理阶段，退化为了Serial Old。那么是因为CMS启动时间过晚，并发清理阶段产生浮动垃圾的速度大于垃圾清理速度，使得程序无法到达安全点，只能采用Serial Old清理老年代垃圾，需要适当设置<code>-XX：CMSInitiatingOccupancyFraction=percent</code>，提前触发老年代垃圾回收。</li>
</ul>
</li>
<li><p>案例3 老年代充裕情况下，发生Full GC (CMS jdk1.7)</p>
<p>查看GC日志，没有并发失败和碎片过多产生的提示，说明老年代空间充裕。</p>
<p>发生这种情况的原因是，在JDK7以及之前，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。故而永久代内存紧张也会触发Full GC，所以需要增大永久代的内存大小。JDK8以及之后，方法区移到了元空间（位于操作系统物理内存，这个比较充裕）。</p>
</li>
</ul>
<h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151300.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>一个简单的HelloWorld.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先获得.class字节码文件</p>
<p>方法：</p>
<ul>
<li>  在文件对应目录下，执行<code>javac -parameters -d . HelloWorld.java</code> (-parameters 生成元数据以用于方法参数的反射)</li>
<li>  然后使用<code>od</code>命令，查看二进制字节码文件，<code> od -t xC HelloWorld.class</code></li>
</ul>
<p>以下是字节码文件</p>
<p>第一列是八进制的标号，后面是字节码文件的内容</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost ~]<span class="hljs-comment"># od -t xC HelloWorld.class</span><br>0000000 ca fe ba be<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 00 </span>23 0a<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>15 09<br>0000020<span class="hljs-number"> 00 </span>16<span class="hljs-number"> 00 </span>17<span class="hljs-number"> 08 </span>00<span class="hljs-number"> 18 </span>0a<span class="hljs-number"> 00 </span>19<span class="hljs-number"> 00 </span>1a<span class="hljs-number"> 07 </span>00 1b 07<br>0000040<span class="hljs-number"> 00 </span>1c<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 06 </span>3c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 69 </span>74 3e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>28 29<br>0000060<span class="hljs-number"> 56 </span>01<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 43 </span>6f<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 01 </span>00 0f 4c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 65 </span>4e<br>0000100<span class="hljs-number"> 75 </span>6d<span class="hljs-number"> 62 </span>65<span class="hljs-number"> 72 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>12 4c 6f 63<br>0000120<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 56 </span>61<span class="hljs-number"> 72 </span>69<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<br>0000140<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 74 </span>68<span class="hljs-number"> 69 </span>73<span class="hljs-number"> 01 </span>00 1d 4c<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74 63<br>0000160<span class="hljs-number"> 61 </span>73<span class="hljs-number"> 74 </span>2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c 6f<br>0000200<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>6d<span class="hljs-number"> 61 </span>69 6e<span class="hljs-number"> 01 </span>00 16<br>0000220<span class="hljs-number"> 28 </span>5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74 72<br>0000240<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>61<span class="hljs-number"> 72 </span>67<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>13<br>0000260 5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69<br>0000300 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>4d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 64 </span>50<span class="hljs-number"> 61 </span>72 61<br>0000320 6d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 65 </span>72<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 53 </span>6f<span class="hljs-number"> 75 </span>72<span class="hljs-number"> 63 </span>65 46<br>0000340<span class="hljs-number"> 69 </span>6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 48 </span>65 6c 6c 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c 64<br>0000360 2e 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>0c<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 07 </span>00 1d 0c<span class="hljs-number"> 00 </span>1e<br>0000400<span class="hljs-number"> 00 </span>1f<span class="hljs-number"> 01 </span>00 0b<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 20 </span>77 6f<span class="hljs-number"> 72 </span>6c 64<br>0000420<span class="hljs-number"> 07 </span>00<span class="hljs-number"> 20 </span>0c<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>22<span class="hljs-number"> 01 </span>00 1b<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74<br>0000440<span class="hljs-number"> 63 </span>61<span class="hljs-number"> 73 </span>74 2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c<br>0000460 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c 61<br>0000500 6e<span class="hljs-number"> 67 </span>2f 4f<span class="hljs-number"> 62 </span>6a<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76 61<br>0000520 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>79<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 65 </span>6d<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>6f<br>0000540<span class="hljs-number"> 75 </span>74<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<br>0000560<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d 3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>6a<span class="hljs-number"> 61 </span>76<br>0000600<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d<br>0000620<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 07 </span>70<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 74 </span>6c 6e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>28 4c 6a<br>0000640<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<br>0000660<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<br>0000700<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>2f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>01<br>0000720<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05 2a b7<span class="hljs-number"> 00 </span>01 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a 00<br>0000740<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 04 </span>00 0b<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c 00<br>0000760<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 05 </span>00 0c<span class="hljs-number"> 00 </span>0d<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>0e 00<br>0001000 0f<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>37<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00 00<br>0001020<span class="hljs-number"> 09 </span>b2<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 12 </span>03 b6<span class="hljs-number"> 00 </span>04 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a<br>0001040<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>0b<br>0001060<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>10<span class="hljs-number"> 00 </span>11<span class="hljs-number"> 00 </span>00<br>0001100<span class="hljs-number"> 00 </span>12<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>00<br>0001120<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 02 </span>00 14<br></code></pre></td></tr></table></figure>

<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<p>第一列是字节数，前四个字节是魔数，再接下来两个字节是小版本号，再接下来两个字节是主版本号。再接下来的<code>constant_pool_count</code>和<code>constant_pool[constant_pool_count-1]</code>是常量池的信息。<code>access_flags</code>是访问标志，这个Class是一个类还是接口，这个类是不是公共的等等，<code>this_class</code>自己的包名和类名信息，<code>super_class</code>父类的信息，<code>interfaces_count</code>和<code>interfaces[interfaces_count]</code>是该类的接口信息，<code>fields_count</code>和<code>fields[fields_count]</code>该类中成员变量和静态变量信息，<code>methods_count</code>    和<code>methods[methods_count]</code>该类中成员方法和静态方法的信息，<code>attributes_count</code>和<code>attributes[attributes_count]</code>类的一些附加的属性信息。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">ClassFile</span> &#123;<br>    <span class="hljs-attribute">u4</span> 			 magic<br>    u2             minor_version;    <br>    <span class="hljs-attribute">u2</span>             major_version;    <br>    <span class="hljs-attribute">u2</span>             constant_pool_count;    <br>    <span class="hljs-attribute">cp_info</span>        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];    <br>    <span class="hljs-attribute">u2</span>             access_flags;    <br>    <span class="hljs-attribute">u2</span>             this_class;    <br>    <span class="hljs-attribute">u2</span>             super_class;   <br>    <span class="hljs-attribute">u2</span>             interfaces_count;    <br>    <span class="hljs-attribute">u2</span>             interfaces[interfaces_count];   <br>    <span class="hljs-attribute">u2</span>             fields_count;    <br>    <span class="hljs-attribute">field_info</span>     fields[fields_count];   <br>    <span class="hljs-attribute">u2</span>             methods_count;    <br>    <span class="hljs-attribute">method_info</span>    methods[methods_count];    <br>    <span class="hljs-attribute">u2</span>             attributes_count;    <br>    <span class="hljs-attribute">attribute_info</span> attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p><code>u4 magic</code>，字节码文件的0-3字节，表示它是否是[class]类型的文件.(魔术就是来标示改文件的类型，是.class文件还是.jpg文件等等)</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>字节码文件的4-7字节，表示类的版本 00 34(52)表示是 Java 8</p>
<p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>34H = 52，代表JDK8</p>
<h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230320100753234.png" srcset="/img/loading.gif" lazyload></p>
<p>字节码文件的8-9字节，表示常量池长度，00 23(35)表示常量池有#1~#34项，注意#0项不计入，也没有值 </p>
<p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p>
<p>第#1项<strong>0a</strong>通过查上述表可以得知表示一个 Method信息，<strong>00 06</strong>和<strong>00 15</strong> (21)表示它引用了常量池中 #6 和 #21项来获得这个方法的【所属类】和【方法名】</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a 00 06 00 15</strong> 09</p>
<p>第2项<strong>09</strong>通过查上述表可以得知表示一个 Field信息，<strong>00 16(22)</strong> 和<strong>00 17(23）</strong> 表示它引用了常量池中#22和#23项来获得这个成员变量的【所属类】和【成员变量名】 </p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong></p>
<p>0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 la 07 00 1b 07</p>
<p>第#3项 <strong>08</strong> 表示一个字符串常量名称，**00 18(24)**表示它引用了常量池中 #24 项 </p>
<p>0000020 00 16 00 17 <strong>08 00 18</strong> 0a 00 19 00 1a 07 00 1b 07</p>
<p>第#4项 <strong>0a</strong> 表示一个 Method 信息，<strong>00 19(25)</strong> 和 <strong>00 1a(26)</strong> 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】</p>
<p>0000020 00 16 00 17 08 00 18 <strong>0a 00 19 00 1a</strong> 07 00 1b 07</p>
<p>第#5项 07 表示一个 Class 信息，00 1b(27) 表示它引用了常量池中 #27 项 </p>
<p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <strong>07 00 1b</strong> 07</p>
<p>第#6项 07 表示一个 Class 信息，00 1c(28) 表示它引用了常量池中 #28 项 </p>
<p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <strong>07<br>0000040 00 1c</strong> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 <init> 】 <code>代表构造方法</code></p>
<p>0000040 00 1c <strong>01 00 06 3c 69 6e 69 74 3e</strong> 01 00 03 28 29</p>
<p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值 </p>
<p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <strong>01 00 03 28 29</strong><br> 0000060 <strong>56</strong> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p>
<p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】 </p>
<p>0000060 56 <strong>01 00 04 43 6f 64 65</strong> 01 00 0f 4c 69 6e 65 4e</p>
<p>第#10项 01 表示一个 utf8 串，00 0f(15) 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】</p>
<p>0000060 56 01 00 04 43 6f 64 65 **01 00 0f 4c 69 6e 65 4e **</p>
<p>0000100 <strong>75 6d 62 65 72 54 61 62 6c 65</strong> 01 00 12 4c 6f 63</p>
<p>第#11项 01 表示一个 utf8 串，00 12(18) 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】</p>
<p>0000100 75 6d 62 65 72 54 61 62 6c 65 **01 00 12 4c 6f 63 **</p>
<p>0000120 <strong>61 6c 56 61 72 69 61 62 6c 65</strong> 54 61 62 6c 65 01</p>
<p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】 </p>
<p>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <strong>01</strong><br>0000140 <strong>00 04 74 68 69 73</strong> 01 00 1d 4c 63 6e 2f 69 74 63</p>
<p>第#13项 01 表示一个 utf8 串，00 1d(29) 表示长度，4c 63 6e 2f 69 74 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 57 6f 72 6c 64 3b是【Lcn/itcast/jvm/t5/HelloWorld;】 <code>在字节码文件中表示类型，引用类型是L开头，分号结尾，中间是该类型的全路径</code></p>
<p>0000140 00 04 74 68 69 73 <strong>01 00 1d 4c 63 6e 2f 69 74 63</strong></p>
<p>0000160 <strong>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</strong></p>
<p>0000200 <strong>57 6f 72 6c 64 3b</strong> 01 00 04 6d 61 69 6e 01 00 16</p>
<p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 75 是【main】</p>
<p>0000200 57 6f 72 6c 64 3b <strong>01 00 04 6d 61 69 6e</strong> 01 00 16</p>
<p> 第#15项 01 表示一个 utf8 串，00 16(22) 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值<code>在字节码文件中，类型前面加[说明是一个数组</code></p>
<p>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e **01 00 16 **</p>
<p>0000220 **28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 **</p>
<p>0000240 <strong>69 6e 67 3b 29 56</strong> 01 00 04 61 72 67 73 01 00 13</p>
<p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】 </p>
<p>0000240 69 6e 67 3b 29 56 <strong>01 00 04 61 72 67 73</strong> 01 00 13</p>
<p>第#17项 01 表示一个 utf8 串，00 13(19) 表示长度，是【[Ljava/lang/String;】</p>
<p>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 **01 00 13 **</p>
<p>0000260 **5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 **</p>
<p>0000300 <strong>6e 67 3b</strong> 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p>
<p>第#18项 01 表示一个 utf8 串，00 10(16) 表示长度，是【MethodParameters】 </p>
<p>0000300 6e 67 3b <strong>01 00 10 4d 65 74 68 6f 64 50 61 72 61</strong><br>0000320 <strong>6d 65 74 65 72 73</strong> 01 00 0a 53 6f 75 72 63 65 46</p>
<p>第#19项 01 表示一个 utf8 串，00 0a(10) 表示长度，是【SourceFile】 </p>
<p>0000320 6d 65 74 65 72 73 <strong>01 00 0a 53 6f 75 72 63 65 46</strong><br>0000340 <strong>69 6c 65</strong> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p>
<p>第#20项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【HelloWorld.java】 </p>
<p>0000340 69 6c 65 <strong>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</strong></p>
<p>0000360 <strong>2e 6a 61</strong> 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p>
<p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项</p>
<p>0000360 2e 6a 61 76 61 <strong>0c 00 07 00 08</strong> 07 00 1d 0c 00 1e</p>
<p>第#22项 07 表示一个 Class 信息，00 1d(29) 引用了常量池中</p>
<p>#29 项 0000360 2e 6a 61 76 61 0c 00 07 00 08 <strong>07 00 1d</strong> 0c 00 1e</p>
<p>第#23项 0c 表示一个 【名+类型】，00 1e(30) 00 1f (31)引用了常量池中 #30 #31 两项 </p>
<p>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <strong>0c 00 1e</strong><br>0000400 <strong>00 1f</strong> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p>
<p>第#24项 01 表示一个 utf8 串，00 0b(11) 表示长度，是【hello world】 </p>
<p>0000400 00 1f <strong>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</strong></p>
<p>第#25项 07 表示一个 Class 信息，00 20(32) 引用了常量池中 #32 项 </p>
<p>0000420 <strong>07 00 20</strong> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p>
<p>第#26项 0c 表示一个 【名+类型】，00 21(33) 00 22(34)引用了常量池中 #33 #34 两项 </p>
<p>0000420 07 00 20 <strong>0c 00 21 00 22</strong> 01 00 1b 63 6e 2f 69 74</p>
<p>第#27项 01 表示一个 utf8 串，00 1b(27) 表示长度，是【cn/itcast/jvm/t5/HelloWorld】 </p>
<p>0000420 07 00 20 0c 00 21 00 22 01 <strong>00 1b 63 6e 2f 69 74</strong><br>0000440<strong>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</strong><br>0000460 <strong>6f 57 6f 72 6c 64</strong> 01 00 10 6a 61 76 61 2f 6c 61</p>
<p>第#28项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/Object】 </p>
<p>0000460 6f 57 6f 72 6c 64 01 <strong>00 10 6a 61 76 61 2f 6c 61</strong><br>0000500 <strong>6e 67 2f 4f 62 6a 65 63 74</strong> 01 00 10 6a 61 76 61</p>
<p>第#29项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/System】 </p>
<p>0000500 6e 67 2f 4f 62 6a 65 63 74 01 <strong>00 10 6a 61 76 61<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d</strong> 01 00 03 6f</p>
<p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】 </p>
<p>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 **00 03 6f **</p>
<p>0000540 <strong>75 74</strong> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p>
<p>第#31项 01 表示一个 utf8 串，00 15(21) 表示长度，是【Ljava/io/PrintStream;】 </p>
<p>0000540 75 74 <strong>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</strong><br>0000560 <strong>69 6e 74 53 74 72 65 61 6d 3b</strong> 01 00 13 6a 61 76</p>
<p>第#32项 01 表示一个 utf8 串，00 13(19) 表示长度，是【java/io/PrintStream】 </p>
<p>0000560 69 6e 74 53 74 72 65 61 6d 3b <strong>01 00 13 6a 61 76<br>0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</strong></p>
<p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】 </p>
<p>0000620 <strong>01 00 07 70 72 69 6e 74 6c 6e</strong> 01 00 15 28 4c 6a</p>
<p>第#34项 01 表示一个 utf8 串，00 15(21) 表示长度，是【(Ljava/lang/String;)V】 </p>
<p>0000620 01 00 07 70 72 69 6e 74 6c 6e <strong>01 00 15 28 4c 6a</strong><br>0000640 <strong>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</strong><br>0000660 <strong>29 56</strong> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p>
<h4 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h4><p>21 表示该 class 是一个类，公共的（0x0001 + 0x0010)<br> 0000660 29 56 <strong>00 21</strong> 00 05 00 06 00 00 00 00 00 02 00 01 05 </p>
<p>表示根据常量池中 #5 找到本类全限定名<br> 0000660 29 56 00 21 <strong>00 05</strong> 00 06 00 00 00 00 00 02 00 01 06 </p>
<p>表示根据常量池中 #6 找到父类全限定名<br> 0000660 29 56 00 21 00 05 <strong>00 06</strong> 00 00 00 00 00 02 00 01 </p>
<p>表示接口的数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 <strong>00 00</strong> 00 00 00 02 00 01</p>
<table>
<thead>
<tr>
<th><strong>Flag Name</strong></th>
<th><strong>Value</strong></th>
<th><strong>Interpretation</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>Declared public ; may be accessed from outside its package.</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>Declared final ; no subclasses allowed.</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>Treat superclass methods specially when invoked by the <em>invokespecial</em> instruction.表示一个类</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>Is an interface, not a class.</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>Declared abstract ; must not be instantiated.</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>Declared synthetic; not present in the source code.人工合成的，不是源代码的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>Declared as an annotation type.表示注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>Declared as an enum type.表示枚举</td>
</tr>
</tbody></table>
<h4 id="Field-信息"><a href="#Field-信息" class="headerlink" title="Field 信息"></a>Field 信息</h4><p>表示成员变量数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 00 00 00 <strong>00 00</strong> 02 00 01</p>
<table>
<thead>
<tr>
<th><strong>FieldType</strong></th>
<th><strong>Type</strong></th>
<th><strong>Interpretation</strong></th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>signed byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer</td>
</tr>
<tr>
<td>LClassName;</td>
<td>reference</td>
<td>an instance of class <em>ClassName</em></td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension</td>
</tr>
</tbody></table>
<h4 id="Method-信息"><a href="#Method-信息" class="headerlink" title="Method 信息"></a>Method 信息</h4><p>表示方法数量，本类为 2（构造方法和main方法）</p>
<p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <strong>00 02</strong> 00 01</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p> 一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成</p>
<ul>
<li><p>00 01代表访问修饰符(本类中是 public) </p>
</li>
<li><p>00 07代表引用了常量池 #07 项作为方法名称 </p>
</li>
<li><p>00 08代表引用了常量池 #08 项作为方法参数描述<br>00 01黄色代表方法属性数量，本方法是 1</p>
</li>
<li><p>剩下的代表方法属性</p>
<ul>
<li>00 09 表示引用了常量池 #09 项，发现是【Code】属性 </li>
<li>00 00 00 2f 表示此属性的长度是 47</li>
<li>00 01 表示【操作数栈】最大深度</li>
<li>00 01 表示【局部变量表】最大槽(slot)数</li>
<li>00 00 00 05 表示字节码长度，本例是 5</li>
<li>2a b7 00 01 b1 是字节码指令</li>
<li>00 00 00 02 表示方法细节属性数量，本例是 2</li>
<li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性，将字节码文件行号和Java源码行号进行对应，方便Debug调试使用<ul>
<li><p>00 00 00 06 表示此属性的总长度，本例是 6</p>
</li>
<li><p>00 01 表示【LineNumberTable】长度</p>
</li>
<li><p>00 00 表示【字节码】行号 00 04 表示【java 源码】行号</p>
</li>
</ul>
</li>
<li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性，局部变量表<ul>
<li>00 00 00 0c 表示此属性的总长度，本例是 12<ul>
<li>00 01 表示【LocalVariableTable】长度</li>
<li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li>
<li>00 05 表示局部变量覆盖的范围长度</li>
<li>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】 00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是 【Lcn/itcast/jvm/t5/HelloWorld;】</li>
<li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 <strong>00 01</strong> </p>
<p>0000700 <strong>00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</strong> </p>
<p>0000720 **00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 **</p>
<p>0000740 **00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 **</p>
<p>0000760 <strong>01 00 00 00 05 00 0c 00 0d 00 00</strong> 00 09 00 0e 00</p>
<h5 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h5><ul>
<li>00 09代表访问修饰符(本类中是 public static) </li>
<li>00 03代表引用了常量池 #14 项作为方法名称 </li>
<li>00 0f代表引用了常量池 #15 项作为方法参数描述 </li>
<li>00 02代表方法属性数量，本方法是 2 </li>
<li>其余黑体代表方法属性(属性1)<ul>
<li>00 09 表示引用了常量池 #09 项，发现是【Code】属性 </li>
<li>00 00 00 37 表示此属性的长度是 55</li>
<li>00 02 表示【操作数栈】最大深度</li>
<li>00 01 表示【局部变量表】最大槽(slot)数</li>
<li>00 00 00 05 表示字节码长度，本例是 9</li>
<li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li>
<li>00 00 00 02 表示方法细节属性数量，本例是 2</li>
<li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<ul>
<li>00 00 00 0a 表示此属性的总长度，本例是 10</li>
<li>00 02 表示【LineNumberTable】长度</li>
<li>00 00 表示【字节码】行号 00 06 表示【java 源码】行号 </li>
<li>00 08 表示【字节码】行号 00 07 表示【java 源码】行号</li>
</ul>
</li>
<li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<ul>
<li>00 00 00 0c 表示此属性的总长度，本例是 12 </li>
<li>00 01 表示【LocalVariableTable】长度</li>
<li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li>
<li>00 09 表示局部变量覆盖的范围长度</li>
<li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】</li>
<li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】 </li>
<li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 **00 09 00 0e 00 **</p>
<p>0001000 **0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 **</p>
<p>0001020 **09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a **</p>
<p>0001040 **00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b **</p>
<p>0001060 <strong>00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</strong></p>
<p>黑体代表方法属性(属性2)</p>
<ul>
<li>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性<ul>
<li>00 00 00 05 表示此属性的总长度，本例是 5 </li>
<li>01 参数数量</li>
<li>00 10 表示引用了常量池 #16 项，是【args】 </li>
<li>00 00 访问修饰符</li>
</ul>
</li>
</ul>
<p>0001100 <strong>00 12 00 00 00 05 01 00 10 00 00</strong> 00 01 00 13 00 </p>
<p>0001120 00 00 02 00 14</p>
<h4 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h4><ul>
<li>00 01 表示附加属性数量</li>
<li>00 13 表示引用了常量池 #19 项，即【SourceFile】</li>
<li>00 00 00 02 表示此属性的长度</li>
<li>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】</li>
</ul>
<p>0001100 00 12 00 00 00 05 01 00 10 00 00 **00 01 00 13 00 **</p>
<p>0001120 <strong>00 00 02 00 14</strong></p>
<p>参考文献</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">oracle官方文档</a></p>
<h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>接着上一节，研究一下两组字节码指令，一个是<code>public cn.itcast.jvm.t5.HelloWorld();</code>构造方法的字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">2a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1<br></code></pre></td></tr></table></figure>

<ol>
<li>2a =&gt; <em>aload_0</em> 加载 slot 0 的局部变量，即 this，做为下面的 <em>invokespecial</em> 构造方法调用的对象</li>
<li>b7 =&gt; <em>invokespecial</em> 预备调用构造方法，哪个方法呢?</li>
<li>00 01 引用常量池中 #1 项，即【 Method java/lang/Object.”<init>“:()V 】 </li>
<li>b1 =&gt; return 表示返回</li>
</ol>
<p>另一个是 <code>public static void main(java.lang.String[]);</code> 主方法的字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1<br></code></pre></td></tr></table></figure>

<ol>
<li>b2 =&gt; <em>getstatic</em> 用来加载静态变量，哪个静态变量呢?</li>
<li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12 =&gt; <em>ldc</em> 加载参数，哪个参数呢?</li>
<li>03 引用常量池中 #3 项，即 【String hello world】</li>
<li>b6 =&gt; <em>invokevirtual</em> 预备调用成员方法，哪个方法呢?</li>
<li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】 </li>
<li>b1 =&gt; return 表示返回</li>
</ol>
<p>参考文献</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">oracle官方文档</a></p>
<h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>自己分析类文件结构太麻烦了，Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@localhost ~]# javap -v HelloWorld.<span class="hljs-keyword">class</span><br>Classfile /root/HelloWorld.<span class="hljs-keyword">class</span><br>  Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">597</span> bytes<br>  MD5 checksum <span class="hljs-number">361</span>dca1c3f4ae38644a9cd5060ac6dbc       <span class="hljs-comment">//MD5检验签名</span><br>  Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br>public <span class="hljs-keyword">class</span> cn.itcast.jvm.t5.HelloWorld<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">21</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">22.</span>#<span class="hljs-number">23</span>        <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br>	 #<span class="hljs-number">3</span> = String						 #<span class="hljs-number">24</span>            <span class="hljs-comment">// hello world</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">27</span>            <span class="hljs-comment">// cn/itcast/jvm/t5/HelloWorld</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">28</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               this<br>  #<span class="hljs-number">13</span> = Utf8               Lcn/itcast/jvm/t5/HelloWorld;<br>	#<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               MethodParameters<br>  #<span class="hljs-number">19</span> = Utf8               SourceFile<br>  #<span class="hljs-number">20</span> = Utf8               HelloWorld.java<br>  #<span class="hljs-number">21</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">22</span> = Class              #<span class="hljs-number">29</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">30</span>:#<span class="hljs-number">31</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">24</span> = Utf8               hello world<br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">33</span>:#<span class="hljs-number">34</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">27</span> = Utf8               cn/itcast/jvm/t5/HelloWorld<br>  #<span class="hljs-number">28</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">29</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">30</span> = Utf8               out<br>  #<span class="hljs-number">31</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">32</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">33</span> = Utf8               println<br>  #<span class="hljs-number">34</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  public cn.itcast.jvm.t5.HelloWorld();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>              <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: return<br>      LineNumberTable:<br>        line <span class="hljs-number">4</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  this   Lcn/itcast/jvm/t5/HelloWorld;<br>          <br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>        stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>           <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>   <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>           <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>   <span class="hljs-comment">//String java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>           <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span>   <span class="hljs-comment">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>           <span class="hljs-number">8</span>: return<br>        LineNumberTable:<br>          line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>          line <span class="hljs-number">7</span>: <span class="hljs-number">8</span><br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>              <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>      MethodParameters:<br>        Name                           Flags<br>        args<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p><strong>1)原始Java代码</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package cn.itcast.jvm.t3.bytecode;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">	* 演示 字节码指令 和 操作数栈、常量池的关系 </span><br><span class="hljs-comment">	*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    		<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> c = a + b;<br>        System.out.<span class="hljs-built_in">println</span>(c);<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2）编译后的字节码文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@localhost</span> ~]# javap -v Demo3_1.class<br>Classfile /root/Demo3_1.class<br>  Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">665</span> bytes<br>  MD5 checksum a2c29a22421e218d4924d31e6990cfc5<br>  Compiled from <span class="hljs-string">&quot;Demo3_1.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">t3</span>.<span class="hljs-title">bytecode</span>.<span class="hljs-title">Demo3_1</span></span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">     #1 </span>= Methodref							#<span class="hljs-number">7.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>     #<span class="hljs-number">2</span> = Class									#<span class="hljs-number">27</span>            <span class="hljs-comment">// java/lang/Short</span><br>     #<span class="hljs-number">3</span> = Integer								<span class="hljs-number">32768</span><br>     #<span class="hljs-number">4</span> = Fieldref							#<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br>     #<span class="hljs-number">5</span> = Methodref							#<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>     #<span class="hljs-number">6</span> = Class									#<span class="hljs-number">32</span>            <span class="hljs-comment">// cn/itcast/jvm/t3/bytecode/Demo3_1</span><br>     #<span class="hljs-number">7</span> = Class									#<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>     #<span class="hljs-number">8</span> = Utf8									&lt;init&gt;<br>     #<span class="hljs-number">9</span> = Utf8									()V<br>     #<span class="hljs-number">10</span> = Utf8									Code<br>     #<span class="hljs-number">11</span> = Utf8									LineNumberTable<br>     #<span class="hljs-number">12</span> = Utf8									LocalVariableTable<br>     #<span class="hljs-number">13</span> = Utf8									<span class="hljs-keyword">this</span><br>     #<span class="hljs-number">14</span> = Utf8									Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>     #<span class="hljs-number">15</span> = Utf8									main<br>     #<span class="hljs-number">16</span> = Utf8									([Ljava/lang/String;)V<br>     #<span class="hljs-number">17</span> = Utf8									args<br>     #<span class="hljs-number">18</span> = Utf8									[Ljava/lang/String;<br>     #<span class="hljs-number">19</span> = Utf8									a<br>    #<span class="hljs-number">20</span> = Utf8									I<br>    #<span class="hljs-number">21</span> = Utf8									b<br>    #<span class="hljs-number">22</span> = Utf8									c<br>    #<span class="hljs-number">23</span> = Utf8									MethodParameters<br>    #<span class="hljs-number">24</span> = Utf8									SourceFile<br>    #<span class="hljs-number">25</span> = Utf8									Demo3_1.java<br>    #<span class="hljs-number">26</span> = NameAndType						#<span class="hljs-number">8</span>:#<span class="hljs-number">9</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>    #<span class="hljs-number">27</span> = Utf8									java/lang/Short<br>    #<span class="hljs-number">28</span> = Class									#<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>    #<span class="hljs-number">29</span> = NameAndType						#<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>    #<span class="hljs-number">30</span> = Class									#<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>    #<span class="hljs-number">31</span> = NameAndType						#<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span><br>    #<span class="hljs-number">32</span> = Utf8									cn/itcast/jvm/t3/bytecode/Demo3_1<br>    #<span class="hljs-number">33</span> = Utf8									java/lang/Object<br>    #<span class="hljs-number">34</span> = Utf8									java/lang/System<br>    #<span class="hljs-number">35</span> = Utf8									out<br>    #<span class="hljs-number">36</span> = Utf8									Ljava/io/PrintStream;<br>    #<span class="hljs-number">37</span> = Utf8									java/io/PrintStream<br>    #<span class="hljs-number">38</span> = Utf8									println<br>    #<span class="hljs-number">39</span> = Utf8									(I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> cn.itcast.jvm.t3.bytecode.Demo3_1();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>					<span class="hljs-comment">// Method java/lang/Object.&quot;  &lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>      descriptor: ([Ljava/lang/String;)V<br>      flags: ACC_PUBLIC, ACC_STATIC<br>      Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">2</span>: istore_1	<br>       <span class="hljs-number">3</span>: ldc						#<span class="hljs-number">3</span>									<span class="hljs-comment">//int 32768</span><br>       <span class="hljs-number">5</span>: istore_2<br>       <span class="hljs-number">6</span>: iload_1<br>       <span class="hljs-number">7</span>: iload_2<br>       <span class="hljs-number">8</span>: iadd<br>     	 <span class="hljs-number">9</span>: istore_3<br>      <span class="hljs-number">10</span>: getstatic			#<span class="hljs-number">4</span>									<span class="hljs-comment">//Field		java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">13</span>: iload_3<br>      <span class="hljs-number">14</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">//Method  java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">17</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">18</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">15</span>     <span class="hljs-number">1</span>     a   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">12</span>     <span class="hljs-number">2</span>     b   I<br>           <span class="hljs-number">10</span>       <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     c   I<br>    MethodParameters:<br>      Name  																		Flags<br>      args <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3)常量池载入运行时常量池</strong></p>
<p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151317.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>4)方法字节码载入方法区，main线程开始运行，分配栈帧内存</strong></p>
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151325.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>5）执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<ul>
<li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有<ul>
<li>  sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>  ldc 将一个 int 压入操作数栈</li>
<li>  ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>  这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151336.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p><code>bipush 10</code> 和 <code>istore 1</code>对应Java代码中的</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151346.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151412.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的，此操作是编译优化，叫做常量折叠。</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151421.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151432.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151441.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>  因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151450.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151459.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151508.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151523.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151547.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151555.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151605.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151613.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151624.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>invokevirtual 5</strong></p>
<ul>
<li><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
</li>
<li><p>生成新的栈帧（分配 locals、stack等）</p>
</li>
<li><p>传递参数，执行新栈帧中的字节码</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151632.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>执行完毕，弹出栈帧</p>
</li>
<li><p>清除 main 操作数栈内容</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151640.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>return</strong>  </p>
<ul>
<li><p>完成 main 方法调用，弹出 main 栈帧</p>
</li>
<li><p>程序结束</p>
</li>
</ul>
<h4 id="联系-分析i"><a href="#联系-分析i" class="headerlink" title="联系 - 分析i++"></a>联系 - 分析i++</h4><p>目的：从字节码角度分析 a++ 相关题目</p>
<p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.bytecode;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从字节码角度分析 a++ 相关题目 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">int</span> b = a++ + ++a + a--;<br>      System.out.println(a);<br>      System.out.println(b);<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs class">public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (0x0009) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=3, args_size=1<br>         0: bipush				10<br>         2: istore_1<br>         3: iload_1<br>         4: iinc					1,1<br>         7: iinc					1,1<br>        10: iload_1<br>        11: iadd<br>        12: iload_1<br>        13: iinc					1,-1<br>        16: iadd<br>        17: istore_2<br>        18: getstatic     #2						//Field						java/lang/System.out:Ljava/io/PrintStream;<br>				21: iload_1<br>        22: invokevirtual #3						//Method					java/io/PrintStream.println:(I)V<br>        25: getstatic     #2						//Field						java/lang/System.out:Ljava/io/PrintStream;<br>				28: iload_2<br>        29: invokevirtual #3						//Method					java/io/PrintStream.println:(I)V<br>        32: return<br>      LineNumberTable:<br>        line 8: 0<br>        line 9: 3<br>        line 10: 18<br>        line 11: 25<br>        line 12: 32<br>      LocalVariableTable:<br>           Start  Length  Slot  Name   Signature<br>               0      33     0  args   [Ljava/lang/String;<br>               3      30     1     a   I<br>              18      15     2     b   I<br></code></pre></td></tr></table></figure>

<p>分析:</p>
<ul>
<li>注意 iinc 指令是直接在局部变量 slot 上进行运算 </li>
<li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144617986.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144635042.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144715209.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144737695.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144752804.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144815653.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-202303221457025586.png" srcset="/img/loading.gif" lazyload></p>
<p>几点说明:</p>
<ul>
<li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li>
<li>goto 用来进行跳转到指定行号的字节码</li>
</ul>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      	<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;<br>        	a = <span class="hljs-number">10</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        	a = <span class="hljs-number">20</span>; <br>        &#125;<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs class"> 0: iconst_0      //从0-5这种比较小的数，用iconst_x来表示的<br> 1: istore_1<br> 2: iload_1<br> 3: ifne          12      //如果不等于成立，跳转到12行<br> 6: bipush        10<br> 8: istore_1<br> 9: goto          15<br>12: bipush        20<br>14: istore_1<br>15: return<br></code></pre></td></tr></table></figure>

<blockquote>
<p>思考</p>
<p>细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办?</p>
<p>参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p>
</blockquote>
<h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a><strong>循环控制指令</strong></h4><p>其实循环控制还是前面介绍的那些指令，例如 while 循环:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;<br>						a++; <br>        &#125;<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class">0: iconst_0<br> 1: istore_1<br> 2: iload_1<br> 3: bipush			10<br> 5: if_icmpge		14         //如果大于等于成立，跳转到14行<br> 8: iinc				1, 1<br>11: goto				2<br>14: return<br></code></pre></td></tr></table></figure>

<p>再比如 do while 循环:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <br>      <span class="hljs-keyword">do</span> &#123;<br>        	a++;<br>    	&#125; <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>);<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs class">0: iconst_0 <br>1: istore_1 <br>2: iinc			1,1<br>5: iload_1 <br>6: bipush 	10<br>8: if_icmplt 2							//如果小于成立，跳转到2行<br>11: return<br></code></pre></td></tr></table></figure>

<p>最后再看看 for 循环:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			&#125;<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class"> 0: iconst_0<br> 1: istore_1<br> 2: iload_1<br> 3: bipush				10<br> 5: if_icmpge			14<br> 8: iinc					1,1<br>11: goto					2<br>14: return<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归😊</p>
</blockquote>
<h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>Java源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>			x = x++;<br>			i++;<br>		&#125;<br>		System.out.println(x); <span class="hljs-comment">//结果为0</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>	//操作数栈分配<span class="hljs-number">2</span>个空间，局部变量表分配<span class="hljs-number">3</span>个空间<br>        <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span>	//准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>	//将常数<span class="hljs-number">0</span>放入局部变量表的<span class="hljs-number">1</span>号槽位 i=<span class="hljs-number">0</span><br>        <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">0</span>	//准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>	//将常数<span class="hljs-number">0</span>放入局部变量的<span class="hljs-number">2</span>号槽位 x=<span class="hljs-number">0</span>	<br>        <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>		//将局部变量表<span class="hljs-number">1</span>号槽位的数放入操作数栈中<br>        <span class="hljs-attribute">5</span>: bipush        <span class="hljs-number">10</span>	//将数字<span class="hljs-number">10</span>放入操作数栈中，此时操作数栈中有<span class="hljs-number">2</span>个数<br>        <span class="hljs-attribute">7</span>: if_icmpge     <span class="hljs-number">21</span>	//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到<span class="hljs-number">21</span>。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空<br>       <span class="hljs-attribute">10</span>: iload_<span class="hljs-number">2</span>		//将局部变量<span class="hljs-number">2</span>号槽位的数放入操作数栈中，放入的值是<span class="hljs-number">0</span><br>       <span class="hljs-attribute">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span>	//将局部变量<span class="hljs-number">2</span>号槽位的数加<span class="hljs-number">1</span>，自增后，槽位中的值为<span class="hljs-number">1</span><br>       <span class="hljs-attribute">14</span>: istore_<span class="hljs-number">2</span>	//将操作数栈中的数放入到局部变量表的<span class="hljs-number">2</span>号槽位，<span class="hljs-number">2</span>号槽位的值又变为了<span class="hljs-number">0</span><br>       <span class="hljs-attribute">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> //<span class="hljs-number">1</span>号槽位的值自增<span class="hljs-number">1</span><br>       <span class="hljs-attribute">18</span>: goto          <span class="hljs-number">4</span> //跳转到第<span class="hljs-number">4</span>条指令<br>       <span class="hljs-attribute">21</span>: getstatic     #<span class="hljs-number">2</span>                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       <span class="hljs-attribute">24</span>: iload_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">25</span>: invokevirtual #<span class="hljs-number">3</span>                  // Method java/io/PrintStream.println:(I)V<br>       <span class="hljs-attribute">28</span>: return<br></code></pre></td></tr></table></figure>

<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="lt-cinit-gt-V"><a href="#lt-cinit-gt-V" class="headerlink" title="&lt;cinit&gt;()V"></a>&lt;cinit&gt;()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>  <br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><br>	<span class="hljs-keyword">static</span> &#123;<br>		i = <span class="hljs-number">20</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">static</span> &#123;<br>		i = <span class="hljs-number">30</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		System.out.println(i); <span class="hljs-comment">//结果为30</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 <code>&lt;cinit()&gt;V </code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=0,</span> <span class="hljs-string">args_size=0</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">10:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">30</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">15:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</p>
<h5 id="lt-init-gt-V"><a href="#lt-init-gt-V" class="headerlink" title="&lt;init&gt;()V"></a>&lt;init&gt;()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br><br>	&#123;<br>		b = <span class="hljs-number">20</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>	&#123;<br>		a = <span class="hljs-string">&quot;s2&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.a = a;<br>		<span class="hljs-keyword">this</span>.b = b;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>		System.out.println(d.a);<br>		System.out.println(d.b);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有初始化代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> cn.itcast.jvm.t<span class="hljs-number">3</span>.bytecode.Demo<span class="hljs-number">3</span>_<span class="hljs-number">8</span>_<span class="hljs-number">2</span>(java.lang.String, int);<br>    <span class="hljs-attribute">descriptor</span>: (Ljava/lang/String;I)V<br>    <span class="hljs-attribute">flags</span>: ACC_PUBLIC<br>    <span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>         <span class="hljs-attribute">0</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">1</span>: invokespecial	 	#<span class="hljs-number">1</span>				// super.&lt;init&gt;()V<br>         <span class="hljs-attribute">4</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">5</span>: ldc						 	#<span class="hljs-number">2</span>				// &lt;- <span class="hljs-string">&quot;s1&quot;</span><br>         <span class="hljs-attribute">7</span>: putfield			 	#<span class="hljs-number">3</span>       	// -&gt; this.a<br>         <span class="hljs-attribute">10</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">11</span>: bipush					<span class="hljs-number">20</span>				//&lt;-<span class="hljs-number">20</span><br>         <span class="hljs-attribute">13</span>: putfield				#<span class="hljs-number">4</span>				// -&gt; this.b<br>         <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">17</span>: bipush					<span class="hljs-number">10</span>				//&lt;-<span class="hljs-number">10</span><br>         <span class="hljs-attribute">19</span>: putfield				#<span class="hljs-number">4</span>				//-&gt; this.b<br>         <span class="hljs-attribute">22</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">23</span>: ldc						#<span class="hljs-number">5</span> 				//&lt;- <span class="hljs-string">&quot;s2&quot;</span><br>         <span class="hljs-attribute">25</span>: putfield				#<span class="hljs-number">3</span>				//-&gt; this.a<br>         <span class="hljs-attribute">28</span>: aload_<span class="hljs-number">0</span>									// ------------------------------<br>         <span class="hljs-attribute">29</span>: aload_<span class="hljs-number">1</span>									// &lt;- slot <span class="hljs-number">1</span>(a) <span class="hljs-string">&quot;s3&quot;</span>            |<br>         <span class="hljs-attribute">30</span>: putfield									// -&gt; this.a                    |<br>         <span class="hljs-attribute">33</span>: aload_<span class="hljs-number">0</span>																									|<br>         <span class="hljs-attribute">34</span>: iload_<span class="hljs-number">2</span>									// &lt;- slot <span class="hljs-number">2</span>(b) <span class="hljs-number">30</span>              |<br>         <span class="hljs-attribute">35</span>: putfield									// -&gt; this.b --------------------<br>         <span class="hljs-attribute">38</span>: return<br>        <span class="hljs-attribute">LineNumberTable</span>: ...<br>        <span class="hljs-attribute">LocalVariableTable</span>:<br>            <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">0</span>  this   Lcn/itcast/jvm/t<span class="hljs-number">3</span>/bytecode/Demo<span class="hljs-number">3</span>_<span class="hljs-number">8</span>_<span class="hljs-number">2</span>;<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">1</span>     a   Ljava/lang/String;<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">2</span>     b   I<br>        <span class="hljs-attribute">MethodParameters</span>: ...<br></code></pre></td></tr></table></figure>

<blockquote>
<p>1、aload</p>
<p>从局部变量表的相应位置装载一个对象引用到操作数栈的栈顶</p>
<p>aload_0把this装载到了操作数栈中aload_0是一组格式为aload_的操作码中的一个，这一组操作码把对象的引用装载到操作数栈中标志了待处理的局部变量表中的位置，但取值仅可为0、1、2或者3。</p>
<p>2、iload_,lload_,fload_,dload_</p>
<p>还有一些其他相似的操作码用来装载非对象引用，包括iload_、lload_、fload_和dload_，这里的i代表int型，l代表long型，f代表float型以及d代表double型。在局部变量表中的索引位置大于3的变量的装载可以使用iload、lload、fload,、dload和aload，这些操作码都需要一个操作数的参数，用于确认需要装载的局部变量的位置。</p>
</blockquote>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>看一下几种不同的方法调用对应的字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();<br>		demo5.test1();<br>		demo5.test2();<br>		demo5.test3();<br>		Demo5.test4();<br>    demo5.test4();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>  私有、构造、被final修饰的方法，在调用时都使用<code>invokespecial</code>指令</li>
<li>  普通成员方法在调用时，使用<code>invokevirtual</code>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定，即为动态绑定。</li>
<li>  静态方法在调用时使用<code>invokestatic</code>指令。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: new           #<span class="hljs-number">2</span>                  // class com/nyima/JVM/day<span class="hljs-number">5</span>/Demo<span class="hljs-number">5</span> <br>         <span class="hljs-attribute">3</span>: dup<br>         <span class="hljs-attribute">4</span>: invokespecial #<span class="hljs-number">3</span>                  // Method <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>:()V<br>         <span class="hljs-attribute">7</span>: astore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">8</span>: aload_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">9</span>: invokespecial #<span class="hljs-number">4</span>                  // Method test<span class="hljs-number">1</span>:()V<br>        <span class="hljs-attribute">12</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">13</span>: invokespecial #<span class="hljs-number">5</span>                  // Method test<span class="hljs-number">2</span>:()V<br>        <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">17</span>: invokevirtual #<span class="hljs-number">6</span>                  // Method test<span class="hljs-number">3</span>:()V<br>        <span class="hljs-attribute">20</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">21</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">22</span>: pop<br>        <span class="hljs-attribute">25</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">28</span>: return<br></code></pre></td></tr></table></figure>

<ul>
<li>  new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>  dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>  终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定。只需要查找一次就可以找到方法地址。</li>
<li>  普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态。可能需要查找多次才能找到方法地址。</li>
<li>  成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
<li>  比较有意思的是 demo.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了。所以尽量使用类名来调用静态方法，否则，会产生 <code>aload</code>和<code>pop</code>这两条无用指令。</li>
<li>  还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li>
</ul>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.bytecode;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩</span><br><span class="hljs-comment">* -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_10</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Animal animal)</span> </span>&#123;<br>        animal.eat();<br>        System.out.println(animal.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        test(<span class="hljs-keyword">new</span> Cat());<br>        test(<span class="hljs-keyword">new</span> Dog());<br>        System.in.read();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>			&#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;啃骨头&quot;</span>);<br>		&#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123; <br>  			System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>		&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>1)运行代码<br>停在 System.in.read() 方法上，这时运行 jps 获取进程 id </p>
<p>2）运行HSDB工具<br>进入 JDK 安装目录，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure>

<p>进入图形界面 <code>attach to HotSpot process</code>输入进程 id</p>
<p>3)查找某个对象</p>
<p>打开 Tools -&gt; Find Object By Query<br> 输入 <code>select d from cn.itcast.jvm.t3.bytecode.Dog d</code> 点击 Execute 执行。<strong>输入全路径类名即可查询，该类对象地址</strong></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211108650.png" srcset="/img/loading.gif" lazyload></p>
<p>4)查看对象内存结构</p>
<p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是MarkWord（对象的hash码，以及对象将来加锁的锁标记），后 8 字节就是对象的 Class 指针（对象的类型指针，根据该指针可以找到对象的Class类），但目前看不到它Class类的实际地址</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211158647.png" srcset="/img/loading.gif" lazyload></p>
<p>5)查看对象 Class 的内存地址</p>
<p>可以通过 Windows -&gt; Console 进入命令行模式，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mem 0x00000001299b4978 2<br></code></pre></td></tr></table></figure>

<p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行(即 16 字节)。结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211329720.png" srcset="/img/loading.gif" lazyload></p>
<p>查看类的vtable</p>
<ul>
<li><p>方法1:Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面（该类Class对象的所有信息，Class对象在方法区中）</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211723668.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>方法2:或者 Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211742521.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法(多态相关的，final，static 不会列入)</p>
<p>那么这 6 个方法都是谁呢?从 Class 的起始地址开始算，偏移 0x1b8 （<strong>这是vtable相对Class对象固定的偏移地址</strong>）就是 vtable 的起始地址，进行计算得到:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000000001b7d4028<br>               1b8 +<br>---------------------<br>0x000000001b7d41e0<br></code></pre></td></tr></table></figure>

<p>通过 Windows -&gt; Console 进入命令行模式，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mem 0x000000001b7d41e0 6<br>0x000000001b7d41e0: 0x000000001b3d1b10<br>0x000000001b7d41e8: 0x000000001b3d15e8<br>0x000000001b7d41f0: 0x000000001b7d35e8<br>0x000000001b7d41f8: 0x000000001b3d1540<br>0x000000001b7d4200: 0x000000001b3d1678<br>0x000000001b7d4208: 0x000000001b7d3fa8<br></code></pre></td></tr></table></figure>

<p>就得到了 6 个虚方法的入口地址.</p>
<p>7)验证方法地址<br>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Dog - public void eat() @0x000000001b7d3fa8<br>Animal - public java.lang.String toString() @0x000000001b7d35e8;<br>Object - protected void finalize() @0x000000001b3d1b10;<br>Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;<br>Object - public native int hashCode() @0x000000001b3d1540;<br>Object - protected native java.lang.Object clone() @0x000000001b3d1678;<br></code></pre></td></tr></table></figure>

<p>对号入座，发现</p>
<ul>
<li>eat() 方法是 Dog 类自己的</li>
<li>toString() 方法是继承 Animal 类的</li>
<li>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的</li>
</ul>
<p>8)小结</p>
<h5 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h5><ul>
<li>在类加载阶段-链接阶段，生成vtable，确定各个普通成员方法入口地址。</li>
<li>vtable中包含和多态相关的方法（被public protected default修饰的方法），不包含被final, static,private修饰的方法。</li>
</ul>
<p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令。</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>  先通过栈帧中对象的引用找到对象</li>
<li>  分析对象头，找到对象实际的在方法区中的Class对象</li>
<li>  Class结构中有<strong>vtable</strong>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>  查询vtable找到方法的具体地址</li>
<li>  执行方法的字节码</li>
</ul>
<p><strong>从性能层面上看，调用普通成员方法效率不如调用static,final,private成员方法高，因为他要在运行期间进行动态查找方法入口地址。当然，JVM会对这个查找过程做一定的优化，如果频繁地调用每个方法达到一定的次数，那么JVM会把该方法的字节码地址加载入缓存中，以后从缓存中直接取出方法的字节码地址，不需要再经过这么多步的查找了。另外，如果JVM发现某个类一直以来只调用了一个子类，那么JVM会做一个单态的优化，这也可以加快方法的寻址速度。</strong></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">goto          12</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">astore_2</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">//多出来一个异常表</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target type</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5     8   Class java/lang/Exception</span><br>      <span class="hljs-attr">LineNumberTable</span>: <span class="hljs-string">...</span><br>      <span class="hljs-attr">LocalVariableTable</span>:<span class="hljs-string"></span><br>        <span class="hljs-attr">Start</span>  <span class="hljs-string">Length  Slot  Name   Signature</span><br>            <span class="hljs-attr">9</span>       <span class="hljs-string">3     2     e   Ljava/lang/Exception;</span><br>            <span class="hljs-attr">0</span>      <span class="hljs-string">13     0  args   [Ljava/lang/String;</span><br>            <span class="hljs-attr">2</span>      <span class="hljs-string">11     1     i   I</span><br>      <span class="hljs-attr">StackMapTable</span>: <span class="hljs-string">...</span><br>    <span class="hljs-attr">MethodParameters</span>: <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure>

<ul>
<li>  可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>  8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			i = <span class="hljs-number">30</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);<br>    <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V<br>    <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC<br>    <span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">2</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">5</span>: goto          <span class="hljs-number">26</span><br>         <span class="hljs-attribute">8</span>: astore_<span class="hljs-number">2</span><br>         <span class="hljs-attribute">9</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-attribute">11</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">12</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-attribute">15</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">16</span>: bipush        <span class="hljs-number">40</span><br>        <span class="hljs-attribute">18</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">19</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-attribute">22</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">23</span>: bipush        <span class="hljs-number">50</span><br>        <span class="hljs-attribute">25</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">26</span>: return<br>      <span class="hljs-attribute">Exception</span> table:<br>         <span class="hljs-attribute">from</span>    to  target type<br>          <span class="hljs-attribute">2</span>		<span class="hljs-number">5</span>		<span class="hljs-number">8</span> 	Class java/lang/ArithmeticException<br>          <span class="hljs-attribute">2</span> 	<span class="hljs-number">5</span> 		<span class="hljs-number">15</span>  Class java/lang/NullPointerException<br>          <span class="hljs-attribute">2</span> 	<span class="hljs-number">5</span> 		<span class="hljs-number">22</span>  Class java/lang/Exception<br>          <span class="hljs-attribute">LineNumberTable</span>: ...<br>          <span class="hljs-attribute">LocalVariableTable</span>:<br>              <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature<br>                  <span class="hljs-attribute">9</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/ArithmeticException;<br>                 <span class="hljs-attribute">16</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/NullPointerException;<br>                 <span class="hljs-attribute">23</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>                  <span class="hljs-attribute">0</span>      <span class="hljs-number">27</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span><br><span class="hljs-meta">                  2      25     1     i   I</span><br><span class="hljs-meta">            StackMapTable: ...</span><br><span class="hljs-meta">          MethodParameters: ...</span><br></code></pre></td></tr></table></figure>

<ul>
<li>  因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong>，这样做可以节省栈帧内存。</li>
</ul>
<h5 id="multi-catch-的情况"><a href="#multi-catch-的情况" class="headerlink" title="multi-catch 的情况"></a><strong>multi-catch</strong> <strong>的情况</strong></h5><p>JDK1.7之后，允许同时catch多个异常类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>            test.invoke(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>		&#125; <br>	&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs class">public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=3, locals=2, args_size=1<br>         0: ldc           #2<br>         2: ldc           #3<br>         4: iconst_0<br>         5: anewarray     #4<br>         8: invokevirtual #5<br>        11: astore_1<br>        12: aload_1<br>        13: aconst_null<br>        14: iconst_0<br>        15: anewarray     #6<br>        18: invokevirtual #7<br>        21: pop<br>        22: goto          30<br>        25: astore_1<br>        26: aload_1<br>        27: invokevirtual #11 // e.printStackTrace:()V<br>        30: return<br>      Exception table:<br>         from    to  target type<br>           0    22    25	Class java/lang/NoSuchMethodException<br>           0    22    25	Class java/lang/IllegalAccessException<br>           0    22    25	Class java/lang/reflect/InvocationTargetException<br>        LineNumberTable: ...<br>        LocalVariableTable:    <br>            Start  Length  Slot  Name   Signature<br>               12      10     1  test   Ljava/lang/reflect/Method;<br>               26       4     1     e   Ljava/lang/ReflectiveOperationException;<br>                0      31     0  args   [Ljava/lang/String;<br>          StackMapTable: ...<br>        MethodParameters: ...<br></code></pre></td></tr></table></figure>

<p><strong>这里异常对象和test对象共用一个局部变量槽位，JVM是非常智能的，他会统计最大需要多少局部变量槽位。</strong></p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><strong>加上finally之后，由于finally块内代码没有被catch，故而JVM字节码会在finally代码块最后补上一个athrow</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_4</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          i = <span class="hljs-number">10</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          i = <span class="hljs-number">20</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          i = <span class="hljs-number">30</span>;<br>      &#125; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>   <span class="hljs-comment">//locals=4，说明有四个局部变量，但是下面的局部变量表只有3个，说明有一个没有名字的局部变量槽位</span><br>		<span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1				<span class="hljs-comment">// 0-&gt;i</span><br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>		<span class="hljs-comment">// try --------------------------------------</span><br>        <span class="hljs-number">4</span>: istore_1				<span class="hljs-comment">// 10-&gt;i									|</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>		<span class="hljs-comment">// finally 									|</span><br>        <span class="hljs-number">7</span>: istore_1				<span class="hljs-comment">// 30-&gt;i									|</span><br>        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span>		<span class="hljs-comment">// return -----------------------------------</span><br>        <span class="hljs-number">11</span>: astore_2			<span class="hljs-comment">// catch Exceptin -&gt; e ----------------------</span><br>        <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>    <span class="hljs-comment">//                                          |</span><br>        <span class="hljs-number">14</span>: istore_1			<span class="hljs-comment">// 20-&gt;i									|</span><br>        <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span>	<span class="hljs-comment">// finally									|</span><br>        <span class="hljs-number">17</span>: istore_1            <span class="hljs-comment">// 30-&gt;i									|</span><br>        <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span>	<span class="hljs-comment">// return -----------------------------------</span><br>        <span class="hljs-number">21</span>: astore_3			<span class="hljs-comment">// catch any -&gt; slot 3 ---------------------- </span><br>        <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span>	<span class="hljs-comment">// finally									|</span><br>        <span class="hljs-number">24</span>: istore_1			<span class="hljs-comment">// 30-&gt;i 									|</span><br>        <span class="hljs-number">25</span>: aload_3				<span class="hljs-comment">// &lt;- slot 3 								|</span><br>        <span class="hljs-number">26</span>: athrow				<span class="hljs-comment">// throw ------------------------------------</span><br>        <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>      Exception table:<br>         from    to  target type<br>            <span class="hljs-number">2</span> 	  <span class="hljs-number">5</span> 	<span class="hljs-number">11</span>  	Class java/lang/Exception<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    	<span class="hljs-number">21</span>		any <span class="hljs-comment">// 剩余的异常类型，比如 Error</span><br>            <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>		any <span class="hljs-comment">// 剩余的异常类型，比如 Error</span><br>      LineNumberTable: ...<br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>             <span class="hljs-number">12</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>              <span class="hljs-number">0</span>      <span class="hljs-number">28</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>              <span class="hljs-number">2</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I<br>        StackMapTable: ...<br>      MethodParameters: ...<br></code></pre></td></tr></table></figure>

<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程。</p>
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
<h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><p>下面代码，输出是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_12_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = test();<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        	<span class="hljs-keyword">return</span> <span class="hljs-number">20</span>; <br>        &#125;<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()I<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush			<span class="hljs-number">10</span> 	<span class="hljs-comment">// &lt;- 10 放入栈顶</span><br>        <span class="hljs-number">2</span>: istore_0				<span class="hljs-comment">// 10 -&gt; slot 0 (从栈顶移除了)</span><br>        <span class="hljs-number">3</span>: bipush			<span class="hljs-number">20</span> 	<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">5</span>: ireturn				<span class="hljs-comment">// 返回栈顶 int(20)</span><br>        <span class="hljs-number">6</span>: astore_1				<span class="hljs-comment">// catch any -&gt; slot 1 </span><br>        <span class="hljs-number">7</span>: bipush			<span class="hljs-number">20</span>	<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">9</span>: ireturn				<span class="hljs-comment">// 返回栈顶 int(20)</span><br>        Exception table:<br>           from    to  target type<br>               <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   any<br>        LineNumberTable: ...<br>        StackMapTable: ...<br></code></pre></td></tr></table></figure>

<ul>
<li>  由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>  至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>  跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong>。<strong>catch 匹配到any，在throw之前return了，所以不会throw异常</strong></li>
<li>  所以<strong>一定不要在finally中进行返回操作，否则会吞掉异常</strong></li>
</ul>
<h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会发现打印结果为20，并未抛出异常。</p>
<h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><p>下面代码输出10，因为在执行finally代码块之前，JVM已经把返回值暂存到特定临时变量槽中了，所以后面对i进行赋值，并不会影响返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = Demo4.test();<br>		System.out.println(i);  <span class="hljs-comment">//10</span><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">return</span> i;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()I<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush			<span class="hljs-number">10</span> 	<span class="hljs-comment">// &lt;- 10 放入栈顶</span><br>        <span class="hljs-number">2</span>: istore_0				<span class="hljs-comment">// 10-&gt;i</span><br>        <span class="hljs-number">3</span>: iload_0				<span class="hljs-comment">// &lt;- i(10)</span><br>        <span class="hljs-number">4</span>: istore_1				<span class="hljs-comment">// 10 -&gt; slot 1，暂存至 slot 1，目的是为了固定返回值 </span><br>        <span class="hljs-number">5</span>: bipush			<span class="hljs-number">20</span>	<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">7</span>: istore_0				<span class="hljs-comment">// 20-&gt;i</span><br>        <span class="hljs-number">8</span>: iload_1				<span class="hljs-comment">// &lt;- slot 1(10) 载入 slot 1 暂存的值</span><br>        <span class="hljs-number">9</span>: ireturn				<span class="hljs-comment">// 返回栈顶的 int(10)</span><br>        <span class="hljs-number">10</span>: astore_2<br>        <span class="hljs-number">11</span>: bipush        	<span class="hljs-number">20</span><br>        <span class="hljs-number">13</span>: istore_0<br>        <span class="hljs-number">14</span>: aload_2<br>        <span class="hljs-number">15</span>: athrow<br>        Exception table:<br>           from    to  target type<br>               <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br>        LineNumberTable: ...<br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>        	<span class="hljs-number">3</span> 		<span class="hljs-number">13</span> 		<span class="hljs-number">0</span> 	i 		I<br>          StackMapTable: ...<br></code></pre></td></tr></table></figure>

<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_13</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object lock = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        	System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>	<span class="hljs-comment">// new Object</span><br>         <span class="hljs-number">3</span>: dup					<span class="hljs-comment">// 复制一份Object实例对象的引用，因为下面一个实例对象的引用要去调用构造方法，另一份要加锁。</span><br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>	<span class="hljs-comment">// invokespecial &lt;init&gt;:()V</span><br>         <span class="hljs-number">7</span>: astore_1			<span class="hljs-comment">// lock引用 -&gt; lock</span><br>       	 <span class="hljs-number">8</span>: aload_1				<span class="hljs-comment">// &lt;- lock (synchronized开始)</span><br>         <span class="hljs-number">9</span>: dup					<span class="hljs-comment">// 复制一份Object实例对象的引用，因为下面monitorenter,monitorexit要各消耗一个Object实例对象引用</span><br>        <span class="hljs-number">10</span>: astore_2			<span class="hljs-comment">// lock引用 -&gt; slot 2</span><br>        <span class="hljs-number">11</span>: monitorenter		<span class="hljs-comment">// monitorenter(lock引用)，即加锁</span><br>        <span class="hljs-number">12</span>: getstatic	#<span class="hljs-number">3</span>		<span class="hljs-comment">// &lt;- System.out</span><br>        <span class="hljs-number">15</span>: ldc			#<span class="hljs-number">4</span>		<span class="hljs-comment">// &lt;- &quot;ok&quot;</span><br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span>	<span class="hljs-comment">// invokevirtual println: (Ljava/lang/String;)V</span><br>        <span class="hljs-number">20</span>: aload_2				<span class="hljs-comment">// &lt;- slot 2(lock引用)</span><br>        <span class="hljs-number">21</span>: monitorexit			<span class="hljs-comment">// monitorexit(lock引用)，即正常解锁代码块</span><br>        <span class="hljs-number">22</span>: goto		<span class="hljs-number">30</span><br>        <span class="hljs-number">25</span>: astore_3			<span class="hljs-comment">// any -&gt; slot 3</span><br>        <span class="hljs-number">26</span>: aload_2				<span class="hljs-comment">// &lt;- slot 2(lock引用)</span><br>        <span class="hljs-number">27</span>: monitorexit			<span class="hljs-comment">// monitorexit(lock引用)，即异常解锁代码块</span><br>        <span class="hljs-number">28</span>: aload_3<br>        <span class="hljs-number">29</span>: athrow<br>        <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>            Exception table:<br>               from    to  target type<br>            	<span class="hljs-number">12</span> 		<span class="hljs-number">22</span> 	<span class="hljs-number">25</span> 	  any      <span class="hljs-comment">// synchronized代码块和正常解锁代码块出现异常，直接跳转到异常解锁代码块。</span><br>                <span class="hljs-number">25</span>    	<span class="hljs-number">28</span>  <span class="hljs-number">25</span>    any	   <span class="hljs-comment">// 异常解锁代码块出现异常，直接跳转到异常解锁代码块。</span><br>            LineNumberTable: ...<br>          LocalVariableTable:<br>            Start  Length  Slot  Name   Signature<br>                <span class="hljs-number">0</span>      <span class="hljs-number">31</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>                <span class="hljs-number">8</span>      <span class="hljs-number">23</span>     <span class="hljs-number">1</span>  lock   Ljava/lang/Object;<br>              StackMapTable: ...<br>            MethodParameters: ...<br></code></pre></td></tr></table></figure>

<p><strong>为了保证，程序一定能够解锁成功，JVM加上了异常处理机制。</strong></p>
<blockquote>
<p>注意：</p>
<p>方法级别的 synchronized 不会在字节码指令中有所体现。</p>
</blockquote>
<h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 _.java 源码编译为 _.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。</p>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。并不是编译器还会转换出中间的 java 源码，这只是将字节码文件反编译成java文件便于阅读，java编译器转换的结果直接就是 class 字节码。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过编译期优化后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-keyword">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱。</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成，代码片段1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码在 JDK5之前是无法编译通过的，必须改写为代码片段2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型)，因此这些转换的事情在了JDK5以后都由编译器在编译阶段完成。即代码片段1都会在编译阶段被转换为代码片段2</p>
<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即有一些泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理（有一些泛型信息不会被擦除）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是 list.add(Objcet o)</span><br>      Integer x = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是Object x = get(int index)   </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">11</span>: invokestatic  #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Object o)</span><br>      <span class="hljs-number">14</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(int index)   </span><br>      <span class="hljs-number">22</span>: invokeinterface #<span class="hljs-number">6</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span><br>      <span class="hljs-number">27</span>: checkcast     #<span class="hljs-number">7</span>                  <span class="hljs-comment">// class java/lang/Integer</span><br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br>          <br>    LineNumberTable:<br>      line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">9</span>: <span class="hljs-number">8</span><br>      line <span class="hljs-number">10</span>: <span class="hljs-number">20</span><br>      line <span class="hljs-number">11</span>: <span class="hljs-number">31</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>      <span class="hljs-number">0</span>      <span class="hljs-number">32</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>      <span class="hljs-number">8</span>      <span class="hljs-number">24</span>     <span class="hljs-number">1</span>  list   Ljava/util/List;<br>    LocalVariableTypeTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">8</span>      <span class="hljs-number">24</span>     <span class="hljs-number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;<br></code></pre></td></tr></table></figure>

<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需要将 Object 转为 Integer</span><br>Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>如果前面的x变量类型修改为int基本类型那么最终生成的字节码是： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer， 并执行拆箱操作</span><br><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure>

<p>还好这些麻烦事都不用自己做。</p>
<p><strong>擦除的是字节码上的（即方法体内的）泛型信息，可以看到 LocalVariableTypeTable（局部变量类型表） 仍然保留了局部变量的泛型的信息，但是无法通过反射得到这些局部变量的泛型信息。只能通过反射得到方法的参数和返回值的泛型信息。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Method test = Candy3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);<br>Type[] types = test.getGenericParameterTypes();<br><span class="hljs-keyword">for</span> (Type type : types) &#123;<br>	<span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>		ParameterizedType parameterizedType = (ParameterizedType) type; <br>        System.out.println(<span class="hljs-string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType()); <br>        Type[] arguments = parameterizedType.getActualTypeArguments(); <br>    	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>    		System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]); <br>        &#125;<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span> </span><br><span class="hljs-class">   泛型参数[0] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span> </span><br><span class="hljs-class">   原始类型 - <span class="hljs-title">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Map</span> </span><br><span class="hljs-class">   泛型参数[0] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Integer</span> </span><br><span class="hljs-class">   泛型参数[1] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br></code></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数也是JDK5开始加入的新特性：</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。</p>
<p>同样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>仍是JDK5开始引入的语法糖，数组的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;   <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>			System.out.println(x);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会帮我们转换为最朴素的for循环遍历数组下标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br>			<span class="hljs-keyword">int</span> x = arr[i];<br>			System.out.println(x);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意 </p>
<p>foreach 循环写法，能够配合数组，以及所有实现了 Iterable接口的集合类一起使用，其中 Iterable()方法 用 来获取集合的迭代(Iterator)</p>
</blockquote>
<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><p>从JDK7开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> 注意 </p>
<p>switch配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚</p>
</blockquote>
<p>在编译器中执行的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>  字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>  使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>  第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<p>可以看到，执行了两遍 switch， 第一遍是根据字符串的hashCode和 equals将字符串的转换为相应 byte类 型，第二遍才是利用byte执行进行比较。 </p>
<p>为什么第一遍时必须既比较 hashCode， 又利用 equals 比较呢？ hashCode是为了提高效率，减少可能的比 较；而 equals 是为了防止 hashCode冲突，例如<code>BM</code>和<code>c.</code>这两个字符串的hashCode值都是 2123，如果有如下 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (str) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BM&quot;</span>: &#123;<br>                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C.&quot;</span>: &#123;<br>                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会被编译器转换为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy6_2</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span> x = -<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">switch</span>(str.hashCode()) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">2123</span>: <span class="hljs-comment">// hashCode 值可能相同，需要进一步用 equals 比较</span><br>            <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;C.&quot;</span>)) &#123;<br>                x = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;BM&quot;</span>)) &#123;<br>                x = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">switch</span>(x) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            	System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><p>switch 枚举的例子，原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器中执行的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）,是一个静态内部类，程序员不可见，JVM仅可见   </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>JDK7新增了枚举类，以前面的性别枚举为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    	<span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    	MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> 	<br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><strong>try-with-resources</strong></h4><p>JDK7开始新增了对需要关闭的资源处理的特殊语法<code> try-with-resources</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象)&#123;<br>    <br>&#125; <span class="hljs-keyword">catch</span>( ) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中资源对象需要实现 <code>AutoCloseable</code>接口,例如<code> Inputstream</code>、 <code>Outputstream</code>、<code> Connection</code>、<code> Statement</code>、<code>ResultSet </code>等接口都实现了<code>AutoCloseable</code>,使用 <code>try-with-resources</code> 可以不用写<code>finally</code> 语句块,编译器会帮助生成关闭资源代码,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>)) &#123;<br>            System.out.println(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会被转换为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            Throwable t = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(is);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>                <span class="hljs-comment">// t 是我们代码出现的异常 </span><br>                t = e1;<br>                <span class="hljs-keyword">throw</span> e1;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 判断了资源不为空 </span><br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>                	<span class="hljs-comment">// 如果我们代码有异常 </span><br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            is.close();<br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;<br>                        <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加 </span><br>                            t.addSuppressed(e2);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span><br>                		is.close();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>JVM会将要抛出的异常的对象的引用存放到一个局部变量里，并将该变量存到方法栈的栈顶等待弹出，此时程序计数器指针指向finally内的代码，遇到下一个要抛出的异常，该异常则顶替先前异常对象引用所在位置，所以程序只会输出finally内的异常。</p>
<p>为什么要设计一个 <code>addsuppressed(Throwab1e e)</code>(添加被压制异常)的方法呢?是为了防止异常信息的丢失（想想 try-with-resources 生成的fianlly 中如果抛出了异常):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;close 异常&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br>	at test.Test6.main(Test6.java:<span class="hljs-number">7</span>) <br>    Suppressed: java.lang.Exception: close 异常<br>        at test.MyResource.close(Test6.java:<span class="hljs-number">18</span>)<br>        at test.Test6.main(Test6.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>

<p>如以上代码所示，两个异常信息都不会丢。</p>
<h4 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a><strong>方法重写时的桥接方法</strong></h4><p>我们都知道，方法重写时对返回值分两种情况:</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类(比较绕口，见下面的例子)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>	<span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于子类，java 编译器会做如下处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>    &#125;<br>	<span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 调用 public Integer m()</span><br>		<span class="hljs-keyword">return</span> m(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中桥接方法（合成方法）比较特殊，仅对 java 虚拟机可见，合成方法允许方法同名且参数一致，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Method m : B.class.getDeclaredMethods()) &#123;<br>    System.out.println(m);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer test.candy.B.m()<br><span class="hljs-keyword">public</span> java.lang.Number test.candy.B.m()<br></code></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;   <span class="hljs-comment">//虽然不是final变量，但是代码未对其进行修改，是实际上的final变量</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转化后代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val$x;<br>    Candy11$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>.val$x = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-keyword">this</span>.val$x);<br>	&#125; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的或者实际上的final不变量:因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化。</p>
<p>从内部类引用的本地变量必须是最终变量或实际上的最终变量。</p>
</blockquote>
<h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><p>关于在什么时候启动类加载阶段的第一个阶段“加载”，《Java虚拟机规范》中没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul>
<li>  _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用。因为C++的instanceKlass不能直接被Java访问，但是.class和instanceKlass互相有各自的地址，这个类镜像起到一个桥梁的作用。</li>
<li>  _super 即父类</li>
<li>  _ﬁelds 即成员变量</li>
<li>  _methods 即方法</li>
<li>  _constants 即常量池</li>
<li>  _class_loader 即类加载器</li>
<li>  _vtable 虚方法表</li>
<li>  _itable 接口方法</li>
</ul>
</li>
<li>  如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li>  加载和链接可能是<strong>交替运行</strong>的</li>
</ul>
<blockquote>
<p>注意 </p>
<ul>
<li>instanceKlass 这样的【元数据】是存储在方法区(1.8后的元空间内)，但java_mirror是存储在堆中 </li>
<li>可以通过前面介绍的 HSDB 工具查看</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611205050.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>  _java_mirror则是保存在<strong>堆内存</strong>中，*.class是一个对象，该对象是在加载instanceKlass的同时生成的，放在堆内存中。</li>
<li>  InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>  类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>
<p>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld<br>Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="hljs-number">3405691578</span> in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">file</span> <span class="hljs-title">cn</span>/<span class="hljs-title">itcast</span>/<span class="hljs-title">jvm</span>/<span class="hljs-title">t5</span>/<span class="hljs-title">HelloWorld</span></span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">defineClass1</span>(<span class="hljs-title">Native</span> <span class="hljs-title">Method</span>)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:763)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">security</span>.<span class="hljs-title">SecureClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">SecureClassLoader</span>.<span class="hljs-title">java</span>:142)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:467)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">access</span>$100(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:73)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>$1.<span class="hljs-title">run</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:368)</span><br><span class="hljs-class">    	<span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>$1.<span class="hljs-title">run</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:362)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">security</span>.<span class="hljs-title">AccessController</span>.<span class="hljs-title">doPrivileged</span>(<span class="hljs-title">Native</span> <span class="hljs-title">Method</span>)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">findClass</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:361)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:424)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">sun</span>.<span class="hljs-title">misc</span>.<span class="hljs-title">Launcher</span>$<span class="hljs-title">AppClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">Launcher</span>.<span class="hljs-title">java</span>:331)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:357)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">sun</span>.<span class="hljs-title">launcher</span>.<span class="hljs-title">LauncherHelper</span>.<span class="hljs-title">checkAndLoadMain</span>(<span class="hljs-title">LauncherHelper</span>.<span class="hljs-title">java</span>:495)</span><br></code></pre></td></tr></table></figure>



<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>  static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>  static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成。</li>
<li>  如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>  如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
<li>  对于String和基本数据类型来说，如果字面量的方式赋值，且static final修饰的话，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行。如果是new出来的，则是在初始化阶段<clinit>()中赋值的情况： 排除上述的在准备环节赋值的。</li>
</ul>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中的符号引用解析为直接引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 解析的含义 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException,IOException </span>&#123;<br>		ClassLoader classloader = Load2.class.getClassLoader();<br>		<span class="hljs-comment">// loadClass 方法不会导致类的解析和初始化，只会导致加载阶段进行。</span><br>		Class&lt;?&gt; c = classloader.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.C&quot;</span>);<br>		<span class="hljs-comment">// new C(); 会触发类的加载，链接-解析，初始化。</span><br>        <br>        System.in.read();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>HSDB的使用</strong></p>
<ul>
<li>  先获得要查看的进程ID</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></td></tr></table></figure>

<ul>
<li>  打开HSDB</li>
</ul>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -cp F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>a-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure>

<ul>
<li>  运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611221703.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  定位需要的进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611221857.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611222029.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>解析的含义</strong></p>
<p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li>  未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      ClassLoader loader = Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>打开HSDB<ul>
<li>  可以看到此时只加载了类C</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611223153.png" srcset="/img/loading.gif" lazyload></p>
<p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611230658.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>解析以后，会将常量池中的符号引用解析为直接引用<ul>
<li>  可以看到，此时已加载并解析了类C和类D</li>
</ul>
  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611223441.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200613104723.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化即调用 <strong>cinit()V</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li>  main 方法所在的类，总会被首先初始化</li>
<li>  首次访问这个类的静态变量或静态方法时</li>
<li>  子类初始化，如果父类还没初始化，会先引发父类初始化</li>
<li>  子类访问父类的静态变量，只会触发父类的初始化</li>
<li>  Class.forName</li>
<li>  new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>  访问类的 .static ﬁnal 静态常量（基本类型和字符串）不会触发初始化</li>
<li>  类对象.class 不会触发初始化</li>
<li>  创建该类对象的数组不会触发初始化</li>
<li>  类加载器的.loadClass方法</li>
<li>  Class.forNamed的参数2为false时</li>
</ul>
<p>实验如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>验证(实验时请先全部注释，每次只执行其中一个)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load3</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123; <br>        <span class="hljs-comment">// 1. 静态常量(基本类型和字符串)不会触发初始化</span><br>        System.out.println(B.b);<br>        <span class="hljs-comment">// 2. 类对象.class 不会触发初始化</span><br>        System.out.println(B.class);<br>        <span class="hljs-comment">// 3. 创建该类的数组不会触发初始化</span><br>        System.out.println(<span class="hljs-keyword">new</span> B[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span><br>        ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>        cl.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>);<br>        <span class="hljs-comment">// 5. 不会初始化类 B，但会加载 B、A</span><br>        ClassLoader c2 = Thread.currentThread().getContextClassLoader(); <br>        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>, <span class="hljs-keyword">false</span>, c2);<br>        <br>        <span class="hljs-comment">// 1. 首次访问这个类的静态变量或静态方法时 </span><br>        System.out.println(A.a);<br>        <span class="hljs-comment">// 2. 子类初始化，如果父类还没初始化，会引发 </span><br>        System.out.println(B.c);<br>        <span class="hljs-comment">// 3. 子类访问父类静态变量，只触发父类初始化 </span><br>        System.out.println(B.a);<br>        <span class="hljs-comment">// 4. 会初始化类 B，并先初始化类 A </span><br>        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<p><strong>需要特别注意的是，</strong>针对<strong>访问类的 static final静态常量（基本类型和字符串）</strong>是不是会触发初始化，要分两种情况：static final静态常量只能在定义时或者静态代码块中初始化：</p>
<p><strong>定义时</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jyg.reflection.classload_;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoad02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(A.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">//        num = 2;</span><br>        System.out.println(<span class="hljs-string">&quot;static &#123;&#125; runing&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2<br></code></pre></td></tr></table></figure>

<p><strong>静态代码块中</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jyg.reflection.classload_;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoad02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(A.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;static &#123;&#125; running&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">static &#123;&#125; running<br>2<br></code></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(E.a); <span class="hljs-comment">//不会</span><br>        System.out.println(E.b); <span class="hljs-comment">//不会</span><br>        System.out.println(E.c); <span class="hljs-comment">//会</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>典型应用 - 完成懒惰初始化单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; <br>        <br>    &#125;<br>	<span class="hljs-comment">// 内部类中保存单例</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>	<span class="hljs-comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上的实现特点是:</p>
<ul>
<li>懒惰实例化</li>
<li>初始化时的线程安全是有保障的（类的加载是线程安全的，有加锁的，你可以看源码）</li>
</ul>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
<th>显示</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>因为它是C++代码，不允许Java直接访问</td>
<td>null</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap</td>
<td>ExtensionClassLoader</td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
<td>ApplicationClassLoader</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
<td></td>
</tr>
</tbody></table>
<p>每次要加载一个类时，会逐级向上委派，如果上级类加载器<code>已经加载过该类</code>或者<code>上级目录中有该类，上级会加载该类</code>，此时下级不会加载该类，即便下级类加载器路径下有该类。如果上级类加载器<code>已经没有加载过该类</code>并且<code>上级目录中没有该类，上级无法加载该类</code>，此时下级类加载器路径下有该类，下级才会加载该类。</p>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p><code>Bootstrap</code>类加载器一般加载<code>JAVA\_HOME/jre/lib</code>目录下的类，也可以通过JVM虚拟机参数，把自己写的类交由<code>Bootstrap</code>类加载器来加载。</p>
<p>用 Bootstrap 类加载器加载类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;bootstrap F init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.F&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5_1<br>bootstrap F init<br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>-Xbootclasspath</code> 表示设置 <code>bootclasspath</code></p>
</li>
<li><p>其中 <code>/a:.</code>表示将后面的参数目录追加至 <code>bootclasspath</code> 之后 </p>
</li>
<li><p>可以用这个办法替换核心类</p>
<ul>
<li><p><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code> </p>
<p><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code><br><code> java -Xbootclasspath/p:&lt;追加路径&gt;</code></p>
</li>
</ul>
</li>
</ul>
<p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;classpath G init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.G&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">classpath G init<br>sun.misc.Launcher$AppClassLoader@18b4aac2<br></code></pre></td></tr></table></figure>

<p>写一个同名的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ext G init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打个 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class<br>已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = <span class="hljs-number">481</span>) (输出 = <span class="hljs-number">322</span>)(压缩了 <span class="hljs-number">33</span>%)<br></code></pre></td></tr></table></figure>

<p>将 jar 包拷贝到 <code>JAVA_HOME/jre/lib/ext </code></p>
<p>重新执行，输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ext G init<br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure>

<p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<blockquote>
<p><strong>注意</strong></p>
<p>这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p>
</blockquote>
<p>loadClass源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// // 1. 检查该类是否已经加载，即查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 2. 有上级的话，委派上级 loadClass</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 3. 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader，其实BootstrapClassLoader就是null</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 4. 如果上级类加载器每一层找不到，调用当前类加载器的 findClass 方法在当前类加载器的指定目录下来加载</span><br>                <span class="hljs-comment">// 如果还是没有找到该类，由当前类加载器的 findClass方法抛出ClassNotFoundException异常</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 5. 记录耗时</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader()<br>            .loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.H&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行流程为:</p>
<ol>
<li><code>sun.misc.Launcher$AppClassLoader </code>//1 处， 开始查看已加载的类，结果没有</li>
<li><code>sun.misc.Launcher$AppClassLoader</code> // 2 处，委派上级<code>sun.misc.Launcher$ExtClassLoader.loadClass()</code></li>
<li><code>sun.misc.Launcher$ExtClassLoader</code> // 1 处，查看已加载的类，结果没有</li>
<li><code>sun.misc.Launcher$ExtClassLoader</code> // 3 处，没有上级了，则委派 <code>BootstrapClassLoader</code>查找</li>
<li><code>BootstrapClassLoader</code> 是在 <code>JAVA_HOME/jre/lib</code> 下找 <code>H </code>这个类，显然没有</li>
<li><code>sun.misc.Launcher$ExtClassLoader</code> // 4 处，调用自己的<code>findClass</code>方法，是在<code>JAVA_HOME/jre/lib/ext</code> 下找<code>H</code>这个类，显然没有，回到 <code>sun.misc.Launcher$AppClassLoader</code>的 // 2 处</li>
<li>继续执行到 <code>sun.misc.Launcher$AppClassLoader </code>// 4 处，调用它自己的 findClass 方法，在<code>classpath</code> 下查找，找到了</li>
</ol>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a><strong>线程上下文类加载器</strong></h4><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的，你知道是怎么做的吗?</p>
<p>让我们追踪一下源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>&#123;<br>	<span class="hljs-comment">// 注册驱动的集合</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers<br>        = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>	<span class="hljs-comment">// 初始化驱动 </span><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>先不看别的，看看 DriverManager 的类加载器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(DriverManager.class.getClassLoader()); <span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure>

<p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢?</p>
<p>继续看 loadInitialDrivers() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>        String drivers;<br>        <span class="hljs-keyword">try</span> &#123;<br>            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-function">PrivilegedAction&lt;String&gt;</span><br><span class="hljs-function">                <span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>                &#125;<br>			&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            drivers = <span class="hljs-keyword">null</span>;<br>		&#125;<br>		<span class="hljs-comment">// 1)使用 ServiceLoader 机制加载驱动，即 SPI </span><br>    	AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                        driversIterator.next();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                    <span class="hljs-comment">// Do nothing</span><br>                &#125;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;);<br>        println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br>		<span class="hljs-comment">// 2)使用 jdbc.drivers 定义的驱动名加载驱动</span><br>		<span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>        <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>                <span class="hljs-comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 </span><br>                <span class="hljs-comment">// DriverManager的类加载器是BootstrapClassLoader,这里却使用的是应用程序类加载器，打破了JVM的双亲委派机制</span><br>                Class.forName(aDriver, <span class="hljs-keyword">true</span>, ClassLoader.getSystemClassLoader());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    				println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先看 2)发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载</p>
<p>再看 1)它就是大名鼎鼎的 Service Provider Interface (SPI)，主要是为了解耦<br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名命名文件，文件内容是实现类名称</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230330191157300.png" srcset="/img/loading.gif" lazyload></p>
<p>这样就可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); <br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br>    iter.next();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想:</p>
<ul>
<li>JDBC</li>
<li>Servlet 初始化器</li>
<li>Spring 容器</li>
<li>Dubbo(对 SPI 进行了扩展)</li>
</ul>
<p>接着看 ServiceLoader.load 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>	<span class="hljs-comment">// 获取线程上下文类加载器</span><br>	ClassLoader cl = Thread.currentThread().getContextClassLoader(); <br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;<br>        fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;<br>        fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>    &#125; <span class="hljs-keyword">try</span> &#123;<br>            S p = service.cast(c.newInstance());<br>            providers.put(cn, p);<br>            <span class="hljs-keyword">return</span> p;<br>     &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>, x);<br>    &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();          <span class="hljs-comment">// This cannot happen</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>1、在jre/lib包下有一个DriverManager，是BootstrapClassLoader加载的，但是jdbc的驱动是各个厂商来实现的不在启动类加载路径下，启动类无法加载，而驱动管理需要用到这些驱动。</li>
<li>2、只能打破双亲委派，启动类直接请求系统类加载器去classpath下加载驱动（正常是向上委托，这个反过来了），而打破双亲委派的就是这个线程上下文类加载器</li>
<li>3、过程就是：启动类加载器加载DriverManager，DriverManager代码里调用了线程上下文类加载器，这个加载器默认就是使用应用程序类加载器加载类，通过应用程序类加载器加载jdbc驱动</li>
</ul>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>  想加载非 classpath 随意路径中的类文件</li>
<li>  通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>  这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>  继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>  不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>  读取类文件的字节码</li>
<li>  调用父类的 deﬁneClass 方法来加载类</li>
<li>  使用者调用该类加载器的 loadClass 方法</li>
</ul>
<p>示例:<br> 准备好一个字节码（<code>MapImpl1.class</code>）文件放入 E:\myclasspath，它实现了 java.util.Map 接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c1 = classLoader.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        Class&lt;?&gt; c2 = classLoader.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        System.out.println(c1 == c2); <span class="hljs-comment">//true</span><br><br>        MyClassLoader classLoader2 = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c3 = classLoader2.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        System.out.println(c1 == c3); <span class="hljs-comment">//false  </span><br><br>        c1.newInstance();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        String path = <span class="hljs-string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            Files.copy(Paths.get(path), os);<br><br>            <span class="hljs-comment">// 得到字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = os.toByteArray();<br><br>            <span class="hljs-comment">// byte[] -&gt; *.class</span><br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(<span class="hljs-string">&quot;类文件未找到&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>两个Class对象是否完全相同，要比较包名+类名+类加载器对象。三者完全相同，两个Class对象才相同。</strong></p>
<p><strong>自定义的类加载器，在调用构造方法时，会调用继承的<code>ClassLoader</code>的有参构造器，会将线程上下文类加载器（ApplicationClassLoader）放入当前类加载器对象的上级字段中，所以自定义类加载器的上级是ApplicationClassLoader</strong></p>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p><strong>分层编译</strong></p>
<p>(TieredCompilation) 先来个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.jit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT1</span> </span>&#123;<br><br>    <span class="hljs-comment">// -XX:+PrintCompilation -XX:-DoEscapeAnalysis</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                <span class="hljs-keyword">new</span> Object();<br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.printf(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,i,(end - start));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>   <span class="hljs-number">96426</span><br><span class="hljs-number">1</span>   <span class="hljs-number">52907</span><br><span class="hljs-number">2</span>   <span class="hljs-number">44800</span><br><span class="hljs-number">3</span>   <span class="hljs-number">119040</span><br><span class="hljs-number">4</span>   <span class="hljs-number">65280</span><br><span class="hljs-number">5</span>   <span class="hljs-number">47360</span><br><span class="hljs-number">6</span>   <span class="hljs-number">45226</span><br><span class="hljs-number">7</span>   <span class="hljs-number">47786</span><br><span class="hljs-number">8</span>   <span class="hljs-number">48640</span><br><span class="hljs-number">9</span>   <span class="hljs-number">60586</span><br><span class="hljs-number">10</span>  <span class="hljs-number">42667</span><br><span class="hljs-number">11</span>  <span class="hljs-number">48640</span><br><span class="hljs-number">12</span>  <span class="hljs-number">70400</span><br><span class="hljs-number">13</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">14</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">15</span>  <span class="hljs-number">45227</span><br><span class="hljs-number">16</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">17</span>  <span class="hljs-number">60160</span><br><span class="hljs-number">18</span>  <span class="hljs-number">58880</span><br><span class="hljs-number">19</span>  <span class="hljs-number">46080</span><br><span class="hljs-number">20</span>  <span class="hljs-number">47787</span><br><span class="hljs-number">21</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">22</span>  <span class="hljs-number">54187</span><br><span class="hljs-number">23</span>  <span class="hljs-number">57173</span><br><span class="hljs-number">24</span>  <span class="hljs-number">50346</span><br><span class="hljs-number">25</span>  <span class="hljs-number">52906</span><br><span class="hljs-number">26</span>  <span class="hljs-number">50346</span><br><span class="hljs-number">27</span>  <span class="hljs-number">47786</span><br><span class="hljs-number">28</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">29</span>  <span class="hljs-number">64000</span><br><span class="hljs-number">30</span>  <span class="hljs-number">49067</span><br><span class="hljs-number">31</span>  <span class="hljs-number">63574</span><br><span class="hljs-number">32</span>  <span class="hljs-number">63147</span><br><span class="hljs-number">33</span>  <span class="hljs-number">56746</span><br><span class="hljs-number">34</span>  <span class="hljs-number">49494</span><br><span class="hljs-number">35</span>  <span class="hljs-number">64853</span><br><span class="hljs-number">36</span>  <span class="hljs-number">107520</span><br><span class="hljs-number">37</span>  <span class="hljs-number">46933</span><br><span class="hljs-number">38</span>  <span class="hljs-number">51627</span><br><span class="hljs-number">39</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">40</span>  <span class="hljs-number">103680</span><br><span class="hljs-number">41</span>  <span class="hljs-number">51626</span><br><span class="hljs-number">42</span>  <span class="hljs-number">60160</span><br><span class="hljs-number">43</span>  <span class="hljs-number">49067</span><br><span class="hljs-number">44</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">45</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">46</span>  <span class="hljs-number">51626</span><br><span class="hljs-number">47</span>  <span class="hljs-number">49066</span><br><span class="hljs-number">48</span>  <span class="hljs-number">47360</span><br><span class="hljs-number">49</span>  <span class="hljs-number">50774</span><br><span class="hljs-number">50</span>  <span class="hljs-number">70827</span><br><span class="hljs-number">51</span>  <span class="hljs-number">64000</span><br><span class="hljs-number">52</span>  <span class="hljs-number">72107</span><br><span class="hljs-number">53</span>  <span class="hljs-number">49066</span><br><span class="hljs-number">54</span>  <span class="hljs-number">46080</span><br><span class="hljs-number">55</span>  <span class="hljs-number">44800</span><br><span class="hljs-number">56</span>  <span class="hljs-number">46507</span><br><span class="hljs-number">57</span>  <span class="hljs-number">73813</span><br><span class="hljs-number">58</span>  <span class="hljs-number">61013</span><br><span class="hljs-number">59</span>  <span class="hljs-number">57600</span><br><span class="hljs-number">60</span>  <span class="hljs-number">83200</span><br><span class="hljs-number">61</span>  <span class="hljs-number">7024204</span><br><span class="hljs-number">62</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">63</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">64</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">65</span>  <span class="hljs-number">20053</span><br><span class="hljs-number">66</span>  <span class="hljs-number">20906</span><br><span class="hljs-number">67</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">68</span>  <span class="hljs-number">21333</span><br><span class="hljs-number">69</span>  <span class="hljs-number">22187</span><br><span class="hljs-number">70</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">71</span>  <span class="hljs-number">21760</span><br><span class="hljs-number">72</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">73</span>  <span class="hljs-number">15360</span><br><span class="hljs-number">74</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">75</span>  <span class="hljs-number">19627</span><br><span class="hljs-number">76</span>  <span class="hljs-number">17067</span><br><span class="hljs-number">77</span>  <span class="hljs-number">34134</span><br><span class="hljs-number">78</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">79</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">80</span>  <span class="hljs-number">17493</span><br><span class="hljs-number">81</span>  <span class="hljs-number">15360</span><br><span class="hljs-number">82</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">83</span>  <span class="hljs-number">17067</span><br><span class="hljs-number">84</span>  <span class="hljs-number">21760</span><br><span class="hljs-number">85</span>  <span class="hljs-number">23467</span><br><span class="hljs-number">86</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">87</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">88</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">89</span>  <span class="hljs-number">18773</span><br><span class="hljs-number">90</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">91</span>  <span class="hljs-number">20053</span><br><span class="hljs-number">92</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">93</span>  <span class="hljs-number">22187</span><br><span class="hljs-number">94</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">95</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">96</span>  <span class="hljs-number">19626</span><br><span class="hljs-number">97</span>  <span class="hljs-number">33280</span><br><span class="hljs-number">98</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">99</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">100</span> <span class="hljs-number">18773</span><br><span class="hljs-number">101</span> <span class="hljs-number">47786</span><br><span class="hljs-number">102</span> <span class="hljs-number">17493</span><br><span class="hljs-number">103</span> <span class="hljs-number">22614</span><br><span class="hljs-number">104</span> <span class="hljs-number">64427</span><br><span class="hljs-number">105</span> <span class="hljs-number">18347</span><br><span class="hljs-number">106</span> <span class="hljs-number">19200</span><br><span class="hljs-number">107</span> <span class="hljs-number">26027</span><br><span class="hljs-number">108</span> <span class="hljs-number">21333</span><br><span class="hljs-number">109</span> <span class="hljs-number">20480</span><br><span class="hljs-number">110</span> <span class="hljs-number">24747</span><br><span class="hljs-number">111</span> <span class="hljs-number">32426</span><br><span class="hljs-number">112</span> <span class="hljs-number">21333</span><br><span class="hljs-number">113</span> <span class="hljs-number">17920</span><br><span class="hljs-number">114</span> <span class="hljs-number">17920</span><br><span class="hljs-number">115</span> <span class="hljs-number">19200</span><br><span class="hljs-number">116</span> <span class="hljs-number">18346</span><br><span class="hljs-number">117</span> <span class="hljs-number">15360</span><br><span class="hljs-number">118</span> <span class="hljs-number">24320</span><br><span class="hljs-number">119</span> <span class="hljs-number">19200</span><br><span class="hljs-number">120</span> <span class="hljs-number">20053</span><br><span class="hljs-number">121</span> <span class="hljs-number">17920</span><br><span class="hljs-number">122</span> <span class="hljs-number">18773</span><br><span class="hljs-number">123</span> <span class="hljs-number">20053</span><br><span class="hljs-number">124</span> <span class="hljs-number">18347</span><br><span class="hljs-number">125</span> <span class="hljs-number">18347</span><br><span class="hljs-number">126</span> <span class="hljs-number">22613</span><br><span class="hljs-number">127</span> <span class="hljs-number">18773</span><br><span class="hljs-number">128</span> <span class="hljs-number">19627</span><br><span class="hljs-number">129</span> <span class="hljs-number">20053</span><br><span class="hljs-number">130</span> <span class="hljs-number">20480</span><br><span class="hljs-number">131</span> <span class="hljs-number">19627</span><br><span class="hljs-number">132</span> <span class="hljs-number">20053</span><br><span class="hljs-number">133</span> <span class="hljs-number">15360</span><br><span class="hljs-number">134</span> <span class="hljs-number">136533</span><br><span class="hljs-number">135</span> <span class="hljs-number">43093</span><br><span class="hljs-number">136</span> <span class="hljs-number">853</span><br><span class="hljs-number">137</span> <span class="hljs-number">853</span><br><span class="hljs-number">138</span> <span class="hljs-number">853</span><br><span class="hljs-number">139</span> <span class="hljs-number">853</span><br><span class="hljs-number">140</span> <span class="hljs-number">854</span><br><span class="hljs-number">141</span> <span class="hljs-number">853</span><br><span class="hljs-number">142</span> <span class="hljs-number">853</span><br><span class="hljs-number">143</span> <span class="hljs-number">853</span><br><span class="hljs-number">144</span> <span class="hljs-number">853</span><br><span class="hljs-number">145</span> <span class="hljs-number">853</span><br><span class="hljs-number">146</span> <span class="hljs-number">853</span><br><span class="hljs-number">147</span> <span class="hljs-number">854</span><br><span class="hljs-number">148</span> <span class="hljs-number">853</span><br><span class="hljs-number">149</span> <span class="hljs-number">853</span><br><span class="hljs-number">150</span> <span class="hljs-number">854</span><br><span class="hljs-number">151</span> <span class="hljs-number">853</span><br><span class="hljs-number">152</span> <span class="hljs-number">853</span><br><span class="hljs-number">153</span> <span class="hljs-number">853</span><br><span class="hljs-number">154</span> <span class="hljs-number">1280</span><br><span class="hljs-number">155</span> <span class="hljs-number">853</span><br><span class="hljs-number">156</span> <span class="hljs-number">853</span><br><span class="hljs-number">157</span> <span class="hljs-number">854</span><br><span class="hljs-number">158</span> <span class="hljs-number">853</span><br><span class="hljs-number">159</span> <span class="hljs-number">853</span><br><span class="hljs-number">160</span> <span class="hljs-number">854</span><br><span class="hljs-number">161</span> <span class="hljs-number">854</span><br><span class="hljs-number">162</span> <span class="hljs-number">853</span><br><span class="hljs-number">163</span> <span class="hljs-number">854</span><br><span class="hljs-number">164</span> <span class="hljs-number">854</span><br><span class="hljs-number">165</span> <span class="hljs-number">854</span><br><span class="hljs-number">166</span> <span class="hljs-number">854</span><br><span class="hljs-number">167</span> <span class="hljs-number">853</span><br><span class="hljs-number">168</span> <span class="hljs-number">853</span><br><span class="hljs-number">169</span> <span class="hljs-number">854</span><br><span class="hljs-number">170</span> <span class="hljs-number">853</span><br><span class="hljs-number">171</span> <span class="hljs-number">853</span><br><span class="hljs-number">172</span> <span class="hljs-number">853</span><br><span class="hljs-number">173</span> <span class="hljs-number">1280</span><br><span class="hljs-number">174</span> <span class="hljs-number">853</span><br><span class="hljs-number">175</span> <span class="hljs-number">1280</span><br><span class="hljs-number">176</span> <span class="hljs-number">853</span><br><span class="hljs-number">177</span> <span class="hljs-number">854</span><br><span class="hljs-number">178</span> <span class="hljs-number">854</span><br><span class="hljs-number">179</span> <span class="hljs-number">427</span><br><span class="hljs-number">180</span> <span class="hljs-number">853</span><br><span class="hljs-number">181</span> <span class="hljs-number">854</span><br><span class="hljs-number">182</span> <span class="hljs-number">854</span><br><span class="hljs-number">183</span> <span class="hljs-number">854</span><br><span class="hljs-number">184</span> <span class="hljs-number">853</span><br><span class="hljs-number">185</span> <span class="hljs-number">853</span><br><span class="hljs-number">186</span> <span class="hljs-number">854</span><br><span class="hljs-number">187</span> <span class="hljs-number">853</span><br><span class="hljs-number">188</span> <span class="hljs-number">853</span><br><span class="hljs-number">189</span> <span class="hljs-number">854</span><br><span class="hljs-number">190</span> <span class="hljs-number">1280</span><br><span class="hljs-number">191</span> <span class="hljs-number">853</span><br><span class="hljs-number">192</span> <span class="hljs-number">853</span><br><span class="hljs-number">193</span> <span class="hljs-number">853</span><br><span class="hljs-number">194</span> <span class="hljs-number">853</span><br><span class="hljs-number">195</span> <span class="hljs-number">854</span><br><span class="hljs-number">196</span> <span class="hljs-number">853</span><br><span class="hljs-number">197</span> <span class="hljs-number">853</span><br><span class="hljs-number">198</span> <span class="hljs-number">853</span><br><span class="hljs-number">199</span> <span class="hljs-number">854</span><br></code></pre></td></tr></table></figure>

<p>原因是什么呢?</p>
<p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>  0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>  1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>  2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>  3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>  4层：使用 C2 即时编译器编译执行</li>
</ul>
<p><strong>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等</strong></p>
<h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul>
<li>解释器<ul>
<li>  将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>  是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>  将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>  根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1(速度提升5倍) &lt; C2（速度提升10到100倍），总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>C2即时编译器中有一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p>
<p>参考资料:<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine-performance-enhancements.html">Oracle官方文档</a></p>
<p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>  开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>  关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>  显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<p><strong>全局逃逸（GlobalEscape）</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>  对象是一个静态变量</li>
<li>  对象是一个已经发生逃逸的对象</li>
<li>  对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>  即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>  即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>  开启锁消除：-XX:+EliminateLocks</li>
<li>  关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>  开启标量替换：-XX:+EliminateAllocations</li>
<li>  关闭标量替换：-XX:-EliminateAllocations</li>
<li>  显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>(Inlining) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i * i;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(square(<span class="hljs-number">9</span>));<br></code></pre></td></tr></table></figure>

<p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure>

<p>还能够进行常量折叠(constant folding)的优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">81</span>);<br></code></pre></td></tr></table></figure>

<p>实验:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.jit;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT2</span> </span>&#123;<br>    <span class="hljs-comment">// -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:CompileCommand=dontinline,*JIT2.square</span><br>    <span class="hljs-comment">// -XX:+PrintCompilation</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                x = square(<span class="hljs-number">9</span>);<br><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.printf(<span class="hljs-string">&quot;%d\t%d\t%d\n&quot;</span>,i,x,(end - start));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i * i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a><strong>字段优化</strong></h4><p>JMH 基准测试请参考:<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a> </p>
<p>创建 maven 工程，添加依赖如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br>    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;<br>    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br>    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;<br>    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>编写基准测试代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-meta">@Warmup(iterations = 2, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@State(Scope.Benchmark)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Benchmark1</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] elements = randomInts(<span class="hljs-number">1_000</span>);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] randomInts(<span class="hljs-keyword">int</span> size) &#123;<br>        Random random = ThreadLocalRandom.current();<br>        <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            values[i] = random.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br>	<span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123;<br>            doSum(elements[i]);<br>        &#125;<br>	&#125;<br>	<span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] local = <span class="hljs-keyword">this</span>.elements;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; local.length; i++) &#123;<br>            doSum(local[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> element : elements) &#123;<br>            doSum(element);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-meta">@CompilerControl(CompilerControl.Mode.INLINE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>		sum += x; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>&#123;<br>        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<br>                .include(Benchmark1.class.getSimpleName())<br>                .forks(<span class="hljs-number">1</span>)<br>                .build();<br>        <br>				<span class="hljs-keyword">new</span> Runner(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先启用 doSum 的方法内联，测试结果如下(每秒吞吐量，分数越高的更好):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Benchmark              Mode  Samples        Score  Score error  Units<br>t.Benchmark1.test1    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">2420286.539</span>   <span class="hljs-number">390747.467</span>  ops/s<br>t.Benchmark1.test2    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">2544313.594</span>    <span class="hljs-number">91304.136</span>  ops/s<br>t.Benchmark1.test3    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">2469176.697</span>   <span class="hljs-number">450570.647</span>  ops/s<br></code></pre></td></tr></table></figure>

<p>接下来禁用 doSum 方法内联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    sum += x; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Benchmark              Mode  Samples       Score  Score error  Units<br>t.Benchmark1.test1    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">296141.478</span>    <span class="hljs-number">63649.220</span>  ops/s<br>t.Benchmark1.test2    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">371262.351</span>    <span class="hljs-number">83890.984</span>  ops/s<br>t.Benchmark1.test3    thrpt  <span class="hljs-number">5</span>  			<span class="hljs-number">368960.847</span>    <span class="hljs-number">60163.391</span>  ops/s<br></code></pre></td></tr></table></figure>

<p>分析:</p>
<p>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化: </p>
<p>如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子(伪代码):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Benchmark</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123; <span class="hljs-comment">// 后续 999 次 求长度 &lt;- local</span><br>		sum += elements[i]; <span class="hljs-comment">// 1000 次取下标 i 的元素 &lt;- local </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以节省 1999 次 Field 读取操作</p>
<p>但如果 doSum 方法没有内联，则不会进行上面的优化</p>
<p>练习:在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p>
<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<p><code>Method</code>类的<code>invoke</code>方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">       InvocationTargetException</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200614133554.png" srcset="/img/loading.gif" lazyload></p>
<p>会由<code>DelegatingMehodAccessorImpl</code>去调用<code>NativeMethodAccessorImpl</code>的<code>invoke</code>方法</p>
<p><code>NativeMethodAccessorImpl</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br>	<br>	<span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br>	<span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-comment">// inflationThreshold 膨胀阈值，默认 15</span><br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = <br>                (MethodAccessorImpl)<br>                (<span class="hljs-keyword">new</span> MethodAccessorGenerator())<br>                	.generateMethod(<br>                		<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <br>                		<span class="hljs-keyword">this</span>.method.getName(), <br>                		<span class="hljs-keyword">this</span>.method.getParameterTypes(), <br>                		<span class="hljs-keyword">this</span>.method.getReturnType(), <br>                		<span class="hljs-keyword">this</span>.method.getExceptionTypes(), <br>                		<span class="hljs-keyword">this</span>.method.getModifiers()<br>            );<br>           <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>  一开始if条件不满足，就会调用本地方法invoke0，本地方法的调用比较费时。</li>
<li>  随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就由本地方法访问器替换为一个运行时动态生成的访问器（构造一个对象，来直接调用方法），来提高效率；当调用到第 16 次(从0开始算)时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1。这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
<p>可以使用阿里的 arthas 工具:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java -jar arthas-boot.jar<br>[INFO] arthas-boot version: <span class="hljs-number">3.1</span><span class="hljs-number">.1</span><br>[INFO] Found existing java process, please choose one and hit RETURN.<br>* [<span class="hljs-number">1</span>]: <span class="hljs-number">13065</span> cn.itcast.jvm.t3.reflect.Reflect1<br></code></pre></td></tr></table></figure>

<p>选择 1 回车表示分析该进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br>[INFO] arthas home: /root/.arthas/lib/<span class="hljs-number">3.1</span><span class="hljs-number">.1</span>/arthas<br>[INFO] Try to attach process <span class="hljs-number">13065</span><br>[INFO] Attach process <span class="hljs-number">13065</span> success.<br>[INFO] arthas-client connect <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">3658</span><br>,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \| .--.<span class="hljs-string">&#x27;&#x27;</span>--. .--<span class="hljs-string">&#x27;| &#x27;</span>--<span class="hljs-string">&#x27; |/ O \&#x27; .-&#x27;</span> |.-.||<span class="hljs-string">&#x27;--&#x27;</span>.<span class="hljs-string">&#x27; || |.--.||.-.|`.`-.</span><br><span class="hljs-string">||||||\\ || ||||||||.-&#x27;</span> | `--<span class="hljs-string">&#x27; `--&#x27;</span>`--<span class="hljs-string">&#x27; &#x27;</span>--<span class="hljs-string">&#x27; `--&#x27;</span> `--<span class="hljs-string">&#x27; `--&#x27;</span>`--<span class="hljs-string">&#x27; `--&#x27;</span>`-----<span class="hljs-string">&#x27;</span><br><span class="hljs-string">wiki      https://alibaba.github.io/arthas</span><br><span class="hljs-string">tutorials https://alibaba.github.io/arthas/arthas-tutorials</span><br><span class="hljs-string">version   3.1.1</span><br><span class="hljs-string">pid       13065</span><br><span class="hljs-string">time      2019-06-10 12:23:54</span><br></code></pre></td></tr></table></figure>

<p>再输入【jad + 类名】来进行反编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742<br>  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>    +-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Decompiled with CFR 0_132.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Could not load the following classes:</span><br><span class="hljs-comment"> *  cn.itcast.jvm.t3.reflect.Reflect1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> sun.reflect;<br><span class="hljs-keyword">import</span> cn.itcast.jvm.t3.reflect.Reflect1;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> sun.reflect.MethodAccessorImpl;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratedMethodAccessor1</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Loose catch block</span><br><span class="hljs-comment">     * Enabled aggressive block sorting</span><br><span class="hljs-comment">     * Enabled unnecessary exception pruning</span><br><span class="hljs-comment">     * Enabled aggressive exception aggregation</span><br><span class="hljs-comment">     * Lifted jumps to return sites</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object object, Object[] arrobject)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>&#123;<br>			<span class="hljs-comment">// 比较奇葩的做法，如果有参数，那么抛非法参数异常 block4 : &#123;</span><br>            <span class="hljs-keyword">if</span> (arrobject == <span class="hljs-keyword">null</span> || arrobject.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> block4;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 可以看到，已经是直接调用了😱😱😱 Reflect1.foo();</span><br>            <span class="hljs-comment">// 因为没有返回值</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(throwable);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(Object.<span class="hljs-keyword">super</span>.toString());<br>        &#125;<br>	&#125;<br>&#125;<br>Affect(row-cnt:<span class="hljs-number">1</span>) cost in <span class="hljs-number">1540</span> ms.<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>通过查看 ReflectionFactory 源码可知</p>
<p>sun.reflect.noInflation 可以用来禁用膨胀(直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算)<br> sun.reflect.inflationThreshold 可以修改膨胀阈值</p>
</blockquote>
<h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p>
<p>关于它的权威解释，请参考 <a target="_blank" rel="noopener" href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b</a></p>
<p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p>
<ul>
<li>  很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（<strong>JMM</strong>）的意思。</li>
<li>  简单的说，<strong>JMM</strong> 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的<strong>可见性</strong>、<strong>有序性</strong>、和<strong>原子性</strong>的规则和保障</li>
</ul>
<h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下:</p>
<p>提出问题：两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<h4 id="1-1-问题解析"><a href="#1-1-问题解析" class="headerlink" title="1-1 问题解析"></a>1-1 问题解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                i++;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                i--;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上的结果可能是正数、负数、零。为什么呢?因为 Java 中对静态变量的自增，自减并不是原子操作。</p>
<p>例如对于 i++ 而言(i 为静态变量)，实际会产生如下的 JVM 字节码指令:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic	i 	<span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1		<span class="hljs-comment">// 准备常量1</span><br>iadd			<span class="hljs-comment">// 加法</span><br>putstatic	i	<span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure>

<p>而对应 i– 也是类似:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic	i 	<span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1		<span class="hljs-comment">// 准备常量1</span><br>isub			<span class="hljs-comment">// 减法</span><br>putstatic	i	<span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure>

<p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换:</p>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230331131854874.png" srcset="/img/loading.gif" lazyload></p>
<p>如果是单线程以上 8 行代码是顺序执行(不会交错)没有问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic	i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>iconst_1	<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd		<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic	i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>getstatic	i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=1</span><br>iconst_1	<span class="hljs-comment">// 线程1-准备常量1</span><br>isub		<span class="hljs-comment">// 线程1-自减 线程内i=0</span><br>putstatic	i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></code></pre></td></tr></table></figure>

<p>但多线程下这 8 行代码可能交错运行(为什么会交错?思考一下): 出现负数的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic	i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>getstatic	i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1	<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd		<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic	i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1	<span class="hljs-comment">// 线程2-准备常量1</span><br>isub		<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic	i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure>

<p>出现正数的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic	i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>getstatic	i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1	<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd		<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>iconst_1	<span class="hljs-comment">// 线程2-准备常量1</span><br>isub		<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic	i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br>putstatic	i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br></code></pre></td></tr></table></figure>

<h4 id="1-2-解决方法"><a href="#1-2-解决方法" class="headerlink" title="1-2 解决方法"></a>1-2 解决方法</h4><h5 id="（1）synchronized（同步关键字）"><a href="#（1）synchronized（同步关键字）" class="headerlink" title="（1）synchronized（同步关键字）"></a>（1）synchronized（同步关键字）</h5><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>( 对象 ) &#123;<br>    要作为原子操作代码<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用 <code>synchronized</code> 解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                    i++;<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//输出为0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要这里的 <code>obj</code> 对象呢？</p>
</blockquote>
<p>我们可以这样理解：可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p>
<p>当线程 t1 执行到 <code>synchronized(obj)</code> 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。这时候如果 t2 也运行到了 <code>synchronized(obj)</code> 时，它发现门被锁住了，只能在门外等待。</p>
<p>当 t1 执行完 <code>synchronized&#123;&#125;</code> 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p>
<blockquote>
<p>注意:上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p>
</blockquote>
<blockquote>
<p>怎么从JVM角度理解呢？（这里引用《Java并发编程的艺术》里的一段话）</p>
<p>从JVM规范中可以看到<code>Synchonized</code>在JVM里的实现原理，JVM基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code> 和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是，方法同步同样可以使用这两个指令来实现。 <code>monitorenter</code>指令是在编译后插入到同步代码块的<strong>开始位置</strong>，而<code>monitorexit</code>是插入到<strong>方法结束处</strong>和<strong>异常处</strong>，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个<code>monitor</code>与之关联，当且一个<code>monitor</code>被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code> 指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                        i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                        i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//输出为0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这里做了一个优化，将synchronized放在for循环之外，每个线程的加锁解锁次数从5000次变为了1次（synchronized是可重入的的），提高了效率。</strong></p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><h4 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2-1 退不出的循环"></a>2-1 退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(run)&#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么会这样？</p>
<ol>
<li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p>
<p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/3242.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>因为 t 线程要频繁从<strong>主内存</strong>中读取 run 的值，<strong>JIT 编译器</strong>会将 run 的值缓存至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/13242.jpg" srcset="/img/loading.gif" lazyload></p>
<ol start="3">
<li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p>
<p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/2345678.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h4 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2-2 解决办法"></a>2-2 解决办法</h4><h5 id="（1）volatile（易变关键字）"><a href="#（1）volatile（易变关键字）" class="headerlink" title="（1）volatile（易变关键字）"></a>（1）volatile（易变关键字）</h5><p>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <strong>volatile</strong> 变量都是直接操作主存，保证了共享变量的<strong>可见性</strong>，但<strong>不能保证原子性</strong>，仅适用在一个写线程，多个读线程的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">// ....</span><br>            &#125;<br>        &#125;);<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况: </p>
<p>上例从字节码理解是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic	run <span class="hljs-comment">//线程t获取runtrue</span><br>getstatic	run <span class="hljs-comment">//线程t获取runtrue</span><br>getstatic	run <span class="hljs-comment">//线程t获取runtrue</span><br>getstatic	run <span class="hljs-comment">//线程t获取runtrue</span><br>putstatic	run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic	run <span class="hljs-comment">// 线程 t 获取 run false</span><br></code></pre></td></tr></table></figure>

<p>比较一下之前我们将线程安全时举的例子:两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic	i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>getstatic	i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1	<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd		<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic	 i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1	<span class="hljs-comment">// 线程2-准备常量1</span><br>isub		<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic	 i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：</p>
<p><code>synchronized</code> 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。但缺点是<code>synchronized</code>是属于重量级操作，<strong>性能相对更低</strong></p>
<p>如果在前面示例的死循环中加入 <code>System.out.println()</code> 会发现即使不加 volatile 修饰符，线程 t 也 能正确看到对 run 变量的修改了，想一想为什么？</p>
</blockquote>
<p>进入<code>println</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出加了<code>synchronized</code>，保证了每次<code>run</code>变量都会从主存中获取。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><h4 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3-1 诡异的结果"></a>3-1 诡异的结果</h4><p>看下面一个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种?</p>
<p>看到这里可能聪明的小伙伴会想到有下面三种情况：</p>
<p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p>
<p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p>
<p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p>
<p><strong>但其实还有可能为0哦</strong>！线程 2 执行 ready=true ，切换到线程1 ，进入if分支，相加为0，在切回线程 2 执行 num=2</p>
<h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现:</p>
<p>借助 java 并发压测工具 jcstress <a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn archetype:generate  -DinteractiveMode=<span class="hljs-keyword">false</span> -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DgroupId=org.sample -DartifactId=test -Dversion=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure>

<p>创建 maven 项目，提供如下测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>	<span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn clean install <br>java -jar target/jcstress.jar<br></code></pre></td></tr></table></figure>

<p>会输出我们感兴趣的结果，摘录其中一次结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">*** INTERESTING tests<br>  Some interesting behaviors observed. This is <span class="hljs-keyword">for</span> the plain curiosity.<br>  <span class="hljs-number">2</span> matching test results.<br>      [OK] test.ConcurrencyTest<br>    (JVM args: [-XX:-TieredCompilation])<br>  Observed state   Occurrences              Expectation  Interpretation<br>      		 <span class="hljs-number">0</span>         <span class="hljs-number">1</span>,<span class="hljs-number">729</span>   ACCEPTABLE_INTERESTING  		!!!!<br>             <span class="hljs-number">1</span>    <span class="hljs-number">42</span>,<span class="hljs-number">617</span>,<span class="hljs-number">915</span>				ACCEPTABLE		ok<br>             <span class="hljs-number">4</span>     <span class="hljs-number">5</span>,<span class="hljs-number">146</span>,<span class="hljs-number">627</span>				ACCEPTABLE		ok<br>    [OK] test.ConcurrencyTest<br>  (JVM args: [])<br>Observed state   Occurrences			Expectation		Interpretation	<br>             <span class="hljs-number">0</span>         <span class="hljs-number">1</span>,<span class="hljs-number">652</span>   ACCEPTABLE_INTERESTING  !!!!<br>             <span class="hljs-number">1</span>    <span class="hljs-number">46</span>,<span class="hljs-number">460</span>,<span class="hljs-number">657</span>               ACCEPTABLE  ok<br>             <span class="hljs-number">4</span>     <span class="hljs-number">4</span>,<span class="hljs-number">571</span>,<span class="hljs-number">072</span>               ACCEPTABLE  ok<br></code></pre></td></tr></table></figure>

<p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p>
<h4 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3-2 解决方法"></a>3-2 解决方法</h4><p><strong>volatile 修饰的变量，可以禁用指令重排</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//可以禁用指令重排</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重新测试，发现未发生指令重排现象。</p>
<h4 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3-3 有序性理解"></a>3-3 有序性理解</h4><p>同一线程内，JVM会在不影响正确性的前提下，可以调整语句的执行顺序，看看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure>

<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时， 既可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure>

<p>也可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br></code></pre></td></tr></table></figure>

<p>这种特性称之为<strong>指令重排</strong>，<strong>多线程下指令重排会影响正确性</strong>，例如著名的 <code>double-checked locking</code> 模式实现单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实例没创建，才会进入内部的 synchronized 代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//可能第一个线程在synchronized 代码块还没创建完对象时，第二个线程已经到了这一步，所以里面还需要加上判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//也许有其他线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>  懒惰实例化</li>
<li>  首次使用 getInstance() 才使用<code>synchronized</code>加锁，后续使用时无需加锁</li>
</ul>
<p>上面的代码看似已经很完美了，但是<strong>在多线程环境下还是会有指令重排问题！</strong></p>
<p><code>INSTANCE = new Singleton()</code> 对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> <span class="hljs-comment">// class cn/itcast/jvm/t4/Singleton</span><br><span class="hljs-number">3</span>: dup<br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">7</span>: putstatic #<span class="hljs-number">4</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;</span><br></code></pre></td></tr></table></figure>

<p>其中<code>4</code>和<code>7</code>两步顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1,t2 按如下时间顺序执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">时间<span class="hljs-number">1</span> t1 线程执行到 INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>时间<span class="hljs-number">2</span> t1 线程分配空间，为Singleton对象生成了引用地址（<span class="hljs-number">0</span> 处）<br>时间<span class="hljs-number">3</span> t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-number">7</span> 处）<br>时间<span class="hljs-number">4</span> t2 线程进入getInstance() 方法，发现 INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-keyword">synchronized</span>块外），直接返回 INSTANCE<br>时间<span class="hljs-number">5</span> t1 线程执行Singleton的构造方法（<span class="hljs-number">4</span> 处）<br></code></pre></td></tr></table></figure>

<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p>
<p>对 INSTANCE 使用 <strong>volatile</strong> 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 <strong>volatile</strong> 才会真正有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实例没创建，才会进入内部的 synchronized 代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//可能第一个线程在synchronized 代码块还没创建完对象时，第二个线程已经到了这一步，所以里面还需要加上判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//也许有其他线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3-4 happens-before"></a>3-4 happens-before</h4><p><strong>happens-before</strong> 规定了哪些写操作对其它线程的读操作可见，它是<strong>可见性</strong>与<strong>有序性</strong>的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start()<br></code></pre></td></tr></table></figure>
</li>
<li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br></code></pre></td></tr></table></figure></li>
<li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br></code></pre></td></tr></table></figure></li>
<li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 <code>t1.isAlive()</code> 或 <code>t1.join()</code>等待它结束）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t1.join();<br>System.out.println(x);<br><br></code></pre></td></tr></table></figure></li>
<li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程(包括被打断线程)得知 t2 被打断后对变量的读可见（通过<code>t2.interrupted</code> 或 <code>t2.isInterrupted()</code>）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(x);<span class="hljs-comment">//0</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>        Thread.yield();<br>    &#125;<br>    System.out.println(x);<span class="hljs-comment">//0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
</li>
<li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code></p>
</li>
</ul>
<blockquote>
<p>以上变量都是指<strong>共享变量</strong>即成员变量或静态资源变量</p>
</blockquote>
<h3 id="4-CAS与原子类"><a href="#4-CAS与原子类" class="headerlink" title="4.CAS与原子类"></a>4.CAS与原子类</h3><h4 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4-1 CAS"></a>4-1 CAS</h4><p><strong>CAS</strong> 即 <code>Compare and Swap</code> ，它体现的一种<strong>乐观锁</strong>的思想，比如多个线程要对一个共享的整型变量执行 +1 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要不断尝试</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> 旧值 = 共享变量 ; <span class="hljs-comment">// 比如拿到了当前值 0</span><br>    <span class="hljs-keyword">int</span> 结果 = 旧值 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候</span><br><span class="hljs-comment">	compareAndSwap 返回 false，重新尝试，直到：</span><br><span class="hljs-comment">	compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰</span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123;<br>        <span class="hljs-comment">// 成功，退出循环</span><br>    &#125;<br>    <span class="hljs-comment">//不一样，继续循环尝试</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>CompareAndSwap</code>，是根据地址再取一次旧值（新旧值）,然后与旧值（旧旧值）比较，如果一样就set（内部保证原子性）结果，不一样就再试。</strong></p>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 <code>volatile</code> 修饰。<strong>结合 CAS 和 volatile 可以实现无锁并发</strong>，适用于<strong>竞争不激烈</strong>（不要频繁重试）、<strong>多核 CPU</strong>（重试需要消耗CPU时间，所以多核CPU提供更多CPU时间片） 的场景下。</p>
<ul>
<li>  因为没有使用 <code>synchronized</code>，所以线程不会陷入阻塞（涉及到线程的上下文切换），这是效率提升的因素之一</li>
<li>  但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS 底层依赖于一个 <code>Unsafe</code> 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        DataContainer dc = <span class="hljs-keyword">new</span> DataContainer();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                dc.increase();<br>            &#125;<br>        &#125;);<br>        t.start();<br>        t.join();<br>        System.out.println(dc.getData());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DATA_OFFSET;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Unsafe 对象不能直接调用，只能通过反射获得</span><br>            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            DATA_OFFSET =<br>                    unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>            oldValue = data;<br>            <span class="hljs-comment">// 旧值与当前共享变量一致，才做修改。否则，不修改，重新尝试。</span><br>            <span class="hljs-comment">// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue +<br>                    <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            oldValue = data;<br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4-2 乐观锁与悲观锁"></a>4-2 乐观锁与悲观锁</h4><ul>
<li>  <strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>  <strong>synchronized</strong> 是基于<strong>悲观锁</strong>的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
</ul>
<h4 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4-3 原子操作类"></a>4-3 原子操作类</h4><p>**JUC<code>（java.util.concurrent）</code>中提供了原子操作类，可以提供线程安全的操作，例如：<code>AtomicInteger</code>、 <code>AtomicBoolean</code>等，它们底层就是采用 **CAS 技术 + volatile 来实现的。 可以使用 AtomicInteger 改写之前的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>&#123;<br>    <span class="hljs-comment">//创建原子整数对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                i.getAndIncrement(); <span class="hljs-comment">//获取并且自增 i++</span><br>                <span class="hljs-comment">// i.incrementAndGet(); //自增并且获取 ++i</span><br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                i.getAndDecrement(); <span class="hljs-comment">//获取并且自减 i--</span><br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5.synchronized 优化"></a>5.synchronized 优化</h3><p>从JDK1.6开始，对<code>synchronized</code>做了大量优化，在某些场景下甚至比<code>CAS</code>性能要更好。</p>
<p>Java HotSpot 虚拟机中，每个对象都有<strong>对象头</strong>（包括 <code>class 指针</code>和 <code>Mark Word</code>）。<code>Mark Word</code> 平时存储这个对象的哈希码 、 分代年龄 ；当加锁时，这些信息就根据情况被替换为标记位 、 线程锁记录指针 、 重量级锁指针 、 线程ID 等内容</p>
<h4 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5-1 轻量级锁"></a>5-1 轻量级锁</h4><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用<strong>轻量级锁</strong>来优化。这就好比：</p>
<p>学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程A 随即升级为<strong>重量级锁</strong>，进入重量级锁的流程。</p>
<p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来，假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每个线程的栈帧中都会包含一个<strong>锁记录（栈结构，每次加锁push对象的Mark Word，解锁pop对象的Mark Word）</strong>的结构，内部可以存储锁定对象的 <code>Mark Word</code>，即对象Mark Word做修改之前，先把当前Mark Word存放在当前线程栈帧的锁记录的结构中，以便之后恢复。即<strong>每次加锁的过程就是，对象的Mark Word与当前线程的锁记录结构中的锁记录地址进行交换。</strong></p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>对象Mark Word</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>访问同步块 A，把 Mark 复制到 线程 1 的锁记录（线程1锁记录push对象的Mark Word）</td>
<td>01(无锁)</td>
<td>-</td>
</tr>
<tr>
<td>CAS 修改 Mark 为线程 1 锁记录 地址</td>
<td>01(无锁)</td>
<td>-</td>
</tr>
<tr>
<td>成功（加锁）</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块 A</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>访问同步块 B，把 Mark 复制到 线程 1 的锁记录（线程1锁记录push对象的Mark Word）</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>CAS 修改 Mark 为线程 1 锁记录地址</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>失败(发现是自己的锁)</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>锁重入</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块 B</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>同步块 B 执行完毕（线程1锁记录pop出一个Mark Word）</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>同步块 A 执行完毕（线程1锁记录pop出一个Mark Word，并且交换和对象的Mark Word）</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>成功(解锁)</td>
<td>01（无锁）</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>01（无锁）</td>
<td>访问同步块 A，把 Mark 复制到 线程 2 的锁记录</td>
</tr>
<tr>
<td>-</td>
<td>01（无锁）</td>
<td>CAS 修改 Mark 为线程 2 锁记录 地址</td>
</tr>
<tr>
<td>-</td>
<td>00(轻量锁)线程 2 锁记录地址</td>
<td>成功(加锁)</td>
</tr>
<tr>
<td>-</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h4 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5-2 锁膨胀"></a>5-2 锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，<strong>将轻量级锁变为重量级锁。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span>( obj ) &#123; <br>        <span class="hljs-comment">// 同步块</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>线程1</th>
<th>对象Mark Word</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>访问同步块 A，把 Mark 复制到 线程 1 的锁记录</td>
<td>01(无锁)</td>
<td>-</td>
</tr>
<tr>
<td>CAS 修改 Mark 为线程 1 锁记录 地址</td>
<td>01(无锁)</td>
<td>-</td>
</tr>
<tr>
<td>成功（加锁）</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>访问同步块，把 Mark 复制 到线程 2 锁记录</td>
</tr>
<tr>
<td>执行同步块</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>CAS 修改 Mark 为线程 2 锁记录地址</td>
</tr>
<tr>
<td>执行同步块</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>失败(发现别人已经占了锁)</td>
</tr>
<tr>
<td>执行同步块</td>
<td>00(轻量锁)线程 1 - 锁记录地址</td>
<td>CAS 修改 Mark 为重量锁</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>阻塞中</td>
</tr>
<tr>
<td>执行完毕</td>
<td>10(重量锁)重量锁指针</td>
<td>阻塞中</td>
</tr>
<tr>
<td><strong>失败(解锁)</strong></td>
<td>10(重量锁)重量锁指针</td>
<td>阻塞中</td>
</tr>
<tr>
<td>释放重量锁，唤起阻塞线程竞争</td>
<td>01（无锁）</td>
<td>阻塞中</td>
</tr>
<tr>
<td>-</td>
<td>10(重量锁)</td>
<td>竞争重量锁</td>
</tr>
<tr>
<td>-</td>
<td>10(重量锁)</td>
<td>成功(加锁)</td>
</tr>
<tr>
<td>-</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>对象Mark Word设置重量锁指针是为了，重量锁被释放后，根据重量锁指针来唤醒被阻塞的线程们来竞争重量锁。</p>
<h4 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5-3 重量锁"></a>5-3 重量锁</h4><p>重量级锁竞争的时候，还可以使用<strong>自旋</strong>来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p><strong>在 Java 6 之后自旋锁是自适应的</strong>，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li>
<li>好比等红灯时汽车是不是熄火，不熄火相当于<strong>自旋</strong>(等待时间短了划算)，熄火了相当于<strong>线程阻塞</strong>(等待时间长了划算)</li>
<li> Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>自旋重试成功的情况</p>
<table>
<thead>
<tr>
<th>线程1（cpu1上）</th>
<th>对象Mark</th>
<th>线程2（cpu2上）</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>10(重量锁)</td>
<td>-</td>
</tr>
<tr>
<td>访问同步块，获取monitor</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>访问同步块，获取 monitor</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行完毕</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>成功(解锁)</td>
<td>01（无锁）</td>
<td>自旋重试</td>
</tr>
<tr>
<td>-</td>
<td>10(重量锁)重量锁指针</td>
<td>成功(加锁)</td>
</tr>
<tr>
<td>-</td>
<td>10(重量锁)重量锁指针</td>
<td>执行同步块</td>
</tr>
<tr>
<td>-</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>自旋重试失败的情况</p>
<table>
<thead>
<tr>
<th>线程1（cpu1上）</th>
<th>对象Mark</th>
<th>线程2（cpu2上）</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>10(重量锁)</td>
<td>-</td>
</tr>
<tr>
<td>访问同步块，获取monitor</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>成功（加锁）</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>访问同步块，获取 monitor</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10(重量锁)重量锁指针</td>
<td>阻塞</td>
</tr>
<tr>
<td>-</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h4 id="5-4-偏向锁"><a href="#5-4-偏向锁" class="headerlink" title="5-4 偏向锁"></a>5-4 偏向锁</h4><p>轻量级锁在没有竞争时(就自己这个线程)，每次重入仍然需要执行CAS操作。Java 6中引入了<strong>偏向锁</strong>来做进一步优化：<strong>只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS</strong></p>
<ul>
<li>  撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li>
<li>  访问对象的 hashCode 也会撤销偏向锁，因为此时Mark Word（含hashCode）被换成了线程ID</li>
<li>  如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，<strong>重偏向</strong>会重置对象的 Thread ID</li>
<li>  撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>  如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>  由于偏向锁的种种弊端，可以主动使用 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li>
</ul>
<p>可以参考这篇论文:<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf</a></p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span>( obj ) &#123; <span class="hljs-comment">// 同步块 A</span><br>		method2(); <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span>( obj ) &#123; <br>        <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>线程1</th>
<th>对象Mark</th>
</tr>
</thead>
<tbody><tr>
<td>访问同步块 A，检查 Mark 中是否有线程 ID</td>
<td>101(无锁可偏向)</td>
</tr>
<tr>
<td>尝试加偏向锁</td>
<td>101(无锁可偏向)对象 hashCode</td>
</tr>
<tr>
<td>成功</td>
<td>101(无锁可偏向)线程ID</td>
</tr>
<tr>
<td>执行同步块 A</td>
<td>101(无锁可偏向)线程ID</td>
</tr>
<tr>
<td>访问同步块 B，检查 Mark 中是否有线程 ID</td>
<td>101(无锁可偏向)线程ID</td>
</tr>
<tr>
<td>是自己的线程 ID，锁是自己的，无需做更多操作</td>
<td>101(无锁可偏向)线程ID</td>
</tr>
<tr>
<td>执行同步块 B</td>
<td>101(无锁可偏向)线程ID</td>
</tr>
<tr>
<td>执行完毕</td>
<td>101(无锁可偏向)对象hashCode</td>
</tr>
</tbody></table>
<h4 id="5-5-其他优化"><a href="#5-5-其他优化" class="headerlink" title="5-5 其他优化"></a>5-5 其他优化</h4><h5 id="（1）减少上锁时间"><a href="#（1）减少上锁时间" class="headerlink" title="（1）减少上锁时间"></a>（1）减少上锁时间</h5><p>同步代码块中尽量短，同步代码块运行时间短，竞争的机会就少了。</p>
<h5 id="（2）减少锁的粒度"><a href="#（2）减少锁的粒度" class="headerlink" title="（2）减少锁的粒度"></a>（2）减少锁的粒度</h5><p>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>  <code>ConcurrentHashMap</code>，将数组中的各个链表头进行加锁，而不是像<code>HashTable</code>一样对整个数组进行加锁。</li>
<li>  <code>LongAdder</code> 分为 <code>base</code> 和 <code>cells</code> 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加到base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li>
<li>  <code>LinkedBlockingQueue</code> 入队和出队使用不同的锁，相对于<code>LinkedBlockingArray</code>只有一个锁效率要高</li>
</ul>
<h5 id="（3）锁粗化"><a href="#（3）锁粗化" class="headerlink" title="（3）锁粗化"></a>（3）锁粗化</h5><p>多次循环进入同步块不如同步块内多次循环，另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">&quot;a&quot;</span>).append(<span class="hljs-string">&quot;b&quot;</span>).append(<span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure>

<h5 id="（4）锁消除"><a href="#（4）锁消除" class="headerlink" title="（4）锁消除"></a>（4）锁消除</h5><p>JVM 会进行代码的<strong>逃逸分析</strong>，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p>
<h5 id="（5）读写分离"><a href="#（5）读写分离" class="headerlink" title="（5）读写分离"></a>（5）读写分离</h5><p><code>CopyOnWriteArrayList</code>和<code>ConyOnWriteSet</code>读操作直接读原始数组，而写操作在副本数组上写，故而不需要对读操作进行同步，只需要对写操作进行同步。</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a> </p>
<p><a target="_blank" rel="noopener" href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luojinping.com/2015/07/09/java锁优化/ </a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/java-se-16-synchronized</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9932047a89be">https://www.jianshu.com/p/9932047a89be</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblogs.com/sheeva/p/6366782.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JVM/">JVM</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/03/Netty%E5%AD%A6%E4%B9%A0/">
                        <span class="hidden-mobile">Netty学习</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
