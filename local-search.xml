<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2023/05/04/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/05/04/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>  一次编写，到处运行</li><li>  自动内存管理，垃圾回收机制</li><li>  数组下标越界检查（比如C语言本身不提供数组下标越界检查，可能会导致覆盖其他代码的内存，这是十分严重的）</li><li>  多态（虚方法表）</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong><code>JDK = (JRE + 编译工具(javac、javap)) = (JVM + 基础类库(java.util..) + 编译工具(javac、javap))</code></strong></p><p><strong><code>JavaEE = (JavaSE + 应用服务器(tomcat ...)) = (JDK + ID工具(IDEA...) + 应用服务器(tomcat ...))</code></strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150422.png"></p><h3 id="常见JVM"><a href="#常见JVM" class="headerlink" title="常见JVM"></a>常见JVM</h3><p><code>JVM</code>是一套规范，只要符合这一套规范就可以称为<code>JVM</code>。比较常用的是<code>Sun</code>或<code>Oracle</code>公司的<code>HotSpot</code>的<code>JVM</code>。并且本篇博客以<code>HotSpot</code>为准。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220827153133041.png"></p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><code>JVM</code>整体结构主要有类加载器模块、内存架构以及执行引擎。执行流程是，java源代码编译为java二进制字节码文件，然后通过类加载器加载进<code>JVM    </code>去运行，类放在方法区，类创建的实例对象放在堆里，而堆里的实例对象调用方法时又会用到虚拟机栈、程序计数器和本地方法栈。方法运行时每一行代码是由执行引擎中的解释器逐行执行，方法里的热点代码（也就是频繁调用的代码）会被<code>JIT Compiler</code>即时编译器进行编译执行（优化后的执行）。而垃圾回收模块会对堆里面不再引用的对象进行垃圾回收。当然还有一些java代码不方便实现的功能，必须调用底层操作系统的功能，所以需要通过本地方法接口来调用操作系统调用。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150440.png"></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>Program Counter Register程序计数器（寄存器)，程序计数器是java对于物理硬件的屏蔽和抽象，在物理上是通过寄存器来实现的。寄存器是CPU里读取速度最快的单元，又因为读取指令地址是非常频繁的，所以JVM在设计时就把寄存器当做了程序计数器用它来存储地址。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM指令中下一条所要执行的指令的地址，比如下图所示二进制字节码文件中jvm指令前的数字就是jvm指令的地址。当解释器将当前jvm指令编译成机器码之后，会去程序计数器获得下一条jvm指令的地址，当解释器获得了jvm指令地址时，程序计数器会加载在下一条jvm指令地址，以此类推。</p><blockquote><p>Java是解释执行还是编译执行？</p><p>这个问题并没有统一的答案，JVM规范并没有强制要求JVM实现应该使用哪种方式来执行程序，只能说不同的JVM实现的方式不一样。有纯解释执行的、纯编译执行的（JRockit）、还有解释+编译两者混用的（HotSpot）</p><p>解释器与编译器两者各有优势：</p><ol><li>当程序需要迅速启动时，解释器可以发挥优势，省去编译的时间，立即执行。</li><li>程序启动后，随着时间的推移，编译器开始发挥作用，JVM会将越来越多的热点代码编译成本地代码，减少解释器的中间损耗，获得更高的执行效率。</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220827162459828.png"></p><p>java源代码会被先编译成二进制字节码文件，然后通过解释器再编译为机器码，最后机器码被CPU运行。<code>二进制字节码（也叫jvm指令）</code>和<code>java源代码</code>在所有平台是一样的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>线程私有</p><ul><li>  当多个线程运行时，CPU的调度器组件会为每个线程分配时间片，当当前线程的时间片使用完以后，并且当前线程没有执行结束那么会把当前线程的状态进行一个暂存，CPU就会去执行另一个线程中的代码。</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令。</li></ul></li><li><p>在JVM规范中唯一一个不会存在内存溢出的区，其他的区都可能会出现内存溢出。</p><blockquote><p>首先，我们熟悉的栈和堆，都是可以通过运行时对内存需求的扩增导致内存不够用的情况。比如某个线程递归调用，随着调用层次的加深，可能会出现栈空间不足的情况，这时候如果可以动态扩增，jvm就会向申请更多的内存空间来扩充栈，当没有更多的内存空间得以申请的时候，就会发生OutOfMemoryError。</p><p>但是，程序计算器仅仅只是一个运行指示器，它所需要存储的内容仅仅就是下一个需要待执行的命令的地址，无论代码有多少，最坏情况下死循环也不会让这块内存区域超限，因为程序计算器所维护的就是下一条待执行的命令的地址，所以不存在OutOfMemoryError。只存下一个字节码指令的地址，消耗内存小且固定，无论方法多深，他只存一条。只针对一个线程，随着线程的结束而销毁。</p></blockquote></li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存（参数，局部变量，返回地址（当前方法执行结束后，需要返回到的代码地址）等等）</li><li>每个线程只能有<strong>一个活动栈帧</strong>（虚拟机栈栈顶的栈帧），对应着<strong>当前正在执行的方法</strong></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220828132812433.png"></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method1();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608150534.png"></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。<blockquote><p>通过-Xsssize 设置线程栈大小(以字节为单位)。用字母k或K表示KB、m或M表示MB，用G表示GB。默认值取决于平台(windows默认值取决于虚拟内存)。需要注意的是-Xss和size之间不允许有空格。</p><p>在使用javac Xxx.java生成字节码文件后，java -Xss 1m Xxx就可以指定栈大小运行程序。</p></blockquote></li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了（堆里的）对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">4</span>);<br>        sb.append(<span class="hljs-number">5</span>);<br>        sb.append(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            m2(sb);<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-number">2</span>);<br>        sb.append(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面例子中，m1()一定是线程安全的；m2()不一定是线程安全的，因为sb是作为参数传进来的，sb可以被其他线程访问，又因为StringBuilder本身就不是线程安全的，所以m2()不是线程安全的；m3()不一定是线程安全的，因为sb是作为返回值返回了，sb可以被其他线程访问，又因为StringBuilder本身就不是线程安全的，所以m3()不是线程安全的</p></blockquote>m2()发生了线程逃逸；而m3()发生了方法逃逸。方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</li></ul></li></ul><h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong>异常， 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li><p>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method1();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>        method1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在IDEA的<code>VM options</code>中，通过<code>-Xss</code>减小栈大小，可以观察到count减小了。</strong></p></li><li><p>每个栈帧<strong>所占用过大</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dept d = <span class="hljs-keyword">new</span> Dept();<br>        d.setName(<span class="hljs-string">&quot;market&quot;</span>);<br><br>        Emp e1 = <span class="hljs-keyword">new</span> Emp();<br>        e1.setName(<span class="hljs-string">&quot;zhang&quot;</span>);<br>        e1.setDept(d);<br><br>        Emp e2 = <span class="hljs-keyword">new</span> Emp();<br>        e2.setName(<span class="hljs-string">&quot;li&quot;</span>);<br>        e2.setDept(d);<br><br>        d.setEmps(Arrays.asList(e1, e2));<br><br>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        System.out.println(mapper.writeValueAsString(d));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Dept dept;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">getDept</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dept;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept</span><span class="hljs-params">(Dept dept)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dept = dept;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">getEmps</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> emps;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmps</span><span class="hljs-params">(List&lt;Emp&gt; emps)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.emps = emps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不写<code>@JsonIgnore</code>那么，员工类和部门类之间存在循环引用，那么在转换成json时，会导致栈内存溢出。</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220828150042752.png"></p><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>案例1：CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程  <code>nohup java 某个二进制字节码文件 &amp;</code> <strong>&amp; ： 指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出。 nohup ： 不挂断的运行，注意并没有后台运行的功能，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行。</strong><ul><li>  <strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高，然后通过<strong>ps -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高（-e 打印正在运行的所有进程相关信息，-o格式化输出）</li><li>  <strong>jstack 进程id</strong> 可以列出该进程中所有线程，通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong>。然后查看是哪一个类中的哪一行代码出现了问题。<strong>需要注意的是，jstack列出的tid指的是jvm中java线程id，nid才是操作系统映射的线程id，每一个java线程都有一个对应的操作系统线程。</strong></li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><p><code>nohup java 某个二进制字节码文件 &amp;</code> 会返回进程id，然后使用<code>jstack pid</code>列出该进程中所有线程，如果有死锁，会在最后显示在哪几行代码出现死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Object a = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> Object b = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (a) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (b) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;get a and b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (b) &#123;<br>                <span class="hljs-keyword">synchronized</span> (a) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;get a and b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829131244745.png"></p><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法（不是由java编写的方法）就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。这些本地方法运行时，使用的内存就是本地方法栈。本地方法是非常多的，不管是java类库里，还是执行引擎里都会频繁调用本地方法。</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><p>上面讲解的程序计数器、虚拟机栈以及本地方法栈都是线程私有的，且没有垃圾回收机制；而堆和方法区都是线程共有的，而且有垃圾回收机制。</p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>  <strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>  有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError : java heap space</strong>. 堆内存溢出。被引用的对象过多导致堆内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                list.add(str);<br>                str += str;<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>-Xmxsize</code>指定最大堆内存空间；<code>-Xmssize</code>初始的堆内存空间的大小。</strong></p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul><li><p><strong>jps</strong>，查看当前系统中有哪些java进程。</p><p><code>jps</code>直接查看有哪些java进程。</p></li><li><p><strong>jmap</strong>，查看堆内存占用情况，不过只能查看某一时刻的堆内存占用情况，但是有一个缺点就是在debug模式下抓不到变量个数。</p><p><code>jmap -heap pid</code>查看该进行堆信息。<code>-heap 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;1... jmap -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">30000</span>);<br>        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]; <span class="hljs-comment">//10MB</span><br>        System.out.println(<span class="hljs-string">&quot;2... jmap -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">30000</span>);<br>        array = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;3... jamp -heap pid查看堆内存占用&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到堆内存的新生代内存占用从1的低点上升到2的高点，最后又下降3的低点。</p><p><code>jmap -dump:format=b,live,file=filename.bin pid</code>，<code>-dump</code>选项是将当前堆内存转储，<code>format=b</code>是指储存格式为二进制，<code>live</code>是指在存储前主动做一次GC，<code>file=filename.bin</code>是指存储的文件名。存储的文件可以使用<code>eclipse</code>的工具<code>MAT</code>查看。</p></li><li><p><strong>jconsole</strong>，图形界面的，多功能的检测工具，可以连续检测</p><p><code>jconsole</code>然后连接对应进程，就可以看到图形界面的堆内存使用情况。</p><p>仍然使用上面的<code>Test2</code>代码，可以看到下图中的上升和下降，分别对应分配10MB数组内存和手动gc。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132016293.png"></p><p>同样的，在<code>线程</code>的详细信息里，可以检测死锁，查看死锁具体情况。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132356930.png"></p><p>此外，<code>jconsole</code>图形界面，还可以手动执行gc，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829132805285.png"></p></li><li><p><strong>jvisualvm</strong></p><p>案例：垃圾回收后，内存占用仍然很高。</p><p><code>jvisualvm</code>命令，可以像jconsole一样可视化堆内存等等，但是功能更加强大，使用<code>堆dump</code>保存当前堆的快照也就是堆转储功能，但是jdk8以上已经不自动安装了。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829135339529.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829135734035.png"></p></li><li><p><strong>jinfo</strong>:实时查看指定Java pid 进程的虚拟机指定参数情况。</p><p><code>jinfo -flag option pid</code>会返回指定参数的情况，[+|-]name 或者 name=value。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo -flag CMSInitiatingOccupancyFraction 1444<br>输出<br>-XX:CMSInitialtingOccupancyFraction=85<br></code></pre></td></tr></table></figure></li></ul><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Oraclejdk1.8文档</a></p><p><code>JVM</code>方法区是所有java虚拟机线程共享的区域。方法区类似于用于传统语言的编译代码的存储区，或者类似于操作系统进程中的“text”段。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p><p>方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但还是要看各厂商的具体实现，各厂商不一定遵从。<code>HotSpot</code>在JDK1.8之前，方法区是在堆内存中使用永久代作为具体实现，而在JDK1.8及以后，使用在本地内存的元空间作为具体实现。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194635728.png"></p><p><strong>Java7及以前版本的Hotspot中方法区位于永久代中</strong>。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。如下图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829141802064.png"></p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jdk.internal.org.objectweb.asm.ClassWriter;<br><span class="hljs-keyword">import</span> jdk.internal.org.objectweb.asm.Opcodes;<br><br><span class="hljs-comment">//设置元空间内存大小 -XX:MaxMetaspaceSize=size</span><br><span class="hljs-comment">//设置永久代内存大小 -XX:MaxPermSize=size</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<span class="hljs-comment">//可以用来加载类的二进制字节码</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Test2 test = <span class="hljs-keyword">new</span> Test2();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;<br>                <span class="hljs-comment">//ClassWriter 作用是生成类的二进制字节码</span><br>                ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//jdk版本号，public，类名，包名，父类，接口</span><br>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//返回byte[]</span><br>                <span class="hljs-keyword">byte</span>[] code = cw.toByteArray();<br>                <span class="hljs-comment">//执行类加载</span><br>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">//Class对象</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>//设置元空间内存大小 -XX:MaxMetaspaceSize=size<br>//设置永久代内存大小 -XX:MaxPermSize=size</p></blockquote><p>方法区内存溢出，也会抛出<code>OutofMemoryError</code>异常。</p><ul><li>  1.8以前会导致<strong>永久代</strong>内存溢出<code>OutofMemoryError : PermGen space </code></li><li>  1.8及以后会导致<strong>元空间</strong>内存溢出<code>OutofMemoryError : Metaspace</code></li></ul><p>实际场景：Spring和Mybatis框架都使用了大量的字节码技术，都会使用到cglib都会动态加载类，可能会导致方法区内存溢出。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获得对应类的.class文件  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java ./Test.java<br></code></pre></td></tr></table></figure></li><li>在控制台输入 javap -v 类的绝对路径，-v参数显示反编译的详细信息。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javap -v ./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test2</span>.</span></span><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure></li><li>然后能在控制台看到反编译以后类的信息了<ul><li>类的基本信息  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153349173.png"></li><li>常量池  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153415363.png"></li><li>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829153316170.png"></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>  就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量（如字符串、整数、布尔值等等）信息</li></ul></li><li>运行时常量池<ul><li>  常量池是.class文件中的，当该类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址（#num）变为真实地址</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li><p>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p></li><li><p>只有字节码命令<code>ldc</code>加载字符串，如果该字符串对象在串池中没有，才会将字符串对象放入串池。只有在代码里，存在的字符串常量（包括拼接形成的字符串常量，或者主动Intern()的字符串）才会被加载入串池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码总共形成了五个对象，串池中的<code>[&quot;a&quot;, &quot;b&quot;]</code>，以及堆中的<code>new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)</code></p></li><li><p>  <strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p></li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String s1 = <span class="hljs-string">&quot;a&quot;</span>; <br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当运行二进制字节码文件时，常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串对象</strong>。只有执行到那一行字节码指令时，才会被加载入串池并成为对象，这是一个懒惰的行为。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String a</span><br><span class="hljs-attr">2:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String b</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">astore_2</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">astore_3</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>去串池中查找是否存在“a”对象，如果没有则放入串池(StringTable)中</strong>（hashtable结构且不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，去串池中查找是否存在“b”对象，如果没有则放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，去串池中查找是否存在“ab”对象，如果没有则放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><code>astore_1</code>、<code>astore_2</code>和<code>astore_3</code>分别是将加载的字符串放入局部变量表<code>LocalVaribleTable</code>中槽<code>Slot</code>1、2和3中。</p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>String s4 = s1 + s2; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a 在串池中寻找&quot;a&quot;，如果没有放入串池</span><br>         <span class="hljs-number">2</span>: astore_1把串池对象<span class="hljs-string">&quot;a&quot;</span>的地址放入局部变量表中的<span class="hljs-number">1</span>位置<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b 在串池中寻找&quot;b&quot;，如果没有放入串池</span><br>         <span class="hljs-number">5</span>: astore_2把串池对象<span class="hljs-string">&quot;b&quot;</span>的地址放入局部变量表中的<span class="hljs-number">2</span>位置<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab 在串池中寻找&quot;ab&quot;，如果没有放入串池</span><br>         <span class="hljs-number">8</span>: astore_3把串池对象<span class="hljs-string">&quot;ab&quot;</span>的地址放入局部变量表中的<span class="hljs-number">3</span>位置<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 无参构造器</span><br>        <span class="hljs-number">16</span>: aload_1从局部变量表中的<span class="hljs-number">1</span>位置获得变量<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;调用append()<br>        <span class="hljs-number">20</span>: aload_2从局部变量表中的<span class="hljs-number">2</span>位置获得变量<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;调用append()<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;调用toString()<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>把toString()的结果放入局部变量表中的<span class="hljs-number">4</span>位置<br>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，是使用<code>new String()</code>创建的字符串对象，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s4 = a+b;<br><span class="hljs-comment">//结果为false,因为s3是存在于串池之中，s4是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(s3 == s4);<br></code></pre></td></tr></table></figure><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>String s4 = a+b;<br><span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">   Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab s5初始化时直接从常量池中获取字符串，并在串池中寻找&quot;ab&quot;,如果没有将&quot;ab&quot;对象加入串池</span><br>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>将上一步的返回结果放入局部变量表中Slot为<span class="hljs-number">5</span>的位置<br>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>  使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac命令在编译期会进行优化，结果已在编译期确定为ab</strong>，而在串池中创建”ab”对象的时候已经在串池中放入了“ab”，所以s5直接从串池中获取值，所以进行的操作和 s3 = “ab” 一致。</li><li>  使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="字符串对象创建是懒惰的"><a href="#字符串对象创建是懒惰的" class="headerlink" title="字符串对象创建是懒惰的"></a>字符串对象创建是懒惰的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1 + s2;<br>        String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在第三行和第四行打上端点，然后利用debug工具进行调试，发现字符串对象的创建确实是懒惰的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829163948853.png"></p><h5 id="JDK1-8中，String-intern-方法"><a href="#JDK1-8中，String-intern-方法" class="headerlink" title="JDK1.8中，String.intern()方法"></a>JDK1.8中，String.intern()方法</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中。<strong>注意，这个放入动作是指，将字符串对象的地址放入串池，而不是说在串池这个地方放入字符串对象。</strong></p><ul><li>  如果串池中没有该字符串对象，则放入成功</li><li>  如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象。大致含义是，当调用intern方法时，如果池中已经包含了一个由equals(Object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>String str2 = str.intern();<br><span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>String str2 = str.intern();<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">//true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JDK1-6中String-intern-方法"><a href="#JDK1-6中String-intern-方法" class="headerlink" title="JDK1.6中String.intern()方法"></a>JDK1.6中String.intern()方法</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>  如果串池中没有该字符串对象，会将该字符串对象复制一份，再将新对象的地址放入到串池中</li><li>  如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会创建一个新的&quot;ab&quot;并将该新对象地址放入串池中，此时堆内存与串池中的&quot;ab&quot;不是同一个对象</span><br>String str2 = str.intern();<br><span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;不是同一个对象，所以以下两条语句打印的都为false</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829195956469.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829195406274.png"></p><p>为什么JDK1.8要把StringTable从永久代中移到堆中呢？因为永久代的内存回收效率很低，需要fullGC时，才会触发垃圾回收。fullGC需要等到老年代的内存不足，才会触发，触发时机比较晚，但是StringTable的使用效率很频繁，如果StringTable的回收效率不高会导致占用大量内存，进而导致永久代的内存不足。故而从JDK1.7开始，StringTable被移到了堆中，只需要minorGC就可以触发垃圾回收。</p><p>那么如何通过实验来证明上述的观点呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">260000</span>; j++) &#123;<br>                list.add((<span class="hljs-string">&quot;&quot;</span> + j).intern());<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>然后在jdk1.8中设置最大堆内存 -Xmx10m 和 打开GC频率限制 -UseGCOverheadlimit（防止频繁发生GC而发生异常<code>OutOfMemoryError:GC overhead limit exceeded</code>。然后运行程序会发生，<code>java.lang.OutOfMemoryError: Java heap space</code></p><p>在jdk1.6中设置最大永久代内存 -XX：MaxPermSize=10m，然后运行会发生<code>OutofMemoryError : PermGen space</code></p></blockquote><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，StringTable中那些没有被引用的字符串常量会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;<br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>设置最大堆内存-Xmx10m；在jvm进程退出时会输出SymbolTable statistics及StringTable statistics  -XX:+PrintStringTableStatistics； 在每次GC时打印详细消息 -XX:+PrintGCDetails；  显示有关每个垃圾收集(GC)事件的信息。 -verbose:gc </p></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829210227410.png"></p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，那么哈希碰撞的概率就会减小，查找的速度也会变快。如果桶的个数比较少，那么哈希碰撞的概率增大，链表（红黑树）的长度变长，查找和增删的效率变慢。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, UnsupportedEncodingException </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;linux.words&quot;</span>), <span class="hljs-string">&quot;utf-8&quot;</span>)))&#123;<br>            <span class="hljs-comment">//try()中的代码一般放的是对资源的声明，try代码块执行完后，()中的资源就会自动关闭；如果&#123;&#125;中的代码出项了异常，()中的资源也会自动关闭。jdk1.7以上可用</span><br>            String line = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                line = reader.readLine();<br>                <span class="hljs-keyword">if</span> (line == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                line.intern();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>-XX:StringTableSize=xx 设置StringTable桶的个数 Number of buckets in the interned String table</p><p>-XX:+PrintStringTableStatistic 在jvm进程退出时会输出SymbolTable statistics及StringTable statistics  </p><p>可以观察到，当StringTable的数量减少时，耗费的总时间增大。</p></blockquote></li><li>考虑是否需要将字符串对象入池，可以通过<strong>intern()方法返回串池对象，防止大量重复字符串占用堆内存。</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        List&lt;String&gt; address = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        System.in.read(); <span class="hljs-comment">//从标准输入读入一个字节，起到停顿作用</span><br>        <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;linux.words&quot;</span>), <span class="hljs-string">&quot;utf-8&quot;</span>)))&#123;<br>            <span class="hljs-comment">//try()中的代码一般放的是对资源的声明，try代码块执行完后，()中的资源就会自动关闭；如果&#123;&#125;中的代码出项了异常，()中的资源也会自动关闭。jdk1.7以上可用</span><br>            String line = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                line = reader.readLine();<br>                <span class="hljs-keyword">if</span> (line == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                address.add(line.intern());<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1000000</span>);<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  使用<code>visualvm</code>查看，使用串池对象和堆内对象占用内存比较，发现使用串池对象大大减小了内存占用。  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220829213427702.png"></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>  不属于JVM内存，而属于操作系统内存，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>  <strong>分配回收成本较高，但读写性能高</strong></li><li>  <strong>不受JVM内存回收管理</strong></li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p>java代码本身不具备读取文件的能力，需要调用操作系统提供的接口。所以需要切换到从用户态切换到内核态去读取文件，但是为了高效利用内存，所以需要多次调用操作系统函数来完成整个文件的读取。同样，内存方面也是需要先从磁盘读取到系统缓存区（操作系统内存中），但是系统内存Java代码也不能直接使用，故而需要再读到Java堆内存的缓冲区中。为了高效利用内存，也需要多次重复这个过程。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194744288.png"></p><p>使用<strong>DirectBuffer</strong>之后，</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194811783.png"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而<strong>成倍</strong>提高了效率。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 ByteBuffer 作用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_9</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FROM = <span class="hljs-string">&quot;./bigFile.zip&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TO = <span class="hljs-string">&quot;./bigFileCopy.zip&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        io(); <span class="hljs-comment">// io 用时：1535.586957 1766.963399 1359.240226</span><br>        directBuffer(); <span class="hljs-comment">// directBuffer 用时：479.295165 702.291454 562.56592</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();<br>             FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();<br>        ) &#123;<br>            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb); <span class="hljs-comment">//分配直接内存</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = from.read(bb);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                bb.flip();<br>                to.write(bb);<br>                bb.clear();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileInputStream from = <span class="hljs-keyword">new</span> FileInputStream(FROM);<br>             FileOutputStream to = <span class="hljs-keyword">new</span> FileOutputStream(TO);<br>        ) &#123;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1Mb];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = from.read(buf);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                to.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h4><p>会抛出<code>java.lang.OutOfMemoryError : Direct buffer memory</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示直接内存溢出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_10</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _100Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);<br>                list.add(byteBuffer);<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-comment">// 方法区是jvm规范， jdk6 中对方法区的实现称为永久代</span><br>        <span class="hljs-comment">//                  jdk8 对方法区的实现称为元空间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p><strong>直接内存不是由JVM管理的，故而不能使用那些检测JVM的工具来观察，需要使用操作系统的监控程序来观察。</strong>直接内存的回收不是通过JVM的垃圾回收来释放的，而是必须通过<strong>unsafe.freeMemory</strong>来手动释放（不推荐普通程序员直接使用Unsafe类，都是JDK内部使用）。</p><p><strong>但是我们观察到，调用System.gc()会释放掉直接内存。不是说JVM的垃圾回收不会释放直接内存吗？这是为什么。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，Full GC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面展示，<code>Unsafe</code>类申请和释放直接内存的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t1.direct;<br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直接内存分配的底层原理：Unsafe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_27</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Unsafe unsafe = getUnsafe();<br>        <span class="hljs-comment">// 分配内存</span><br>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1Gb); <span class="hljs-comment">//返回直接内存的地址</span><br>        unsafe.setMemory(base, _1Gb, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>        System.in.read();<br><br>        <span class="hljs-comment">// 释放内存</span><br>        unsafe.freeMemory(base);<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field f = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            Unsafe unsafe = (Unsafe) f.get(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> unsafe;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="直接内存回收机制"><a href="#直接内存回收机制" class="headerlink" title="直接内存回收机制"></a>直接内存回收机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Cleaner</code>类继承了<code>PhantomReference&lt;Object&gt;</code>类，它是一个虚引用类，<code>Cleaner</code>类的<code>create</code>方法会将后面的回调任务对象（<code>Deallocator</code>类对象，因为该类实现了<code>Runnable</code>接口，所以叫任务对象）关联到前面的<code>DirectByteBuffer</code>类对象上，同时回调任务对象在初始化时就收到了直接内存的地址。</p><p>虚引用类的特点是，当它关联的对象被垃圾回收时，会触发虚引用类对象的<code>clean()</code>方法，当然这个<code>clean()</code>方法不是在主线程执行的，而是在<code>ReferenceHandler</code>线程上执行的（<code>ReferenceHandler</code>是一个守护线程，<code>ReferenceHandler</code>线程专门在后台检测这些虚引用对象，一旦虚引用对象关联的实际对象被垃圾回收了，就会调用虚引用对象的<code>clean()</code>方法，<code>clean()</code>方法中会去执行回调任务对象的<code>run()</code>方法）。</p><blockquote><p> 解读：这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存。</p></blockquote><p><code>Cleaner</code>虚引用类的<code>clean()</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法，thuck对象就是Deallocator类的回调任务对象</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure><p><code>Deallocator</code>类的回调任务对象的run方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>直接内存的回收机制总结</strong></p><ul><li>  使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用Unsafe类的freeMemory()方法</li><li>  ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler线程来调用Cleaner的clean方法调用回调任务对象的run方法来使用freeMemory方法释放内存。</li></ul><h4 id="禁用显示垃圾回收对直接内存的影响"><a href="#禁用显示垃圾回收对直接内存的影响" class="headerlink" title="禁用显示垃圾回收对直接内存的影响"></a>禁用显示垃圾回收对直接内存的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁用显式回收对直接内存的影响</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * -XX:+DisableExplicitGC 显式的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，触发Full GC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>-XX:+DisableExplicitGC 禁用显式的垃圾回收</p><p>显式垃圾回收，即System.gc()，会触发Full GC。而Full GC不光要回收新生代，也会回收老年代，会造成程序暂停时间比较长，影响程序性能。为了防止一些程序员不小心在自己代码里经常显式垃圾回收影响程序性能，需要加上这个虚拟机参数来进行JVM调优。</p></blockquote><p>因为禁用了显式垃圾回收，可能会出现当前内存比较充裕，使得ByteBuffer对象得不到垃圾回收，直接内存也不会被释放，导致直到下次JVM自动垃圾回收之前直接内存长时间的占用系统内存。这种情况下，需要利用反射得到Unsafe对象，来直接调用freeMemory方法来手动释放直接内存。</p><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><p>这里有两种方法可以判断对象是否可回收，分别是引用计数法和可达性分析算法。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法，就是如果一个对象如果被一个变量引用，那么这个对象的引用计数就加1。如果一个变量不再引用该对象了，就将该对象的引用计数减1。那么如果一个对象的引用计数变为0，那么就意味着没有变量引用该对象了，可以作为垃圾进行回收了。</p><p>弊端：循环引用时，两个对象的计数都为1，且这两个对象没有其他变量引用，导致两个对象都无法被释放。这就导致垃圾得不到及时的回收。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194839880.png"></p><p>因为这种循环引用的弊端，JVM并没有采用引用计数法来判断对象是否可以垃圾回收。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>  JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>  扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>  虚拟机栈（栈帧中的本地变量表）中引用的对象。譬如当前正在运行的方法所使用到的参数、局部变量、临时变量等。　</li><li>  方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>  方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li><li>  本地方法栈中JNI（即一般说的Native方法）引用的对象。</li><li>  Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointerException、OutOfMemoryError）等，还有系统类加载器。</li><li>  所有被同步锁（synchronized关键字）持有的对象。</li><li>  反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li><li>  除了上面这些固定的GC Roots集合外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p>下图中实线是强引用，虚线为其他引用。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194859237.png"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>强引用是最传统的“引用”定义，是指在程序代码之中普遍存在的引用赋值，即类似于<code>Object obj = new Object()</code>这种引用关系，只要沿着GC Root的强引用关系能够找到该对象，那么无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><p>只有GC Root<strong>都不引用（包括间接强引用）</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>  如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2版之后提供了<code>SoftReference</code>类来实现软引用。</p><p>当GC Root指向（包括间接指向）软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>  如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用软引用对象 list和SoftReference之间是强引用关系，而SoftReference和byte数组之间则是软引用关系</span><br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get()); <span class="hljs-comment">//获得软引用对象指向的实际对象</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">null<br>null<br>null<br>null<br>[B@2503dbd3<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831211502938.png"></p><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong>。软引用对象本身也是需要占用内存的，虽然占用内存少，如果想要<strong>清理软引用</strong>，需要使用<strong>引用队列</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.Reference;<br><span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;<br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用, 配合引用队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 引用队列的泛型需要和软引用指向的对象一致。</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 在创建软引用对象时，在软引用类构造器传入引用队列对象，代表关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>( poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; reference : list) &#123;<br>            System.out.println(reference.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（<strong>即切断软引用对象的强引用关系，使得软引用对象可以被回收</strong>）。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会收回掉只被弱引用关联的对象。在JDK1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</p><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>  如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><blockquote><p>需要注意的是，弱引用是指发生GC就可以被回收，但不意味着发生GC一定被回收，但是Full GC一定会清除所有弱引用指向的对象。比如：</p><p>JAVA内存模型中，弱引用对象在发生GC的时候就会被GC线程回收，但并不意味着在年轻代就会被回收，当JVM垃圾回收器的GC thread还没有执行到回收垃到时刻，如果此时被修饰为弱引用的对象已经通过某个途径copy到了老年代（如：该弱引用对象占独立内存块比较大，首次放入堆内存的时候，由于年轻代的Eden和From zone无足够连续内存空间存放，在老年代的担保策略下，直接存入old generation），此时此刻，这个弱引用对象就存在于老年代，当下一次full GC发生时，被GC线程回收掉，所以不能说弱引用是在young GC回收。</p><p>软引用对象一般会经历多次GC，自然晋升到old generation，一般情况下，当内存不足时，才会在GC线程运行时，经由标记算法，一次回收此类对象，因此可以说，软引用对象一般都在full gc过程中被回收。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示弱引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//  list --&gt; WeakReference --&gt; byte[]</span><br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(ref);<br>            <span class="hljs-keyword">for</span> (WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; w : list) &#123;<br>                System.out.print(w.get()+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831213726035.png"></p><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用也被称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2班之后提供了<code>PhantomReference</code>类来实现虚引用。</p><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，虚引用对象所在的引用队列会由<code>ReferenceHandler</code>线程定时查看是否有新入队的<code>Cleaner</code>(该类继承自<code>PhantomReference</code>)对象，如果有那么调用<code>Cleaner</code>对象的<code>clean()</code>方法。</p><ul><li>  虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>  如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，虚拟机会创建该对象的终结器引用对象，并会先将终结器引用对象放入引用队列中，再由一个优先级很低的<code>finalizeHandler</code>线程在某些时机查看引用队列中是否存在终结器引用对象，如果有，则根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，<strong>等到下一次垃圾回收时该对象所占用的内存就可以真正地被垃圾回收了</strong>。<strong>需要注意的是，这种方式效率很低，第一次垃圾回收时需要先将终结器引用对象加入引用队列，并且<code>finalizeHandler</code>线程优先级很低，可能要等很久才能等到<code>finalizeHandler</code>线程，之后finalize方法被调用，下一次垃圾回收才能真正回收对象的内存。finalize方法已经过时，不推荐使用，同样也不推荐使用终结器引用，<code>try-finally</code>或者其他方式可以做的更好。</strong></p><ul><li>  如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><p><code>ReferenceQueue</code>是用来配合引用工作的，没有ReferenceQueue 一样可以运行。<code>ReferenceQueue</code>是专门用来存放引用的, 当软引用,弱引用,虚引用对应的那个对象被回收后的同时,该引用会自动加入到你所定义的<code>ReferenceQueue</code>中。<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference </code>都有一个可以传递 <code>ReferenceQueue </code>的构造器。创建引用的时候，可以指定关联的队列，当 GC 释放对象内存的时候，会将引用加入到引用队列。 <del>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。为什么所引用对象还没被回收，虚引用对象已经加入引用队列了，这句话不确定是否正确。</del>当关联的引用队列中有数据的时候，意味着指向的堆内存中的对象被回收。通过这种方式，JVM 允许我们在对象被销毁后，做一些我们自己想做的事情。<br>软引用和弱引用<strong>可以配合也可以不配合</strong>引用队列使用</p><ul><li><ul><li>  在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列使用<ul><li>  虚引用对象和终结器引用对象在创建时会关联一个引用队列</li></ul></li></ul><h5 id="强软弱虚引用总结"><a href="#强软弱虚引用总结" class="headerlink" title="强软弱虚引用总结"></a>强软弱虚引用总结</h5><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220831201540595.png"></p><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><p>比如现在有如下一段内存，看看三种垃圾回收算法的处理方式：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220901164958025.png"></p><h4 id="标记-清除-Mark-Sweep"><a href="#标记-清除-Mark-Sweep" class="headerlink" title="标记-清除(Mark Sweep)"></a>标记-清除(Mark Sweep)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194927582.png"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，分两个阶段，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间（这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址并放入空闲地址列表里，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存）</p><p><strong>优点</strong>：速度快，清除操作只需要将垃圾对象的起始结束地址放入空闲地址列表里做一个记录就可以。</p><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理（Mark-Compact"><a href="#标记-整理（Mark-Compact" class="headerlink" title="标记-整理（Mark Compact)"></a>标记-整理（Mark Compact)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504194948373.png"></p><p><strong>定义</strong>标记-整理，会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低。</p><p><strong>优点</strong>：没有内存碎片。</p><p><strong>缺点</strong>：整理阶段涉及到对象的复制移动和引用地址的改变（<strong>比如，其他的变量引用了要移动的对象，需要改变该变量的引用地址</strong>），效率较低。</p><h4 id="标记-复制-Copy"><a href="#标记-复制-Copy" class="headerlink" title="标记-复制(Copy)"></a>标记-复制(Copy)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220901170254664.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195030732.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195102772.png"></p><p><strong>定义</strong>：标记-复制算法，将内存分为等大小的两个区域，FROM和TO（TO中为空）。首先先做一次标记找到那些不被引用的对象，然后将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><p><strong>优点</strong>：不会产生内存碎片。</p><p><strong>缺点</strong>：需要占用双倍的内存空间，造成空间浪费。如果对象存活率较高时，需要进行较多的复制操作，效率降低。<strong>所以JVM大多优先使用这种收集算法去回收新生代。</strong></p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><strong>定义：</strong>分代垃圾回收机制，把整个堆内存分为两块，新生代和老年代。其中新生代又划分为伊甸园、幸存区From和幸存区To。新生代处理的大多是朝生夕死的对象，而老年代处理的是存活时间更长，更有价值的对象。针对不同区域，采取不同的垃圾回收算法，可以更有效的管理内存。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195146303.png"></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195202087.png"></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong>。Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195230457.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230504195253790.png"></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903132254785.png"></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151018.png"></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收。</p><p><strong>总结：</strong></p><ul><li>对象有限分配在伊甸园区域 </li><li>新生代空间不足时，触发minor gc，伊甸园和 from存活的对象使用copy复制到to中，存活的对象年龄加 1并且交换 from和to </li><li>minor gc 会引发 stop the world（暂停其他用户线程，只让垃圾回收线程工作，直到垃圾回收完成，用户线程才会恢复工作。因为这里牵扯到对象的移动，对象的引用地址在发生变化，所以如果不停止用户线程，会发生混乱）。不过由于新生代大部分对象都是朝生夕死的，标记和复制过程是比较短的，STW也是比较短的。</li><li>当对象寿命超过阈值（阈值不一定是最大值15）时，会晋升至老年代，最大寿命是15（寿命存放在每个对象的对象头中，占4bit，故而最大就是15）</li><li>大对象直接进入老年区，<code>-XX:PretenureSizeThreshold指定大于设置值的对象直接在老年代分配</code>防止大对象在Eden区和两个Survivor区之间来回复制，产生大量的内存复制操作。当老年代空间不足，会先尝试触发 minor gc， 如果之后空间仍不足，那么触发 full gc（Full GC也会触发STW，但是相比于minor GC产生的STW的暂停时间要长。因为老年代大部分是存活对象，并且使用标记-清除和标记-整理算法，STW的暂停时间要更长。）</li></ul><h4 id="各个GC定义"><a href="#各个GC定义" class="headerlink" title="各个GC定义"></a>各个GC定义</h4><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：只目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意”Major GC“这个说法现在有点混淆，在不同资料上常有不同所指，读者需按照上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li>整堆收集（Full GC）：<del>收集整个Java堆和方法区的垃圾收集。深入理解jvm里面的概念，个人认为不准确</del>针对老年代的GC行为。</li></ul><h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h4><blockquote><p>含义                            参数</p><p>堆初始大小                -Xms</p><p>堆最大大小                -Xmx 等价 -XX:MaxHeapSize=size</p><p>新生代大小                -Xmn 等价 （-XX:NewSize=size 加 -XX:MaxNewSize=size）</p><p>幸存区比例（动态）-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</p><p>幸存区比例                -XX:SurvivorRatio=ratio(设置伊甸园空间大小和幸存者空间大小之间的比率。默认情况下，此选项设置为8。例如，新生代一共有10MB，伊甸园占8MB，两个幸存区分别占用1MB)</p><p>晋升阈值                    -XX:MaxTenuringThreshold=threshold</p><p>晋升详情                    -XX:+PrintTenuringDistribution</p><p>GC详情                        -XX:+PrintGCDetails -verbose:gc</p><p>FullGC 前 MinorGC    -XX:+ScavengeBeforeFullGC（在每次完全GC之前启用年轻一代的GC。默认情况下，此选项处于启用状态。Oracle建议您不要禁用它，因为在Full GC之前清理年轻一代可以减少从老一代空间到年轻一代空间可访问的对象数量，加速Full GC。） </p></blockquote><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903155531563.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903161016488.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_7MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903161949798.png"></p><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903162310476.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903162637673.png"></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  演示内存的分配策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_8MB]);<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;sleep....&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220903163155133.png"></p><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="第一类：串行"><a href="#第一类：串行" class="headerlink" title="第一类：串行"></a>第一类：串行</h4><ul><li>  单线程</li><li>  堆内存较小，个人电脑（CPU核数较少）</li></ul><blockquote><p>开启串行垃圾回收器 -XX:+UseSerialGC  等于Serial（新生代里面的复制算法）加SerialOld（老年代里的标记-整理算法）</p></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151027.png"></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="第二类：吞吐量优先"><a href="#第二类：吞吐量优先" class="headerlink" title="第二类：吞吐量优先"></a>第二类：吞吐量优先</h4><ul><li>  多线程</li><li>  堆内存较大，多核CPU</li><li>  单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短。<strong>吞吐量是指一定时间内回收垃圾的多少。</strong></li><li>  <strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><blockquote><p>-XX:+UseParallelGC 和 -XX:+UseParallelOldGC：分别开启新生代和老年代的并行垃圾回收器。JDK1.8默认开启。这两个开关，只要开启任意一个，另外一个也会自动开启。一般都会把CPU里的所有线程都占满，尽快完成垃圾回收。</p><p>-XX:+UseAdaptiveSizePolicy 启用自适应新生代调整，比如eden区和两个幸存区的比例，以及晋升老年代的阈值等。</p><p>-XX:GCTimeRatio=ratio 调整垃圾回收的时间相对于总时间的占比。ratio默认值99，垃圾回收器占用总时间的比率不能超过1/(1 + radio)，如果超过了，那么JVM会动态增大堆内存大小，以减少垃圾回收。</p><p>-XX:MaxGCPauseMillis=ms 最大暂停毫秒时间。默认值是200ms。GCTimeRatio和这个参数是相反的，需要折中。因为想要降低垃圾回收的时间占比，需要将堆内存变大，但是堆内存变大，每次暂停时间会变长。</p><p>-XX:ParallelGCThreads=n 设置垃圾回收器可以调用的线程数。默认值取决于JVM可用的CPU数量。</p></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151039.png"></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>  XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>  XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h5 id="JDK8默认是什么垃圾回收器？"><a href="#JDK8默认是什么垃圾回收器？" class="headerlink" title="JDK8默认是什么垃圾回收器？"></a><strong>JDK8默认是什么垃圾回收器？</strong></h5><blockquote><p>-XX:+PrintCommandLineFlags 参数可查看默认设置收集器类型<br>-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断</p></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922202412989.png"></p><p>UseParallelGC = Parallel Scavenge + Parallel Old。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922203820862.png"></p><table><thead><tr><th>新生代（别名）</th><th>老年代（别名）</th><th>JVM参数</th></tr></thead><tbody><tr><td>Serial (DefNew)</td><td>Serial Old(PSOldGen或Tenured)</td><td>-XX:+UseSerialGC</td></tr><tr><td>Parallel Scavenge (PSYoungGen)</td><td>Parallel Old (ParOldGen)</td><td>-XX:+UseParallelOldGC 或者 -XX:+UseParallelGC</td></tr><tr><td>ParNew (ParNew)</td><td>Serial Old(PSOldGen或Tenured)</td><td>-XX:-UseParNewGC同时打开ParNew GC和Serial Old JDK9之后不再支持</td></tr><tr><td>ParNew (ParNew)</td><td>CMS+Serial Old(PSOldGen或Tenured)</td><td>-XX:+UseConcMarkSweepGC</td></tr><tr><td>G1</td><td>G1</td><td>-XX:+UseG1GC</td></tr></tbody></table><h4 id="第三类：响应时间优先"><a href="#第三类：响应时间优先" class="headerlink" title="第三类：响应时间优先"></a>第三类：响应时间优先</h4><ul><li>  多线程</li><li>  堆内存较大，多核CPU</li><li>  尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><blockquote><p>-XX:+UseConcMarkSweepGC 打开并发的（垃圾回收线程和用户线程并发）标记-清除垃圾收集器，它工作再老年代（标记-清除算法，适合于长时间存活的区域） 和老年代的CMS垃圾收集器配的是新生代的ParNewGC，ParNewGC采用并发的复制算法，使用-XX:+UseParNewGC打开新生代ParNewGC垃圾收集器。一般CMS和ParNewGC是一对组合，分别工作在老年代和新生代。</p><p>对于CMS，如果老年代内存触发的GC的内存占比设置的过大，以致于无法满足浮动垃圾（或者说并发清理过程中新产生的对象），那么会出现<code>并发失败</code>，这时CMS的并发清理就会退化为 SerialOld，一边冻结用户线程的执行，一边SerialOld重新进行老年代的垃圾收集，不过这样STW的时间就十分长了。       但是如果老年代内存触发的GC的内存占比设置的过小，GC的频率会比较高。故而老年代内存触发的GC的内存占比需要折中选择。</p><p>-XX:ParallelGCThreads=n 垃圾回收器并行线程数，默认值是JVM可调用CPU数量 ~ -XX:ConcGCThreads=threads 垃圾回收器并发线程数，一般推荐设置为并行线程数的1/4（留出用户线程），默认值是JVM可调用CPU数量</p><p>-XX:CMSInitiatingOccupancyFraction=percent 老年代占用百分比(0到100)的阈值，触发CMS。</p><p>-XX:+CMSScavengeBeforeRemark    重新标记阶段之前，由于用户线程在并发标记阶段产生了一些新生代里的对象并且引用了老年代里的对象，在重新标记阶段，需要通过新生代的对象到老年代里的对象做一次可达性分析。由于新产生的新生代对象是比较多的，并且很大一部分是朝生夕死的，从新生代到老年代做可达性分析，就算找到了一些老年代，这些新生代有很大一部分也会马上被回收，做了很多无用的查找工作。这个开关就是在重新标记阶段之前，对新生代做一次ParNewGC，先清理一次新生代，减小重新标记的工作量。</p></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151052.png"></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>一种以获取<strong>最短回收停顿时间</strong>为目标的收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><ul><li><p><strong>初始标记</strong>：标记GC Roots能<strong>直接</strong>到的对象。速度很快但是<strong>仍存在Stop The World问题(很短暂)</strong></p></li><li><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p></li><li><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p></li><li><p><strong>并发清除</strong>：对标记的对象进行清除回收</p></li></ul><p><strong>问题</strong>：</p><ul><li>由于<strong>并发清除</strong>过程中，其他用户线程仍会不断产生新的垃圾，这些新的垃圾需要等到下一次垃圾回收时才能清理，这些垃圾被称为<strong>浮动垃圾</strong>，由于CMS在垃圾回收的过程中会产生浮动垃圾，这样导致CMS不能像其他垃圾回收器一样等到堆内存不足了再做垃圾回收。故而需要预留一些来存放浮动垃圾。</li><li>由于CMS是标记-清除算法，会导致在老年代产生大量内存碎片。如果发生<code>并发失败</code>，那么CMS会想浮动垃圾过多产生<code>并发失败</code>一样，CMS退化为单线程的SerialOld（标记-整理算法）进行整理碎片，这STW时间会很长。</li></ul><p><strong>关于为什么CMS会退化成SerialOld，而不是Parallel Old。我个人认为是，<code>并发失败</code>发生的两个原因来的都比较突然，无法到达Parallel Old要求的安全点，故而只能采用Serial Old彻底阻塞用户线程，进行老年代的标记-整理算法。</strong></p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>  同时注重吞吐量和低延迟（低响应时间），默认的暂停目标是200ms</li><li>  超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的Region区域（每个区域大小在1MB—32MB之间，且应为2的N次幂，每个区域都可以独立的做为Eden、幸存区和老年代。堆内存过大，回收速度会变慢，这种化整为零的思想，可以进行优化，加快标记和拷贝的速度）（当内存较小时，G1和CMS的暂停时间基本一致，但是当内存越大时，G1的暂停时间会比CMS的暂停时间越来越小。G1比CMS更适合大内存的服务器场景。）</li><li>  整体上是<strong>标记-整理</strong>算法（避免了CMS的内存碎片问题），两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：</p><blockquote><p>-XX:MaxGCPauseMillis=time 设置GC暂停目标时间</p><p>-XX:+UseG1GC JDK8 并不是默认开启的，所需要参数开启，JDK9默认开启</p><p>-XX:G1HeapRegionSize=size 设置每个区域大小在1MB—32MB之间，且应为2的N次幂</p></blockquote><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p>第一个阶段：Young Collection</p><p>第二个阶段：Young Collection + Concurrent Mark</p><p>第三个阶段：Mixed Collection</p><p>以上三个阶段循环执行，刚开始是新生代的垃圾收集，如果经过一段时间老年代的内存超过阈值了，那么它会在新生代的垃圾收集的同时进行并发标记，等这个阶段完成后，会进行混合收集，混合收集会对整个新生代和部分老年代都进行一次比较大的收集。如此循环往复。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151109.png" style="zoom:50%;" /><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个区域都可以独立的做为伊甸园、幸存区和老年代，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间。<strong>G1的垃圾回收是以区域为单位的。</strong></p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>  会STW（新生代垃圾回收的复制算法引起的，时间较短）</li></ul><p>刚开始都是伊甸园区，当伊甸园逐渐被占满，触发新生代垃圾回收。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151119.png" style="zoom:50%;" /><p>新生代垃圾回收的复制算法，会将存活的对象放入幸存区。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151129.png" style="zoom:50%;" /><p>在工作一段时间，当幸存区的存活对象年龄超过阈值或幸存区内存比较满，又会触发新生代的垃圾回收，一部分年龄超过阈值的会晋升到老年代，在幸存区里不够年龄的对象和伊甸园这一轮存活的对象会。复制到另外一块幸存区区域。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151140.png" style="zoom:50%;" /><h5 id="Young-Collection-CM（Concurrent-Mark并发标记）"><a href="#Young-Collection-CM（Concurrent-Mark并发标记）" class="headerlink" title="Young Collection + CM（Concurrent Mark并发标记）"></a>Young Collection + CM（Concurrent Mark并发标记）</h5><ul><li>不会STW</li></ul><ul><li><p>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong>。就是说在Young GC的STW时，进行初始标记，不会占用并发标记的时间，相当于这个阶段没有STW。</p><ul><li>  初始标记：对GC Root进行标记</li><li>  并发标记：顺着GC Root对其引用的对象进行标记</li></ul></li><li><p>  当老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</p></li></ul><blockquote><p>-XX:InitiatingHeapOccupancyPercent=percent 默认45%</p></blockquote><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151150.png" style="zoom:50%;" /><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong>。</p><ul><li>  最终标记（Remark）会STW，之前并发标记时，用户线程在工作可能会产生新的垃圾和改变一些对象的引用，造成漏标和错标，所以需要STW，进行最终标记。</li><li>  <strong>拷贝</strong>存活（Evacuation）会STW，在不超过暂停时间的前提下，选出一部分价值最高的老年代区域进行回收。</li></ul><blockquote><p> -XX:MaxGCPauseMills:ms 用于指定最长的停顿时间</p></blockquote><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，老年代中存活的对象很多，有大量的老年代存活对象需要从一个区域复制到另一个区域，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）。因为每次清理块的时间时一样的,所以在用户设置的时间内尽可能回收性价比比较高的块。在垃圾清理时,并不需要一下清理所有的新生代老年代区域,只需要清理哪些需要清理的小块。</p><p>Mixed Collection中的新生代垃圾回收：Eden中的存活对象和幸存区中不够晋升年龄的存活对象，复制到另外一块幸存区。幸存区符合晋升年龄的存活对象复制到老年区。</p><p>Mixed Collection中的老年代垃圾回收：选出回收价值和暂停时间，选出一批回收价值最高且不超过暂停时间，进行老年代的垃圾回收，将存活的老年代对象复制到另一个区域。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151201.png" style="zoom:50%;" /><h5 id="为什么叫Garbage-first？"><a href="#为什么叫Garbage-first？" class="headerlink" title="为什么叫Garbage first？"></a>为什么叫Garbage first？</h5><p>因为要优先回收价值高的区域，目的是达到暂停时间短的目标。</p><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>  新生代回收的跨代引用（老年代引用新生代）问题。但是老年代存活的对象是比较多的且存活的GC Root也多，这些GC Root引用新生代对象也比较少，如果遍历整个老年代，然后通过可达性分析算法从GC Root找那些新生代对象被引用，这是比较耗时的。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151211.png"></p><ul><li>卡表与Remembered Set<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域有一个老年代的对象引用了新生代对象，则该区域被称为脏卡。这样只需要从脏卡中的GC Root对象开始可达性分析，对新生代对象进行标记，效率比较高。</li><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡。每个Region内都会维护一个,因此G1收集器相对而言比较消耗内存的原因就在这里,它需要约5~10%的空间维护记忆集。这样做新生代垃圾回收时，先通过Remenbered set得到脏卡位置，到这些脏卡遍历GC Root，做可达性分析，提高了效率。</li><li><strong>Remembered Set保存脏卡，脏卡就是一段含有指向内存地址的数据。</strong><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906111542863.png"></li></ul></li><li>  在引用变更时通过post-write barried<strong>写屏障</strong> + dirty card queue<strong>脏卡队列</strong>（通过写屏障，在每次对象的引用发生变更时，都要更新脏卡，这是一个异步操作不会立刻完成脏卡的更新，把更新的指令放入脏卡队列之中，将来脏卡队列size到达阈值之后由一个线程完成脏卡的更新操作）</li><li>  concurrent refinement threads 更新 Remembered Set</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151222.png"></p><h5 id="Remark（重新标记阶段）"><a href="#Remark（重新标记阶段）" class="headerlink" title="Remark（重新标记阶段）"></a>Remark（重新标记阶段）</h5><p>在垃圾回收时，收集器处理对象的过程中。</p><h4 id="G1总结"><a href="#G1总结" class="headerlink" title="G1总结"></a>G1总结</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220922213348397.png"></p><p>总体上来说，G1垃圾收集器一共有四个步骤：</p><ul><li><strong>初始标记（Initial Marking）：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，并修改TAMS指针的值，让下一个阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记（Concurrent Marking）：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li>**最终标记（Final Marking):**对用户线程做另外一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li>**筛选回收（Live Data Counting and Evacuation):**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region种，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</li></ul><p><strong>三色标记法</strong></p><ul><li>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</li><li>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC需要从此对象中去寻找垃圾）</li><li>白色：该对象没有被标记过。（垃圾对象）</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906103622566.png"></p><p>下图是并发标记阶段，对象的处理状态：</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220906102435159.png" style="zoom:50%;" /><p>但是在<strong>并发标记过程中</strong>，有可能C被处理了(此时没有对象引用C)，但该处理过程还未结束，在处理过程结束之前A引用了C，这是C就被漏掉了，这时就会用到remark。</p><p>过程如下</p><ul><li>  之前C未被引用，这时A引用了C，就会给C加一个**<code>pre-write barrier</code><strong>写屏障，写屏障的指令会被执行，将C放入一个</strong><code>satb_mark_queue</code>**队列当中，并将C变为 处理中 状态</li><li>  在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151239.png"></p><p>原理：当对象的引用发生改变时，JVM就会加入一个写屏障（只要对象的引用发生改变，写屏障代码就会被执行），写屏障代码会将该对象加入一个队列当中并且会将该对象改为灰色（正在处理状态）。等到并发标记阶段结束后，进入remark阶段，此时发生STW，此时重新标记线程从队列中逐个取出对象，如果对象是灰色的则需要再做一次可达性分析。</p><h5 id="G1从JDK8到JDK9的优化"><a href="#G1从JDK8到JDK9的优化" class="headerlink" title="G1从JDK8到JDK9的优化"></a>G1从JDK8到JDK9的优化</h5><ul><li>JDK 8u20 字符串去重</li><li>JDK 8u40 并发标记类卸载</li><li>JDK 8u60 回收巨型对象</li><li>JDK 9并发标记起始时间的调整</li></ul><h5 id="JDK-8u20版本中-字符串去重"><a href="#JDK-8u20版本中-字符串去重" class="headerlink" title="JDK 8u20版本中 字符串去重"></a>JDK 8u20版本中 字符串去重</h5><blockquote><p>-XX:+UseStringDeduplication 打开字符串char数组去重，默认是打开</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span><br></code></pre></td></tr></table></figure><p>观察上面代码，我们发现，虽然两个字符串的值相同，但是却是两个堆对象，分别指向两个char数组。这种空间浪费的情况可以使用intern()来解决，使其引用串池中共同的一个字符串对象。但是这对于程序员的要求比较高。所以JDK 8u20版本中，优化了这种空间浪费，使得两个堆字符串对象的成员变量char数组引用同一个，减少了空间浪费。</p><p>过程</p><ul><li>  将所有新分配的字符串（底层是char[]）放入一个队列</li><li>  当新生代回收时，G1并发检查是否有重复的字符串（和intern()使用的字符串表不同，个人理解只检查在队列里面的字符串）</li><li>  如果字符串的值一样，就让他们<strong>引用同一个char数组</strong></li><li>注意，其与String.intern的区别<ul><li>  intern关注的是字符串对象</li><li>  字符串去重关注的是char[]</li><li>  在JVM内部，使用了不同的字符串表</li></ul></li></ul><p>优点与缺点</p><ul><li>  节省了大量内存</li><li>  新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在JDK 8u40的之前版本中，类一般是没办法卸载的，只要加载了之后会一直占用内存。尤其是一些自定义的类加载器创建和加载的类，使用一段时间后就没有人再用了，一直占用内存，对垃圾回收是不利的。</p><p><strong>过程：</strong></p><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类。一般卸载的是自定义的类，JVM的启动类加载器、扩展类加载器和应用程序类加载器会始终存在，对于自定义的类加载器才会有卸载的需求和功能。</p><p><strong>类卸载的条件：</strong></p><ul><li>类的实例都被回收掉了</li><li>类所在的类加载器的所有类都不在使用了</li></ul><blockquote><p>-XX:+ClassUnloadingWithConcurrentMark 打开并发标记类卸载，默认开启</p></blockquote><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><p>其实G1中有四种区域：Eden区、幸存区、老年代区、<strong>巨型对象区</strong></p><p>巨型对象：</p><ul><li><p>一个对象大于region的一半时，当然也可以占用多个区，就称为巨型对象</p></li><li><p>G1不会对巨型对象进行拷贝，因为拷贝的代价十分大</p></li><li><p>回收时被优先考虑巨型对象</p></li><li><p>G1会跟踪从老年代到巨型对象所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉（G1希望巨型对象越早回收越好，最好在新生代垃圾回收时就回收掉）。</p><p><strong>为什么只需要跟踪老年代到巨型对象的引用呢？</strong></p><p><strong>这是因为新生代存活对象少，很快就可以遍历分析可达性完成；而老年代存活对象多，遍历分析可达性代价大，这也是为什么要引用脏卡和记忆表的原因。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151249.png"></p><h5 id="JDK9-并发标记起始时间的调整"><a href="#JDK9-并发标记起始时间的调整" class="headerlink" title="JDK9 并发标记起始时间的调整"></a>JDK9 并发标记起始时间的调整</h5><p>并发标记必须在堆空间占满前完成,否则退化为FullGC(之前是使用Serial GC清理老年代，现在也变为多线程清理老年代了，但是也不好，因为STW时间长)。故而应该提前开始并发收集老年代。</p><blockquote><p> JDK9之前需要使用-XX:InitiatingHeapOccupancyPercent 设置老年代占比阈值，如果大于这个值，并发的老年代垃圾回收就会开始了。 但是比较麻烦，阈值大了，退化为FullGC的概率大，STW时间长；阈值小了，并发垃圾回收老年代的频率高，同样影响程序。</p></blockquote><p>JDK9可以动态调整了，只用设置一个初始阈值，不需要人为调整。</p><ul><li><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值 </p></li><li><p>进行数据采样并动态调整 </p></li><li><p>总会添加一个安全的空档空间</p></li></ul><h4 id="各种类型GC总结"><a href="#各种类型GC总结" class="headerlink" title="各种类型GC总结"></a>各种类型GC总结</h4><ul><li>Serial GC<ul><li>新生代内存不足发生的垃圾收集 minor gc </li><li>老年代内存不足发生的垃圾收集 full gc（Major gc）</li></ul></li><li>Parallel GC<ul><li>新生代内存不足发生的垃圾收集 minor gc </li><li>老年代内存不足发生的垃圾收集 full gc（Major gc）</li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集 minor gc </li><li>老年代内存不足。如果没有并发失败就继续并发清理，否则Serial GC。</li></ul></li><li>G1<ul><li>新生代内存不足发生的垃圾收集 minor gc </li><li>老年代内存不足</li></ul></li></ul><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>  如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC(老年代进行Serial GC)，还是并发地进行清理</li><li>  如果垃圾产生速度快于垃圾回收速度，便会触发Serial GC（现在的版本，即使是Full GC，也是多线程的老年代回收器，但是也不好，STW的时间长）</li></ul><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">各个JDK版本调优的官方文档</a></p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h4><ul><li><p>掌握GC相关的VM参数，会基本的空间调整 </p><blockquote><p>“F:\JAVA\JDK8.0\bin\java” -XX:+PrintFlagsFinal -version | findstr “GC” 查看与GC相关的参数设置情况，可以根据参数去查询具体的信息。</p></blockquote></li><li><p>掌握相关工具 </p><p><code>jmap</code>,<code>jconsole</code>等等工具。</p></li><li><p>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</p></li></ul><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS（jdk9已经不推荐）, G1（jdk9默认，大堆内存下工作比CMS要好，可以通过调参平衡低延迟和高吞吐量目标）, ZGC（JDK12体验垃圾回收器，目标是超低延迟） （低延迟）</li><li>ParallelGC (高吞吐量)</li><li>Zing（对外宣称几乎零STW，同时可以管理超大堆内存）</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？<ul><li>  JDBC中，resultSet = statement.executeQuery(“select * from 大表”)。把表中数据都从mysql加载入堆内存。</li></ul></li><li>数据表示是否太臃肿<ul><li>  对象图</li><li>  对象大小</li></ul></li><li>是否存在内存泄漏<ul><li>  有一些缓存数据，比如static Map map不断向它put对象，导致堆内存吃紧，不断发生GC。缓存数据不建议使用Java中的实现，因为他们不是专业做缓存的。可以考虑使用第三方缓存实现，如Redis，他们都会考虑缓存数据的过期，Redis自己做内存管理不会对JVM堆内存造成压力。如果不想使用第三方缓存实现，可以使用软、弱引用，及时回收缓存数据。</li></ul></li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p>GC调优一般从新生代调优开始，因为新生代调优优化空间大一些。</p><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的，在Eden区分配内存。<ul><li>  TLAB（thread-local allocation buffer），即对于每个线程都会在Eden区给它分配一块私有的区域。当new一个对象时，会优先检查TLAB是否有可用内存，如果有则优先在这块内存进行分配，保证线程并发安全保护。</li></ul></li><li>  死亡对象回收零代价。因为新生代采用标记-复制算法，故而死亡对象回收代价为零。</li><li>  大部分新生代对象用过即死（朝生夕死）</li><li>由于使用标记-复制算法且大部分新生代对象朝生夕死，MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是，Oracle推荐新生代内存占用堆内存的四分之一到二分之一。  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220921140004033.png"><ul><li>  新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC，Full GC的STW要比新生代时间长得多，因为老年代存活对象多，且采用一般需要采用标记-整理算法。而且触发Minor GC时，清理新生代所花费的时间会更长。</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求到响应过程中产生对象的总内存)]的数据为宜。因为这段时间后，这一段时间产生的大部分对象会被回收，只要新生代内存大于[并发量*(请求到响应过程中产生对象的总内存)]，就可以较少的触发Minor GC，保证并发量。</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li><p>幸存区需要能够保存 <strong>当前活跃对象（正在使用，可能下次Minor GC会回收）</strong>+<strong>需要晋升的对象（年龄不够，但是是存活时间较长的对象，将来会晋升到老年代）</strong></p></li><li><p>晋升阈值配置得当。一方面希望存活时间短的新生代对象留在新生代中，以便下次Minor GC能够回收掉，不想让它晋升到老年代，如果晋升到老年代，需要等到下次Full GC才能回收，占用空间。另一方面希望让长时间存活的对象尽快晋升，不要在Minor GC过程中每次都要在From 和 To区之间来回复制。</p><blockquote><p>-XX:MaxTenuringThreshold=threshold  设置晋升阈值</p><p>-XX:+PrintTenuringDistribution 打印幸存区各年龄段内存信息</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220921142649953.png"></p><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以 CMS 为例 </p><ul><li><p>CMS 的老年代内存越大越好 </p></li><li><p>先尝试不做调优，如果没有Full GC那么已经很ok。即使发生了Full GC，也应该先尝试调优新生代。 </p></li><li><p>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3 ，减少Full GC的发生频率。</p><blockquote><p> -XX：CMSInitiatingOccupancyFraction=percent 设置老年代内存占比触发CMS垃圾回收器的比率，若过大，可能会导致在老年代垃圾回收过程中产生过多浮动垃圾，使得CMS垃圾回收器在老年代上从并发垃圾回收变为Serial Old垃圾回收，大幅增大STW时间。一般来说，该值设置为0.75 ~ 0.80，剩下的空间预留给浮动垃圾。</p></blockquote></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li><p>案例1 Full GC和 Minor GC频繁 </p><p>首先，Minor GC和Full GC都频繁触发，说明空间不足。排除代码写的有比较严重的内存浪费的情况，有一种情况就是，当业务高峰期时，又使用的是新生代和老年代的并行垃圾回收器，那么打开自适应新生代调整。当大量的对象在新生代被创建，幸存区内存紧张，不仅频繁触发Minor GC，晋升老年代的阈值下调，使得大量朝生夕死的新生代对象晋升到老年代，使得老年代内存也紧张，进而频繁触发Full GC。</p><p>解决方法：增大新生代空间，幸存区内存紧张得到缓解，不会频繁触发Minor GC。同时，晋升老年代的阈值也会自适应提高，不会使得大量朝生夕死对象进入老年代，Full GC也不会频繁被触发。</p><blockquote><p>-XX:+UseParallelGC 和 -XX:+UseParallelOldGC：分别开启新生代和老年代的并行垃圾回收器。JDK1.8默认开启。这两个开关，只要开启任意一个，另外一个也会自动开启。一般都会把CPU里的所有线程都占满，尽快完成垃圾回收。</p><p>-XX:+UseAdaptiveSizePolicy 启用自适应新生代调整，比如eden区和两个幸存区的比例，以及晋升老年代的阈值等。</p></blockquote></li><li><p>案例2 请求高峰期发生Full GC，单次暂停时间特别长(采用CMS垃圾回收器) </p><p>首先，应当查看GC日志，查看究竟是CMS垃圾回收器哪个阶段耗时比较长。</p><ul><li>如果是重新标记时间过长，那么应当打开<code>-XX:+CMSScavengeBeforeRemark</code>,重新标记阶段之前做一次新生代的垃圾回收ParNewGC，因为新生代对象是比较多的，很大一部分是朝生夕死的。重新标记阶段需要从新生代对象到老年代对象做一次可达性分析，从新生代到老年代做可达性分析，就算找到了一些老年代，这些新生代有很大一部分也会马上被回收，做了很多无用的查找工作。这个开关就是在重新标记阶段之前，对新生代做一次ParNewGC，先清理一次新生代，减小重新标记的工作量。</li><li>如果是并发清理阶段，退化为了Serial Old。那么是因为CMS启动时间过晚，并发清理阶段产生浮动垃圾的速度大于垃圾清理速度，使得程序无法到达安全点，只能采用Serial Old清理老年代垃圾，需要适当设置<code>-XX：CMSInitiatingOccupancyFraction=percent</code>，提前触发老年代垃圾回收。</li></ul></li><li><p>案例3 老年代充裕情况下，发生Full GC (CMS jdk1.7)</p><p>查看GC日志，没有并发失败和碎片过多产生的提示，说明老年代空间充裕。</p><p>发生这种情况的原因是，在JDK7以及之前，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。故而永久代内存紧张也会触发Full GC，所以需要增大永久代的内存大小。JDK8以及之后，方法区移到了元空间（位于操作系统物理内存，这个比较充裕）。</p></li></ul><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151300.png"></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>一个简单的HelloWorld.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>  在文件对应目录下，执行<code>javac -parameters -d . HelloWorld.java</code> (-parameters 生成元数据以用于方法参数的反射)</li><li>  然后使用<code>od</code>命令，查看二进制字节码文件，<code> od -t xC HelloWorld.class</code></li></ul><p>以下是字节码文件</p><p>第一列是八进制的标号，后面是字节码文件的内容</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost ~]<span class="hljs-comment"># od -t xC HelloWorld.class</span><br>0000000 ca fe ba be<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 00 </span>23 0a<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>15 09<br>0000020<span class="hljs-number"> 00 </span>16<span class="hljs-number"> 00 </span>17<span class="hljs-number"> 08 </span>00<span class="hljs-number"> 18 </span>0a<span class="hljs-number"> 00 </span>19<span class="hljs-number"> 00 </span>1a<span class="hljs-number"> 07 </span>00 1b 07<br>0000040<span class="hljs-number"> 00 </span>1c<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 06 </span>3c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 69 </span>74 3e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>28 29<br>0000060<span class="hljs-number"> 56 </span>01<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 43 </span>6f<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 01 </span>00 0f 4c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 65 </span>4e<br>0000100<span class="hljs-number"> 75 </span>6d<span class="hljs-number"> 62 </span>65<span class="hljs-number"> 72 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>12 4c 6f 63<br>0000120<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 56 </span>61<span class="hljs-number"> 72 </span>69<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<br>0000140<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 74 </span>68<span class="hljs-number"> 69 </span>73<span class="hljs-number"> 01 </span>00 1d 4c<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74 63<br>0000160<span class="hljs-number"> 61 </span>73<span class="hljs-number"> 74 </span>2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c 6f<br>0000200<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>6d<span class="hljs-number"> 61 </span>69 6e<span class="hljs-number"> 01 </span>00 16<br>0000220<span class="hljs-number"> 28 </span>5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74 72<br>0000240<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>61<span class="hljs-number"> 72 </span>67<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>13<br>0000260 5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69<br>0000300 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>4d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 64 </span>50<span class="hljs-number"> 61 </span>72 61<br>0000320 6d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 65 </span>72<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 53 </span>6f<span class="hljs-number"> 75 </span>72<span class="hljs-number"> 63 </span>65 46<br>0000340<span class="hljs-number"> 69 </span>6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 48 </span>65 6c 6c 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c 64<br>0000360 2e 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>0c<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 07 </span>00 1d 0c<span class="hljs-number"> 00 </span>1e<br>0000400<span class="hljs-number"> 00 </span>1f<span class="hljs-number"> 01 </span>00 0b<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 20 </span>77 6f<span class="hljs-number"> 72 </span>6c 64<br>0000420<span class="hljs-number"> 07 </span>00<span class="hljs-number"> 20 </span>0c<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>22<span class="hljs-number"> 01 </span>00 1b<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74<br>0000440<span class="hljs-number"> 63 </span>61<span class="hljs-number"> 73 </span>74 2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c<br>0000460 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c 61<br>0000500 6e<span class="hljs-number"> 67 </span>2f 4f<span class="hljs-number"> 62 </span>6a<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76 61<br>0000520 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>79<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 65 </span>6d<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>6f<br>0000540<span class="hljs-number"> 75 </span>74<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<br>0000560<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d 3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>6a<span class="hljs-number"> 61 </span>76<br>0000600<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d<br>0000620<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 07 </span>70<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 74 </span>6c 6e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>28 4c 6a<br>0000640<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<br>0000660<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<br>0000700<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>2f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>01<br>0000720<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05 2a b7<span class="hljs-number"> 00 </span>01 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a 00<br>0000740<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 04 </span>00 0b<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c 00<br>0000760<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 05 </span>00 0c<span class="hljs-number"> 00 </span>0d<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>0e 00<br>0001000 0f<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>37<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00 00<br>0001020<span class="hljs-number"> 09 </span>b2<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 12 </span>03 b6<span class="hljs-number"> 00 </span>04 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a<br>0001040<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>0b<br>0001060<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>10<span class="hljs-number"> 00 </span>11<span class="hljs-number"> 00 </span>00<br>0001100<span class="hljs-number"> 00 </span>12<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>00<br>0001120<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 02 </span>00 14<br></code></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><p>第一列是字节数，前四个字节是魔数，再接下来两个字节是小版本号，再接下来两个字节是主版本号。再接下来的<code>constant_pool_count</code>和<code>constant_pool[constant_pool_count-1]</code>是常量池的信息。<code>access_flags</code>是访问标志，这个Class是一个类还是接口，这个类是不是公共的等等，<code>this_class</code>自己的包名和类名信息，<code>super_class</code>父类的信息，<code>interfaces_count</code>和<code>interfaces[interfaces_count]</code>是该类的接口信息，<code>fields_count</code>和<code>fields[fields_count]</code>该类中成员变量和静态变量信息，<code>methods_count</code>    和<code>methods[methods_count]</code>该类中成员方法和静态方法的信息，<code>attributes_count</code>和<code>attributes[attributes_count]</code>类的一些附加的属性信息。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">ClassFile</span> &#123;<br>    <span class="hljs-attribute">u4</span>  magic<br>    u2             minor_version;    <br>    <span class="hljs-attribute">u2</span>             major_version;    <br>    <span class="hljs-attribute">u2</span>             constant_pool_count;    <br>    <span class="hljs-attribute">cp_info</span>        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];    <br>    <span class="hljs-attribute">u2</span>             access_flags;    <br>    <span class="hljs-attribute">u2</span>             this_class;    <br>    <span class="hljs-attribute">u2</span>             super_class;   <br>    <span class="hljs-attribute">u2</span>             interfaces_count;    <br>    <span class="hljs-attribute">u2</span>             interfaces[interfaces_count];   <br>    <span class="hljs-attribute">u2</span>             fields_count;    <br>    <span class="hljs-attribute">field_info</span>     fields[fields_count];   <br>    <span class="hljs-attribute">u2</span>             methods_count;    <br>    <span class="hljs-attribute">method_info</span>    methods[methods_count];    <br>    <span class="hljs-attribute">u2</span>             attributes_count;    <br>    <span class="hljs-attribute">attribute_info</span> attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p><code>u4 magic</code>，字节码文件的0-3字节，表示它是否是[class]类型的文件.(魔术就是来标示改文件的类型，是.class文件还是.jpg文件等等)</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>字节码文件的4-7字节，表示类的版本 00 34(52)表示是 Java 8</p><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230320100753234.png"></p><p>字节码文件的8-9字节，表示常量池长度，00 23(35)表示常量池有#1~#34项，注意#0项不计入，也没有值 </p><p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p><p>第#1项<strong>0a</strong>通过查上述表可以得知表示一个 Method信息，<strong>00 06</strong>和<strong>00 15</strong> (21)表示它引用了常量池中 #6 和 #21项来获得这个方法的【所属类】和【方法名】</p><p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a 00 06 00 15</strong> 09</p><p>第2项<strong>09</strong>通过查上述表可以得知表示一个 Field信息，<strong>00 16(22)</strong> 和<strong>00 17(23）</strong> 表示它引用了常量池中#22和#23项来获得这个成员变量的【所属类】和【成员变量名】 </p><p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong></p><p>0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 la 07 00 1b 07</p><p>第#3项 <strong>08</strong> 表示一个字符串常量名称，**00 18(24)**表示它引用了常量池中 #24 项 </p><p>0000020 00 16 00 17 <strong>08 00 18</strong> 0a 00 19 00 1a 07 00 1b 07</p><p>第#4项 <strong>0a</strong> 表示一个 Method 信息，<strong>00 19(25)</strong> 和 <strong>00 1a(26)</strong> 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】</p><p>0000020 00 16 00 17 08 00 18 <strong>0a 00 19 00 1a</strong> 07 00 1b 07</p><p>第#5项 07 表示一个 Class 信息，00 1b(27) 表示它引用了常量池中 #27 项 </p><p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <strong>07 00 1b</strong> 07</p><p>第#6项 07 表示一个 Class 信息，00 1c(28) 表示它引用了常量池中 #28 项 </p><p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <strong>07<br>0000040 00 1c</strong> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 <init> 】 <code>代表构造方法</code></p><p>0000040 00 1c <strong>01 00 06 3c 69 6e 69 74 3e</strong> 01 00 03 28 29</p><p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值 </p><p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <strong>01 00 03 28 29</strong><br> 0000060 <strong>56</strong> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】 </p><p>0000060 56 <strong>01 00 04 43 6f 64 65</strong> 01 00 0f 4c 69 6e 65 4e</p><p>第#10项 01 表示一个 utf8 串，00 0f(15) 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】</p><p>0000060 56 01 00 04 43 6f 64 65 **01 00 0f 4c 69 6e 65 4e **</p><p>0000100 <strong>75 6d 62 65 72 54 61 62 6c 65</strong> 01 00 12 4c 6f 63</p><p>第#11项 01 表示一个 utf8 串，00 12(18) 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】</p><p>0000100 75 6d 62 65 72 54 61 62 6c 65 **01 00 12 4c 6f 63 **</p><p>0000120 <strong>61 6c 56 61 72 69 61 62 6c 65</strong> 54 61 62 6c 65 01</p><p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】 </p><p>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <strong>01</strong><br>0000140 <strong>00 04 74 68 69 73</strong> 01 00 1d 4c 63 6e 2f 69 74 63</p><p>第#13项 01 表示一个 utf8 串，00 1d(29) 表示长度，4c 63 6e 2f 69 74 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 57 6f 72 6c 64 3b是【Lcn/itcast/jvm/t5/HelloWorld;】 <code>在字节码文件中表示类型，引用类型是L开头，分号结尾，中间是该类型的全路径</code></p><p>0000140 00 04 74 68 69 73 <strong>01 00 1d 4c 63 6e 2f 69 74 63</strong></p><p>0000160 <strong>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</strong></p><p>0000200 <strong>57 6f 72 6c 64 3b</strong> 01 00 04 6d 61 69 6e 01 00 16</p><p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 75 是【main】</p><p>0000200 57 6f 72 6c 64 3b <strong>01 00 04 6d 61 69 6e</strong> 01 00 16</p><p> 第#15项 01 表示一个 utf8 串，00 16(22) 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值<code>在字节码文件中，类型前面加[说明是一个数组</code></p><p>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e **01 00 16 **</p><p>0000220 **28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 **</p><p>0000240 <strong>69 6e 67 3b 29 56</strong> 01 00 04 61 72 67 73 01 00 13</p><p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】 </p><p>0000240 69 6e 67 3b 29 56 <strong>01 00 04 61 72 67 73</strong> 01 00 13</p><p>第#17项 01 表示一个 utf8 串，00 13(19) 表示长度，是【[Ljava/lang/String;】</p><p>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 **01 00 13 **</p><p>0000260 **5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 **</p><p>0000300 <strong>6e 67 3b</strong> 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p><p>第#18项 01 表示一个 utf8 串，00 10(16) 表示长度，是【MethodParameters】 </p><p>0000300 6e 67 3b <strong>01 00 10 4d 65 74 68 6f 64 50 61 72 61</strong><br>0000320 <strong>6d 65 74 65 72 73</strong> 01 00 0a 53 6f 75 72 63 65 46</p><p>第#19项 01 表示一个 utf8 串，00 0a(10) 表示长度，是【SourceFile】 </p><p>0000320 6d 65 74 65 72 73 <strong>01 00 0a 53 6f 75 72 63 65 46</strong><br>0000340 <strong>69 6c 65</strong> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p><p>第#20项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【HelloWorld.java】 </p><p>0000340 69 6c 65 <strong>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</strong></p><p>0000360 <strong>2e 6a 61</strong> 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项</p><p>0000360 2e 6a 61 76 61 <strong>0c 00 07 00 08</strong> 07 00 1d 0c 00 1e</p><p>第#22项 07 表示一个 Class 信息，00 1d(29) 引用了常量池中</p><p>#29 项 0000360 2e 6a 61 76 61 0c 00 07 00 08 <strong>07 00 1d</strong> 0c 00 1e</p><p>第#23项 0c 表示一个 【名+类型】，00 1e(30) 00 1f (31)引用了常量池中 #30 #31 两项 </p><p>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <strong>0c 00 1e</strong><br>0000400 <strong>00 1f</strong> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#24项 01 表示一个 utf8 串，00 0b(11) 表示长度，是【hello world】 </p><p>0000400 00 1f <strong>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</strong></p><p>第#25项 07 表示一个 Class 信息，00 20(32) 引用了常量池中 #32 项 </p><p>0000420 <strong>07 00 20</strong> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#26项 0c 表示一个 【名+类型】，00 21(33) 00 22(34)引用了常量池中 #33 #34 两项 </p><p>0000420 07 00 20 <strong>0c 00 21 00 22</strong> 01 00 1b 63 6e 2f 69 74</p><p>第#27项 01 表示一个 utf8 串，00 1b(27) 表示长度，是【cn/itcast/jvm/t5/HelloWorld】 </p><p>0000420 07 00 20 0c 00 21 00 22 01 <strong>00 1b 63 6e 2f 69 74</strong><br>0000440<strong>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</strong><br>0000460 <strong>6f 57 6f 72 6c 64</strong> 01 00 10 6a 61 76 61 2f 6c 61</p><p>第#28项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/Object】 </p><p>0000460 6f 57 6f 72 6c 64 01 <strong>00 10 6a 61 76 61 2f 6c 61</strong><br>0000500 <strong>6e 67 2f 4f 62 6a 65 63 74</strong> 01 00 10 6a 61 76 61</p><p>第#29项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/System】 </p><p>0000500 6e 67 2f 4f 62 6a 65 63 74 01 <strong>00 10 6a 61 76 61<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d</strong> 01 00 03 6f</p><p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】 </p><p>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 **00 03 6f **</p><p>0000540 <strong>75 74</strong> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p><p>第#31项 01 表示一个 utf8 串，00 15(21) 表示长度，是【Ljava/io/PrintStream;】 </p><p>0000540 75 74 <strong>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</strong><br>0000560 <strong>69 6e 74 53 74 72 65 61 6d 3b</strong> 01 00 13 6a 61 76</p><p>第#32项 01 表示一个 utf8 串，00 13(19) 表示长度，是【java/io/PrintStream】 </p><p>0000560 69 6e 74 53 74 72 65 61 6d 3b <strong>01 00 13 6a 61 76<br>0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</strong></p><p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】 </p><p>0000620 <strong>01 00 07 70 72 69 6e 74 6c 6e</strong> 01 00 15 28 4c 6a</p><p>第#34项 01 表示一个 utf8 串，00 15(21) 表示长度，是【(Ljava/lang/String;)V】 </p><p>0000620 01 00 07 70 72 69 6e 74 6c 6e <strong>01 00 15 28 4c 6a</strong><br>0000640 <strong>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</strong><br>0000660 <strong>29 56</strong> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h4 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h4><p>21 表示该 class 是一个类，公共的（0x0001 + 0x0010)<br> 0000660 29 56 <strong>00 21</strong> 00 05 00 06 00 00 00 00 00 02 00 01 05 </p><p>表示根据常量池中 #5 找到本类全限定名<br> 0000660 29 56 00 21 <strong>00 05</strong> 00 06 00 00 00 00 00 02 00 01 06 </p><p>表示根据常量池中 #6 找到父类全限定名<br> 0000660 29 56 00 21 00 05 <strong>00 06</strong> 00 00 00 00 00 02 00 01 </p><p>表示接口的数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 <strong>00 00</strong> 00 00 00 02 00 01</p><table><thead><tr><th><strong>Flag Name</strong></th><th><strong>Value</strong></th><th><strong>Interpretation</strong></th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>Declared public ; may be accessed from outside its package.</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>Declared final ; no subclasses allowed.</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>Treat superclass methods specially when invoked by the <em>invokespecial</em> instruction.表示一个类</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>Is an interface, not a class.</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>Declared abstract ; must not be instantiated.</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>Declared synthetic; not present in the source code.人工合成的，不是源代码的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>Declared as an annotation type.表示注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>Declared as an enum type.表示枚举</td></tr></tbody></table><h4 id="Field-信息"><a href="#Field-信息" class="headerlink" title="Field 信息"></a>Field 信息</h4><p>表示成员变量数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 00 00 00 <strong>00 00</strong> 02 00 01</p><table><thead><tr><th><strong>FieldType</strong></th><th><strong>Type</strong></th><th><strong>Interpretation</strong></th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>LClassName;</td><td>reference</td><td>an instance of class <em>ClassName</em></td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h4 id="Method-信息"><a href="#Method-信息" class="headerlink" title="Method 信息"></a>Method 信息</h4><p>表示方法数量，本类为 2（构造方法和main方法）</p><p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <strong>00 02</strong> 00 01</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p> 一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成</p><ul><li><p>00 01代表访问修饰符(本类中是 public) </p></li><li><p>00 07代表引用了常量池 #07 项作为方法名称 </p></li><li><p>00 08代表引用了常量池 #08 项作为方法参数描述<br>00 01黄色代表方法属性数量，本方法是 1</p></li><li><p>剩下的代表方法属性</p><ul><li>00 09 表示引用了常量池 #09 项，发现是【Code】属性 </li><li>00 00 00 2f 表示此属性的长度是 47</li><li>00 01 表示【操作数栈】最大深度</li><li>00 01 表示【局部变量表】最大槽(slot)数</li><li>00 00 00 05 表示字节码长度，本例是 5</li><li>2a b7 00 01 b1 是字节码指令</li><li>00 00 00 02 表示方法细节属性数量，本例是 2</li><li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性，将字节码文件行号和Java源码行号进行对应，方便Debug调试使用<ul><li><p>00 00 00 06 表示此属性的总长度，本例是 6</p></li><li><p>00 01 表示【LineNumberTable】长度</p></li><li><p>00 00 表示【字节码】行号 00 04 表示【java 源码】行号</p></li></ul></li><li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性，局部变量表<ul><li>00 00 00 0c 表示此属性的总长度，本例是 12<ul><li>00 01 表示【LocalVariableTable】长度</li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li><li>00 05 表示局部变量覆盖的范围长度</li><li>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】 00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是 【Lcn/itcast/jvm/t5/HelloWorld;】</li><li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li></ul></li></ul></li></ul></li></ul><p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 <strong>00 01</strong> </p><p>0000700 <strong>00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</strong> </p><p>0000720 **00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 **</p><p>0000740 **00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 **</p><p>0000760 <strong>01 00 00 00 05 00 0c 00 0d 00 00</strong> 00 09 00 0e 00</p><h5 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h5><ul><li>00 09代表访问修饰符(本类中是 public static) </li><li>00 03代表引用了常量池 #14 项作为方法名称 </li><li>00 0f代表引用了常量池 #15 项作为方法参数描述 </li><li>00 02代表方法属性数量，本方法是 2 </li><li>其余黑体代表方法属性(属性1)<ul><li>00 09 表示引用了常量池 #09 项，发现是【Code】属性 </li><li>00 00 00 37 表示此属性的长度是 55</li><li>00 02 表示【操作数栈】最大深度</li><li>00 01 表示【局部变量表】最大槽(slot)数</li><li>00 00 00 05 表示字节码长度，本例是 9</li><li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li><li>00 00 00 02 表示方法细节属性数量，本例是 2</li><li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<ul><li>00 00 00 0a 表示此属性的总长度，本例是 10</li><li>00 02 表示【LineNumberTable】长度</li><li>00 00 表示【字节码】行号 00 06 表示【java 源码】行号 </li><li>00 08 表示【字节码】行号 00 07 表示【java 源码】行号</li></ul></li><li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<ul><li>00 00 00 0c 表示此属性的总长度，本例是 12 </li><li>00 01 表示【LocalVariableTable】长度</li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li><li>00 09 表示局部变量覆盖的范围长度</li><li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】</li><li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】 </li><li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li></ul></li></ul></li></ul><p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 **00 09 00 0e 00 **</p><p>0001000 **0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 **</p><p>0001020 **09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a **</p><p>0001040 **00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b **</p><p>0001060 <strong>00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</strong></p><p>黑体代表方法属性(属性2)</p><ul><li>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性<ul><li>00 00 00 05 表示此属性的总长度，本例是 5 </li><li>01 参数数量</li><li>00 10 表示引用了常量池 #16 项，是【args】 </li><li>00 00 访问修饰符</li></ul></li></ul><p>0001100 <strong>00 12 00 00 00 05 01 00 10 00 00</strong> 00 01 00 13 00 </p><p>0001120 00 00 02 00 14</p><h4 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h4><ul><li>00 01 表示附加属性数量</li><li>00 13 表示引用了常量池 #19 项，即【SourceFile】</li><li>00 00 00 02 表示此属性的长度</li><li>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】</li></ul><p>0001100 00 12 00 00 00 05 01 00 10 00 00 **00 01 00 13 00 **</p><p>0001120 <strong>00 00 02 00 14</strong></p><p>参考文献</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">oracle官方文档</a></p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>接着上一节，研究一下两组字节码指令，一个是<code>public cn.itcast.jvm.t5.HelloWorld();</code>构造方法的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">2a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1<br></code></pre></td></tr></table></figure><ol><li>2a =&gt; <em>aload_0</em> 加载 slot 0 的局部变量，即 this，做为下面的 <em>invokespecial</em> 构造方法调用的对象</li><li>b7 =&gt; <em>invokespecial</em> 预备调用构造方法，哪个方法呢?</li><li>00 01 引用常量池中 #1 项，即【 Method java/lang/Object.”<init>“:()V 】 </li><li>b1 =&gt; return 表示返回</li></ol><p>另一个是 <code>public static void main(java.lang.String[]);</code> 主方法的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1<br></code></pre></td></tr></table></figure><ol><li>b2 =&gt; <em>getstatic</em> 用来加载静态变量，哪个静态变量呢?</li><li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li><li>12 =&gt; <em>ldc</em> 加载参数，哪个参数呢?</li><li>03 引用常量池中 #3 项，即 【String hello world】</li><li>b6 =&gt; <em>invokevirtual</em> 预备调用成员方法，哪个方法呢?</li><li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】 </li><li>b1 =&gt; return 表示返回</li></ol><p>参考文献</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">oracle官方文档</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>自己分析类文件结构太麻烦了，Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@localhost ~]# javap -v HelloWorld.<span class="hljs-keyword">class</span><br>Classfile /root/HelloWorld.<span class="hljs-keyword">class</span><br>  Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">597</span> bytes<br>  MD5 checksum <span class="hljs-number">361</span>dca1c3f4ae38644a9cd5060ac6dbc       <span class="hljs-comment">//MD5检验签名</span><br>  Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br>public <span class="hljs-keyword">class</span> cn.itcast.jvm.t5.HelloWorld<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">21</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">22.</span>#<span class="hljs-number">23</span>        <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br> #<span class="hljs-number">3</span> = String #<span class="hljs-number">24</span>            <span class="hljs-comment">// hello world</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">27</span>            <span class="hljs-comment">// cn/itcast/jvm/t5/HelloWorld</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">28</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               this<br>  #<span class="hljs-number">13</span> = Utf8               Lcn/itcast/jvm/t5/HelloWorld;<br>#<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               MethodParameters<br>  #<span class="hljs-number">19</span> = Utf8               SourceFile<br>  #<span class="hljs-number">20</span> = Utf8               HelloWorld.java<br>  #<span class="hljs-number">21</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">22</span> = Class              #<span class="hljs-number">29</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">30</span>:#<span class="hljs-number">31</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">24</span> = Utf8               hello world<br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">33</span>:#<span class="hljs-number">34</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">27</span> = Utf8               cn/itcast/jvm/t5/HelloWorld<br>  #<span class="hljs-number">28</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">29</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">30</span> = Utf8               out<br>  #<span class="hljs-number">31</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">32</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">33</span> = Utf8               println<br>  #<span class="hljs-number">34</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  public cn.itcast.jvm.t5.HelloWorld();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>              <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: return<br>      LineNumberTable:<br>        line <span class="hljs-number">4</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  this   Lcn/itcast/jvm/t5/HelloWorld;<br>          <br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>        stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>           <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>   <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>           <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>   <span class="hljs-comment">//String java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>           <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span>   <span class="hljs-comment">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>           <span class="hljs-number">8</span>: return<br>        LineNumberTable:<br>          line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>          line <span class="hljs-number">7</span>: <span class="hljs-number">8</span><br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>              <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>      MethodParameters:<br>        Name                           Flags<br>        args<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p><strong>1)原始Java代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package cn.itcast.jvm.t3.bytecode;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 演示 字节码指令 和 操作数栈、常量池的关系 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> c = a + b;<br>        System.out.<span class="hljs-built_in">println</span>(c);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）编译后的字节码文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@localhost</span> ~]# javap -v Demo3_1.class<br>Classfile /root/Demo3_1.class<br>  Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">665</span> bytes<br>  MD5 checksum a2c29a22421e218d4924d31e6990cfc5<br>  Compiled from <span class="hljs-string">&quot;Demo3_1.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">t3</span>.<span class="hljs-title">bytecode</span>.<span class="hljs-title">Demo3_1</span></span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">     #1 </span>= Methodref#<span class="hljs-number">7.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>     #<span class="hljs-number">2</span> = Class#<span class="hljs-number">27</span>            <span class="hljs-comment">// java/lang/Short</span><br>     #<span class="hljs-number">3</span> = Integer<span class="hljs-number">32768</span><br>     #<span class="hljs-number">4</span> = Fieldref#<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br>     #<span class="hljs-number">5</span> = Methodref#<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>     #<span class="hljs-number">6</span> = Class#<span class="hljs-number">32</span>            <span class="hljs-comment">// cn/itcast/jvm/t3/bytecode/Demo3_1</span><br>     #<span class="hljs-number">7</span> = Class#<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>     #<span class="hljs-number">8</span> = Utf8&lt;init&gt;<br>     #<span class="hljs-number">9</span> = Utf8()V<br>     #<span class="hljs-number">10</span> = Utf8Code<br>     #<span class="hljs-number">11</span> = Utf8LineNumberTable<br>     #<span class="hljs-number">12</span> = Utf8LocalVariableTable<br>     #<span class="hljs-number">13</span> = Utf8<span class="hljs-keyword">this</span><br>     #<span class="hljs-number">14</span> = Utf8Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>     #<span class="hljs-number">15</span> = Utf8main<br>     #<span class="hljs-number">16</span> = Utf8([Ljava/lang/String;)V<br>     #<span class="hljs-number">17</span> = Utf8args<br>     #<span class="hljs-number">18</span> = Utf8[Ljava/lang/String;<br>     #<span class="hljs-number">19</span> = Utf8a<br>    #<span class="hljs-number">20</span> = Utf8I<br>    #<span class="hljs-number">21</span> = Utf8b<br>    #<span class="hljs-number">22</span> = Utf8c<br>    #<span class="hljs-number">23</span> = Utf8MethodParameters<br>    #<span class="hljs-number">24</span> = Utf8SourceFile<br>    #<span class="hljs-number">25</span> = Utf8Demo3_1.java<br>    #<span class="hljs-number">26</span> = NameAndType#<span class="hljs-number">8</span>:#<span class="hljs-number">9</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>    #<span class="hljs-number">27</span> = Utf8java/lang/Short<br>    #<span class="hljs-number">28</span> = Class#<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>    #<span class="hljs-number">29</span> = NameAndType#<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>    #<span class="hljs-number">30</span> = Class#<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>    #<span class="hljs-number">31</span> = NameAndType#<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span><br>    #<span class="hljs-number">32</span> = Utf8cn/itcast/jvm/t3/bytecode/Demo3_1<br>    #<span class="hljs-number">33</span> = Utf8java/lang/Object<br>    #<span class="hljs-number">34</span> = Utf8java/lang/System<br>    #<span class="hljs-number">35</span> = Utf8out<br>    #<span class="hljs-number">36</span> = Utf8Ljava/io/PrintStream;<br>    #<span class="hljs-number">37</span> = Utf8java/io/PrintStream<br>    #<span class="hljs-number">38</span> = Utf8println<br>    #<span class="hljs-number">39</span> = Utf8(I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> cn.itcast.jvm.t3.bytecode.Demo3_1();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span><span class="hljs-comment">// Method java/lang/Object.&quot;  &lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>      descriptor: ([Ljava/lang/String;)V<br>      flags: ACC_PUBLIC, ACC_STATIC<br>      Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">2</span>: istore_1<br>       <span class="hljs-number">3</span>: ldc#<span class="hljs-number">3</span><span class="hljs-comment">//int 32768</span><br>       <span class="hljs-number">5</span>: istore_2<br>       <span class="hljs-number">6</span>: iload_1<br>       <span class="hljs-number">7</span>: iload_2<br>       <span class="hljs-number">8</span>: iadd<br>      <span class="hljs-number">9</span>: istore_3<br>      <span class="hljs-number">10</span>: getstatic#<span class="hljs-number">4</span><span class="hljs-comment">//Fieldjava/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">13</span>: iload_3<br>      <span class="hljs-number">14</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">//Method  java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">17</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">18</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">15</span>     <span class="hljs-number">1</span>     a   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">12</span>     <span class="hljs-number">2</span>     b   I<br>           <span class="hljs-number">10</span>       <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     c   I<br>    MethodParameters:<br>      Name  Flags<br>      args <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3)常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151317.png"></p><p><strong>4)方法字节码载入方法区，main线程开始运行，分配栈帧内存</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151325.png"></p><p><strong>5）执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有<ul><li>  sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>  ldc 将一个 int 压入操作数栈</li><li>  ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>  这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151336.png"></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p><code>bipush 10</code> 和 <code>istore 1</code>对应Java代码中的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151346.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151412.png"></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的，此操作是编译优化，叫做常量折叠。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151421.png"></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151432.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151441.png"></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>  因为只能在操作数栈中执行运算操作</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151450.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151459.png"></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151508.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151523.png"></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151547.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151555.png"></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151605.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151613.png"></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151624.png"></p><p><strong>invokevirtual 5</strong></p><ul><li><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p></li><li><p>生成新的栈帧（分配 locals、stack等）</p></li><li><p>传递参数，执行新栈帧中的字节码</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151632.png"></p><ul><li><p>执行完毕，弹出栈帧</p></li><li><p>清除 main 操作数栈内容</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200608151640.png"></p><p><strong>return</strong>  </p><ul><li><p>完成 main 方法调用，弹出 main 栈帧</p></li><li><p>程序结束</p></li></ul><h4 id="联系-分析i"><a href="#联系-分析i" class="headerlink" title="联系 - 分析i++"></a>联系 - 分析i++</h4><p>目的：从字节码角度分析 a++ 相关题目</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.bytecode;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从字节码角度分析 a++ 相关题目 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">int</span> b = a++ + ++a + a--;<br>      System.out.println(a);<br>      System.out.println(b);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs class">public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (0x0009) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=3, args_size=1<br>         0: bipush10<br>         2: istore_1<br>         3: iload_1<br>         4: iinc1,1<br>         7: iinc1,1<br>        10: iload_1<br>        11: iadd<br>        12: iload_1<br>        13: iinc1,-1<br>        16: iadd<br>        17: istore_2<br>        18: getstatic     #2//Fieldjava/lang/System.out:Ljava/io/PrintStream;<br>21: iload_1<br>        22: invokevirtual #3//Methodjava/io/PrintStream.println:(I)V<br>        25: getstatic     #2//Fieldjava/lang/System.out:Ljava/io/PrintStream;<br>28: iload_2<br>        29: invokevirtual #3//Methodjava/io/PrintStream.println:(I)V<br>        32: return<br>      LineNumberTable:<br>        line 8: 0<br>        line 9: 3<br>        line 10: 18<br>        line 11: 25<br>        line 12: 32<br>      LocalVariableTable:<br>           Start  Length  Slot  Name   Signature<br>               0      33     0  args   [Ljava/lang/String;<br>               3      30     1     a   I<br>              18      15     2     b   I<br></code></pre></td></tr></table></figure><p>分析:</p><ul><li>注意 iinc 指令是直接在局部变量 slot 上进行运算 </li><li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144617986.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144635042.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144715209.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144737695.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144752804.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230322144815653.png"></p><h4 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-202303221457025586.png"></p><p>几点说明:</p><ul><li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li><li>goto 用来进行跳转到指定行号的字节码</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;<br>        a = <span class="hljs-number">10</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        a = <span class="hljs-number">20</span>; <br>        &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs class"> 0: iconst_0      //从0-5这种比较小的数，用iconst_x来表示的<br> 1: istore_1<br> 2: iload_1<br> 3: ifne          12      //如果不等于成立，跳转到12行<br> 6: bipush        10<br> 8: istore_1<br> 9: goto          15<br>12: bipush        20<br>14: istore_1<br>15: return<br></code></pre></td></tr></table></figure><blockquote><p>思考</p><p>细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办?</p><p>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p></blockquote><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a><strong>循环控制指令</strong></h4><p>其实循环控制还是前面介绍的那些指令，例如 while 循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;<br>a++; <br>        &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class">0: iconst_0<br> 1: istore_1<br> 2: iload_1<br> 3: bipush10<br> 5: if_icmpge14         //如果大于等于成立，跳转到14行<br> 8: iinc1, 1<br>11: goto2<br>14: return<br></code></pre></td></tr></table></figure><p>再比如 do while 循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <br>      <span class="hljs-keyword">do</span> &#123;<br>        a++;<br>    &#125; <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs class">0: iconst_0 <br>1: istore_1 <br>2: iinc1,1<br>5: iload_1 <br>6: bipush 10<br>8: if_icmplt 2//如果小于成立，跳转到2行<br>11: return<br></code></pre></td></tr></table></figure><p>最后再看看 for 循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>&#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>字节码是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class"> 0: iconst_0<br> 1: istore_1<br> 2: iload_1<br> 3: bipush10<br> 5: if_icmpge14<br> 8: iinc1,1<br>11: goto2<br>14: return<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归😊</p></blockquote><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>Java源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>x = x++;<br>i++;<br>&#125;<br>System.out.println(x); <span class="hljs-comment">//结果为0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>//操作数栈分配<span class="hljs-number">2</span>个空间，局部变量表分配<span class="hljs-number">3</span>个空间<br>        <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span>//准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>//将常数<span class="hljs-number">0</span>放入局部变量表的<span class="hljs-number">1</span>号槽位 i=<span class="hljs-number">0</span><br>        <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">0</span>//准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>//将常数<span class="hljs-number">0</span>放入局部变量的<span class="hljs-number">2</span>号槽位 x=<span class="hljs-number">0</span><br>        <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>//将局部变量表<span class="hljs-number">1</span>号槽位的数放入操作数栈中<br>        <span class="hljs-attribute">5</span>: bipush        <span class="hljs-number">10</span>//将数字<span class="hljs-number">10</span>放入操作数栈中，此时操作数栈中有<span class="hljs-number">2</span>个数<br>        <span class="hljs-attribute">7</span>: if_icmpge     <span class="hljs-number">21</span>//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到<span class="hljs-number">21</span>。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空<br>       <span class="hljs-attribute">10</span>: iload_<span class="hljs-number">2</span>//将局部变量<span class="hljs-number">2</span>号槽位的数放入操作数栈中，放入的值是<span class="hljs-number">0</span><br>       <span class="hljs-attribute">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span>//将局部变量<span class="hljs-number">2</span>号槽位的数加<span class="hljs-number">1</span>，自增后，槽位中的值为<span class="hljs-number">1</span><br>       <span class="hljs-attribute">14</span>: istore_<span class="hljs-number">2</span>//将操作数栈中的数放入到局部变量表的<span class="hljs-number">2</span>号槽位，<span class="hljs-number">2</span>号槽位的值又变为了<span class="hljs-number">0</span><br>       <span class="hljs-attribute">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> //<span class="hljs-number">1</span>号槽位的值自增<span class="hljs-number">1</span><br>       <span class="hljs-attribute">18</span>: goto          <span class="hljs-number">4</span> //跳转到第<span class="hljs-number">4</span>条指令<br>       <span class="hljs-attribute">21</span>: getstatic     #<span class="hljs-number">2</span>                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       <span class="hljs-attribute">24</span>: iload_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">25</span>: invokevirtual #<span class="hljs-number">3</span>                  // Method java/io/PrintStream.println:(I)V<br>       <span class="hljs-attribute">28</span>: return<br></code></pre></td></tr></table></figure><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="lt-cinit-gt-V"><a href="#lt-cinit-gt-V" class="headerlink" title="&lt;cinit&gt;()V"></a>&lt;cinit&gt;()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(i); <span class="hljs-comment">//结果为30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 <code>&lt;cinit()&gt;V </code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=0,</span> <span class="hljs-string">args_size=0</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">10:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">30</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">15:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</p><h5 id="lt-init-gt-V"><a href="#lt-init-gt-V" class="headerlink" title="&lt;init&gt;()V"></a>&lt;init&gt;()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br><br>&#123;<br>b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>&#123;<br>a = <span class="hljs-string">&quot;s2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.a = a;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>System.out.println(d.a);<br>System.out.println(d.b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有初始化代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> cn.itcast.jvm.t<span class="hljs-number">3</span>.bytecode.Demo<span class="hljs-number">3</span>_<span class="hljs-number">8</span>_<span class="hljs-number">2</span>(java.lang.String, int);<br>    <span class="hljs-attribute">descriptor</span>: (Ljava/lang/String;I)V<br>    <span class="hljs-attribute">flags</span>: ACC_PUBLIC<br>    <span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>         <span class="hljs-attribute">0</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">1</span>: invokespecial #<span class="hljs-number">1</span>// super.&lt;init&gt;()V<br>         <span class="hljs-attribute">4</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">5</span>: ldc #<span class="hljs-number">2</span>// &lt;- <span class="hljs-string">&quot;s1&quot;</span><br>         <span class="hljs-attribute">7</span>: putfield #<span class="hljs-number">3</span>       // -&gt; this.a<br>         <span class="hljs-attribute">10</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">11</span>: bipush<span class="hljs-number">20</span>//&lt;-<span class="hljs-number">20</span><br>         <span class="hljs-attribute">13</span>: putfield#<span class="hljs-number">4</span>// -&gt; this.b<br>         <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">17</span>: bipush<span class="hljs-number">10</span>//&lt;-<span class="hljs-number">10</span><br>         <span class="hljs-attribute">19</span>: putfield#<span class="hljs-number">4</span>//-&gt; this.b<br>         <span class="hljs-attribute">22</span>: aload_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">23</span>: ldc#<span class="hljs-number">5</span> //&lt;- <span class="hljs-string">&quot;s2&quot;</span><br>         <span class="hljs-attribute">25</span>: putfield#<span class="hljs-number">3</span>//-&gt; this.a<br>         <span class="hljs-attribute">28</span>: aload_<span class="hljs-number">0</span>// ------------------------------<br>         <span class="hljs-attribute">29</span>: aload_<span class="hljs-number">1</span>// &lt;- slot <span class="hljs-number">1</span>(a) <span class="hljs-string">&quot;s3&quot;</span>            |<br>         <span class="hljs-attribute">30</span>: putfield// -&gt; this.a                    |<br>         <span class="hljs-attribute">33</span>: aload_<span class="hljs-number">0</span>|<br>         <span class="hljs-attribute">34</span>: iload_<span class="hljs-number">2</span>// &lt;- slot <span class="hljs-number">2</span>(b) <span class="hljs-number">30</span>              |<br>         <span class="hljs-attribute">35</span>: putfield// -&gt; this.b --------------------<br>         <span class="hljs-attribute">38</span>: return<br>        <span class="hljs-attribute">LineNumberTable</span>: ...<br>        <span class="hljs-attribute">LocalVariableTable</span>:<br>            <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">0</span>  this   Lcn/itcast/jvm/t<span class="hljs-number">3</span>/bytecode/Demo<span class="hljs-number">3</span>_<span class="hljs-number">8</span>_<span class="hljs-number">2</span>;<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">1</span>     a   Ljava/lang/String;<br>                <span class="hljs-attribute">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">2</span>     b   I<br>        <span class="hljs-attribute">MethodParameters</span>: ...<br></code></pre></td></tr></table></figure><blockquote><p>1、aload</p><p>从局部变量表的相应位置装载一个对象引用到操作数栈的栈顶</p><p>aload_0把this装载到了操作数栈中aload_0是一组格式为aload_的操作码中的一个，这一组操作码把对象的引用装载到操作数栈中标志了待处理的局部变量表中的位置，但取值仅可为0、1、2或者3。</p><p>2、iload_,lload_,fload_,dload_</p><p>还有一些其他相似的操作码用来装载非对象引用，包括iload_、lload_、fload_和dload_，这里的i代表int型，l代表long型，f代表float型以及d代表double型。在局部变量表中的索引位置大于3的变量的装载可以使用iload、lload、fload,、dload和aload，这些操作码都需要一个操作数的参数，用于确认需要装载的局部变量的位置。</p></blockquote><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>看一下几种不同的方法调用对应的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();<br>demo5.test1();<br>demo5.test2();<br>demo5.test3();<br>Demo5.test4();<br>    demo5.test4();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>  私有、构造、被final修饰的方法，在调用时都使用<code>invokespecial</code>指令</li><li>  普通成员方法在调用时，使用<code>invokevirtual</code>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定，即为动态绑定。</li><li>  静态方法在调用时使用<code>invokestatic</code>指令。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: new           #<span class="hljs-number">2</span>                  // class com/nyima/JVM/day<span class="hljs-number">5</span>/Demo<span class="hljs-number">5</span> <br>         <span class="hljs-attribute">3</span>: dup<br>         <span class="hljs-attribute">4</span>: invokespecial #<span class="hljs-number">3</span>                  // Method <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>:()V<br>         <span class="hljs-attribute">7</span>: astore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">8</span>: aload_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">9</span>: invokespecial #<span class="hljs-number">4</span>                  // Method test<span class="hljs-number">1</span>:()V<br>        <span class="hljs-attribute">12</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">13</span>: invokespecial #<span class="hljs-number">5</span>                  // Method test<span class="hljs-number">2</span>:()V<br>        <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">17</span>: invokevirtual #<span class="hljs-number">6</span>                  // Method test<span class="hljs-number">3</span>:()V<br>        <span class="hljs-attribute">20</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">21</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">22</span>: pop<br>        <span class="hljs-attribute">25</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">28</span>: return<br></code></pre></td></tr></table></figure><ul><li>  new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>  dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>  终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定。只需要查找一次就可以找到方法地址。</li><li>  普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态。可能需要查找多次才能找到方法地址。</li><li>  成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li><li>  比较有意思的是 demo.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了。所以尽量使用类名来调用静态方法，否则，会产生 <code>aload</code>和<code>pop</code>这两条无用指令。</li><li>  还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.bytecode;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩</span><br><span class="hljs-comment">* -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_10</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Animal animal)</span> </span>&#123;<br>        animal.eat();<br>        System.out.println(animal.toString());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        test(<span class="hljs-keyword">new</span> Cat());<br>        test(<span class="hljs-keyword">new</span> Dog());<br>        System.in.read();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>&#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;啃骨头&quot;</span>);<br>&#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123; <br>  System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>1)运行代码<br>停在 System.in.read() 方法上，这时运行 jps 获取进程 id </p><p>2）运行HSDB工具<br>进入 JDK 安装目录，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure><p>进入图形界面 <code>attach to HotSpot process</code>输入进程 id</p><p>3)查找某个对象</p><p>打开 Tools -&gt; Find Object By Query<br> 输入 <code>select d from cn.itcast.jvm.t3.bytecode.Dog d</code> 点击 Execute 执行。<strong>输入全路径类名即可查询，该类对象地址</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211108650.png"></p><p>4)查看对象内存结构</p><p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是MarkWord（对象的hash码，以及对象将来加锁的锁标记），后 8 字节就是对象的 Class 指针（对象的类型指针，根据该指针可以找到对象的Class类），但目前看不到它Class类的实际地址</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211158647.png"></p><p>5)查看对象 Class 的内存地址</p><p>可以通过 Windows -&gt; Console 进入命令行模式，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mem 0x00000001299b4978 2<br></code></pre></td></tr></table></figure><p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行(即 16 字节)。结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211329720.png"></p><p>查看类的vtable</p><ul><li><p>方法1:Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面（该类Class对象的所有信息，Class对象在方法区中）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211723668.png"></p></li><li><p>方法2:或者 Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230323211742521.png"></p></li></ul><p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法(多态相关的，final，static 不会列入)</p><p>那么这 6 个方法都是谁呢?从 Class 的起始地址开始算，偏移 0x1b8 （<strong>这是vtable相对Class对象固定的偏移地址</strong>）就是 vtable 的起始地址，进行计算得到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000000001b7d4028<br>               1b8 +<br>---------------------<br>0x000000001b7d41e0<br></code></pre></td></tr></table></figure><p>通过 Windows -&gt; Console 进入命令行模式，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mem 0x000000001b7d41e0 6<br>0x000000001b7d41e0: 0x000000001b3d1b10<br>0x000000001b7d41e8: 0x000000001b3d15e8<br>0x000000001b7d41f0: 0x000000001b7d35e8<br>0x000000001b7d41f8: 0x000000001b3d1540<br>0x000000001b7d4200: 0x000000001b3d1678<br>0x000000001b7d4208: 0x000000001b7d3fa8<br></code></pre></td></tr></table></figure><p>就得到了 6 个虚方法的入口地址.</p><p>7)验证方法地址<br>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Dog - public void eat() @0x000000001b7d3fa8<br>Animal - public java.lang.String toString() @0x000000001b7d35e8;<br>Object - protected void finalize() @0x000000001b3d1b10;<br>Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;<br>Object - public native int hashCode() @0x000000001b3d1540;<br>Object - protected native java.lang.Object clone() @0x000000001b3d1678;<br></code></pre></td></tr></table></figure><p>对号入座，发现</p><ul><li>eat() 方法是 Dog 类自己的</li><li>toString() 方法是继承 Animal 类的</li><li>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的</li></ul><p>8)小结</p><h5 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h5><ul><li>在类加载阶段-链接阶段，生成vtable，确定各个普通成员方法入口地址。</li><li>vtable中包含和多态相关的方法（被public protected default修饰的方法），不包含被final, static,private修饰的方法。</li></ul><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令。</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>  先通过栈帧中对象的引用找到对象</li><li>  分析对象头，找到对象实际的在方法区中的Class对象</li><li>  Class结构中有<strong>vtable</strong>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li><li>  查询vtable找到方法的具体地址</li><li>  执行方法的字节码</li></ul><p><strong>从性能层面上看，调用普通成员方法效率不如调用static,final,private成员方法高，因为他要在运行期间进行动态查找方法入口地址。当然，JVM会对这个查找过程做一定的优化，如果频繁地调用每个方法达到一定的次数，那么JVM会把该方法的字节码地址加载入缓存中，以后从缓存中直接取出方法的字节码地址，不需要再经过这么多步的查找了。另外，如果JVM发现某个类一直以来只调用了一个子类，那么JVM会做一个单态的优化，这也可以加快方法的寻址速度。</strong></p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">goto          12</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">astore_2</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">//多出来一个异常表</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target type</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5     8   Class java/lang/Exception</span><br>      <span class="hljs-attr">LineNumberTable</span>: <span class="hljs-string">...</span><br>      <span class="hljs-attr">LocalVariableTable</span>:<span class="hljs-string"></span><br>        <span class="hljs-attr">Start</span>  <span class="hljs-string">Length  Slot  Name   Signature</span><br>            <span class="hljs-attr">9</span>       <span class="hljs-string">3     2     e   Ljava/lang/Exception;</span><br>            <span class="hljs-attr">0</span>      <span class="hljs-string">13     0  args   [Ljava/lang/String;</span><br>            <span class="hljs-attr">2</span>      <span class="hljs-string">11     1     i   I</span><br>      <span class="hljs-attr">StackMapTable</span>: <span class="hljs-string">...</span><br>    <span class="hljs-attr">MethodParameters</span>: <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><ul><li>  可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>  8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);<br>    <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V<br>    <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC<br>    <span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span><br>         <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">2</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">5</span>: goto          <span class="hljs-number">26</span><br>         <span class="hljs-attribute">8</span>: astore_<span class="hljs-number">2</span><br>         <span class="hljs-attribute">9</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-attribute">11</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">12</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-attribute">15</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">16</span>: bipush        <span class="hljs-number">40</span><br>        <span class="hljs-attribute">18</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">19</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-attribute">22</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">23</span>: bipush        <span class="hljs-number">50</span><br>        <span class="hljs-attribute">25</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">26</span>: return<br>      <span class="hljs-attribute">Exception</span> table:<br>         <span class="hljs-attribute">from</span>    to  target type<br>          <span class="hljs-attribute">2</span><span class="hljs-number">5</span><span class="hljs-number">8</span> Class java/lang/ArithmeticException<br>          <span class="hljs-attribute">2</span> <span class="hljs-number">5</span> <span class="hljs-number">15</span>  Class java/lang/NullPointerException<br>          <span class="hljs-attribute">2</span> <span class="hljs-number">5</span> <span class="hljs-number">22</span>  Class java/lang/Exception<br>          <span class="hljs-attribute">LineNumberTable</span>: ...<br>          <span class="hljs-attribute">LocalVariableTable</span>:<br>              <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature<br>                  <span class="hljs-attribute">9</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/ArithmeticException;<br>                 <span class="hljs-attribute">16</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/NullPointerException;<br>                 <span class="hljs-attribute">23</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>                  <span class="hljs-attribute">0</span>      <span class="hljs-number">27</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span><br><span class="hljs-meta">                  2      25     1     i   I</span><br><span class="hljs-meta">            StackMapTable: ...</span><br><span class="hljs-meta">          MethodParameters: ...</span><br></code></pre></td></tr></table></figure><ul><li>  因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong>，这样做可以节省栈帧内存。</li></ul><h5 id="multi-catch-的情况"><a href="#multi-catch-的情况" class="headerlink" title="multi-catch 的情况"></a><strong>multi-catch</strong> <strong>的情况</strong></h5><p>JDK1.7之后，允许同时catch多个异常类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>            test.invoke(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>&#125; <br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs class">public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=3, locals=2, args_size=1<br>         0: ldc           #2<br>         2: ldc           #3<br>         4: iconst_0<br>         5: anewarray     #4<br>         8: invokevirtual #5<br>        11: astore_1<br>        12: aload_1<br>        13: aconst_null<br>        14: iconst_0<br>        15: anewarray     #6<br>        18: invokevirtual #7<br>        21: pop<br>        22: goto          30<br>        25: astore_1<br>        26: aload_1<br>        27: invokevirtual #11 // e.printStackTrace:()V<br>        30: return<br>      Exception table:<br>         from    to  target type<br>           0    22    25Class java/lang/NoSuchMethodException<br>           0    22    25Class java/lang/IllegalAccessException<br>           0    22    25Class java/lang/reflect/InvocationTargetException<br>        LineNumberTable: ...<br>        LocalVariableTable:    <br>            Start  Length  Slot  Name   Signature<br>               12      10     1  test   Ljava/lang/reflect/Method;<br>               26       4     1     e   Ljava/lang/ReflectiveOperationException;<br>                0      31     0  args   [Ljava/lang/String;<br>          StackMapTable: ...<br>        MethodParameters: ...<br></code></pre></td></tr></table></figure><p><strong>这里异常对象和test对象共用一个局部变量槽位，JVM是非常智能的，他会统计最大需要多少局部变量槽位。</strong></p><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><strong>加上finally之后，由于finally块内代码没有被catch，故而JVM字节码会在finally代码块最后补上一个athrow</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_4</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          i = <span class="hljs-number">10</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          i = <span class="hljs-number">20</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          i = <span class="hljs-number">30</span>;<br>      &#125; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>   <span class="hljs-comment">//locals=4，说明有四个局部变量，但是下面的局部变量表只有3个，说明有一个没有名字的局部变量槽位</span><br><span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">// 0-&gt;i</span><br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">// try --------------------------------------</span><br>        <span class="hljs-number">4</span>: istore_1<span class="hljs-comment">// 10-&gt;i|</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span><span class="hljs-comment">// finally |</span><br>        <span class="hljs-number">7</span>: istore_1<span class="hljs-comment">// 30-&gt;i|</span><br>        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span><span class="hljs-comment">// return -----------------------------------</span><br>        <span class="hljs-number">11</span>: astore_2<span class="hljs-comment">// catch Exceptin -&gt; e ----------------------</span><br>        <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>    <span class="hljs-comment">//                                          |</span><br>        <span class="hljs-number">14</span>: istore_1<span class="hljs-comment">// 20-&gt;i|</span><br>        <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span><span class="hljs-comment">// finally|</span><br>        <span class="hljs-number">17</span>: istore_1            <span class="hljs-comment">// 30-&gt;i|</span><br>        <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span><span class="hljs-comment">// return -----------------------------------</span><br>        <span class="hljs-number">21</span>: astore_3<span class="hljs-comment">// catch any -&gt; slot 3 ---------------------- </span><br>        <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span><span class="hljs-comment">// finally|</span><br>        <span class="hljs-number">24</span>: istore_1<span class="hljs-comment">// 30-&gt;i |</span><br>        <span class="hljs-number">25</span>: aload_3<span class="hljs-comment">// &lt;- slot 3 |</span><br>        <span class="hljs-number">26</span>: athrow<span class="hljs-comment">// throw ------------------------------------</span><br>        <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>      Exception table:<br>         from    to  target type<br>            <span class="hljs-number">2</span>   <span class="hljs-number">5</span> <span class="hljs-number">11</span>  Class java/lang/Exception<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>any <span class="hljs-comment">// 剩余的异常类型，比如 Error</span><br>            <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>any <span class="hljs-comment">// 剩余的异常类型，比如 Error</span><br>      LineNumberTable: ...<br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>             <span class="hljs-number">12</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>              <span class="hljs-number">0</span>      <span class="hljs-number">28</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>              <span class="hljs-number">2</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I<br>        StackMapTable: ...<br>      MethodParameters: ...<br></code></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程。</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><p>下面代码，输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_12_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = test();<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>; <br>        &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()I<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush<span class="hljs-number">10</span> <span class="hljs-comment">// &lt;- 10 放入栈顶</span><br>        <span class="hljs-number">2</span>: istore_0<span class="hljs-comment">// 10 -&gt; slot 0 (从栈顶移除了)</span><br>        <span class="hljs-number">3</span>: bipush<span class="hljs-number">20</span> <span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">5</span>: ireturn<span class="hljs-comment">// 返回栈顶 int(20)</span><br>        <span class="hljs-number">6</span>: astore_1<span class="hljs-comment">// catch any -&gt; slot 1 </span><br>        <span class="hljs-number">7</span>: bipush<span class="hljs-number">20</span><span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">// 返回栈顶 int(20)</span><br>        Exception table:<br>           from    to  target type<br>               <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   any<br>        LineNumberTable: ...<br>        StackMapTable: ...<br></code></pre></td></tr></table></figure><ul><li>  由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>  至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>  跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong>。<strong>catch 匹配到any，在throw之前return了，所以不会throw异常</strong></li><li>  所以<strong>一定不要在finally中进行返回操作，否则会吞掉异常</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常。</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><p>下面代码输出10，因为在执行finally代码块之前，JVM已经把返回值暂存到特定临时变量槽中了，所以后面对i进行赋值，并不会影响返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = Demo4.test();<br>System.out.println(i);  <span class="hljs-comment">//10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()I<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush<span class="hljs-number">10</span> <span class="hljs-comment">// &lt;- 10 放入栈顶</span><br>        <span class="hljs-number">2</span>: istore_0<span class="hljs-comment">// 10-&gt;i</span><br>        <span class="hljs-number">3</span>: iload_0<span class="hljs-comment">// &lt;- i(10)</span><br>        <span class="hljs-number">4</span>: istore_1<span class="hljs-comment">// 10 -&gt; slot 1，暂存至 slot 1，目的是为了固定返回值 </span><br>        <span class="hljs-number">5</span>: bipush<span class="hljs-number">20</span><span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>        <span class="hljs-number">7</span>: istore_0<span class="hljs-comment">// 20-&gt;i</span><br>        <span class="hljs-number">8</span>: iload_1<span class="hljs-comment">// &lt;- slot 1(10) 载入 slot 1 暂存的值</span><br>        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">// 返回栈顶的 int(10)</span><br>        <span class="hljs-number">10</span>: astore_2<br>        <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">13</span>: istore_0<br>        <span class="hljs-number">14</span>: aload_2<br>        <span class="hljs-number">15</span>: athrow<br>        Exception table:<br>           from    to  target type<br>               <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br>        LineNumberTable: ...<br>        LocalVariableTable:<br>          Start  Length  Slot  Name   Signature<br>        <span class="hljs-number">3</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> i I<br>          StackMapTable: ...<br></code></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_13</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object lock = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span><span class="hljs-comment">// new Object</span><br>         <span class="hljs-number">3</span>: dup<span class="hljs-comment">// 复制一份Object实例对象的引用，因为下面一个实例对象的引用要去调用构造方法，另一份要加锁。</span><br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span><span class="hljs-comment">// invokespecial &lt;init&gt;:()V</span><br>         <span class="hljs-number">7</span>: astore_1<span class="hljs-comment">// lock引用 -&gt; lock</span><br>        <span class="hljs-number">8</span>: aload_1<span class="hljs-comment">// &lt;- lock (synchronized开始)</span><br>         <span class="hljs-number">9</span>: dup<span class="hljs-comment">// 复制一份Object实例对象的引用，因为下面monitorenter,monitorexit要各消耗一个Object实例对象引用</span><br>        <span class="hljs-number">10</span>: astore_2<span class="hljs-comment">// lock引用 -&gt; slot 2</span><br>        <span class="hljs-number">11</span>: monitorenter<span class="hljs-comment">// monitorenter(lock引用)，即加锁</span><br>        <span class="hljs-number">12</span>: getstatic#<span class="hljs-number">3</span><span class="hljs-comment">// &lt;- System.out</span><br>        <span class="hljs-number">15</span>: ldc#<span class="hljs-number">4</span><span class="hljs-comment">// &lt;- &quot;ok&quot;</span><br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span><span class="hljs-comment">// invokevirtual println: (Ljava/lang/String;)V</span><br>        <span class="hljs-number">20</span>: aload_2<span class="hljs-comment">// &lt;- slot 2(lock引用)</span><br>        <span class="hljs-number">21</span>: monitorexit<span class="hljs-comment">// monitorexit(lock引用)，即正常解锁代码块</span><br>        <span class="hljs-number">22</span>: goto<span class="hljs-number">30</span><br>        <span class="hljs-number">25</span>: astore_3<span class="hljs-comment">// any -&gt; slot 3</span><br>        <span class="hljs-number">26</span>: aload_2<span class="hljs-comment">// &lt;- slot 2(lock引用)</span><br>        <span class="hljs-number">27</span>: monitorexit<span class="hljs-comment">// monitorexit(lock引用)，即异常解锁代码块</span><br>        <span class="hljs-number">28</span>: aload_3<br>        <span class="hljs-number">29</span>: athrow<br>        <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>            Exception table:<br>               from    to  target type<br>            <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">25</span>   any      <span class="hljs-comment">// synchronized代码块和正常解锁代码块出现异常，直接跳转到异常解锁代码块。</span><br>                <span class="hljs-number">25</span>    <span class="hljs-number">28</span>  <span class="hljs-number">25</span>    any   <span class="hljs-comment">// 异常解锁代码块出现异常，直接跳转到异常解锁代码块。</span><br>            LineNumberTable: ...<br>          LocalVariableTable:<br>            Start  Length  Slot  Name   Signature<br>                <span class="hljs-number">0</span>      <span class="hljs-number">31</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>                <span class="hljs-number">8</span>      <span class="hljs-number">23</span>     <span class="hljs-number">1</span>  lock   Ljava/lang/Object;<br>              StackMapTable: ...<br>            MethodParameters: ...<br></code></pre></td></tr></table></figure><p><strong>为了保证，程序一定能够解锁成功，JVM加上了异常处理机制。</strong></p><blockquote><p>注意：</p><p>方法级别的 synchronized 不会在字节码指令中有所体现。</p></blockquote><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 _.java 源码编译为 _.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。并不是编译器还会转换出中间的 java 源码，这只是将字节码文件反编译成java文件便于阅读，java编译器转换的结果直接就是 class 字节码。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-keyword">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱。</p><p>在JDK 5以后，它们的转换可以在编译期自动完成，代码片段1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在 JDK5之前是无法编译通过的，必须改写为代码片段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型)，因此这些转换的事情在了JDK5以后都由编译器在编译阶段完成。即代码片段1都会在编译阶段被转换为代码片段2</p><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即有一些泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理（有一些泛型信息不会被擦除）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是 list.add(Objcet o)</span><br>      Integer x = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是Object x = get(int index)   </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">11</span>: invokestatic  #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Object o)</span><br>      <span class="hljs-number">14</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(int index)   </span><br>      <span class="hljs-number">22</span>: invokeinterface #<span class="hljs-number">6</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span><br>      <span class="hljs-number">27</span>: checkcast     #<span class="hljs-number">7</span>                  <span class="hljs-comment">// class java/lang/Integer</span><br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br>          <br>    LineNumberTable:<br>      line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">9</span>: <span class="hljs-number">8</span><br>      line <span class="hljs-number">10</span>: <span class="hljs-number">20</span><br>      line <span class="hljs-number">11</span>: <span class="hljs-number">31</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>      <span class="hljs-number">0</span>      <span class="hljs-number">32</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>      <span class="hljs-number">8</span>      <span class="hljs-number">24</span>     <span class="hljs-number">1</span>  list   Ljava/util/List;<br>    LocalVariableTypeTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">8</span>      <span class="hljs-number">24</span>     <span class="hljs-number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;<br></code></pre></td></tr></table></figure><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需要将 Object 转为 Integer</span><br>Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>如果前面的x变量类型修改为int基本类型那么最终生成的字节码是： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer， 并执行拆箱操作</span><br><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure><p>还好这些麻烦事都不用自己做。</p><p><strong>擦除的是字节码上的（即方法体内的）泛型信息，可以看到 LocalVariableTypeTable（局部变量类型表） 仍然保留了局部变量的泛型的信息，但是无法通过反射得到这些局部变量的泛型信息。只能通过反射得到方法的参数和返回值的泛型信息。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Method test = Candy3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);<br>Type[] types = test.getGenericParameterTypes();<br><span class="hljs-keyword">for</span> (Type type : types) &#123;<br><span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>ParameterizedType parameterizedType = (ParameterizedType) type; <br>        System.out.println(<span class="hljs-string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType()); <br>        Type[] arguments = parameterizedType.getActualTypeArguments(); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>    System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]); <br>        &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span> </span><br><span class="hljs-class">   泛型参数[0] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span> </span><br><span class="hljs-class">   原始类型 - <span class="hljs-title">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Map</span> </span><br><span class="hljs-class">   泛型参数[0] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Integer</span> </span><br><span class="hljs-class">   泛型参数[1] - <span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数也是JDK5开始加入的新特性：</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。</p><p>同样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null。</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>仍是JDK5开始引入的语法糖，数组的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;   <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为最朴素的for循环遍历数组下标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br><span class="hljs-keyword">int</span> x = arr[i];<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意 </p><p>foreach 循环写法，能够配合数组，以及所有实现了 Iterable接口的集合类一起使用，其中 Iterable()方法 用 来获取集合的迭代(Iterator)</p></blockquote><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><p>从JDK7开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 注意 </p><p>switch配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚</p></blockquote><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>  字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>  使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>  第二个用来根据x的值来决定输出语句</li></ul></li></ul><p>可以看到，执行了两遍 switch， 第一遍是根据字符串的hashCode和 equals将字符串的转换为相应 byte类 型，第二遍才是利用byte执行进行比较。 </p><p>为什么第一遍时必须既比较 hashCode， 又利用 equals 比较呢？ hashCode是为了提高效率，减少可能的比 较；而 equals 是为了防止 hashCode冲突，例如<code>BM</code>和<code>c.</code>这两个字符串的hashCode值都是 2123，如果有如下 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (str) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BM&quot;</span>: &#123;<br>                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C.&quot;</span>: &#123;<br>                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译器转换为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy6_2</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span> x = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span>(str.hashCode()) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2123</span>: <span class="hljs-comment">// hashCode 值可能相同，需要进一步用 equals 比较</span><br>            <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;C.&quot;</span>)) &#123;<br>                x = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;BM&quot;</span>)) &#123;<br>                x = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">switch</span>(x) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><p>switch 枚举的例子，原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）,是一个静态内部类，程序员不可见，JVM仅可见   </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>JDK7新增了枚举类，以前面的性别枚举为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> <br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><strong>try-with-resources</strong></h4><p>JDK7开始新增了对需要关闭的资源处理的特殊语法<code> try-with-resources</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象)&#123;<br>    <br>&#125; <span class="hljs-keyword">catch</span>( ) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>其中资源对象需要实现 <code>AutoCloseable</code>接口,例如<code> Inputstream</code>、 <code>Outputstream</code>、<code> Connection</code>、<code> Statement</code>、<code>ResultSet </code>等接口都实现了<code>AutoCloseable</code>,使用 <code>try-with-resources</code> 可以不用写<code>finally</code> 语句块,编译器会帮助生成关闭资源代码,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>)) &#123;<br>            System.out.println(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            Throwable t = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(is);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>                <span class="hljs-comment">// t 是我们代码出现的异常 </span><br>                t = e1;<br>                <span class="hljs-keyword">throw</span> e1;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 判断了资源不为空 </span><br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果我们代码有异常 </span><br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            is.close();<br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;<br>                        <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加 </span><br>                            t.addSuppressed(e2);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span><br>                is.close();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM会将要抛出的异常的对象的引用存放到一个局部变量里，并将该变量存到方法栈的栈顶等待弹出，此时程序计数器指针指向finally内的代码，遇到下一个要抛出的异常，该异常则顶替先前异常对象引用所在位置，所以程序只会输出finally内的异常。</p><p>为什么要设计一个 <code>addsuppressed(Throwab1e e)</code>(添加被压制异常)的方法呢?是为了防止异常信息的丢失（想想 try-with-resources 生成的fianlly 中如果抛出了异常):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;close 异常&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br>at test.Test6.main(Test6.java:<span class="hljs-number">7</span>) <br>    Suppressed: java.lang.Exception: close 异常<br>        at test.MyResource.close(Test6.java:<span class="hljs-number">18</span>)<br>        at test.Test6.main(Test6.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>如以上代码所示，两个异常信息都不会丢。</p><h4 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a><strong>方法重写时的桥接方法</strong></h4><p>我们都知道，方法重写时对返回值分两种情况:</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类(比较绕口，见下面的例子)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于子类，java 编译器会做如下处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>    &#125;<br><span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 调用 public Integer m()</span><br><span class="hljs-keyword">return</span> m(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中桥接方法（合成方法）比较特殊，仅对 java 虚拟机可见，合成方法允许方法同名且参数一致，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Method m : B.class.getDeclaredMethods()) &#123;<br>    System.out.println(m);<br>&#125;<br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer test.candy.B.m()<br><span class="hljs-keyword">public</span> java.lang.Number test.candy.B.m()<br></code></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;   <span class="hljs-comment">//虽然不是final变量，但是代码未对其进行修改，是实际上的final变量</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val$x;<br>    Candy11$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>.val$x = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-keyword">this</span>.val$x);<br>&#125; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的或者实际上的final不变量:因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化。</p><p>从内部类引用的本地变量必须是最终变量或实际上的最终变量。</p></blockquote><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><p>关于在什么时候启动类加载阶段的第一个阶段“加载”，《Java虚拟机规范》中没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul><li>  _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用。因为C++的instanceKlass不能直接被Java访问，但是.class和instanceKlass互相有各自的地址，这个类镜像起到一个桥梁的作用。</li><li>  _super 即父类</li><li>  _ﬁelds 即成员变量</li><li>  _methods 即方法</li><li>  _constants 即常量池</li><li>  _class_loader 即类加载器</li><li>  _vtable 虚方法表</li><li>  _itable 接口方法</li></ul></li><li>  如果这个类还有父类没有加载，<strong>先加载父类</strong></li><li>  加载和链接可能是<strong>交替运行</strong>的</li></ul><blockquote><p>注意 </p><ul><li>instanceKlass 这样的【元数据】是存储在方法区(1.8后的元空间内)，但java_mirror是存储在堆中 </li><li>可以通过前面介绍的 HSDB 工具查看</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611205050.png"></p><ul><li>  instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>  _java_mirror则是保存在<strong>堆内存</strong>中，*.class是一个对象，该对象是在加载instanceKlass的同时生成的，放在堆内存中。</li><li>  InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>  类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><p>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld<br>Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="hljs-number">3405691578</span> in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">file</span> <span class="hljs-title">cn</span>/<span class="hljs-title">itcast</span>/<span class="hljs-title">jvm</span>/<span class="hljs-title">t5</span>/<span class="hljs-title">HelloWorld</span></span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">defineClass1</span>(<span class="hljs-title">Native</span> <span class="hljs-title">Method</span>)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:763)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">security</span>.<span class="hljs-title">SecureClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">SecureClassLoader</span>.<span class="hljs-title">java</span>:142)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">defineClass</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:467)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">access</span>$100(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:73)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>$1.<span class="hljs-title">run</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:368)</span><br><span class="hljs-class">    <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>$1.<span class="hljs-title">run</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:362)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">security</span>.<span class="hljs-title">AccessController</span>.<span class="hljs-title">doPrivileged</span>(<span class="hljs-title">Native</span> <span class="hljs-title">Method</span>)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">net</span>.<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">findClass</span>(<span class="hljs-title">URLClassLoader</span>.<span class="hljs-title">java</span>:361)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:424)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">sun</span>.<span class="hljs-title">misc</span>.<span class="hljs-title">Launcher</span>$<span class="hljs-title">AppClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">Launcher</span>.<span class="hljs-title">java</span>:331)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">loadClass</span>(<span class="hljs-title">ClassLoader</span>.<span class="hljs-title">java</span>:357)</span><br><span class="hljs-class">        <span class="hljs-title">at</span> <span class="hljs-title">sun</span>.<span class="hljs-title">launcher</span>.<span class="hljs-title">LauncherHelper</span>.<span class="hljs-title">checkAndLoadMain</span>(<span class="hljs-title">LauncherHelper</span>.<span class="hljs-title">java</span>:495)</span><br></code></pre></td></tr></table></figure><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>  static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>  static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成。</li><li>  如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>  如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li><li>  对于String和基本数据类型来说，如果字面量的方式赋值，且static final修饰的话，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行。如果是new出来的，则是在初始化阶段<clinit>()中赋值的情况： 排除上述的在准备环节赋值的。</li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中的符号引用解析为直接引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 解析的含义 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException,IOException </span>&#123;<br>ClassLoader classloader = Load2.class.getClassLoader();<br><span class="hljs-comment">// loadClass 方法不会导致类的解析和初始化，只会导致加载阶段进行。</span><br>Class&lt;?&gt; c = classloader.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.C&quot;</span>);<br><span class="hljs-comment">// new C(); 会触发类的加载，链接-解析，初始化。</span><br>        <br>        System.in.read();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HSDB的使用</strong></p><ul><li>  先获得要查看的进程ID</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></td></tr></table></figure><ul><li>  打开HSDB</li></ul><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -cp F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>a-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure><ul><li>  运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611221703.png"></p><ul><li>  定位需要的进程</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611221857.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611222029.png"></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>  未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      ClassLoader loader = Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打开HSDB<ul><li>  可以看到此时只加载了类C</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611223153.png"></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611230658.png"></p><ul><li>解析以后，会将常量池中的符号引用解析为直接引用<ul><li>  可以看到，此时已加载并解析了类C和类D</li></ul>  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200611223441.png"></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200613104723.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化即调用 <strong>cinit()V</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>  main 方法所在的类，总会被首先初始化</li><li>  首次访问这个类的静态变量或静态方法时</li><li>  子类初始化，如果父类还没初始化，会先引发父类初始化</li><li>  子类访问父类的静态变量，只会触发父类的初始化</li><li>  Class.forName</li><li>  new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>  访问类的 .static ﬁnal 静态常量（基本类型和字符串）不会触发初始化</li><li>  类对象.class 不会触发初始化</li><li>  创建该类对象的数组不会触发初始化</li><li>  类加载器的.loadClass方法</li><li>  Class.forNamed的参数2为false时</li></ul><p>实验如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证(实验时请先全部注释，每次只执行其中一个)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load3</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123; <br>        <span class="hljs-comment">// 1. 静态常量(基本类型和字符串)不会触发初始化</span><br>        System.out.println(B.b);<br>        <span class="hljs-comment">// 2. 类对象.class 不会触发初始化</span><br>        System.out.println(B.class);<br>        <span class="hljs-comment">// 3. 创建该类的数组不会触发初始化</span><br>        System.out.println(<span class="hljs-keyword">new</span> B[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span><br>        ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>        cl.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>);<br>        <span class="hljs-comment">// 5. 不会初始化类 B，但会加载 B、A</span><br>        ClassLoader c2 = Thread.currentThread().getContextClassLoader(); <br>        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>, <span class="hljs-keyword">false</span>, c2);<br>        <br>        <span class="hljs-comment">// 1. 首次访问这个类的静态变量或静态方法时 </span><br>        System.out.println(A.a);<br>        <span class="hljs-comment">// 2. 子类初始化，如果父类还没初始化，会引发 </span><br>        System.out.println(B.c);<br>        <span class="hljs-comment">// 3. 子类访问父类静态变量，只触发父类初始化 </span><br>        System.out.println(B.a);<br>        <span class="hljs-comment">// 4. 会初始化类 B，并先初始化类 A </span><br>        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.B&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><p><strong>需要特别注意的是，</strong>针对<strong>访问类的 static final静态常量（基本类型和字符串）</strong>是不是会触发初始化，要分两种情况：static final静态常量只能在定义时或者静态代码块中初始化：</p><p><strong>定义时</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jyg.reflection.classload_;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoad02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(A.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">//        num = 2;</span><br>        System.out.println(<span class="hljs-string">&quot;static &#123;&#125; runing&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2<br></code></pre></td></tr></table></figure><p><strong>静态代码块中</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jyg.reflection.classload_;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoad02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(A.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;static &#123;&#125; running&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">static &#123;&#125; running<br>2<br></code></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(E.a); <span class="hljs-comment">//不会</span><br>        System.out.println(E.b); <span class="hljs-comment">//不会</span><br>        System.out.println(E.c); <span class="hljs-comment">//会</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>典型应用 - 完成懒惰初始化单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; <br>        <br>    &#125;<br><span class="hljs-comment">// 内部类中保存单例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><span class="hljs-comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是:</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的（类的加载是线程安全的，有加锁的，你可以看源码）</li></ul><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>因为它是C++代码，不允许Java直接访问</td><td>null</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap</td><td>ExtensionClassLoader</td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td><td>ApplicationClassLoader</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td><td></td></tr></tbody></table><p>每次要加载一个类时，会逐级向上委派，如果上级类加载器<code>已经加载过该类</code>或者<code>上级目录中有该类，上级会加载该类</code>，此时下级不会加载该类，即便下级类加载器路径下有该类。如果上级类加载器<code>已经没有加载过该类</code>并且<code>上级目录中没有该类，上级无法加载该类</code>，此时下级类加载器路径下有该类，下级才会加载该类。</p><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p><code>Bootstrap</code>类加载器一般加载<code>JAVA\_HOME/jre/lib</code>目录下的类，也可以通过JVM虚拟机参数，把自己写的类交由<code>Bootstrap</code>类加载器来加载。</p><p>用 Bootstrap 类加载器加载类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;bootstrap F init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.F&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5_1<br>bootstrap F init<br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><ul><li><p><code>-Xbootclasspath</code> 表示设置 <code>bootclasspath</code></p></li><li><p>其中 <code>/a:.</code>表示将后面的参数目录追加至 <code>bootclasspath</code> 之后 </p></li><li><p>可以用这个办法替换核心类</p><ul><li><p><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code> </p><p><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code><br><code> java -Xbootclasspath/p:&lt;追加路径&gt;</code></p></li></ul></li></ul><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;classpath G init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.G&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">classpath G init<br>sun.misc.Launcher$AppClassLoader@18b4aac2<br></code></pre></td></tr></table></figure><p>写一个同名的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ext G init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打个 jar 包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class<br>已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = <span class="hljs-number">481</span>) (输出 = <span class="hljs-number">322</span>)(压缩了 <span class="hljs-number">33</span>%)<br></code></pre></td></tr></table></figure><p>将 jar 包拷贝到 <code>JAVA_HOME/jre/lib/ext </code></p><p>重新执行，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ext G init<br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><blockquote><p><strong>注意</strong></p><p>这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p></blockquote><p>loadClass源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// // 1. 检查该类是否已经加载，即查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 2. 有上级的话，委派上级 loadClass</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 3. 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader，其实BootstrapClassLoader就是null</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 4. 如果上级类加载器每一层找不到，调用当前类加载器的 findClass 方法在当前类加载器的指定目录下来加载</span><br>                <span class="hljs-comment">// 如果还是没有找到该类，由当前类加载器的 findClass方法抛出ClassNotFoundException异常</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 5. 记录耗时</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader()<br>            .loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.H&quot;</span>);<br>        System.out.println(aClass.getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程为:</p><ol><li><code>sun.misc.Launcher$AppClassLoader </code>//1 处， 开始查看已加载的类，结果没有</li><li><code>sun.misc.Launcher$AppClassLoader</code> // 2 处，委派上级<code>sun.misc.Launcher$ExtClassLoader.loadClass()</code></li><li><code>sun.misc.Launcher$ExtClassLoader</code> // 1 处，查看已加载的类，结果没有</li><li><code>sun.misc.Launcher$ExtClassLoader</code> // 3 处，没有上级了，则委派 <code>BootstrapClassLoader</code>查找</li><li><code>BootstrapClassLoader</code> 是在 <code>JAVA_HOME/jre/lib</code> 下找 <code>H </code>这个类，显然没有</li><li><code>sun.misc.Launcher$ExtClassLoader</code> // 4 处，调用自己的<code>findClass</code>方法，是在<code>JAVA_HOME/jre/lib/ext</code> 下找<code>H</code>这个类，显然没有，回到 <code>sun.misc.Launcher$AppClassLoader</code>的 // 2 处</li><li>继续执行到 <code>sun.misc.Launcher$AppClassLoader </code>// 4 处，调用它自己的 findClass 方法，在<code>classpath</code> 下查找，找到了</li></ol><h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a><strong>线程上下文类加载器</strong></h4><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)<br></code></pre></td></tr></table></figure><p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的，你知道是怎么做的吗?</p><p>让我们追踪一下源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>&#123;<br><span class="hljs-comment">// 注册驱动的集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers<br>        = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br><span class="hljs-comment">// 初始化驱动 </span><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>先不看别的，看看 DriverManager 的类加载器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(DriverManager.class.getClassLoader()); <span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure><p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢?</p><p>继续看 loadInitialDrivers() 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>        String drivers;<br>        <span class="hljs-keyword">try</span> &#123;<br>            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-function">PrivilegedAction&lt;String&gt;</span><br><span class="hljs-function">                <span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>                &#125;<br>&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            drivers = <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-comment">// 1)使用 ServiceLoader 机制加载驱动，即 SPI </span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                        driversIterator.next();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                    <span class="hljs-comment">// Do nothing</span><br>                &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;);<br>        println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><span class="hljs-comment">// 2)使用 jdbc.drivers 定义的驱动名加载驱动</span><br><span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>        <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>                <span class="hljs-comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 </span><br>                <span class="hljs-comment">// DriverManager的类加载器是BootstrapClassLoader,这里却使用的是应用程序类加载器，打破了JVM的双亲委派机制</span><br>                Class.forName(aDriver, <span class="hljs-keyword">true</span>, ClassLoader.getSystemClassLoader());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看 2)发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载</p><p>再看 1)它就是大名鼎鼎的 Service Provider Interface (SPI)，主要是为了解耦<br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名命名文件，文件内容是实现类名称</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230330191157300.png"></p><p>这样就可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); <br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br>    iter.next();<br>&#125;<br></code></pre></td></tr></table></figure><p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想:</p><ul><li>JDBC</li><li>Servlet 初始化器</li><li>Spring 容器</li><li>Dubbo(对 SPI 进行了扩展)</li></ul><p>接着看 ServiceLoader.load 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br><span class="hljs-comment">// 获取线程上下文类加载器</span><br>ClassLoader cl = Thread.currentThread().getContextClassLoader(); <br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></td></tr></table></figure><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;<br>        fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;<br>        fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>    &#125; <span class="hljs-keyword">try</span> &#123;<br>            S p = service.cast(c.newInstance());<br>            providers.put(cn, p);<br>            <span class="hljs-keyword">return</span> p;<br>     &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>, x);<br>    &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();          <span class="hljs-comment">// This cannot happen</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>小结：</p><ul><li>1、在jre/lib包下有一个DriverManager，是BootstrapClassLoader加载的，但是jdbc的驱动是各个厂商来实现的不在启动类加载路径下，启动类无法加载，而驱动管理需要用到这些驱动。</li><li>2、只能打破双亲委派，启动类直接请求系统类加载器去classpath下加载驱动（正常是向上委托，这个反过来了），而打破双亲委派的就是这个线程上下文类加载器</li><li>3、过程就是：启动类加载器加载DriverManager，DriverManager代码里调用了线程上下文类加载器，这个加载器默认就是使用应用程序类加载器加载类，通过应用程序类加载器加载jdbc驱动</li></ul><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>  想加载非 classpath 随意路径中的类文件</li><li>  通过接口来使用实现，希望解耦时，常用在框架设计</li><li>  这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>  继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>  不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>  读取类文件的字节码</li><li>  调用父类的 deﬁneClass 方法来加载类</li><li>  使用者调用该类加载器的 loadClass 方法</li></ul><p>示例:<br> 准备好一个字节码（<code>MapImpl1.class</code>）文件放入 E:\myclasspath，它实现了 java.util.Map 接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c1 = classLoader.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        Class&lt;?&gt; c2 = classLoader.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        System.out.println(c1 == c2); <span class="hljs-comment">//true</span><br><br>        MyClassLoader classLoader2 = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c3 = classLoader2.loadClass(<span class="hljs-string">&quot;MapImpl1&quot;</span>);<br>        System.out.println(c1 == c3); <span class="hljs-comment">//false  </span><br><br>        c1.newInstance();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        String path = <span class="hljs-string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            Files.copy(Paths.get(path), os);<br><br>            <span class="hljs-comment">// 得到字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = os.toByteArray();<br><br>            <span class="hljs-comment">// byte[] -&gt; *.class</span><br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(<span class="hljs-string">&quot;类文件未找到&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两个Class对象是否完全相同，要比较包名+类名+类加载器对象。三者完全相同，两个Class对象才相同。</strong></p><p><strong>自定义的类加载器，在调用构造方法时，会调用继承的<code>ClassLoader</code>的有参构造器，会将线程上下文类加载器（ApplicationClassLoader）放入当前类加载器对象的上级字段中，所以自定义类加载器的上级是ApplicationClassLoader</strong></p><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p><strong>分层编译</strong></p><p>(TieredCompilation) 先来个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.jit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT1</span> </span>&#123;<br><br>    <span class="hljs-comment">// -XX:+PrintCompilation -XX:-DoEscapeAnalysis</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                <span class="hljs-keyword">new</span> Object();<br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.printf(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,i,(end - start));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>   <span class="hljs-number">96426</span><br><span class="hljs-number">1</span>   <span class="hljs-number">52907</span><br><span class="hljs-number">2</span>   <span class="hljs-number">44800</span><br><span class="hljs-number">3</span>   <span class="hljs-number">119040</span><br><span class="hljs-number">4</span>   <span class="hljs-number">65280</span><br><span class="hljs-number">5</span>   <span class="hljs-number">47360</span><br><span class="hljs-number">6</span>   <span class="hljs-number">45226</span><br><span class="hljs-number">7</span>   <span class="hljs-number">47786</span><br><span class="hljs-number">8</span>   <span class="hljs-number">48640</span><br><span class="hljs-number">9</span>   <span class="hljs-number">60586</span><br><span class="hljs-number">10</span>  <span class="hljs-number">42667</span><br><span class="hljs-number">11</span>  <span class="hljs-number">48640</span><br><span class="hljs-number">12</span>  <span class="hljs-number">70400</span><br><span class="hljs-number">13</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">14</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">15</span>  <span class="hljs-number">45227</span><br><span class="hljs-number">16</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">17</span>  <span class="hljs-number">60160</span><br><span class="hljs-number">18</span>  <span class="hljs-number">58880</span><br><span class="hljs-number">19</span>  <span class="hljs-number">46080</span><br><span class="hljs-number">20</span>  <span class="hljs-number">47787</span><br><span class="hljs-number">21</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">22</span>  <span class="hljs-number">54187</span><br><span class="hljs-number">23</span>  <span class="hljs-number">57173</span><br><span class="hljs-number">24</span>  <span class="hljs-number">50346</span><br><span class="hljs-number">25</span>  <span class="hljs-number">52906</span><br><span class="hljs-number">26</span>  <span class="hljs-number">50346</span><br><span class="hljs-number">27</span>  <span class="hljs-number">47786</span><br><span class="hljs-number">28</span>  <span class="hljs-number">49920</span><br><span class="hljs-number">29</span>  <span class="hljs-number">64000</span><br><span class="hljs-number">30</span>  <span class="hljs-number">49067</span><br><span class="hljs-number">31</span>  <span class="hljs-number">63574</span><br><span class="hljs-number">32</span>  <span class="hljs-number">63147</span><br><span class="hljs-number">33</span>  <span class="hljs-number">56746</span><br><span class="hljs-number">34</span>  <span class="hljs-number">49494</span><br><span class="hljs-number">35</span>  <span class="hljs-number">64853</span><br><span class="hljs-number">36</span>  <span class="hljs-number">107520</span><br><span class="hljs-number">37</span>  <span class="hljs-number">46933</span><br><span class="hljs-number">38</span>  <span class="hljs-number">51627</span><br><span class="hljs-number">39</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">40</span>  <span class="hljs-number">103680</span><br><span class="hljs-number">41</span>  <span class="hljs-number">51626</span><br><span class="hljs-number">42</span>  <span class="hljs-number">60160</span><br><span class="hljs-number">43</span>  <span class="hljs-number">49067</span><br><span class="hljs-number">44</span>  <span class="hljs-number">45653</span><br><span class="hljs-number">45</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">46</span>  <span class="hljs-number">51626</span><br><span class="hljs-number">47</span>  <span class="hljs-number">49066</span><br><span class="hljs-number">48</span>  <span class="hljs-number">47360</span><br><span class="hljs-number">49</span>  <span class="hljs-number">50774</span><br><span class="hljs-number">50</span>  <span class="hljs-number">70827</span><br><span class="hljs-number">51</span>  <span class="hljs-number">64000</span><br><span class="hljs-number">52</span>  <span class="hljs-number">72107</span><br><span class="hljs-number">53</span>  <span class="hljs-number">49066</span><br><span class="hljs-number">54</span>  <span class="hljs-number">46080</span><br><span class="hljs-number">55</span>  <span class="hljs-number">44800</span><br><span class="hljs-number">56</span>  <span class="hljs-number">46507</span><br><span class="hljs-number">57</span>  <span class="hljs-number">73813</span><br><span class="hljs-number">58</span>  <span class="hljs-number">61013</span><br><span class="hljs-number">59</span>  <span class="hljs-number">57600</span><br><span class="hljs-number">60</span>  <span class="hljs-number">83200</span><br><span class="hljs-number">61</span>  <span class="hljs-number">7024204</span><br><span class="hljs-number">62</span>  <span class="hljs-number">49493</span><br><span class="hljs-number">63</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">64</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">65</span>  <span class="hljs-number">20053</span><br><span class="hljs-number">66</span>  <span class="hljs-number">20906</span><br><span class="hljs-number">67</span>  <span class="hljs-number">20907</span><br><span class="hljs-number">68</span>  <span class="hljs-number">21333</span><br><span class="hljs-number">69</span>  <span class="hljs-number">22187</span><br><span class="hljs-number">70</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">71</span>  <span class="hljs-number">21760</span><br><span class="hljs-number">72</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">73</span>  <span class="hljs-number">15360</span><br><span class="hljs-number">74</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">75</span>  <span class="hljs-number">19627</span><br><span class="hljs-number">76</span>  <span class="hljs-number">17067</span><br><span class="hljs-number">77</span>  <span class="hljs-number">34134</span><br><span class="hljs-number">78</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">79</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">80</span>  <span class="hljs-number">17493</span><br><span class="hljs-number">81</span>  <span class="hljs-number">15360</span><br><span class="hljs-number">82</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">83</span>  <span class="hljs-number">17067</span><br><span class="hljs-number">84</span>  <span class="hljs-number">21760</span><br><span class="hljs-number">85</span>  <span class="hljs-number">23467</span><br><span class="hljs-number">86</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">87</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">88</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">89</span>  <span class="hljs-number">18773</span><br><span class="hljs-number">90</span>  <span class="hljs-number">19200</span><br><span class="hljs-number">91</span>  <span class="hljs-number">20053</span><br><span class="hljs-number">92</span>  <span class="hljs-number">18347</span><br><span class="hljs-number">93</span>  <span class="hljs-number">22187</span><br><span class="hljs-number">94</span>  <span class="hljs-number">17920</span><br><span class="hljs-number">95</span>  <span class="hljs-number">18774</span><br><span class="hljs-number">96</span>  <span class="hljs-number">19626</span><br><span class="hljs-number">97</span>  <span class="hljs-number">33280</span><br><span class="hljs-number">98</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">99</span>  <span class="hljs-number">20480</span><br><span class="hljs-number">100</span> <span class="hljs-number">18773</span><br><span class="hljs-number">101</span> <span class="hljs-number">47786</span><br><span class="hljs-number">102</span> <span class="hljs-number">17493</span><br><span class="hljs-number">103</span> <span class="hljs-number">22614</span><br><span class="hljs-number">104</span> <span class="hljs-number">64427</span><br><span class="hljs-number">105</span> <span class="hljs-number">18347</span><br><span class="hljs-number">106</span> <span class="hljs-number">19200</span><br><span class="hljs-number">107</span> <span class="hljs-number">26027</span><br><span class="hljs-number">108</span> <span class="hljs-number">21333</span><br><span class="hljs-number">109</span> <span class="hljs-number">20480</span><br><span class="hljs-number">110</span> <span class="hljs-number">24747</span><br><span class="hljs-number">111</span> <span class="hljs-number">32426</span><br><span class="hljs-number">112</span> <span class="hljs-number">21333</span><br><span class="hljs-number">113</span> <span class="hljs-number">17920</span><br><span class="hljs-number">114</span> <span class="hljs-number">17920</span><br><span class="hljs-number">115</span> <span class="hljs-number">19200</span><br><span class="hljs-number">116</span> <span class="hljs-number">18346</span><br><span class="hljs-number">117</span> <span class="hljs-number">15360</span><br><span class="hljs-number">118</span> <span class="hljs-number">24320</span><br><span class="hljs-number">119</span> <span class="hljs-number">19200</span><br><span class="hljs-number">120</span> <span class="hljs-number">20053</span><br><span class="hljs-number">121</span> <span class="hljs-number">17920</span><br><span class="hljs-number">122</span> <span class="hljs-number">18773</span><br><span class="hljs-number">123</span> <span class="hljs-number">20053</span><br><span class="hljs-number">124</span> <span class="hljs-number">18347</span><br><span class="hljs-number">125</span> <span class="hljs-number">18347</span><br><span class="hljs-number">126</span> <span class="hljs-number">22613</span><br><span class="hljs-number">127</span> <span class="hljs-number">18773</span><br><span class="hljs-number">128</span> <span class="hljs-number">19627</span><br><span class="hljs-number">129</span> <span class="hljs-number">20053</span><br><span class="hljs-number">130</span> <span class="hljs-number">20480</span><br><span class="hljs-number">131</span> <span class="hljs-number">19627</span><br><span class="hljs-number">132</span> <span class="hljs-number">20053</span><br><span class="hljs-number">133</span> <span class="hljs-number">15360</span><br><span class="hljs-number">134</span> <span class="hljs-number">136533</span><br><span class="hljs-number">135</span> <span class="hljs-number">43093</span><br><span class="hljs-number">136</span> <span class="hljs-number">853</span><br><span class="hljs-number">137</span> <span class="hljs-number">853</span><br><span class="hljs-number">138</span> <span class="hljs-number">853</span><br><span class="hljs-number">139</span> <span class="hljs-number">853</span><br><span class="hljs-number">140</span> <span class="hljs-number">854</span><br><span class="hljs-number">141</span> <span class="hljs-number">853</span><br><span class="hljs-number">142</span> <span class="hljs-number">853</span><br><span class="hljs-number">143</span> <span class="hljs-number">853</span><br><span class="hljs-number">144</span> <span class="hljs-number">853</span><br><span class="hljs-number">145</span> <span class="hljs-number">853</span><br><span class="hljs-number">146</span> <span class="hljs-number">853</span><br><span class="hljs-number">147</span> <span class="hljs-number">854</span><br><span class="hljs-number">148</span> <span class="hljs-number">853</span><br><span class="hljs-number">149</span> <span class="hljs-number">853</span><br><span class="hljs-number">150</span> <span class="hljs-number">854</span><br><span class="hljs-number">151</span> <span class="hljs-number">853</span><br><span class="hljs-number">152</span> <span class="hljs-number">853</span><br><span class="hljs-number">153</span> <span class="hljs-number">853</span><br><span class="hljs-number">154</span> <span class="hljs-number">1280</span><br><span class="hljs-number">155</span> <span class="hljs-number">853</span><br><span class="hljs-number">156</span> <span class="hljs-number">853</span><br><span class="hljs-number">157</span> <span class="hljs-number">854</span><br><span class="hljs-number">158</span> <span class="hljs-number">853</span><br><span class="hljs-number">159</span> <span class="hljs-number">853</span><br><span class="hljs-number">160</span> <span class="hljs-number">854</span><br><span class="hljs-number">161</span> <span class="hljs-number">854</span><br><span class="hljs-number">162</span> <span class="hljs-number">853</span><br><span class="hljs-number">163</span> <span class="hljs-number">854</span><br><span class="hljs-number">164</span> <span class="hljs-number">854</span><br><span class="hljs-number">165</span> <span class="hljs-number">854</span><br><span class="hljs-number">166</span> <span class="hljs-number">854</span><br><span class="hljs-number">167</span> <span class="hljs-number">853</span><br><span class="hljs-number">168</span> <span class="hljs-number">853</span><br><span class="hljs-number">169</span> <span class="hljs-number">854</span><br><span class="hljs-number">170</span> <span class="hljs-number">853</span><br><span class="hljs-number">171</span> <span class="hljs-number">853</span><br><span class="hljs-number">172</span> <span class="hljs-number">853</span><br><span class="hljs-number">173</span> <span class="hljs-number">1280</span><br><span class="hljs-number">174</span> <span class="hljs-number">853</span><br><span class="hljs-number">175</span> <span class="hljs-number">1280</span><br><span class="hljs-number">176</span> <span class="hljs-number">853</span><br><span class="hljs-number">177</span> <span class="hljs-number">854</span><br><span class="hljs-number">178</span> <span class="hljs-number">854</span><br><span class="hljs-number">179</span> <span class="hljs-number">427</span><br><span class="hljs-number">180</span> <span class="hljs-number">853</span><br><span class="hljs-number">181</span> <span class="hljs-number">854</span><br><span class="hljs-number">182</span> <span class="hljs-number">854</span><br><span class="hljs-number">183</span> <span class="hljs-number">854</span><br><span class="hljs-number">184</span> <span class="hljs-number">853</span><br><span class="hljs-number">185</span> <span class="hljs-number">853</span><br><span class="hljs-number">186</span> <span class="hljs-number">854</span><br><span class="hljs-number">187</span> <span class="hljs-number">853</span><br><span class="hljs-number">188</span> <span class="hljs-number">853</span><br><span class="hljs-number">189</span> <span class="hljs-number">854</span><br><span class="hljs-number">190</span> <span class="hljs-number">1280</span><br><span class="hljs-number">191</span> <span class="hljs-number">853</span><br><span class="hljs-number">192</span> <span class="hljs-number">853</span><br><span class="hljs-number">193</span> <span class="hljs-number">853</span><br><span class="hljs-number">194</span> <span class="hljs-number">853</span><br><span class="hljs-number">195</span> <span class="hljs-number">854</span><br><span class="hljs-number">196</span> <span class="hljs-number">853</span><br><span class="hljs-number">197</span> <span class="hljs-number">853</span><br><span class="hljs-number">198</span> <span class="hljs-number">853</span><br><span class="hljs-number">199</span> <span class="hljs-number">854</span><br></code></pre></td></tr></table></figure><p>原因是什么呢?</p><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>  0层：解释执行，用解释器将字节码翻译为机器码</li><li>  1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>  2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>  3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>  4层：使用 C2 即时编译器编译执行</li></ul><p><strong>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等</strong></p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>  将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>  是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>  将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>  根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1(速度提升5倍) &lt; C2（速度提升10到100倍），总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>C2即时编译器中有一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料:<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine-performance-enhancements.html">Oracle官方文档</a></p><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>  开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>  关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>  显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>  对象是一个静态变量</li><li>  对象是一个已经发生逃逸的对象</li><li>  对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>  即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>  即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>  开启锁消除：-XX:+EliminateLocks</li><li>  关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>  开启标量替换：-XX:+EliminateAllocations</li><li>  关闭标量替换：-XX:-EliminateAllocations</li><li>  显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>(Inlining) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i * i;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(square(<span class="hljs-number">9</span>));<br></code></pre></td></tr></table></figure><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><p>还能够进行常量折叠(constant folding)的优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">81</span>);<br></code></pre></td></tr></table></figure><p>实验:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.jit;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT2</span> </span>&#123;<br>    <span class="hljs-comment">// -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:CompileCommand=dontinline,*JIT2.square</span><br>    <span class="hljs-comment">// -XX:+PrintCompilation</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                x = square(<span class="hljs-number">9</span>);<br><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.printf(<span class="hljs-string">&quot;%d\t%d\t%d\n&quot;</span>,i,x,(end - start));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i * i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a><strong>字段优化</strong></h4><p>JMH 基准测试请参考:<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a> </p><p>创建 maven 工程，添加依赖如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br>    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;<br>    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br>    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;<br>    &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>编写基准测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-meta">@Warmup(iterations = 2, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@State(Scope.Benchmark)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Benchmark1</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] elements = randomInts(<span class="hljs-number">1_000</span>);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] randomInts(<span class="hljs-keyword">int</span> size) &#123;<br>        Random random = ThreadLocalRandom.current();<br>        <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            values[i] = random.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br><span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123;<br>            doSum(elements[i]);<br>        &#125;<br>&#125;<br><span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] local = <span class="hljs-keyword">this</span>.elements;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; local.length; i++) &#123;<br>            doSum(local[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> element : elements) &#123;<br>            doSum(element);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-meta">@CompilerControl(CompilerControl.Mode.INLINE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>sum += x; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>&#123;<br>        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<br>                .include(Benchmark1.class.getSimpleName())<br>                .forks(<span class="hljs-number">1</span>)<br>                .build();<br>        <br><span class="hljs-keyword">new</span> Runner(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先启用 doSum 的方法内联，测试结果如下(每秒吞吐量，分数越高的更好):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Benchmark              Mode  Samples        Score  Score error  Units<br>t.Benchmark1.test1    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">2420286.539</span>   <span class="hljs-number">390747.467</span>  ops/s<br>t.Benchmark1.test2    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">2544313.594</span>    <span class="hljs-number">91304.136</span>  ops/s<br>t.Benchmark1.test3    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">2469176.697</span>   <span class="hljs-number">450570.647</span>  ops/s<br></code></pre></td></tr></table></figure><p>接下来禁用 doSum 方法内联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    sum += x; <br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Benchmark              Mode  Samples       Score  Score error  Units<br>t.Benchmark1.test1    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">296141.478</span>    <span class="hljs-number">63649.220</span>  ops/s<br>t.Benchmark1.test2    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">371262.351</span>    <span class="hljs-number">83890.984</span>  ops/s<br>t.Benchmark1.test3    thrpt  <span class="hljs-number">5</span>  <span class="hljs-number">368960.847</span>    <span class="hljs-number">60163.391</span>  ops/s<br></code></pre></td></tr></table></figure><p>分析:</p><p>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化: </p><p>如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子(伪代码):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Benchmark</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123; <span class="hljs-comment">// 后续 999 次 求长度 &lt;- local</span><br>sum += elements[i]; <span class="hljs-comment">// 1000 次取下标 i 的元素 &lt;- local </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以节省 1999 次 Field 读取操作</p><p>但如果 doSum 方法没有内联，则不会进行上面的优化</p><p>练习:在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p><code>Method</code>类的<code>invoke</code>方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">       InvocationTargetException</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/20200614133554.png"></p><p>会由<code>DelegatingMehodAccessorImpl</code>去调用<code>NativeMethodAccessorImpl</code>的<code>invoke</code>方法</p><p><code>NativeMethodAccessorImpl</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br><br><span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-comment">// inflationThreshold 膨胀阈值，默认 15</span><br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = <br>                (MethodAccessorImpl)<br>                (<span class="hljs-keyword">new</span> MethodAccessorGenerator())<br>                .generateMethod(<br>                <span class="hljs-keyword">this</span>.method.getDeclaringClass(), <br>                <span class="hljs-keyword">this</span>.method.getName(), <br>                <span class="hljs-keyword">this</span>.method.getParameterTypes(), <br>                <span class="hljs-keyword">this</span>.method.getReturnType(), <br>                <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <br>                <span class="hljs-keyword">this</span>.method.getModifiers()<br>            );<br>           <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><ul><li>  一开始if条件不满足，就会调用本地方法invoke0，本地方法的调用比较费时。</li><li>  随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就由本地方法访问器替换为一个运行时动态生成的访问器（构造一个对象，来直接调用方法），来提高效率；当调用到第 16 次(从0开始算)时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1。这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul><p>可以使用阿里的 arthas 工具:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java -jar arthas-boot.jar<br>[INFO] arthas-boot version: <span class="hljs-number">3.1</span><span class="hljs-number">.1</span><br>[INFO] Found existing java process, please choose one and hit RETURN.<br>* [<span class="hljs-number">1</span>]: <span class="hljs-number">13065</span> cn.itcast.jvm.t3.reflect.Reflect1<br></code></pre></td></tr></table></figure><p>选择 1 回车表示分析该进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br>[INFO] arthas home: /root/.arthas/lib/<span class="hljs-number">3.1</span><span class="hljs-number">.1</span>/arthas<br>[INFO] Try to attach process <span class="hljs-number">13065</span><br>[INFO] Attach process <span class="hljs-number">13065</span> success.<br>[INFO] arthas-client connect <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">3658</span><br>,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \| .--.<span class="hljs-string">&#x27;&#x27;</span>--. .--<span class="hljs-string">&#x27;| &#x27;</span>--<span class="hljs-string">&#x27; |/ O \&#x27; .-&#x27;</span> |.-.||<span class="hljs-string">&#x27;--&#x27;</span>.<span class="hljs-string">&#x27; || |.--.||.-.|`.`-.</span><br><span class="hljs-string">||||||\\ || ||||||||.-&#x27;</span> | `--<span class="hljs-string">&#x27; `--&#x27;</span>`--<span class="hljs-string">&#x27; &#x27;</span>--<span class="hljs-string">&#x27; `--&#x27;</span> `--<span class="hljs-string">&#x27; `--&#x27;</span>`--<span class="hljs-string">&#x27; `--&#x27;</span>`-----<span class="hljs-string">&#x27;</span><br><span class="hljs-string">wiki      https://alibaba.github.io/arthas</span><br><span class="hljs-string">tutorials https://alibaba.github.io/arthas/arthas-tutorials</span><br><span class="hljs-string">version   3.1.1</span><br><span class="hljs-string">pid       13065</span><br><span class="hljs-string">time      2019-06-10 12:23:54</span><br></code></pre></td></tr></table></figure><p>再输入【jad + 类名】来进行反编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742<br>  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>    +-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Decompiled with CFR 0_132.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Could not load the following classes:</span><br><span class="hljs-comment"> *  cn.itcast.jvm.t3.reflect.Reflect1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> sun.reflect;<br><span class="hljs-keyword">import</span> cn.itcast.jvm.t3.reflect.Reflect1;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> sun.reflect.MethodAccessorImpl;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratedMethodAccessor1</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Loose catch block</span><br><span class="hljs-comment">     * Enabled aggressive block sorting</span><br><span class="hljs-comment">     * Enabled unnecessary exception pruning</span><br><span class="hljs-comment">     * Enabled aggressive exception aggregation</span><br><span class="hljs-comment">     * Lifted jumps to return sites</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object object, Object[] arrobject)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>&#123;<br><span class="hljs-comment">// 比较奇葩的做法，如果有参数，那么抛非法参数异常 block4 : &#123;</span><br>            <span class="hljs-keyword">if</span> (arrobject == <span class="hljs-keyword">null</span> || arrobject.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> block4;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 可以看到，已经是直接调用了😱😱😱 Reflect1.foo();</span><br>            <span class="hljs-comment">// 因为没有返回值</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(throwable);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(Object.<span class="hljs-keyword">super</span>.toString());<br>        &#125;<br>&#125;<br>&#125;<br>Affect(row-cnt:<span class="hljs-number">1</span>) cost in <span class="hljs-number">1540</span> ms.<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>通过查看 ReflectionFactory 源码可知</p><p>sun.reflect.noInflation 可以用来禁用膨胀(直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算)<br> sun.reflect.inflationThreshold 可以修改膨胀阈值</p></blockquote><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p><p>关于它的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b</a></p><p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p><ul><li>  很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（<strong>JMM</strong>）的意思。</li><li>  简单的说，<strong>JMM</strong> 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的<strong>可见性</strong>、<strong>有序性</strong>、和<strong>原子性</strong>的规则和保障</li></ul><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下:</p><p>提出问题：两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><h4 id="1-1-问题解析"><a href="#1-1-问题解析" class="headerlink" title="1-1 问题解析"></a>1-1 问题解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                i++;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                i--;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的结果可能是正数、负数、零。为什么呢?因为 Java 中对静态变量的自增，自减并不是原子操作。</p><p>例如对于 i++ 而言(i 为静态变量)，实际会产生如下的 JVM 字节码指令:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatici <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1<span class="hljs-comment">// 准备常量1</span><br>iadd<span class="hljs-comment">// 加法</span><br>putstatici<span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而对应 i– 也是类似:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatici <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1<span class="hljs-comment">// 准备常量1</span><br>isub<span class="hljs-comment">// 减法</span><br>putstatici<span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换:</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230331131854874.png"></p><p>如果是单线程以上 8 行代码是顺序执行(不会交错)没有问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatici <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>iconst_1<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatici <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>getstatici <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=1</span><br>iconst_1<span class="hljs-comment">// 线程1-准备常量1</span><br>isub<span class="hljs-comment">// 线程1-自减 线程内i=0</span><br>putstatici <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></code></pre></td></tr></table></figure><p>但多线程下这 8 行代码可能交错运行(为什么会交错?思考一下): 出现负数的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatici <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>getstatici <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatici <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1<span class="hljs-comment">// 线程2-准备常量1</span><br>isub<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatici <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure><p>出现正数的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatici <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>getstatici <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>iconst_1<span class="hljs-comment">// 线程2-准备常量1</span><br>isub<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatici <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br>putstatici <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br></code></pre></td></tr></table></figure><h4 id="1-2-解决方法"><a href="#1-2-解决方法" class="headerlink" title="1-2 解决方法"></a>1-2 解决方法</h4><h5 id="（1）synchronized（同步关键字）"><a href="#（1）synchronized（同步关键字）" class="headerlink" title="（1）synchronized（同步关键字）"></a>（1）synchronized（同步关键字）</h5><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>( 对象 ) &#123;<br>    要作为原子操作代码<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>synchronized</code> 解决并发问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                    i++;<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//输出为0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么需要这里的 <code>obj</code> 对象呢？</p></blockquote><p>我们可以这样理解：可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p><p>当线程 t1 执行到 <code>synchronized(obj)</code> 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。这时候如果 t2 也运行到了 <code>synchronized(obj)</code> 时，它发现门被锁住了，只能在门外等待。</p><p>当 t1 执行完 <code>synchronized&#123;&#125;</code> 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p><blockquote><p>注意:上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p></blockquote><blockquote><p>怎么从JVM角度理解呢？（这里引用《Java并发编程的艺术》里的一段话）</p><p>从JVM规范中可以看到<code>Synchonized</code>在JVM里的实现原理，JVM基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code> 和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是，方法同步同样可以使用这两个指令来实现。 <code>monitorenter</code>指令是在编译后插入到同步代码块的<strong>开始位置</strong>，而<code>monitorexit</code>是插入到<strong>方法结束处</strong>和<strong>异常处</strong>，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个<code>monitor</code>与之关联，当且一个<code>monitor</code>被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code> 指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                        i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                        i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//输出为0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里做了一个优化，将synchronized放在for循环之外，每个线程的加锁解锁次数从5000次变为了1次（synchronized是可重入的的），提高了效率。</strong></p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><h4 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2-1 退不出的循环"></a>2-1 退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(run)&#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么会这样？</p><ol><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/3242.jpg"></p></li><li><p>因为 t 线程要频繁从<strong>主内存</strong>中读取 run 的值，<strong>JIT 编译器</strong>会将 run 的值缓存至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率</p></li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/13242.jpg"></p><ol start="3"><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/2345678.jpg"></p></li></ol><h4 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2-2 解决办法"></a>2-2 解决办法</h4><h5 id="（1）volatile（易变关键字）"><a href="#（1）volatile（易变关键字）" class="headerlink" title="（1）volatile（易变关键字）"></a>（1）volatile（易变关键字）</h5><p>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <strong>volatile</strong> 变量都是直接操作主存，保证了共享变量的<strong>可见性</strong>，但<strong>不能保证原子性</strong>，仅适用在一个写线程，多个读线程的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">// ....</span><br>            &#125;<br>        &#125;);<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况: </p><p>上例从字节码理解是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstaticrun <span class="hljs-comment">//线程t获取runtrue</span><br>getstaticrun <span class="hljs-comment">//线程t获取runtrue</span><br>getstaticrun <span class="hljs-comment">//线程t获取runtrue</span><br>getstaticrun <span class="hljs-comment">//线程t获取runtrue</span><br>putstaticrun <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstaticrun <span class="hljs-comment">// 线程 t 获取 run false</span><br></code></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子:两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatici <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>getstatici <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>iconst_1<span class="hljs-comment">// 线程1-准备常量1</span><br>iadd<span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1<span class="hljs-comment">// 线程2-准备常量1</span><br>isub<span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：</p><p><code>synchronized</code> 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。但缺点是<code>synchronized</code>是属于重量级操作，<strong>性能相对更低</strong></p><p>如果在前面示例的死循环中加入 <code>System.out.println()</code> 会发现即使不加 volatile 修饰符，线程 t 也 能正确看到对 run 变量的修改了，想一想为什么？</p></blockquote><p>进入<code>println</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出加了<code>synchronized</code>，保证了每次<code>run</code>变量都会从主存中获取。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><h4 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3-1 诡异的结果"></a>3-1 诡异的结果</h4><p>看下面一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种?</p><p>看到这里可能聪明的小伙伴会想到有下面三种情况：</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p><strong>但其实还有可能为0哦</strong>！线程 2 执行 ready=true ，切换到线程1 ，进入if分支，相加为0，在切回线程 2 执行 num=2</p><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现:</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn archetype:generate  -DinteractiveMode=<span class="hljs-keyword">false</span> -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DgroupId=org.sample -DartifactId=test -Dversion=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>创建 maven 项目，提供如下测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn clean install <br>java -jar target/jcstress.jar<br></code></pre></td></tr></table></figure><p>会输出我们感兴趣的结果，摘录其中一次结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">*** INTERESTING tests<br>  Some interesting behaviors observed. This is <span class="hljs-keyword">for</span> the plain curiosity.<br>  <span class="hljs-number">2</span> matching test results.<br>      [OK] test.ConcurrencyTest<br>    (JVM args: [-XX:-TieredCompilation])<br>  Observed state   Occurrences              Expectation  Interpretation<br>       <span class="hljs-number">0</span>         <span class="hljs-number">1</span>,<span class="hljs-number">729</span>   ACCEPTABLE_INTERESTING  !!!!<br>             <span class="hljs-number">1</span>    <span class="hljs-number">42</span>,<span class="hljs-number">617</span>,<span class="hljs-number">915</span>ACCEPTABLEok<br>             <span class="hljs-number">4</span>     <span class="hljs-number">5</span>,<span class="hljs-number">146</span>,<span class="hljs-number">627</span>ACCEPTABLEok<br>    [OK] test.ConcurrencyTest<br>  (JVM args: [])<br>Observed state   OccurrencesExpectationInterpretation<br>             <span class="hljs-number">0</span>         <span class="hljs-number">1</span>,<span class="hljs-number">652</span>   ACCEPTABLE_INTERESTING  !!!!<br>             <span class="hljs-number">1</span>    <span class="hljs-number">46</span>,<span class="hljs-number">460</span>,<span class="hljs-number">657</span>               ACCEPTABLE  ok<br>             <span class="hljs-number">4</span>     <span class="hljs-number">4</span>,<span class="hljs-number">571</span>,<span class="hljs-number">072</span>               ACCEPTABLE  ok<br></code></pre></td></tr></table></figure><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><h4 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3-2 解决方法"></a>3-2 解决方法</h4><p><strong>volatile 修饰的变量，可以禁用指令重排</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//可以禁用指令重排</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新测试，发现未发生指令重排现象。</p><h4 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3-3 有序性理解"></a>3-3 有序性理解</h4><p>同一线程内，JVM会在不影响正确性的前提下，可以调整语句的执行顺序，看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时， 既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br></code></pre></td></tr></table></figure><p>这种特性称之为<strong>指令重排</strong>，<strong>多线程下指令重排会影响正确性</strong>，例如著名的 <code>double-checked locking</code> 模式实现单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实例没创建，才会进入内部的 synchronized 代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//可能第一个线程在synchronized 代码块还没创建完对象时，第二个线程已经到了这一步，所以里面还需要加上判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//也许有其他线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>  懒惰实例化</li><li>  首次使用 getInstance() 才使用<code>synchronized</code>加锁，后续使用时无需加锁</li></ul><p>上面的代码看似已经很完美了，但是<strong>在多线程环境下还是会有指令重排问题！</strong></p><p><code>INSTANCE = new Singleton()</code> 对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> <span class="hljs-comment">// class cn/itcast/jvm/t4/Singleton</span><br><span class="hljs-number">3</span>: dup<br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">7</span>: putstatic #<span class="hljs-number">4</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;</span><br></code></pre></td></tr></table></figure><p>其中<code>4</code>和<code>7</code>两步顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1,t2 按如下时间顺序执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">时间<span class="hljs-number">1</span> t1 线程执行到 INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>时间<span class="hljs-number">2</span> t1 线程分配空间，为Singleton对象生成了引用地址（<span class="hljs-number">0</span> 处）<br>时间<span class="hljs-number">3</span> t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-number">7</span> 处）<br>时间<span class="hljs-number">4</span> t2 线程进入getInstance() 方法，发现 INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-keyword">synchronized</span>块外），直接返回 INSTANCE<br>时间<span class="hljs-number">5</span> t1 线程执行Singleton的构造方法（<span class="hljs-number">4</span> 处）<br></code></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 <strong>volatile</strong> 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 <strong>volatile</strong> 才会真正有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实例没创建，才会进入内部的 synchronized 代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//可能第一个线程在synchronized 代码块还没创建完对象时，第二个线程已经到了这一步，所以里面还需要加上判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//也许有其他线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3-4 happens-before"></a>3-4 happens-before</h4><p><strong>happens-before</strong> 规定了哪些写操作对其它线程的读操作可见，它是<strong>可见性</strong>与<strong>有序性</strong>的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start()<br></code></pre></td></tr></table></figure></li><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br></code></pre></td></tr></table></figure></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br></code></pre></td></tr></table></figure></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 <code>t1.isAlive()</code> 或 <code>t1.join()</code>等待它结束）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t1.join();<br>System.out.println(x);<br><br></code></pre></td></tr></table></figure></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程(包括被打断线程)得知 t2 被打断后对变量的读可见（通过<code>t2.interrupted</code> 或 <code>t2.isInterrupted()</code>）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(x);<span class="hljs-comment">//0</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>        Thread.yield();<br>    &#125;<br>    System.out.println(x);<span class="hljs-comment">//0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code></p></li></ul><blockquote><p>以上变量都是指<strong>共享变量</strong>即成员变量或静态资源变量</p></blockquote><h3 id="4-CAS与原子类"><a href="#4-CAS与原子类" class="headerlink" title="4.CAS与原子类"></a>4.CAS与原子类</h3><h4 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4-1 CAS"></a>4-1 CAS</h4><p><strong>CAS</strong> 即 <code>Compare and Swap</code> ，它体现的一种<strong>乐观锁</strong>的思想，比如多个线程要对一个共享的整型变量执行 +1 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要不断尝试</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> 旧值 = 共享变量 ; <span class="hljs-comment">// 比如拿到了当前值 0</span><br>    <span class="hljs-keyword">int</span> 结果 = 旧值 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候</span><br><span class="hljs-comment">compareAndSwap 返回 false，重新尝试，直到：</span><br><span class="hljs-comment">compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123;<br>        <span class="hljs-comment">// 成功，退出循环</span><br>    &#125;<br>    <span class="hljs-comment">//不一样，继续循环尝试</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong><code>CompareAndSwap</code>，是根据地址再取一次旧值（新旧值）,然后与旧值（旧旧值）比较，如果一样就set（内部保证原子性）结果，不一样就再试。</strong></p><p>获取共享变量时，为了保证该变量的可见性，需要使用 <code>volatile</code> 修饰。<strong>结合 CAS 和 volatile 可以实现无锁并发</strong>，适用于<strong>竞争不激烈</strong>（不要频繁重试）、<strong>多核 CPU</strong>（重试需要消耗CPU时间，所以多核CPU提供更多CPU时间片） 的场景下。</p><ul><li>  因为没有使用 <code>synchronized</code>，所以线程不会陷入阻塞（涉及到线程的上下文切换），这是效率提升的因素之一</li><li>  但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul><p>CAS 底层依赖于一个 <code>Unsafe</code> 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        DataContainer dc = <span class="hljs-keyword">new</span> DataContainer();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                dc.increase();<br>            &#125;<br>        &#125;);<br>        t.start();<br>        t.join();<br>        System.out.println(dc.getData());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DATA_OFFSET;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Unsafe 对象不能直接调用，只能通过反射获得</span><br>            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            DATA_OFFSET =<br>                    unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>            oldValue = data;<br>            <span class="hljs-comment">// 旧值与当前共享变量一致，才做修改。否则，不修改，重新尝试。</span><br>            <span class="hljs-comment">// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue +<br>                    <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            oldValue = data;<br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4-2 乐观锁与悲观锁"></a>4-2 乐观锁与悲观锁</h4><ul><li>  <strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>  <strong>synchronized</strong> 是基于<strong>悲观锁</strong>的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li></ul><h4 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4-3 原子操作类"></a>4-3 原子操作类</h4><p>**JUC<code>（java.util.concurrent）</code>中提供了原子操作类，可以提供线程安全的操作，例如：<code>AtomicInteger</code>、 <code>AtomicBoolean</code>等，它们底层就是采用 **CAS 技术 + volatile 来实现的。 可以使用 AtomicInteger 改写之前的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>&#123;<br>    <span class="hljs-comment">//创建原子整数对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                i.getAndIncrement(); <span class="hljs-comment">//获取并且自增 i++</span><br>                <span class="hljs-comment">// i.incrementAndGet(); //自增并且获取 ++i</span><br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                i.getAndDecrement(); <span class="hljs-comment">//获取并且自减 i--</span><br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5.synchronized 优化"></a>5.synchronized 优化</h3><p>从JDK1.6开始，对<code>synchronized</code>做了大量优化，在某些场景下甚至比<code>CAS</code>性能要更好。</p><p>Java HotSpot 虚拟机中，每个对象都有<strong>对象头</strong>（包括 <code>class 指针</code>和 <code>Mark Word</code>）。<code>Mark Word</code> 平时存储这个对象的哈希码 、 分代年龄 ；当加锁时，这些信息就根据情况被替换为标记位 、 线程锁记录指针 、 重量级锁指针 、 线程ID 等内容</p><h4 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5-1 轻量级锁"></a>5-1 轻量级锁</h4><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用<strong>轻量级锁</strong>来优化。这就好比：</p><p>学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程A 随即升级为<strong>重量级锁</strong>，进入重量级锁的流程。</p><p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来，假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程的栈帧中都会包含一个<strong>锁记录（栈结构，每次加锁push对象的Mark Word，解锁pop对象的Mark Word）</strong>的结构，内部可以存储锁定对象的 <code>Mark Word</code>，即对象Mark Word做修改之前，先把当前Mark Word存放在当前线程栈帧的锁记录的结构中，以便之后恢复。即<strong>每次加锁的过程就是，对象的Mark Word与当前线程的锁记录结构中的锁记录地址进行交换。</strong></p><table><thead><tr><th>线程1</th><th>对象Mark Word</th><th>线程2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到 线程 1 的锁记录（线程1锁记录push对象的Mark Word）</td><td>01(无锁)</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录 地址</td><td>01(无锁)</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>访问同步块 B，把 Mark 复制到 线程 1 的锁记录（线程1锁记录push对象的Mark Word）</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>失败(发现是自己的锁)</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 B</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>同步块 B 执行完毕（线程1锁记录pop出一个Mark Word）</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>同步块 A 执行完毕（线程1锁记录pop出一个Mark Word，并且交换和对象的Mark Word）</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>成功(解锁)</td><td>01（无锁）</td><td>-</td></tr><tr><td>-</td><td>01（无锁）</td><td>访问同步块 A，把 Mark 复制到 线程 2 的锁记录</td></tr><tr><td>-</td><td>01（无锁）</td><td>CAS 修改 Mark 为线程 2 锁记录 地址</td></tr><tr><td>-</td><td>00(轻量锁)线程 2 锁记录地址</td><td>成功(加锁)</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h4 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5-2 锁膨胀"></a>5-2 锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，<strong>将轻量级锁变为重量级锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123; <br>        <span class="hljs-comment">// 同步块</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><table><thead><tr><th>线程1</th><th>对象Mark Word</th><th>线程2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到 线程 1 的锁记录</td><td>01(无锁)</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录 地址</td><td>01(无锁)</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>访问同步块，把 Mark 复制 到线程 2 锁记录</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>失败(发现别人已经占了锁)</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程 1 - 锁记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td><strong>失败(解锁)</strong></td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10(重量锁)</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10(重量锁)</td><td>成功(加锁)</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>对象Mark Word设置重量锁指针是为了，重量锁被释放后，根据重量锁指针来唤醒被阻塞的线程们来竞争重量锁。</p><h4 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5-3 重量锁"></a>5-3 重量锁</h4><p>重量级锁竞争的时候，还可以使用<strong>自旋</strong>来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p><strong>在 Java 6 之后自旋锁是自适应的</strong>，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li><li>好比等红灯时汽车是不是熄火，不熄火相当于<strong>自旋</strong>(等待时间短了划算)，熄火了相当于<strong>线程阻塞</strong>(等待时间长了划算)</li><li> Java 7 之后不能控制是否开启自旋功能</li></ul><p>自旋重试成功的情况</p><table><thead><tr><th>线程1（cpu1上）</th><th>对象Mark</th><th>线程2（cpu2上）</th></tr></thead><tbody><tr><td>-</td><td>10(重量锁)</td><td>-</td></tr><tr><td>访问同步块，获取monitor</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>成功(解锁)</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10(重量锁)重量锁指针</td><td>成功(加锁)</td></tr><tr><td>-</td><td>10(重量锁)重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程1（cpu1上）</th><th>对象Mark</th><th>线程2（cpu2上）</th></tr></thead><tbody><tr><td>-</td><td>10(重量锁)</td><td>-</td></tr><tr><td>访问同步块，获取monitor</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h4 id="5-4-偏向锁"><a href="#5-4-偏向锁" class="headerlink" title="5-4 偏向锁"></a>5-4 偏向锁</h4><p>轻量级锁在没有竞争时(就自己这个线程)，每次重入仍然需要执行CAS操作。Java 6中引入了<strong>偏向锁</strong>来做进一步优化：<strong>只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS</strong></p><ul><li>  撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li><li>  访问对象的 hashCode 也会撤销偏向锁，因为此时Mark Word（含hashCode）被换成了线程ID</li><li>  如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，<strong>重偏向</strong>会重置对象的 Thread ID</li><li>  撤销偏向和重偏向都是批量进行的，以类为单位</li><li>  如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>  由于偏向锁的种种弊端，可以主动使用 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li></ul><p>可以参考这篇论文:<a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf</a></p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123; <span class="hljs-comment">// 同步块 A</span><br>method2(); <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123; <br>        <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><table><thead><tr><th>线程1</th><th>对象Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>101(无锁可偏向)</td></tr><tr><td>尝试加偏向锁</td><td>101(无锁可偏向)对象 hashCode</td></tr><tr><td>成功</td><td>101(无锁可偏向)线程ID</td></tr><tr><td>执行同步块 A</td><td>101(无锁可偏向)线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101(无锁可偏向)线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101(无锁可偏向)线程ID</td></tr><tr><td>执行同步块 B</td><td>101(无锁可偏向)线程ID</td></tr><tr><td>执行完毕</td><td>101(无锁可偏向)对象hashCode</td></tr></tbody></table><h4 id="5-5-其他优化"><a href="#5-5-其他优化" class="headerlink" title="5-5 其他优化"></a>5-5 其他优化</h4><h5 id="（1）减少上锁时间"><a href="#（1）减少上锁时间" class="headerlink" title="（1）减少上锁时间"></a>（1）减少上锁时间</h5><p>同步代码块中尽量短，同步代码块运行时间短，竞争的机会就少了。</p><h5 id="（2）减少锁的粒度"><a href="#（2）减少锁的粒度" class="headerlink" title="（2）减少锁的粒度"></a>（2）减少锁的粒度</h5><p>将一个锁拆分为多个锁提高并发度，例如：</p><ul><li>  <code>ConcurrentHashMap</code>，将数组中的各个链表头进行加锁，而不是像<code>HashTable</code>一样对整个数组进行加锁。</li><li>  <code>LongAdder</code> 分为 <code>base</code> 和 <code>cells</code> 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加到base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li><li>  <code>LinkedBlockingQueue</code> 入队和出队使用不同的锁，相对于<code>LinkedBlockingArray</code>只有一个锁效率要高</li></ul><h5 id="（3）锁粗化"><a href="#（3）锁粗化" class="headerlink" title="（3）锁粗化"></a>（3）锁粗化</h5><p>多次循环进入同步块不如同步块内多次循环，另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">&quot;a&quot;</span>).append(<span class="hljs-string">&quot;b&quot;</span>).append(<span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="（4）锁消除"><a href="#（4）锁消除" class="headerlink" title="（4）锁消除"></a>（4）锁消除</h5><p>JVM 会进行代码的<strong>逃逸分析</strong>，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p><h5 id="（5）读写分离"><a href="#（5）读写分离" class="headerlink" title="（5）读写分离"></a>（5）读写分离</h5><p><code>CopyOnWriteArrayList</code>和<code>ConyOnWriteSet</code>读操作直接读原始数组，而写操作在副本数组上写，故而不需要对读操作进行同步，只需要对写操作进行同步。</p><p>参考:</p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a> </p><p><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luojinping.com/2015/07/09/java锁优化/ </a></p><p><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/java-se-16-synchronized</a> </p><p><a href="https://www.jianshu.com/p/9932047a89be">https://www.jianshu.com/p/9932047a89be</a> </p><p><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblogs.com/sheeva/p/6366782.html</a> </p><p><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习</title>
    <link href="/2023/05/03/Netty%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/05/03/Netty%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-NIO-基础"><a href="#一-NIO-基础" class="headerlink" title="一. NIO 基础"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p><h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><pre><code class=" mermaid">graph LRchannel --&gt; bufferbuffer --&gt; channel</code></pre><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>buffer 则用来缓冲读写数据，常见的 buffer 有</p><ul><li>ByteBuffer（抽象类）<ul><li>MappedByteBuffer（实现类）</li><li>DirectByteBuffer（实现类）</li><li>HeapByteBuffer（实现类）</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p><h4 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h4><p>一个连接一个线程，BIO（阻塞IO）设计。</p><pre><code class=" mermaid">graph TDsubgraph 多线程版t1(thread) --&gt; s1(socket1)t2(thread) --&gt; s2(socket2)t3(thread) --&gt; s3(socket3)end</code></pre><h4 id="⚠️-多线程版缺点"><a href="#⚠️-多线程版缺点" class="headerlink" title="⚠️ 多线程版缺点"></a>⚠️ 多线程版缺点</h4><ul><li>内存占用高，每个线程需要占用一定的内存，多个线程占用内存过多</li><li>线程上下文切换成本高（如果一个服务器只有16核，如果有多余16个线程同时在运行，那么这多个线程频繁切换，所带来的线程上下文切换成本过高）</li><li>只适合连接数少的场景</li></ul><h4 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h4><pre><code class=" mermaid">graph TDsubgraph 线程池版t4(thread) --&gt; s4(socket1)t5(thread) --&gt; s5(socket2)t4(thread) -.-&gt; s6(socket3)t5(thread) -.-&gt; s7(socket4)end</code></pre><h4 id="⚠️-线程池版缺点"><a href="#⚠️-线程池版缺点" class="headerlink" title="⚠️ 线程池版缺点"></a>⚠️ 线程池版缺点</h4><ul><li>阻塞模式下，一个线程同一时间内仅能处理一个 socket 连接（即一个线程，只有等到当前<code>socket</code>连接断开以后，才能处理下一个<code>socket</code>连接）</li><li>仅适合短连接场景（所以早期服务器（比如：早期Tomcat服务器）都是短连接，在处理完一项业务后，赶紧断开<code>socket</code>连接，释放当前线程，让当前线程去处理其他业务）</li><li>总而言之，由于<code>socket</code>是阻塞IO，导致线程的利用率不高</li></ul><h4 id="selector-版设计"><a href="#selector-版设计" class="headerlink" title="selector 版设计"></a>selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在<strong>非阻塞模式</strong>下，不会让线程吊死在一个 channel 上。适合<strong>连接数特别多</strong>，但<strong>流量低</strong>的场景（low traffic）</p><pre><code class=" mermaid">graph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end</code></pre><p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理。</p><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1234567890abcd<br></code></pre></td></tr></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            FileChannel channel = file.getChannel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 向 buffer 写入</span><br>                <span class="hljs-keyword">int</span> len = channel.read(buffer);<br>                log.debug(<span class="hljs-string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 读模式</span><br>                buffer.flip();<br>                <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (<span class="hljs-keyword">char</span>)buffer.get());<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 写模式</span><br>                buffer.clear();<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：<span class="hljs-number">10</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">3</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">4</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">5</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">6</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">7</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">8</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">9</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：<span class="hljs-number">4</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-selector-tag">a</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-selector-tag">b</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - c<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - d<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="2-1-ByteBuffer-正确使用姿势"><a href="#2-1-ByteBuffer-正确使用姿势" class="headerlink" title="2.1  ByteBuffer 正确使用姿势"></a>2.1  ByteBuffer 正确使用姿势</h3><ol><li>向 buffer 写入数据，例如调用 channel.read(buffer)</li><li>调用 flip() 切换至<strong>读模式</strong></li><li>从 buffer 读取数据，例如调用 buffer.get()</li><li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li><li>重复 1~4 步骤</li></ol><h3 id="2-2-ByteBuffer-结构"><a href="#2-2-ByteBuffer-结构" class="headerlink" title="2.2 ByteBuffer 结构"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>一开始</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0021.png"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0018.png"></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0019.png"></p><p>读取 4 个字节后，状态</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0020.png"></p><p>clear 动作发生后，状态:（<strong>clear动作并不会清楚数据，只是移动了Position和Limit指针</strong>）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/3124123412342.png"></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0022.png"></p><h4 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> String[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> String[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> padding = HEXPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">12</span>);<br>            buf.append(NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> padding = BYTEPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-keyword">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldlimit = buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        StringBuilder origin = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.println(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;<br>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.println(builder);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startIndex = offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> remainder = length &amp; <span class="hljs-number">0xF</span>;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(dump, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> rowStartIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">short</span> <span class="hljs-title">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-ByteBuffer-常见方法"><a href="#2-3-ByteBuffer-常见方法" class="headerlink" title="2.3 ByteBuffer 常见方法"></a>2.3 ByteBuffer 常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间（<strong>不可以动态调整</strong>），其它 buffer 类也有该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ByteBuffer.allocate(<span class="hljs-number">10</span>));<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=10 cap=10]</span><br>System.out.println(ByteBuffer.allocateDirect(<span class="hljs-number">10</span>));<span class="hljs-comment">//java.nio.DirectByteBuffer[pos=0 lim=10 cap=10]</span><br></code></pre></td></tr></table></figure><p><strong>class java.nio.HeapByteBuffer  java 堆内存,读写效率较低，受到JVM的GC的影响(复制和标记-整理垃圾回收算法有可能为了减少内存碎片，会来回的拷贝该内存)</strong></p><p><strong>class java.nio.DirectByteBuffer 直接内存,读写效率高（少一次拷贝），不会受到JVM的GC影响；由于直接内存是系统内存，分配时需要调用系统函数，分配的效率低，并且使用结束，需要正确释放直接内存，否则会造成内存泄露。</strong></p><h4 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h4><p>有两种办法</p><ul><li>调用 channel 的 read 方法</li><li>调用 buffer 自己的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> readBytes = channel.read(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.put((<span class="hljs-keyword">byte</span>)<span class="hljs-number">127</span>);<br></code></pre></td></tr></table></figure><h4 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h4><p>同样有两种办法</p><ul><li>调用 channel 的 write 方法</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> writeBytes = channel.write(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b = buf.get();<br></code></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li><p>可以调用 rewind 方法将 position 重新置为 0，从头重新读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>buffer.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;);<br>buffer.flip();<br><br>buffer.get(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>]);<br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=2 lim=4 cap=10]</span><br>buffer.rewind();<br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=4 cap=10]</span><br></code></pre></td></tr></table></figure></li><li><p>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>buffer.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;);<br>buffer.flip();<br><br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=4 cap=10]</span><br>System.out.println(buffer.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">//98</span><br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=4 cap=10]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h4><p>mark() 是在读取时，做一个标记，即使 position 改变，只要调用 reset() 就能回到 mark 的位置。目的是重复读取某段数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>buffer.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;);<br>buffer.flip();<br><br>buffer.get(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>]);<br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=2 lim=4 cap=10]</span><br>buffer.mark();<br>buffer.get(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>]);<br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=4 lim=4 cap=10]</span><br>buffer.reset();<br>System.out.println(buffer);<span class="hljs-comment">//java.nio.HeapByteBuffer[pos=2 lim=4 cap=10]</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Netty</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//1.字符串转为 byte[] 然后put入 ByteBuffer</span><br>        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>        buffer1.put(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>        System.out.println(buffer1); <span class="hljs-comment">//java.nio.HeapByteBuffer[pos=5 lim=16 cap=16]</span><br>        buffer1.flip(); <span class="hljs-comment">//切换到读模式</span><br>        String str1 = StandardCharsets.UTF_8.decode(buffer1).toString(); <span class="hljs-comment">//这个decode()函数从buffer的position开始读，所以要切换到读模式</span><br>        System.out.println(str1); <span class="hljs-comment">//hello</span><br><br><br>        <span class="hljs-comment">//2.Charset类，并且在put入ByteBuffer之后，直接将position置0，就可以开始读，不用调用flip()</span><br>        ByteBuffer buffer2 = StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br>        <span class="hljs-comment">//ByteBuffer buffer2 = Charset.forName(&quot;UTF-8&quot;).encode(&quot;你好&quot;);</span><br>        System.out.println(buffer2); <span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=6 cap=11]</span><br>        String str2 = StandardCharsets.UTF_8.decode(buffer2).toString(); <span class="hljs-comment">//这个decode()函数从buffer的position开始读，所以要切换到读模式</span><br>        System.out.println(str2);<span class="hljs-comment">// 你好</span><br>        <br><br>        ByteBuffer buffer3 = ByteBuffer.wrap(<span class="hljs-string">&quot;你好&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        System.out.println(buffer3); <span class="hljs-comment">//java.nio.HeapByteBuffer[pos=0 lim=6 cap=6]</span><br>        String str3 = StandardCharsets.UTF_8.decode(buffer3).toString();<br>        System.out.println(str3);<span class="hljs-comment">//你好</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h4><blockquote><p>Buffer 是<strong>非线程安全的</strong></p></blockquote><h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">onetwothree</span><br></code></pre></td></tr></table></figure><p>使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;helloword/3parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    FileChannel channel = file.getChannel();<br>    ByteBuffer a = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    ByteBuffer b = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    ByteBuffer c = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>    channel.read(<span class="hljs-keyword">new</span> ByteBuffer[]&#123;a, b, c&#125;);<br>    a.flip();<br>    b.flip();<br>    c.flip();<br>    debug(a);<br>    debug(b);<br>    debug(c);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6f 6e 65                                        |one             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 74 77 6f                                        |two             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;helloword/3parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    FileChannel channel = file.getChannel();<br>    ByteBuffer d = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    ByteBuffer e = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    channel.position(<span class="hljs-number">11</span>);<br><br>    d.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;);<br>    e.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;);<br>    d.flip();<br>    e.flip();<br>    debug(d);<br>    debug(e);<br>    channel.write(<span class="hljs-keyword">new</span> ByteBuffer[]&#123;d, e&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 69 76 65                                     |five            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">onetwothreefourfive</span><br></code></pre></td></tr></table></figure><p><strong>使用多个buffer分散读和分散写，这样减少了数据在各个buffer或者数组之间来回拷贝，提高了效率。</strong></p><h3 id="2-6-练习"><a href="#2-6-练习" class="headerlink" title="2.6 练习"></a>2.6 练习</h3><h4 id="黏包和半包现象"><a href="#黏包和半包现象" class="headerlink" title="黏包和半包现象"></a>黏包和半包现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m zhangsan\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (黏包，半包)</p><ul><li>Hello,world\nI’m zhangsan\nHo</li><li>w are you?\n</li></ul><p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ByteBuffer source = ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//                     11            24</span><br>    source.put(<span class="hljs-string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());<br>    split(source);<br><br>    source.put(<span class="hljs-string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());<br>    split(source);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer source)</span> </span>&#123;<br>    source.flip();<br>    <span class="hljs-keyword">int</span> oldLimit = source.limit();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldLimit; i++) &#123;<br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            System.out.println(i);<br>            ByteBuffer target = ByteBuffer.allocate(i + <span class="hljs-number">1</span> - source.position());<br>            <span class="hljs-comment">// 0 ~ limit</span><br>            source.limit(i + <span class="hljs-number">1</span>);<br>            target.put(source); <span class="hljs-comment">// 从 source 的position读到limit（不包含limit，只包含position），移动position指针到limit，然后向 target 写</span><br>            debugAll(target);<br>            source.limit(oldLimit);<br>        &#125;<br>    &#125;<br>    source.compact();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><h4 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h4><blockquote><p>FileChannel 只能工作在阻塞模式下，不能配合Selector运行</p></blockquote><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写是根据构造 RandomAccessFile 时的读写模式决定的</li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> readBytes = channel.read(buffer);<br></code></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>写入的正确姿势如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuffer buffer = ...;<br>buffer.put(...); <span class="hljs-comment">// 存入数据</span><br>buffer.flip();   <span class="hljs-comment">// 切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel（channel的写入能力是有上限的，FileChannel没有这个限制，但是后面用到的SocketChannel有上限）。</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法，当然也可以只调用channel的close方法。</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> position = channel.position();<br></code></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> newPos = ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1 </li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="3-2-两个-Channel-传输数据"><a href="#3-2-两个-Channel-传输数据" class="headerlink" title="3.2 两个 Channel 传输数据"></a>3.2 两个 Channel 传输数据</h3><p><strong><code>FileChannel.transferTo()</code>效率高，底层会利用操作系统的零拷贝进行优化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">String FROM = <span class="hljs-string">&quot;helloword/data.txt&quot;</span>;<br>String TO = <span class="hljs-string">&quot;helloword/to.txt&quot;</span>;<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();<br>     FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();<br>) &#123;<br>    from.transferTo(<span class="hljs-number">0</span>, from.size(), to);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transferTo</span> 用时：<span class="hljs-number">8</span>.<span class="hljs-number">2011</span><br></code></pre></td></tr></table></figure><p><strong><code>FileChannel.transferTo()</code>每次传输最大2G字节，如果超过2G字节，需要多次传输。</strong></p><p>超过 2g 大小的文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileChannelTransferTo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (<br>                FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;data.txt&quot;</span>).getChannel();<br>                FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;to.txt&quot;</span>).getChannel();<br>        ) &#123;<br>            <span class="hljs-comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span><br>            <span class="hljs-keyword">long</span> size = from.size();<br>            <span class="hljs-comment">// left 变量代表还剩余多少字节</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> left = size; left &gt; <span class="hljs-number">0</span>; ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;position:&quot;</span> + (size - left) + <span class="hljs-string">&quot; left:&quot;</span> + left);<br>                left -= from.transferTo((size - left), left, to);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际传输一个超大文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">position</span>:<span class="hljs-number">0</span> left:<span class="hljs-number">7769948160</span><br><span class="hljs-attribute">position</span>:<span class="hljs-number">2147483647</span> left:<span class="hljs-number">5622464513</span><br><span class="hljs-attribute">position</span>:<span class="hljs-number">4294967294</span> left:<span class="hljs-number">3474980866</span><br><span class="hljs-attribute">position</span>:<span class="hljs-number">6442450941</span> left:<span class="hljs-number">1327497219</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>); <span class="hljs-comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span><br><br>Path source = Paths.get(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 代表了  d:\1.txt</span><br><br>Path source = Paths.get(<span class="hljs-string">&quot;d:/1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 同样代表了  d:\1.txt</span><br><br>Path projects = Paths.get(<span class="hljs-string">&quot;d:\\data&quot;</span>, <span class="hljs-string">&quot;projects&quot;</span>); <span class="hljs-comment">// 代表了  d:\data\projects</span><br></code></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">d:<br><span class="hljs-string">|- data</span><br><span class="hljs-string">|- projects</span><br><span class="hljs-string">|- a</span><br><span class="hljs-string">|- b</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);<br>System.out.println(path);<br>System.out.println(path.normalize()); <span class="hljs-comment">// 正常化路径</span><br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\a</span><span class="hljs-symbol">\.</span>.<span class="hljs-symbol">\b</span><br>d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\b</span><br></code></pre></td></tr></table></figure><h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>System.out.println(Files.exists(path));<br></code></pre></td></tr></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br>Files.createDirectory(path);<br></code></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;helloword/d1/d2&quot;</span>);<br>Files.createDirectories(path);<br></code></pre></td></tr></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>Path target = Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.copy(source, target);<br></code></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);<br></code></pre></td></tr></table></figure><p><strong>Files.copy和FileChannel.transferTo的具体实习不同，但是性能都很好，Files.copy调用了操作系统的系统调用。</strong></p><p>移动文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>Path target = Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><br>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);<br></code></pre></td></tr></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Path target = Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Path target = Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><p>使用Files类的walkFileTree()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Path path = Paths.get(<span class="hljs-string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);<br>    AtomicInteger dirCount = <span class="hljs-keyword">new</span> AtomicInteger();<br>    AtomicInteger fileCount = <span class="hljs-keyword">new</span> AtomicInteger();<br>    Files.walkFileTree(path, <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            System.out.println(dir);<br>            dirCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preVisitDirectory(dir, attrs);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            System.out.println(file);<br>            fileCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitFile(file, attrs);<br>        &#125;<br>    &#125;);<br>    System.out.println(dirCount); <span class="hljs-comment">// 133</span><br>    System.out.println(fileCount); <span class="hljs-comment">// 1479</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面这段代码，使用到了访问者模式。</strong></p><p>统计 jar 的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);<br>AtomicInteger fileCount = <span class="hljs-keyword">new</span> AtomicInteger();<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (file.toFile().getName().endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)) &#123;<br>            fileCount.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitFile(file, attrs);<br>    &#125;<br>&#125;);<br>System.out.println(fileCount); <span class="hljs-comment">// 724</span><br></code></pre></td></tr></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">&quot;d:\\a&quot;</span>);<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Files.delete(file);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitFile(file, attrs);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Files.delete(dir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.postVisitDirectory(dir, exc);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="⚠️-删除很危险"><a href="#⚠️-删除很危险" class="headerlink" title="⚠️ 删除很危险"></a>⚠️ 删除很危险</h4><blockquote><p>删除是危险操作，确保要递归删除的文件夹没有重要内容，调用Files.delete方法是直接删除文件，不会在回收站中保存文件。</p></blockquote><p>拷贝多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>String source = <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;<br>String target = <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;<br><br>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        String targetName = path.toString().replace(source, target);<br>        <span class="hljs-comment">// 是目录</span><br>        <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>            Files.createDirectory(Paths.get(targetName));<br>        &#125;<br>        <span class="hljs-comment">// 是普通文件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Files.isRegularFile(path)) &#123;<br>            Files.copy(path, Paths.get(targetName));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs 阻塞"></a>4.1 非阻塞 vs 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，可能会阻塞线程池中所有线程，因此不适合长连接，只适合<strong>短连接</strong></li></ul></li></ul><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br>ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br>ServerSocketChannel ssc = ServerSocketChannel.open();<br><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    log.debug(<span class="hljs-string">&quot;connecting...&quot;</span>);<br>    SocketChannel sc = ssc.accept(); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>    log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>    channels.add(sc);<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        log.debug(<span class="hljs-string">&quot;before read... &#123;&#125;&quot;</span>, channel);<br>        channel.read(buffer); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>        buffer.flip();<br>        debugRead(buffer);<br>        buffer.clear();<br>        log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SocketChannel sc = SocketChannel.open();<br>sc.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><p>服务器端，客户端代码不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解非阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br>ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br>ServerSocketChannel ssc = ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    SocketChannel sc = ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-keyword">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-keyword">int</span> read = channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><p>IO多路复用是<strong>一种同步的IO模型</strong>。 利用IO多路复用模型，可以实现一个线程监视多个文件句柄；一旦某个文件句柄就绪，就能够通知到对应应用程序进行相应的读写操作；没有文件句柄就绪时就会阻塞应用程序，从而释放出CPU资源。 复用是指复用一个或多个线程资源。</p><h3 id="4-2-Selector"><a href="#4-2-Selector" class="headerlink" title="4.2 Selector"></a>4.2 Selector</h3><pre><code class=" mermaid">graph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end</code></pre><p>好处</p><ul><li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li><li>让这个线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Selector selector = Selector.open();<br></code></pre></td></tr></table></figure><h4 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>SelectionKey key = channel.register(selector, 绑定事件);<br></code></pre></td></tr></table></figure><ul><li><strong>channel 必须工作在非阻塞模式</strong></li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.select();<br></code></pre></td></tr></table></figure><p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.select(<span class="hljs-keyword">long</span> timeout);<br></code></pre></td></tr></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.selectNow();<br></code></pre></td></tr></table></figure><h4 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select() 何时不阻塞"></a>💡 select() 何时不阻塞</h4><p>select() 在事件未处理时，它不会阻塞；没有事件发生、事件发生后被处理、事件发生后被取消（cancel），它会阻塞。总而言之，使用select() 事件发生后要么处理，要么取消，不能置之不理。</p><blockquote><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件，此时select()不会被阻塞，直到事件被处理或者被取消（cancel）</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时，这是因为Java对不同平台的代码实现不同，故而在linux下有bug，至今未被处理。</li></ul></li><li>调用 selector.wakeup()</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul></blockquote><h3 id="4-3-处理-accept-事件"><a href="#4-3-处理-accept-事件" class="headerlink" title="4.3 处理 accept 事件"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)) &#123;<br>            System.out.println(socket);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelDemo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            Selector selector = Selector.open();<br>            channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br><span class="hljs-comment">//                int count = selector.selectNow();</span><br>                log.debug(<span class="hljs-string">&quot;select count: &#123;&#125;&quot;</span>, count);<br><span class="hljs-comment">//                if(count &lt;= 0) &#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br><br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    SelectionKey key = iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        ServerSocketChannel c = (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        SocketChannel sc = c.accept();<br>                        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><blockquote><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p></blockquote><h3 id="4-4-处理-read-事件"><a href="#4-4-处理-read-事件" class="headerlink" title="4.4 处理 read 事件"></a>4.4 处理 read 事件</h3><p><strong>客户端不论是正常断开，还是异常断开，都会不断地触发read事件。不同点是，正常断开时服务器channel.read()返回-1；异常断开直接抛出异常。需要特别注意的是，不论是正常断开(调用Channel.close()方法)，还是异常断开，另外一方都会不断收到read事件，所以在判断断开连接后需要取消掉检测该Channel的read事件的SelectionKey。</strong></p><p><strong>如果一次read事件没有把消息全部读完，那么会触发多个read事件，直到读完发送来的所有消息。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelDemo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            Selector selector = Selector.open();<br>            channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br><span class="hljs-comment">//                int count = selector.selectNow();</span><br>                log.debug(<span class="hljs-string">&quot;select count: &#123;&#125;&quot;</span>, count);<br><span class="hljs-comment">//                if(count &lt;= 0) &#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br><br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    SelectionKey key = iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        ServerSocketChannel c = (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        SocketChannel sc = c.accept();<br>                        sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                        sc.register(selector, SelectionKey.OP_READ);<br>                        log.debug(<span class="hljs-string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        SocketChannel sc = (SocketChannel) key.channel();<br>                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                        <span class="hljs-keyword">int</span> read = sc.read(buffer);<br>                        <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                            sc.close();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buffer.flip();<br>                            debug(buffer);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启两个客户端，修改一下发送文字，输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]<br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230407133032171.png"></p><blockquote><p>因为 selector 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey ，但是ssckey上的accept事件在被处理后标记为已处理。</li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li></ul></blockquote><h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p></blockquote><h4 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️  不处理边界的问题"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket ss=<span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9000</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket s = ss.accept();<br>            InputStream in = s.getInputStream();<br>            <span class="hljs-comment">// 这里这么写，有没有问题</span><br>            <span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> read = in.read(arr);<br>                <span class="hljs-comment">// 这里这么写，有没有问题</span><br>                <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                System.out.println(<span class="hljs-keyword">new</span> String(arr, <span class="hljs-number">0</span>, read));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket max = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9000</span>);<br>        OutputStream out = max.getOutputStream();<br>        out.write(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;你好&quot;</span>.getBytes());<br>        max.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">hell<br>owor<br><span class="hljs-keyword">ld</span>�<br>�好<br><br></code></pre></td></tr></table></figure><p>为什么？</p><h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0023.png"></p><ul><li>一种思路是固定消息长度，数据包大小一样，客户端按预定长度发送，服务器按预定长度读取，缺点是浪费带宽。</li><li>另一种思路是按分隔符拆分，缺点是效率低。这种思路有两个问题，第一如果客户端发送的消息包长度大于服务器的buffer，那么服务器需要扩容（比如buffer的capacity变为2倍），才能容纳这次的消息包；第二个问题是服务器收到消息，需要按分隔符拆分消息包，效率低。</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><pre><code class=" mermaid">sequenceDiagram participant c1 as 客户端1participant s as 服务器participant b1 as ByteBuffer1participant b2 as ByteBuffer2c1 -&gt;&gt; s: 发送 01234567890abcdef3333\rs -&gt;&gt; b1: 第一次 read 存入 01234567890abcdefs -&gt;&gt; b2: 扩容b1 -&gt;&gt; b2: 拷贝 01234567890abcdefs -&gt;&gt; b2: 第二次 read 存入 3333\rb2 -&gt;&gt; b2: 01234567890abcdef3333\r</code></pre><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer source)</span> </span>&#123;<br>    source.flip();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; source.limit(); i++) &#123;<br>        <span class="hljs-comment">// 找到一条完整消息</span><br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-keyword">int</span> length = i + <span class="hljs-number">1</span> - source.position();<br>            <span class="hljs-comment">// 把这条完整消息存入新的 ByteBuffer</span><br>            ByteBuffer target = ByteBuffer.allocate(length);<br>            <span class="hljs-comment">// 从 source 读，向 target 写</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                target.put(source.get());<br>            &#125;<br>            debugAll(target);<br>        &#125;<br>    &#125;<br>    source.compact(); <span class="hljs-comment">// 0123456789abcdef  position 16 limit 16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1. 创建 selector, 管理多个 channel</span><br>    Selector selector = Selector.open();<br>    ServerSocketChannel ssc = ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">// 2. 建立 selector 和 channel 的联系（注册）</span><br>    <span class="hljs-comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span><br>    SelectionKey sscKey = ssc.register(selector, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// key 只关注 accept 事件</span><br>    sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>    log.debug(<span class="hljs-string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);<br>    ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span><br>        <span class="hljs-comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span><br>        selector.select();<br>        <span class="hljs-comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span><br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="hljs-comment">// accept, read</span><br>        <span class="hljs-comment">// 要在集合遍历时，删除，应该使用迭代器，而不是使用增强for</span><br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            SelectionKey key = iter.next();<br>            <span class="hljs-comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span><br>            iter.remove();<br>            log.debug(<span class="hljs-string">&quot;key: &#123;&#125;&quot;</span>, key);<br>            <span class="hljs-comment">// 5. 区分事件类型</span><br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">// 如果是 accept</span><br>                ServerSocketChannel channel = (ServerSocketChannel) key.channel();<br>                SocketChannel sc = channel.accept();<br>                sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>); <span class="hljs-comment">// attachment</span><br>                <span class="hljs-comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span><br>                SelectionKey scKey = sc.register(selector, <span class="hljs-number">0</span>, buffer);<br>                scKey.interestOps(SelectionKey.OP_READ);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                log.debug(<span class="hljs-string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">// 如果是 read</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    SocketChannel channel = (SocketChannel) key.channel(); <span class="hljs-comment">// 拿到触发事件的channel</span><br>                    <span class="hljs-comment">// 获取 selectionKey 上关联的附件</span><br>                    ByteBuffer buffer = (ByteBuffer) key.attachment();<br>                    <span class="hljs-keyword">int</span> read = channel.read(buffer); <span class="hljs-comment">// 如果是正常断开，read 的方法的返回值是 -1</span><br>                    <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                        key.cancel();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        split(buffer);<br>                        <span class="hljs-comment">// 需要扩容</span><br>                        <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;<br>                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="hljs-number">2</span>);<br>                            buffer.flip();<br>                            newBuffer.put(buffer); <span class="hljs-comment">// 0123456789abcdef3333\n</span><br>                            key.attach(newBuffer);<br>                        &#125;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                    key.cancel();  <span class="hljs-comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">SocketChannel sc = SocketChannel.open();<br>sc.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>SocketAddress address = sc.getLocalAddress();<br><span class="hljs-comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span><br>sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;0123\n456789abcdef&quot;</span>));<br>sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;0123456789abcdef3333\n&quot;</span>));<br>System.in.read();<br></code></pre></td></tr></table></figure><h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="4-5-处理-write-事件"><a href="#4-5-处理-write-事件" class="headerlink" title="4.5 处理 write 事件"></a>4.5 处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul><li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li><li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>);<br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><br>        Selector selector = Selector.open();<br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            selector.select();<br><br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                SelectionKey key = iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    SocketChannel sc = ssc.accept();<br>                    sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);<br>                    <span class="hljs-comment">// 1. 向客户端发送内容</span><br>                    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30000000</span>; i++) &#123;<br>                        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    &#125;<br>                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());<br>                    <span class="hljs-keyword">int</span> write = sc.write(buffer);<br>                    <span class="hljs-comment">// 3. write 表示实际写了多少字节</span><br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-comment">// 4. 如果有剩余未读字节，才需要关注写事件</span><br>                    <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                        <span class="hljs-comment">// read 1  write 4</span><br>                        <span class="hljs-comment">// 在原有关注事件的基础上，多关注 写事件</span><br>                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);<br>                        <span class="hljs-comment">// 把 buffer 作为附件加入 sckey</span><br>                        sckey.attach(buffer);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                    ByteBuffer buffer = (ByteBuffer) key.attachment();<br>                    SocketChannel sc = (SocketChannel) key.channel();<br>                    <span class="hljs-keyword">int</span> write = sc.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="hljs-comment">// 写完了</span><br>                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                        key.attach(<span class="hljs-keyword">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Selector selector = Selector.open();<br>        SocketChannel sc = SocketChannel.open();<br>        sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>        sc.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            selector.select();<br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                SelectionKey key = iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                    System.out.println(sc.finishConnect());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                    count += sc.read(buffer);<br>                    buffer.clear();<br>                    System.out.println(count);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注。</p><h3 id="4-6-更进一步"><a href="#4-6-更进一步" class="headerlink" title="4.6 更进一步"></a>4.6 更进一步</h3><h4 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h4><blockquote><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费。</p><p>还有就是单线程处理多种事件，如果其中一种事件复杂度高，那么会影响其他时间的处理，故而像<code>Redis</code>这种单线程程序，不要使用复杂度高的操作，否则会影响其他操作。</p></blockquote><p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230407171106729.png"></p><p><code>Boss</code>线程只处理accept事件，<code>worker0</code>和<code>worker1</code>处理<code>read</code>和<code>write</code>事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelDemo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">new</span> BossEventLoop().register();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> start = <span class="hljs-keyword">false</span>;<br>        AtomicInteger index = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                ServerSocketChannel ssc = ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                boss = Selector.open();<br>                SelectionKey ssckey = ssc.register(boss, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>                ssckey.interestOps(SelectionKey.OP_ACCEPT);<br>                workers = initEventLoops();<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br><span class="hljs-comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span><br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> WorkerEventLoop[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> WorkerEventLoop(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        SelectionKey key = iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            ServerSocketChannel c = (ServerSocketChannel) key.channel();<br>                            SocketChannel sc = c.accept();<br>                            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> start = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">//向队列添加了任务，但这个任务并没有立刻执行</span><br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    SelectionKey sckey = sc.register(worker, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>                    sckey.interestOps(SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    Runnable task = tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        SelectionKey key = iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            SocketChannel sc = (SocketChannel) key.channel();<br>                            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-keyword">int</span> read = sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                    debugAll(buffer);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>Selector.select()的时候会锁住key集合，先select的话，Selector.register()注册就进不去了。</p><p><strong>也可以使用Selector.wakeup()，唤醒Selector对象，即使Selector对象还未被阻塞，Selector.wakeup()就已经运行，下次Selector.select()还是不会被阻塞，因为Selector.wakeup()相当于给Selector对象发了一张不阻塞的门票。</strong></p><h4 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h4><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h4 id="如何设置线程数"><a href="#如何设置线程数" class="headerlink" title="如何设置线程数"></a>如何设置线程数</h4><ul><li>如果任务是cpu密集型任务：那么线程数设置成cpu的核心数比较合适，因为减少了线程之间的上下文切换，尽最大限度利用cpu的时间片完成任务。</li><li>如果任务是io密集型任务：那么线程数设置成大于cpu的核心数比较合适，因为io密集型任务，伴随着cpu的空转情况，故而设置更多的线程数能够最大限度利用cpu的时间片，具体数目参考<strong>阿姆达尔定律</strong>。</li></ul><h3 id="4-7-UDP"><a href="#4-7-UDP" class="headerlink" title="4.7 UDP"></a>4.7 UDP</h3><ul><li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li><li>server 这边的 receive 方法会将接收到的数据存入 bytebuffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li></ul><p>首先启动服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UdpServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;<br>            channel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>            channel.receive(buffer);<br>            buffer.flip();<br>            debug(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">waiting</span></span>...<br></code></pre></td></tr></table></figure><p>运行客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UdpClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;<br>            ByteBuffer buffer = StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>);<br>            InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>);<br>            channel.send(buffer, address);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来服务器端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h2 id="5-NIO-vs-BIO"><a href="#5-NIO-vs-BIO" class="headerlink" title="5. NIO vs BIO"></a>5. NIO vs BIO</h2><h3 id="5-1-stream-vs-channel"><a href="#5-1-stream-vs-channel" class="headerlink" title="5.1 stream vs channel"></a>5.1 stream vs channel</h3><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ul><h3 id="5-2-IO-模型"><a href="#5-2-IO-模型" class="headerlink" title="5.2 IO 模型"></a>5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p><ul><li>同步：线程自己去获取结果（一个线程）</li><li>异步：线程自己不去获取结果，而是由其它线程（比如内核Kernel）送结果（至少两个线程）</li></ul><p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段：比如等待发送端把数据发送过来。</li><li>复制数据阶段：比如把发送端发送来的数据从网卡复制到内存</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0033.png"></p><ul><li><p>阻塞 IO</p><p>在阻塞IO中，用户线程在等待数据和复制数据阶段一直被阻塞，不能处理其他任务。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0039.png"></p></li><li><p>非阻塞  IO</p><p>在非阻塞IO中，用户线程在等待数据阶段不会被阻塞住，可以处理其他任务；但是在复制数据阶段仍然会被阻塞住，不能处理其他任务。用户线程在等待数据阶段调用read()后，不会被阻塞住，会立刻得到返回值，用户线程会得知等待数据阶段是否完成，如果没有完成，可以去处理其他任务，过一段时间再来查询带带数据阶段是否完成。如果等待数据阶段完成，进入复制数据阶段，用户线程会被阻塞住。</p><p>需要注意的是，<strong>由于非阻塞IO在等待数据阶段频繁调用系统函数read()，涉及到多次的用户态和系统态的切换，故而性能不一定比阻塞IO好多少。</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0035.png"></p></li><li><p>多路复用</p><p>IO多路复用是<strong>一种同步的IO模型</strong>。 利用IO多路复用模型，可以实现一个线程监视多个文件句柄；一旦某个文件句柄就绪，就能够通知到对应应用程序进行相应的读写操作；没有文件句柄就绪时就会阻塞应用程序，从而释放出CPU资源。 复用是指复用一个或多个线程资源。多路复用有三种：selector，poll，epoll。</p><p>IO多路复用模型指的是：使用单个进程同时处理多个网络连接IO，他的原理就是select、 poll、 epoll 不断轮询所负责的所有 socket， 当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><p>多路复用，select()方法在等待数据阶段阻塞，等获得SelectionKey之后，调用read()方法又会在复制数据阶段被阻塞。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0038.png"></p></li><li><p>信号驱动</p><p>不太常用，不做了解。</p></li><li><p>异步 IO</p><p>用户进程发起 aio_read 调用之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它发现一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0037.png"></p><p>thread1和thread2是如何通信的呢？在thread1调用read()方法时，定义了一个回调方法(参数)，等到thread2讲数据拷贝到用户空间了，此时thread2会调用thread1定义的回调方法，并把结果作为参数进行返回，以此来达到线程间通信。</p></li><li><p>阻塞 IO vs 多路复用</p><p>阻塞IO只能通过当前事件的结束来结束阻塞，而多路复用可以通过任意注册的事件的发生来结束阻塞。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0034.png"></p><p>而多路复用的select()每次等待事件，可以一次拿到多个SelectionKey，处理多个请求，不需要像阻塞IO那样多次进入等待阶段。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0036.png"></p></li></ul><h4 id="🔖-参考"><a href="#🔖-参考" class="headerlink" title="🔖 参考"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p><h3 id="5-3-零拷贝"><a href="#5-3-零拷贝" class="headerlink" title="5.3 零拷贝"></a>5.3 零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(f, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)f.length()];<br>file.read(buf);<br><br>Socket socket = ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0024.png"></p><ol><li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p><blockquote><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p></li><li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p></li></ol><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级(第一次是调用read()方法从用户态到内核态，第二次是read()方法结束从内核态到用户态，第三次是调用write()方法从用户态切换到内核态)</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p><ul><li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li><li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存（这块操作系统内存比较特殊，Java程序和操作系统均可访问）</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0025.png"></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射（<strong>mmap</strong>）到 jvm 内存中来直接访问使用</p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0026.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203231669.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享，direct memory access（DMA） 直接内存访问，硬件直接支持，不用cpu参与。</li><li>零拷贝适合小文件传输（大文件需要一次性加载到内核缓冲区，会影响其他文件的读取）</li></ul><h3 id="5-3-AIO"><a href="#5-3-AIO" class="headerlink" title="5.3 AIO"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP 实现了真正的异步 IO</li><li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li></ul></blockquote><h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AioDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            AsynchronousFileChannel s = AsynchronousFileChannel.open(Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>),，StandardOpenOption.READ);<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            <span class="hljs-comment">// read参数：</span><br>            <span class="hljs-comment">//参数1 ByteBuffer </span><br>            <span class="hljs-comment">//参数2读取的起始位置 </span><br>            <span class="hljs-comment">//参数3附件 </span><br>            <span class="hljs-comment">//参数4回调对象 CompletionHandler对象</span><br>            s.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;<br>                <span class="hljs-comment">//read成功</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;read completed...&#123;&#125;&quot;</span>, result);<br>                    buffer.flip();<br>                    debug(buffer);<br>                &#125;<br><br>                <span class="hljs-comment">//read失败</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;read failed...&quot;</span>);<br>                &#125;<br>            &#125;);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...<br>13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...<br>13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 0d                                           |a.              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>可以看到</p><ul><li>响应文件读取成功的是另一个线程 Thread-5</li><li>主线程并没有 IO 操作阻塞</li></ul><h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p><h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AioServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();<br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>        ssc.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> AcceptHandler(ssc));<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeChannel</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.printf(<span class="hljs-string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            sc.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompletionHandler</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">ByteBuffer</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (result == -<span class="hljs-number">1</span>) &#123;<br>                    closeChannel(sc);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>                attachment.flip();<br>                System.out.println(Charset.defaultCharset().decode(attachment));<br>                attachment.clear();<br>                <span class="hljs-comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span><br>                sc.read(attachment, attachment, <span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<br>            closeChannel(sc);<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompletionHandler</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">ByteBuffer</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">WriteHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> </span>&#123;<br>            <span class="hljs-comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span><br>            <span class="hljs-keyword">if</span> (attachment.hasRemaining()) &#123;<br>                sc.write(attachment);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<br>            exc.printStackTrace();<br>            closeChannel(sc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcceptHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompletionHandler</span>&lt;<span class="hljs-title">AsynchronousSocketChannel</span>, <span class="hljs-title">Object</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel ssc;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AcceptHandler</span><span class="hljs-params">(AsynchronousServerSocketChannel ssc)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.ssc = ssc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousSocketChannel sc, Object attachment)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 读事件由 ReadHandler 处理</span><br>            sc.read(buffer, buffer, <span class="hljs-keyword">new</span> ReadHandler(sc));<br>            <span class="hljs-comment">// 写事件由 WriteHandler 处理</span><br>            sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="hljs-number">16</span>), <span class="hljs-keyword">new</span> WriteHandler(sc));<br>            <span class="hljs-comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span><br>            ssc.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> </span>&#123;<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="水平触发和边沿触发"><a href="#水平触发和边沿触发" class="headerlink" title="水平触发和边沿触发"></a>水平触发和边沿触发</h4><p>epoll模式下的水平触发、边沿触发</p><p>1，epoll默认是水平触发</p><p>2，水平触发通俗来讲：只要有数据，epoll_wait函数就一直返回；边沿触发通俗来讲：只有socket状态发生变化，epoll_wait函数才会返回。</p><p>3，水平触发优、缺点及应用场景：</p><p>优点：当进行socket通信的时候，保证了数据的完整输出，进行IO操作的时候，如果还有数据，就会一直的通知你。</p><p>缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，所有占用了大量内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。效率来讲也是很低的。</p><p>应用场景：</p><p>4，边沿触发优、缺点及应用场景：</p><p>优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。</p><p>缺点：不能保证数据的完整。不能及时的取出所有的数据。</p><p>应用场景：处理大数据。使用non-block模式的socket。</p><p>总结：</p><p>如果我们用水平触发不用担心数据有没有读完因为下次epoll返回时，没有读完的socket依然会被返回，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满，所以在水平触发模式下我们一般不关注socket可写事件而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次甚至多次，所以有时候我们也会用到边缘触发但是这种模式下在读数据的时候一定要注意，因为如果一次可写事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。</p><h1 id="二-Netty-入门"><a href="#二-Netty-入门" class="headerlink" title="二. Netty 入门"></a>二. Netty 入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Netty-是什么？"><a href="#1-1-Netty-是什么？" class="headerlink" title="1.1 Netty 是什么？"></a>1.1 Netty 是什么？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Netty <span class="hljs-keyword">is</span> an asynchronous event-driven network <span class="hljs-built_in">application</span> framework<br><span class="hljs-keyword">for</span> rapid development <span class="hljs-keyword">of</span> maintainable high performance protocol servers &amp; clients.<br></code></pre></td></tr></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</p><blockquote><p>这里说的异步不是指异步IO，Netty底层使用的还是同步多路复用。这里的异步是指，使用多线程将方法调用和处理结果相分离（二者可以不是同一个线程处理），称为异步。</p></blockquote><h3 id="1-2-Netty-的作者"><a href="#1-2-Netty-的作者" class="headerlink" title="1.2 Netty 的作者"></a>1.2 Netty 的作者</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203427987.png"></p><p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p><h3 id="1-3-Netty-的地位"><a href="#1-3-Netty-的地位" class="headerlink" title="1.3 Netty 的地位"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p><p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p><ul><li>Cassandra - nosql 数据库</li><li>Spark - 大数据分布式计算框架</li><li>Hadoop - 大数据分布式存储框架</li><li>RocketMQ - ali 开源的消息队列</li><li>ElasticSearch - 搜索引擎</li><li>gRPC - rpc 框架</li><li>Dubbo - rpc 框架</li><li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li><li>Zookeeper - 分布式协调框架</li></ul><h3 id="1-4-Netty-的优势"><a href="#1-4-Netty-的优势" class="headerlink" title="1.4 Netty 的优势"></a>1.4 Netty 的优势</h3><ul><li>Netty vs NIO，工作量大，bug 多<ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>epoll 空轮询导致 CPU 100%（linux的epoll多路复用有一个严重的bug，会导致CPU100%，也就是select()方法不能被正常阻塞）</li><li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li></ul></li><li>Netty vs 其它网络应用框架<ul><li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API的向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li><li>久经考验，已经发展了16年，Netty 版本<ul><li>2.x 2004</li><li>3.x 2008</li><li>4.x 2013</li><li>5.x 已废弃（引入AIO，但没有明显的性能提升，维护成本高）</li></ul></li></ul></li></ul><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送 hello, world</li><li>服务器仅接收，不返回</li></ul><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.39.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-服务器端"><a href="#2-2-服务器端" class="headerlink" title="2.2 服务器端"></a>2.2 服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//启动器，负责组装 netty 组件，启动服务器</span><br><span class="hljs-keyword">new</span> ServerBootstrap() <br>    <span class="hljs-comment">//BossEventLoop, WorkerEventLoop(setector, thread), group 组</span><br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup()) <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">//选择 服务器的 ServerSocketChanneL实现</span><br>    .channel(NioServerSocketChannel.class) <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">//boss负责处理连接worker(child)负责处理读写,决定了 worker(child)能执行哪些操作(handler)</span><br>    .childHandler(<br>    <span class="hljs-comment">//channel 代表和客户端进行数据读写的通道 Initializer 初始化,负责添加别的 handler</span><br>    <span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123; <span class="hljs-comment">// 3</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> </span>&#123;<br>            <span class="hljs-comment">//添加具体 handler</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder()); <span class="hljs-comment">// 5 //将 ByteBuf 转换为字符串</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123; <span class="hljs-comment">// 6 //自定义 handler</span><br>                <span class="hljs-meta">@Override</span> <span class="hljs-comment">//读事件</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;<br>                    <span class="hljs-comment">// 打印上一步转换好的字符串</span><br>                    System.out.println(msg);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    <span class="hljs-comment">//绑定监听端口</span><br>    .bind(<span class="hljs-number">8080</span>); <span class="hljs-comment">// 4 </span><br></code></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p></li><li><p>2 处，选择服务 ServerSocketChannel 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203447852.png"></p></li><li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，ServerSocketChannel 绑定的监听端口</p></li><li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p></li><li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p></li></ul><h3 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//启动类，负责组装 netty 组件</span><br><span class="hljs-keyword">new</span> Bootstrap() <br>    <span class="hljs-comment">//添加 EventLoop</span><br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup()) <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">//选择客户端 channel实现</span><br>    .channel(NioSocketChannel.class) <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">//添加处理器</span><br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; <span class="hljs-comment">// 3</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">//在连接建立后被调用</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder()); <span class="hljs-comment">// 8</span><br>        &#125;<br>    &#125;)<br>    <span class="hljs-comment">//连接到服务器</span><br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>) <span class="hljs-comment">// 4</span><br>    .sync() <span class="hljs-comment">// 5</span><br>    .channel() <span class="hljs-comment">// 6</span><br>    <span class="hljs-comment">//向服务器发送数据</span><br>    .writeAndFlush(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;: hello world!&quot;</span>); <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，同 Server</p></li><li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203504493.png"></p></li><li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，指定要连接的服务器和端口</p></li><li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p></li><li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p></li><li><p>7 处，写入消息并清空缓冲区</p></li><li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p></li><li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p></li></ul><h3 id="2-4-流程梳理"><a href="#2-4-流程梳理" class="headerlink" title="2.4 流程梳理"></a>2.4 流程梳理</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203520736.png"></p><h4 id="💡-提示"><a href="#💡-提示" class="headerlink" title="💡 提示"></a>💡 提示</h4><blockquote><p>一开始需要树立正确的观念</p><ul><li>把 channel 理解为数据的通道</li><li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>把 handler 理解为数据的处理工序<ul><li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler 分 Inbound(入站) 和 Outbound(出站) 两类</li></ul></li><li>把 eventLoop 理解为处理数据的工人<ul><li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）<strong>目的是为了线程安全，防止多个线程同时操作同一个channel</strong></li><li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序（非IO操作的工序）指定不同的工人</li></ul></li></ul></blockquote><h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3. 组件"></a>3. 组件</h2><h3 id="3-1-EventLoop"><a href="#3-1-EventLoop" class="headerlink" title="3.1 EventLoop"></a>3.1 EventLoop</h3><p>事件循环对象</p><p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p><p>它的继承关系比较复杂</p><ul><li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><blockquote><p>单线程的线程池的意思是从线程池里拿一个线程，不是线程池里只有一个线程。和一个线程的区别是线程意外结束后，可以立马从线程池里调一个线程</p></blockquote><p>事件循环组</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全），当然Channel上的普通任务和定时任务也会绑定其中一个EventLoop。</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><blockquote><p>NioEventLoopGroup可以处理IO事件、普通任务以及定时任务。</p><p>DefaultEventLoopGroup可以处理普通任务,定时任务</p></blockquote><p>以一个简单的实现为例：</p><p>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span><br>DefaultEventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup(<span class="hljs-number">2</span>); <span class="hljs-comment">//如果不指定线程数，会以操作系统核心数*2作为核心数</span><br></code></pre></td></tr></table></figure><p>使用next()取出EventLoop：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(group.next());<br>System.out.println(group.next());<br>System.out.println(group.next());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">io</span>.netty.channel.DefaultEventLoop@<span class="hljs-number">60</span>f<span class="hljs-number">82</span>f<span class="hljs-number">98</span><br><span class="hljs-attribute">io</span>.netty.channel.DefaultEventLoop@<span class="hljs-number">35</span>f<span class="hljs-number">983</span>a<span class="hljs-number">6</span><br><span class="hljs-attribute">io</span>.netty.channel.DefaultEventLoop@<span class="hljs-number">60</span>f<span class="hljs-number">82</span>f<span class="hljs-number">98</span><br></code></pre></td></tr></table></figure><p>也可以使用 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (EventExecutor eventLoop : group) &#123;<br>    System.out.println(eventLoop);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">io</span>.netty.channel.DefaultEventLoop@<span class="hljs-number">60</span>f<span class="hljs-number">82</span>f<span class="hljs-number">98</span><br><span class="hljs-attribute">io</span>.netty.channel.DefaultEventLoop@<span class="hljs-number">35</span>f<span class="hljs-number">983</span>a<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>使用EventLoop处理普通任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">group.next().submit(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="💡-优雅关闭"><a href="#💡-优雅关闭" class="headerlink" title="💡 优雅关闭"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h4 id="演示-NioEventLoop-处理-io-事件"><a href="#演示-NioEventLoop-处理-io-事件" class="headerlink" title="演示 NioEventLoop 处理 io 事件"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端一个bossEventLoop，两个 nio worker 工人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ServerBootstrap()<br>    <span class="hljs-comment">//一个bossEventLoop两个workerEventLoopGroup</span><br>    <span class="hljs-comment">//bossEventLoop 只负责ServerSocketChannel上的 accept 事件；workerEventLoop 只负责SocketChannel上的读写事件</span><br>    <span class="hljs-comment">//  bossEventLoop只会有一个线程与ServerSocketChannel进行绑定，EventLoopGroup本质上是个线程池，线程池创建线程不是一次性创建的，如果只调用一次，就只创建一个线程。所以这里不论指定几个线程数，最终只会有一个bossEventLoop。</span><br>    <span class="hljs-comment">//workerEventLoop根据自己需求设置线程数</span><br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    ByteBuf byteBuf = msg <span class="hljs-keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">if</span> (byteBuf != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];<br>                        ByteBuf len = byteBuf.readBytes(buf, <span class="hljs-number">0</span>, byteBuf.readableBytes());<br>                        log.debug(<span class="hljs-keyword">new</span> String(buf));<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;).bind(<span class="hljs-number">8080</span>).sync();<br></code></pre></td></tr></table></figure><p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>            .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>))<br>            .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;init...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                &#125;<br>            &#125;)<br>            .channel(NioSocketChannel.class).connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)<br>            .sync()<br>            .channel();<br><br>    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;wangwu&quot;</span>.getBytes()));<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;wangwu&quot;</span>.getBytes()));<br></code></pre></td></tr></table></figure><p>最后输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">34</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - zhangsan       <br><span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - zhangsan       <br><span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">36</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-2]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - lisi           <br><span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">38</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-2]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - lisi           <br><span class="hljs-number">22</span>:<span class="hljs-number">06</span>:<span class="hljs-number">09</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - wangwu        <br><span class="hljs-number">22</span>:<span class="hljs-number">06</span>:<span class="hljs-number">11</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-3-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest</span> - wangwu         <br></code></pre></td></tr></table></figure><p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203539658.png"></p><h4 id="分工细化"><a href="#分工细化" class="headerlink" title="分工细化"></a>分工细化</h4><p>为什么要细分任务，增加DefaultEventLoopGroup呢？这是为了防止增加NioEventLoopGroup的工作量，Netty中的黄金法则，不能阻塞IO线程。</p><p>再增加两个非 nio 工人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoopGroup normalWorkers = <span class="hljs-keyword">new</span> DefaultEventLoopGroup(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">new</span> ServerBootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span>  </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>            ch.pipeline().addLast(normalWorkers,<span class="hljs-string">&quot;myhandler&quot;</span>,<br>              <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    ByteBuf byteBuf = msg <span class="hljs-keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">if</span> (byteBuf != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];<br>                        ByteBuf len = byteBuf.readBytes(buf, <span class="hljs-number">0</span>, byteBuf.readableBytes());<br>                        log.debug(<span class="hljs-keyword">new</span> String(buf));<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;).bind(<span class="hljs-number">8080</span>).sync();<br></code></pre></td></tr></table></figure><p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED<br>22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE<br>22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE<br>22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        <br>22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE<br>22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        <br>22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED<br>22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE<br>22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE<br>22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            <br>22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE<br>22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            <br>22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED<br>22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE<br>22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE<br>22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          <br>22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE<br>22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          <br></code></pre></td></tr></table></figure><p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203554754.png"></p><h4 id="💡-handler-执行中如何换人？"><a href="#💡-handler-执行中如何换人？" class="headerlink" title="💡 handler 执行中如何换人？"></a>💡 handler 执行中如何换人？</h4><p>一个Channel的headler在执行过程中是如何切换线程的呢？就是使用<code>invokeChannelRead()</code>方法调用下一个handler。</p><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 返回下一个handler的EventLoop</span><br>    EventExecutor executor = next.executor();<br>    <br>    <span class="hljs-comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span><br>    <span class="hljs-comment">// 是，直接调用</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123; <span class="hljs-comment">//调用者的EventLoop和当前handler的EventLoop是否相等</span><br>        next.invokeChannelRead(m);<br>    &#125; <br>    <span class="hljs-comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用，不能在当前EventLoop线程直接调用</li></ul><h4 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoopGroup nioWorkers = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br><br>log.debug(<span class="hljs-string">&quot;server start...&quot;</span>);<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>nioWorkers.execute(()-&gt;&#123;<br>    log.debug(<span class="hljs-string">&quot;normal task...&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">22</span>:<span class="hljs-number">30</span>:<span class="hljs-number">36</span> [<span class="hljs-symbol">DEBUG</span>] [main] c.i.o.<span class="hljs-symbol">EventLoopTest2</span> - server start...<br><span class="hljs-number">22</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span> [<span class="hljs-symbol">DEBUG</span>] [nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-1</span>] c.i.o.<span class="hljs-symbol">EventLoopTest2</span> - normal task...<br></code></pre></td></tr></table></figure><blockquote><p>可以用来执行耗时较长的任务</p></blockquote><h4 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoopGroup nioWorkers = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br><br>log.debug(<span class="hljs-string">&quot;server start...&quot;</span>);<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>nioWorkers.scheduleAtFixedRate(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">15</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest2</span> - server start...<br><span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">17</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest2</span> - running...<br><span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest2</span> - running...<br><span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">19</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest2</span> - running...<br><span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">20</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.EventLoopTest2</span> - running...<br>...<br></code></pre></td></tr></table></figure><blockquote><p>可以用来执行定时任务</p></blockquote><h3 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h3><p>channel 的主要作用</p><ul><li>close() 可以用来关闭 channel，这是一个异步操作</li><li>closeFuture() 用来处理 channel 的关闭<ul><li>sync 方法作用是同步等待 channel 关闭</li><li>而 addListener 方法是异步等待 channel 关闭</li></ul></li><li>pipeline() 方法添加处理器</li><li>write() 方法将数据写入，可能不会立刻刷出，因为可能会先存放在缓冲区中</li><li>writeAndFlush() 方法将数据写入并刷出</li></ul><h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p><strong>带有Future， Promise 的类型都是异步方法配套使用，用来正确处理结果</strong></p><p>这时刚才的客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Bootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>        &#125;<br>    &#125;)<br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>) <span class="hljs-comment">//返回ChannelFuture对象</span><br>    .sync()<br>    .channel()<br>    .writeAndFlush(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;: hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><p>现在把它拆开来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>        &#125;<br>    &#125;)<br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>); <span class="hljs-comment">// 1</span><br><br>channelFuture.sync().channel().writeAndFlush(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;: hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li></ul><p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了（真正执行 connect 是 nio 线程）。因此 channelFuture 对象中不能【立刻】获得到正确Channel 对象</p><h5 id="方法一：使用sync-方法同步处理结果"><a href="#方法一：使用sync-方法同步处理结果" class="headerlink" title="方法一：使用sync()方法同步处理结果"></a>方法一：使用sync()方法同步处理结果</h5><p>实验如下：</p><p>在调用sync()方法时，当前线程会被阻塞住，知道nio线程真正完成连接的建立，当前线程才会恢复运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>        &#125;<br>    &#125;)<br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br><br>System.out.println(channelFuture.channel()); <span class="hljs-comment">// 1</span><br>channelFuture.sync(); <span class="hljs-comment">// 2</span><br>System.out.println(channelFuture.channel()); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li><li>执行到 2 时，sync 方法是同步等待连接建立完成</li><li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li></ul><h5 id="方法二：使用-addListener-回调对象-方法异步处理结果"><a href="#方法二：使用-addListener-回调对象-方法异步处理结果" class="headerlink" title="方法二：使用 addListener(回调对象) 方法异步处理结果"></a>方法二：使用 addListener(回调对象) 方法异步处理结果</h5><p>连接建立以后，当前线程也不做处理了，由其他线程进行处理，所以是异步处理结果。</p><p>除了用 <strong>sync 方法</strong>可以让异步操作同步以外，还可以使用<strong>回调的方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>        &#125;<br>    &#125;)<br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>System.out.println(channelFuture.channel()); <span class="hljs-comment">// 1</span><br>channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;<br>    System.out.println(future.channel()); <span class="hljs-comment">// 2</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li><li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code>（在 nio线程连接建立好之后,会调用 operationComplete，传入operationComplete方法的参数，也是当前调用addListener的ChannelFutrue对象）</li></ul><h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseFutureClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-function">NioEventLoopGroup group new <span class="hljs-title">NioEventLoopGroup</span><span class="hljs-params">()</span></span>;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 在连接建立后被调用</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        Channel channel = channelFuture.sync().channel();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, channel);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String line = scanner.nextLine();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(line)) &#123;<br>                    channel.close(); <span class="hljs-comment">// close 异步操作 1s 之后</span><br><span class="hljs-comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(line);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;input&quot;</span>).start();<br><br>        <span class="hljs-comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span><br>        ChannelFuture closeFuture = channel.closeFuture();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *方法一：同步处理关闭</span><br><span class="hljs-comment">         *log.debug(&quot;waiting close...&quot;);</span><br><span class="hljs-comment">         *closeFuture.sync();</span><br><span class="hljs-comment">         *log.debug(&quot;处理关闭之后的操作&quot;);</span><br><span class="hljs-comment">         */</span><br>        <br>        <span class="hljs-comment">// 方式二：异步处理关闭</span><br>        closeFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;处理关闭之后的操作&quot;</span>);<br>                group.shutdownGracefully();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="💡-异步提升的是什么"><a href="#💡-异步提升的是什么" class="headerlink" title="💡 异步提升的是什么"></a>💡 异步提升的是什么</h4><ul><li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p></li><li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p></li><li><p><strong>异步 future 使用主要是将任务进行划子任务，子任务间可以进行并行操作，提高效率。 将任务划分为子任务进行处理 和 每个任务使用一个线程相比，前者并发与任务数无关只与子任务划分数相关。异步提高的是吞吐量。</strong></p></li></ul><p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203612026.png"></p><p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203629813.png"></p><p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，<del>并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</del>处理病人的能力仍然是<code>1 * 8 * 12 = 96</code></p><p>虽然看起来这个例子，好像吞吐量上没有提升，但是假设将挂号的时间缩短，比如只需要1分钟，那么异步处理这个任务，吞吐量会变成原来的<code>60 / 12 = 5</code>倍！！！</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203735319.png"></p><p><strong>时间没变，但是吞吐量变高了，本来30分钟只有4个病人开始处理，netty的异步做法是6个人已经开始处理了。</strong></p><p>要点</p><ul><li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li><li>异步并没有缩短响应时间，反而有所增加；<strong>异步真正增加的是吞吐量</strong></li><li>合理进行任务拆分，也是利用异步的关键</li></ul><h3 id="3-3-Future-amp-Promise"><a href="#3-3-Future-amp-Promise" class="headerlink" title="3.3 Future &amp; Promise"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口<code>Future</code>和<code>Promise</code>接口</p><p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addListener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h4 id="JDK的Future"><a href="#JDK的Future" class="headerlink" title="JDK的Future"></a>JDK的Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 创建线程池</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 2. 提交任务</span><br>        Future&lt;Integer&gt; future = service.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 3. 主线程阻塞住，等待任务结束，并且通过Future对象获取结果。JDK的Future只能同步获得结果</span><br>        Integer result = future.get();<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Netty的Future"><a href="#Netty的Future" class="headerlink" title="Netty的Future"></a>Netty的Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.channel.EventLoop;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.util.concurrent.Future;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 创建EventLoopGroup对象</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 2. 拿到EventLoop对象</span><br>        EventLoop eventLoop = group.next();<br><br>        <span class="hljs-comment">// 3. 提交任务</span><br>        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 3. 主线程阻塞住，等待任务结束，并且通过Future对象获取结果。 这是同步方式。</span><br>        Integer result = future.get();<br>        System.out.println(result);<br>        <br>        <span class="hljs-comment">// 4. 异步获得结果。这是异步方式</span><br>        future.addListener(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-keyword">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-keyword">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Integer result = (Integer) future.getNow();<br>                System.out.println(result);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Netty的Promise"><a href="#Netty的Promise" class="headerlink" title="Netty的Promise"></a>Netty的Promise</h4><p>Netty的Promise的对象可以提前创建好，不想JDK和Netty的Future需要提交任务才能创建。</p><h5 id="例1：同步处理任务成功"><a href="#例1：同步处理任务成功" class="headerlink" title="例1：同步处理任务成功"></a>例1：同步处理任务成功</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 准备 EventLoop对象</span><br>DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br><span class="hljs-comment">// 2. 可以主动创建 promise，它就是一个结果容器</span><br><span class="hljs-comment">//                 参数就是，指定 Promise 对象异步接收结果线程</span><br>DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br><span class="hljs-comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span><br>eventExecutors.execute(()-&gt;&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;set success, &#123;&#125;&quot;</span>,<span class="hljs-number">10</span>);<br>    promise.setSuccess(<span class="hljs-number">10</span>);<br>&#125;);<br><br><span class="hljs-comment">// 4. 接收结果的线程</span><br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class="hljs-comment">// 还没有结果</span><br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,promise.get());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">53</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - start...<br><span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">53</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - null<br><span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">54</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - set success, <span class="hljs-number">10</span><br><span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">54</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h5 id="例2：异步处理任务成功"><a href="#例2：异步处理任务成功" class="headerlink" title="例2：异步处理任务成功"></a>例2：异步处理任务成功</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br>DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br><span class="hljs-comment">// 设置回调，异步接收结果</span><br>promise.addListener(future -&gt; &#123;<br>    <span class="hljs-comment">// 这里的 future 就是上面的 promise</span><br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,future.getNow());<br>&#125;);<br><br><span class="hljs-comment">// 等待 1000 后设置成功结果</span><br>eventExecutors.execute(()-&gt;&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;set success, &#123;&#125;&quot;</span>,<span class="hljs-number">10</span>);<br>    promise.setSuccess(<span class="hljs-number">10</span>);<br>&#125;);<br><br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">30</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - start...<br><span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">31</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - set success, <span class="hljs-number">10</span><br><span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">31</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h5 id="例3：同步处理任务失败-sync-amp-get"><a href="#例3：同步处理任务失败-sync-amp-get" class="headerlink" title="例3：同步处理任务失败 - sync &amp; get"></a>例3：同步处理任务失败 - sync &amp; get</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br>      DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br>      eventExecutors.execute(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">1000</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br>          RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;error...&quot;</span>);<br>          log.debug(<span class="hljs-string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());<br>          promise.setFailure(e);<br>      &#125;);<br><br>      log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>      log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, promise.getNow());<br>      promise.get(); <span class="hljs-comment">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">12</span>:<span class="hljs-number">11</span>:<span class="hljs-number">07</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - start...<br><span class="hljs-number">12</span>:<span class="hljs-number">11</span>:<span class="hljs-number">07</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - null<br><span class="hljs-number">12</span>:<span class="hljs-number">11</span>:<span class="hljs-number">08</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - set failure, java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ExecutionException</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.AbstractFuture</span><span class="hljs-selector-class">.get</span>(AbstractFuture<span class="hljs-selector-class">.java</span>:<span class="hljs-number">41</span>)<br>at com<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.oio</span><span class="hljs-selector-class">.DefaultPromiseTest2</span><span class="hljs-selector-class">.main</span>(DefaultPromiseTest2<span class="hljs-selector-class">.java</span>:<span class="hljs-number">34</span>)<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br>at com<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.oio</span><span class="hljs-selector-class">.DefaultPromiseTest2</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(DefaultPromiseTest2<span class="hljs-selector-class">.java</span>:<span class="hljs-number">27</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.DefaultEventLoop</span><span class="hljs-selector-class">.run</span>(DefaultEventLoop<span class="hljs-selector-class">.java</span>:<span class="hljs-number">54</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SingleThreadEventExecutor$<span class="hljs-number">5</span><span class="hljs-selector-class">.run</span>(SingleThreadEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">918</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.internal</span>.ThreadExecutorMap$<span class="hljs-number">2</span><span class="hljs-selector-class">.run</span>(ThreadExecutorMap<span class="hljs-selector-class">.java</span>:<span class="hljs-number">74</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FastThreadLocalRunnable</span><span class="hljs-selector-class">.run</span>(FastThreadLocalRunnable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br></code></pre></td></tr></table></figure><h5 id="例4：同步处理任务失败-await"><a href="#例4：同步处理任务失败-await" class="headerlink" title="例4：同步处理任务失败 - await"></a>例4：同步处理任务失败 - await</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br>DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br>eventExecutors.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;error...&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());<br>    promise.setFailure(e);<br>&#125;);<br><br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, promise.getNow());<br>promise.await(); <span class="hljs-comment">// 与 sync 和 get 区别在于，不会抛异常</span><br>log.debug(<span class="hljs-string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">53</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - start...<br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">53</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - null<br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">54</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - set failure, java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">54</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - result java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br></code></pre></td></tr></table></figure><h5 id="例5：异步处理任务失败"><a href="#例5：异步处理任务失败" class="headerlink" title="例5：异步处理任务失败"></a>例5：异步处理任务失败</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br>DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br>promise.addListener(future -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());<br>&#125;);<br><br>eventExecutors.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;error...&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());<br>    promise.setFailure(e);<br>&#125;);<br><br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">57</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - start...<br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">58</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - set failure, java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">58</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[defaultEventLoop-1-1]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.o</span><span class="hljs-selector-class">.DefaultPromiseTest2</span> - result java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: error...<br></code></pre></td></tr></table></figure><h5 id="例6：await-死锁检查"><a href="#例6：await-死锁检查" class="headerlink" title="例6：await 死锁检查"></a>例6：await 死锁检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultEventLoop eventExecutors = <span class="hljs-keyword">new</span> DefaultEventLoop();<br>DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);<br><br>eventExecutors.submit(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        promise.await();<br>        <span class="hljs-comment">// 注意不能仅捕获 InterruptedException 异常</span><br>        <span class="hljs-comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span><br>        <span class="hljs-comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; <br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;);<br>eventExecutors.submit(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        promise.await();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.BlockingOperationException</span>: DefaultPromise@<span class="hljs-number">47499</span>c2a(incomplete)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.DefaultPromise</span><span class="hljs-selector-class">.checkDeadLock</span>(DefaultPromise<span class="hljs-selector-class">.java</span>:<span class="hljs-number">384</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.DefaultPromise</span><span class="hljs-selector-class">.await</span>(DefaultPromise<span class="hljs-selector-class">.java</span>:<span class="hljs-number">212</span>)<br>at com<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.oio</span><span class="hljs-selector-class">.DefaultPromiseTest</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(DefaultPromiseTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">27</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.PromiseTask<span class="hljs-variable">$RunnableAdapter</span><span class="hljs-selector-class">.call</span>(PromiseTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">38</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.PromiseTask</span><span class="hljs-selector-class">.run</span>(PromiseTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.DefaultEventLoop</span><span class="hljs-selector-class">.run</span>(DefaultEventLoop<span class="hljs-selector-class">.java</span>:<span class="hljs-number">54</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SingleThreadEventExecutor$<span class="hljs-number">5</span><span class="hljs-selector-class">.run</span>(SingleThreadEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">918</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.internal</span>.ThreadExecutorMap$<span class="hljs-number">2</span><span class="hljs-selector-class">.run</span>(ThreadExecutorMap<span class="hljs-selector-class">.java</span>:<span class="hljs-number">74</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FastThreadLocalRunnable</span><span class="hljs-selector-class">.run</span>(FastThreadLocalRunnable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br>io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.BlockingOperationException</span>: DefaultPromise@<span class="hljs-number">47499</span>c2a(incomplete)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.DefaultPromise</span><span class="hljs-selector-class">.checkDeadLock</span>(DefaultPromise<span class="hljs-selector-class">.java</span>:<span class="hljs-number">384</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.DefaultPromise</span><span class="hljs-selector-class">.await</span>(DefaultPromise<span class="hljs-selector-class">.java</span>:<span class="hljs-number">212</span>)<br>at com<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.oio</span><span class="hljs-selector-class">.DefaultPromiseTest</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">1</span>(DefaultPromiseTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">36</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.PromiseTask<span class="hljs-variable">$RunnableAdapter</span><span class="hljs-selector-class">.call</span>(PromiseTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">38</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.PromiseTask</span><span class="hljs-selector-class">.run</span>(PromiseTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.DefaultEventLoop</span><span class="hljs-selector-class">.run</span>(DefaultEventLoop<span class="hljs-selector-class">.java</span>:<span class="hljs-number">54</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SingleThreadEventExecutor$<span class="hljs-number">5</span><span class="hljs-selector-class">.run</span>(SingleThreadEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">918</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.internal</span>.ThreadExecutorMap$<span class="hljs-number">2</span><span class="hljs-selector-class">.run</span>(ThreadExecutorMap<span class="hljs-selector-class">.java</span>:<span class="hljs-number">74</span>)<br>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FastThreadLocalRunnable</span><span class="hljs-selector-class">.run</span>(FastThreadLocalRunnable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br><br></code></pre></td></tr></table></figure><h3 id="3-4-Handler-amp-Pipeline"><a href="#3-4-Handler-amp-Pipeline" class="headerlink" title="3.4 Handler &amp; Pipeline"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p><ul><li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><p>先搞清楚顺序，服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ServerBootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 1</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">2</span>);<br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 2</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">3</span>);<br>                    ctx.channel().write(msg); <span class="hljs-comment">// 3</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="hljs-params"><span class="hljs-function">                                  ChannelPromise promise)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">4</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 4</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="hljs-params"><span class="hljs-function">                                  ChannelPromise promise)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">5</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 5</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="hljs-params"><span class="hljs-function">                                  ChannelPromise promise)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-number">6</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 6</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Bootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>        &#125;<br>    &#125;)<br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>)<br>    .addListener((ChannelFutureListener) future -&gt; &#123;<br>        future.channel().writeAndFlush(<span class="hljs-string">&quot;hello,world&quot;</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure><p>服务器端打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>6<br>5<br>4<br></code></pre></td></tr></table></figure><p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表。这里Netty会帮助程序员自动创建位于链首和链尾的head和tail这两个Handler。<strong>需要注意的是，入站处理器不一定要在出站处理器前面，这里入站处理器和出站处理器的顺序是根据业务来的。</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203752899.png"></p><ul><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul></li><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul></li><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul></li><li>ctx.channel().write(msg) vs ctx.write(msg)<ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了（<strong>假设节点3之前有出站处理器，那么还是会调用节点3之前的处理器</strong>）</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li></ul></li></ul><p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><ul><li>入站是从<code>head</code>开始向后传递，直到传递到<code>tail</code></li><li>出站是从<code>tail</code>开始向前传递，直到传递到<code>head</code></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203806667.png"></p><h4 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h4><p>EmbenddedChannel是Netty用来测试的一个类，这样每次测试不需要再重新写一个客户端一个服务端了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOutboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPromise;<br><span class="hljs-keyword">import</span> io.netty.channel.embedded.EmbeddedChannel;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ChannelInboundHandlerAdapter handler1 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br>        ChannelInboundHandlerAdapter handler2 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br>        ChannelInboundHandlerAdapter handler3 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br>        ChannelOutboundHandlerAdapter handler4 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">4</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br>        ChannelOutboundHandlerAdapter handler5 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">5</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br>        ChannelOutboundHandlerAdapter handler6 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-number">6</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br>        EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel(handler1, handler2, handler3, handler4, handler5, handler6);<br>        <span class="hljs-comment">// 1. 模拟入站操作</span><br>        embeddedChannel.writeInbound(<span class="hljs-string">&quot;inbound&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 模拟出站操作</span><br>        embeddedChannel.writeOutbound(<span class="hljs-string">&quot;oubound&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>-------------------------<br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="3-5-ByteBuf"><a href="#3-5-ByteBuf" class="headerlink" title="3.5 ByteBuf"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p><h4 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">10</span>);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p><p>输出</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">read</span> <span class="hljs-keyword">index</span>:<span class="hljs-number">0</span> <span class="hljs-keyword">write</span> <span class="hljs-keyword">index</span>:<span class="hljs-number">0</span> capacity:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>其中 log 方法参考如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buffer)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = buffer.readableBytes();<br>    <span class="hljs-keyword">int</span> rows = length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）直接内存-vs-堆内存"><a href="#2）直接内存-vs-堆内存" class="headerlink" title="2）直接内存 vs 堆内存"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>堆内存创建和销毁的代价昂贵，但读写性能差（内存复制次数多）</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><h4 id="3）池化-vs-非池化"><a href="#3）池化-vs-非池化" class="headerlink" title="3）池化 vs 非池化"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量（即JVM参数）来设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h4 id="4）组成"><a href="#4）组成" class="headerlink" title="4）组成"></a>4）组成</h4><p>ByteBuf 由四部分组成</p><p>默认的<code>max capacity </code>= <code>Integer.MAX_VALUE</code>，所以ByteBuf不能无限制的扩容。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203822223.png"></p><p>最开始读写指针都在 0 位置</p><h5 id="ByteBuf和ByteBuffer相比"><a href="#ByteBuf和ByteBuffer相比" class="headerlink" title="ByteBuf和ByteBuffer相比"></a>ByteBuf和ByteBuffer相比</h5><ul><li>ByteBuffer的读写指针共用，所以在读写之前，需要切换对应的读写模式；ByteBuf读写指针分离，所以读写操作不需要先切换模式，直接开始读写操作。</li><li>ByteBuffer对象一经创建，其容量不可变；但是ByteBuf对象可以根据写操作自动扩容</li><li>ByteBuf有池化功能，ByteBuffer没有池化功能</li></ul><h4 id="5）写入"><a href="#5）写入" class="headerlink" title="5）写入"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td>writebyte把Java四个字节的有效位写进去，一个字节</td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入，先写入大端），即 0x250，写入后 00 00 02 50<strong>一般网路编程采用打断写入</strong></td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入，先写入小端），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li><li>网络传输，默认习惯是 Big Endian</li></ul></blockquote><p>先写入 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:4 capacity:10<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeInt(<span class="hljs-number">5</span>);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:8 capacity:10<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p><h4 id="6）扩容"><a href="#6）扩容" class="headerlink" title="6）扩容"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeInt(<span class="hljs-number">6</span>);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>扩容规则是</p><ul><li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li><li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li><li>扩容不能超过 max capacity 会报错</li></ul><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="7）读取"><a href="#7）读取" class="headerlink" title="7）读取"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>log(buffer);<br></code></pre></td></tr></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1<br>2<br>3<br>4<br>read index:4 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.markReaderIndex();<br>System.out.println(buffer.readInt());<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br>read index:8 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 06                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.resetReaderIndex();<br>log(buffer);<br></code></pre></td></tr></table></figure><p>这时</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:4 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index。</p><h4 id="8）retain-amp-release-方法"><a href="#8）retain-amp-release-方法" class="headerlink" title="8）retain() &amp; release()方法"></a>8）retain() &amp; release()方法</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，虽然直接内存也可以等到GC回收时，间接触发直接内存的回收，但是这种效率比较慢，并且不及时。可以通过特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><blockquote><p>回收内存的源码实现，请关注下面方法的不同实现</p><p><code>protected abstract void deallocate()</code></p></blockquote><p>Netty 这里采用了<strong>引用计数法</strong>来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><p>谁来负责调用 release() 方法呢？</p><p>不是我们想象的（一般情况下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buf = ...<br><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    buf.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p><ul><li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li><li>入站 ByteBuf 处理原则<ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li><li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li><li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li><li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li>出站 ByteBuf 处理原则<ul><li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li></ul></li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><p>TailContext 释放入站未处理ByteBuf逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<br>            <span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +<br>            <span class="hljs-string">&quot;Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ReferenceCounted) &#123;<br>        <span class="hljs-keyword">return</span> ((ReferenceCounted) msg).release();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>HeadContext 释放出站未处理ByteBuf逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.HeadContext</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.unsafe.write(msg, promise);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.assertEventLoop();<br>    ChannelOutboundBuffer outboundBuffer = <span class="hljs-keyword">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.safeSetFailure(promise, <span class="hljs-keyword">this</span>.newClosedChannelException(AbstractChannel.<span class="hljs-keyword">this</span>.initialCloseCause));<br>        ReferenceCountUtil.release(msg); <span class="hljs-comment">// 释放ByteBuf</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> size;<br>        <span class="hljs-keyword">try</span> &#123;<br>            msg = AbstractChannel.<span class="hljs-keyword">this</span>.filterOutboundMessage(msg);<br>            size = AbstractChannel.<span class="hljs-keyword">this</span>.pipeline.estimatorHandle().size(msg);<br>            <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;<br>                size = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var6) &#123;<br>            <span class="hljs-keyword">this</span>.safeSetFailure(promise, var6);<br>            ReferenceCountUtil.release(msg);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        outboundBuffer.addMessage(msg, size, promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9）slice-方法"><a href="#9）slice-方法" class="headerlink" title="9）slice()方法"></a>9）slice()方法</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p><p><strong>需要注意的是，切片后的ByteBuf的max capacity被固定为该切片的大小，不能实行追加写操作，但是可以在该切片大小内修改值。</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203838719.png"></p><p>例，原始 ByteBuf 进行一些初始操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">10</span>);<br>origin.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>origin.readByte();<br>System.out.println(ByteBufUtil.prettyHexDump(origin));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 02 03 04                                        |...             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf slice = origin.slice();<br>System.out.println(ByteBufUtil.prettyHexDump(slice));<br><span class="hljs-comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 02 03 04                                        |...             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">origin.readByte();<br>System.out.println(ByteBufUtil.prettyHexDump(origin));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 03 04                                           |..              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这时的 slice 不受影响，因为它有独立的读写指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ByteBufUtil.prettyHexDump(slice));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 02 03 04                                        |...             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>如果 slice 的内容发生了更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">slice.setByte(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>System.out.println(ByteBufUtil.prettyHexDump(slice));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 02 03 05                                        |...             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufUtil</span>.</span></span>pretty<span class="hljs-constructor">HexDump(<span class="hljs-params">origin</span>)</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 03 05                                           |..              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是：</p><p>如果原始ByteBuf或者该对象的切片调用release()方法并且导致该对象被释放，此时原始的ByteBuf对象和所有的切片也被释放掉了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufAllocator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">10</span>);<br>        ByteBuf slice = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        slice.release();<br>        System.out.println(buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>&#125;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; io.netty.util.IllegalReferenceCountException: refCnt: 0<br>at io.netty.buffer.AbstractByteBuf.ensureAccessible(AbstractByteBuf.java:1464)<br>at io.netty.buffer.AbstractByteBuf.ensureWritable0(AbstractByteBuf.java:279)<br>at io.netty.buffer.AbstractByteBuf.ensureWritable(AbstractByteBuf.java:274)<br>at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1081)<br>at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1089)<br>at Test.main(Test.java:16)<br></code></pre></td></tr></table></figure></blockquote><h4 id="10）duplicate-方法"><a href="#10）duplicate-方法" class="headerlink" title="10）duplicate()方法"></a>10）duplicate()方法</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制（意思是可以追加写入），也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203854042.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufAllocator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">10</span>);<br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        ByteBuf slice = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf duplicate = slice.duplicate();<br>        duplicate.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">6</span>&#125;);<br>        System.out.println(buffer.toString());<br>        System.out.println(slice.toString());<br>        System.out.println(duplicate.toString());<br>        System.out.println(buffer.getByte(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">PooledUnsafeDirectByteBuf(ridx: <span class="hljs-number">0</span>, widx: <span class="hljs-number">5</span>, cap: <span class="hljs-number">10</span>)<br>UnpooledSlicedByteBuf(ridx: <span class="hljs-number">0</span>, widx: <span class="hljs-number">5</span>, cap: <span class="hljs-number">5</span>/<span class="hljs-number">5</span>, unwrapped: PooledUnsafeDirectByteBuf(ridx: <span class="hljs-number">0</span>, widx: <span class="hljs-number">5</span>, cap: <span class="hljs-number">10</span>))<br>UnpooledDuplicatedByteBuf(ridx: <span class="hljs-number">0</span>, widx: <span class="hljs-number">6</span>, cap: <span class="hljs-number">10</span>, unwrapped: PooledUnsafeDirectByteBuf(ridx: <span class="hljs-number">0</span>, widx: <span class="hljs-number">5</span>, cap: <span class="hljs-number">10</span>))<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="11）copy-方法"><a href="#11）copy-方法" class="headerlink" title="11）copy()方法"></a>11）copy()方法</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关。</p><h4 id="12）CompositeByteBuf类"><a href="#12）CompositeByteBuf类" class="headerlink" title="12）CompositeByteBuf类"></a>12）CompositeByteBuf类</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p><p>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf2.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br>System.out.println(ByteBufUtil.prettyHexDump(buf1));<br>System.out.println(ByteBufUtil.prettyHexDump(buf2));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buf3 = ByteBufAllocator.DEFAULT<br>    .buffer(buf1.readableBytes()+buf2.readableBytes());<br>buf3.writeBytes(buf1).writeBytes(buf2);<br>System.out.println(ByteBufUtil.prettyHexDump(buf3));<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();<br><span class="hljs-comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span><br>buf3.addComponents(<span class="hljs-keyword">true</span>, buf1, buf2);<br></code></pre></td></tr></table></figure><p>结果是一样的</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><h4 id="13）Unpooled工具类"><a href="#13）Unpooled工具类" class="headerlink" title="13）Unpooled工具类"></a>13）Unpooled工具类</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p><p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf2.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br><span class="hljs-comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span><br>ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);<br>System.out.println(ByteBufUtil.prettyHexDump(buf3));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buf4 = Unpooled.wrappedBuffer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;);<br>System.out.println(buf4.getClass());<br>System.out.println(ByteBufUtil.prettyHexDump(buf4));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">class io.netty.buffer.CompositeByteBuf<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul><h2 id="4-双向通信"><a href="#4-双向通信" class="headerlink" title="4. 双向通信"></a>4. 双向通信</h2><h3 id="4-1-练习"><a href="#4-1-练习" class="headerlink" title="4.1 练习"></a>4.1 练习</h3><p>实现一个 echo server</p><p>编写 server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ServerBootstrap()<br>    .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    ByteBuf buffer = (ByteBuf) msg;<br>                    System.out.println(buffer.toString(Charset.defaultCharset()));<br><br>                    <span class="hljs-comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span><br>                    ByteBuf response = ctx.alloc().buffer();<br>                    response.writeBytes(buffer);<br>                    ctx.writeAndFlush(response);<br><br>                    <span class="hljs-comment">// 思考：需要释放 buffer 吗         答：需要，因为buffer没有向后传递，所以必须在这里释放</span><br>                    <span class="hljs-comment">// 思考：需要释放 response 吗答：不需要，因为response进入了出站操作，HeadContext会进行释放，这里可以不用释放</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;).bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>编写 client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>    .group(group)<br>    .channel(NioSocketChannel.class)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>                    ByteBuf buffer = (ByteBuf) msg;<br>                    System.out.println(buffer.toString(Charset.defaultCharset()));<br><br>                    <span class="hljs-comment">// 思考：需要释放 buffer 吗答：需要释放buffer，因为buffer没有向后传递了。</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;).connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br><br>channel.closeFuture().addListener(future -&gt; &#123;<br>    group.shutdownGracefully();<br>&#125;);<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        String line = scanner.nextLine();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(line)) &#123;<br>            channel.close();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        channel.writeAndFlush(line);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h3 id="💡-读和写的误解"><a href="#💡-读和写的误解" class="headerlink" title="💡 读和写的误解"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        Socket s = ss.accept();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(s.getInputStream()));<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    System.out.println(reader.readLine());<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(s.getOutputStream()));<br>                <span class="hljs-comment">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    writer.write(String.valueOf(i));<br>                    writer.newLine();<br>                    writer.flush();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket s = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(s.getInputStream()));<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    System.out.println(reader.readLine());<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(s.getOutputStream()));<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    writer.write(String.valueOf(i));<br>                    writer.newLine();<br>                    writer.flush();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-Netty-进阶"><a href="#三-Netty-进阶" class="headerlink" title="三. Netty 进阶"></a>三. Netty 进阶</h1><h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1. 粘包与半包"></a>1. 粘包与半包</h2><h3 id="1-1-粘包现象"><a href="#1-1-粘包现象" class="headerlink" title="1.1 粘包现象"></a>1.1 粘包现象</h3><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            <span class="hljs-comment">// 调整系统的接受缓冲区（滑动窗口），但是TCP协议自己有拥塞控制算法，不用手动指定滑动窗口的大小</span><br>            serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br>            <span class="hljs-comment">// 调整 Netty 的接受缓冲区大小（ByteBuf）</span><br>            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, <span class="hljs-keyword">new</span> AdaptiveRecvByteBufAllocator(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>));<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stoped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> HelloWorldServer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-comment">// 会在连接 channel 建立成功后，会触发 active 事件</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            Random r = <span class="hljs-keyword">new</span> Random();<br>                            <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                ByteBuf buffer = ctx.alloc().buffer();<br>                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tap">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...<br>08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000030|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000040|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000050|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000060|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000070|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000080|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000090|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE<br></code></pre></td></tr></table></figure><h3 id="1-2-半包现象"><a href="#1-2-半包现象" class="headerlink" title="1.2 半包现象"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ctx.alloc().buffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>&#125;<br>ctx.writeAndFlush(buffer);<br></code></pre></td></tr></table></figure><p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tap">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...<br>08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000010|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000020|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000030|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000040|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000050|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000060|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000070|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000080|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f             |............    |<br>+--------+-------------------------------------------------+----------------+<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p></blockquote><h3 id="1-3-现象分析"><a href="#1-3-现象分析" class="headerlink" title="1.3 现象分析"></a>1.3 现象分析</h3><p>粘包</p><ul><li>现象，发送 abc def，接收 abcdef</li><li>原因<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024字节）</li><li>滑动窗口（<strong>TCP原因\接收方原因</strong>）：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法（<strong>TCP原因\发送方原因</strong>）：会造成粘包</li></ul></li></ul><p>半包</p><ul><li>现象，发送 abcdef，接收 abc def</li><li>原因<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口（<strong>TCP原因\接收方原因</strong>）：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS 限制（<strong>数据链路层MTU原因\发送方原因</strong>）：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包。MSS（Maximum Segment Size）是传输层分段的单位，一般是1460字节，是根据数据链路层的MTU：Maximum Transmission Unit，最大传输单元  计算而来</li></ul></li></ul><p>本质是因为 TCP 是流式协议，消息无边界</p><blockquote><p>滑动窗口</p><ul><li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503203949390.png"></p></li></ul><ul><li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503204003160.png"></p></li><li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p><ul><li>图中深色的部分即要发送的数据，高亮的部分即窗口</li><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li><li>滑动窗口大小是在TCP通信过程中，协议自动调整大小的</li></ul></li></ul></blockquote><blockquote><p> MSS 限制</p><ul><li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p></li><li><p>以太网的 MTU 是 1500</p></li><li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p></li><li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p></li><li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</p></li><li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p></li><li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p></li></ul><p>  <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503204023132.png"></p></blockquote><blockquote><p>Nagle 算法</p><ul><li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li><li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul><li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li><li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li><li>如果 TCP_NODELAY = true，则需要发送</li><li>已发送的数据都收到 ack 时，则需要发送</li><li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li><li>除上述情况，延迟发送</li></ul></li></ul></blockquote><h3 id="1-4-解决方案"><a href="#1-4-解决方案" class="headerlink" title="1.4 解决方案"></a>1.4 解决方案</h3><ol><li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li><li>每一条消息采用固定长度，缺点浪费空间</li><li>每一条消息采用分隔符，例如 \n，缺点需要转义</li><li>每一条消息分为 head 和 body，head 中包含 body 的长度</li></ol><h4 id="方法1，短链接"><a href="#方法1，短链接" class="headerlink" title="方法1，短链接"></a>方法1，短链接</h4><p>以解决粘包为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 分 10 次发送</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            send();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;conneted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            ByteBuf buffer = ctx.alloc().buffer();<br>                            buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                            ctx.writeAndFlush(buffer);<br>                            <span class="hljs-comment">// 发完即关</span><br>                            ctx.close();<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出，略</p><blockquote><p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p></blockquote><h4 id="方法2，固定长度"><a href="#方法2，固定长度" class="headerlink" title="方法2，固定长度"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230410211505218.png"></p><p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 发送内容随机的数据包</span><br>                            Random r = <span class="hljs-keyword">new</span> Random();<br>                            <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            ByteBuf buffer = ctx.alloc().buffer();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>];<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r.nextInt(<span class="hljs-number">8</span>); j++) &#123;<br>                                    bytes[j] = (<span class="hljs-keyword">byte</span>) c;<br>                                &#125;<br>                                c++;<br>                                buffer.writeBytes(bytes);<br>                            &#125;<br>                            ctx.writeAndFlush(buffer);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;192.168.0.103&quot;</span>, <span class="hljs-number">9090</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 62 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |aaaa....b.......|<br>|00000010|<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 64 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |cc......d.......|<br>|00000020|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |........ffff....|<br>|00000030|<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 68 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |ggg.....h.......|<br>|00000040|<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>00<span class="hljs-number"> 00 </span>00 6a 6a 6a 6a<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |iiiii...jjjj....|<br>+--------+-------------------------------------------------+----------------+<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...<br>12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE<br></code></pre></td></tr></table></figure><p>缺点是，数据包的大小不好把握</p><ul><li>长度定的太大，浪费</li><li>长度定的太小，对某些数据包又显得不够</li></ul><h4 id="方法3，固定分隔符"><a href="#方法3，固定分隔符" class="headerlink" title="方法3，固定分隔符"></a>方法3，固定分隔符</h4><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">1024</span>));<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230410211631691.png"></p><p>或者服务端使用自定义分隔符Decoder消息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230410211832559.png"></p><p>客户端在每条消息之后，加入 \n 分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            Random r = <span class="hljs-keyword">new</span> Random();<br>                            <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            ByteBuf buffer = ctx.alloc().buffer();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= r.nextInt(<span class="hljs-number">16</span>)+<span class="hljs-number">1</span>; j++) &#123;<br>                                    buffer.writeByte((<span class="hljs-keyword">byte</span>) c);<br>                                &#125;<br>                                buffer.writeByte(<span class="hljs-number">10</span>);<br>                                c++;<br>                            &#125;<br>                            ctx.writeAndFlush(buffer);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;192.168.0.103&quot;</span>, <span class="hljs-number">9090</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 61 </span>0a<span class="hljs-number"> 62 </span>62<span class="hljs-number"> 62 </span>0a<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 63 </span>0a<span class="hljs-number"> 64 </span>64 0a<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>|a.bbb.ccc.dd.eee|<br>|00000010|<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>0a<span class="hljs-number"> 66 </span>66 0a<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>|eeeeeee.ff.ggggg|<br>|00000020|<span class="hljs-number"> 67 </span>67 0a<span class="hljs-number"> 68 </span>68<span class="hljs-number"> 68 </span>68 0a<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>0a |gg.hhhh.iiiiiii.|<br>|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |<br>+--------+-------------------------------------------------+----------------+<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]<br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61                                              |a               |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62                                        |bbb             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 63                                        |ccc             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 64 64                                           |dd              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 66                                           |ff              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE<br></code></pre></td></tr></table></figure><p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p><h4 id="方法4，预设长度"><a href="#方法4，预设长度" class="headerlink" title="方法4，预设长度"></a>方法4，预设长度</h4><h5 id="帧解码器LengthFieldBasedFrameDecoder"><a href="#帧解码器LengthFieldBasedFrameDecoder" class="headerlink" title="帧解码器LengthFieldBasedFrameDecoder"></a>帧解码器<code>LengthFieldBasedFrameDecoder</code></h5><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p><p>使用<code>Netty</code>里的**帧解码器<code>LengthFieldBasedFrameDecoder</code>**来处理黏包半包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最大长度，长度字段偏移，长度字段占用字节，长度字段为基准还有几个字节之后是内容字节，从头剥离字节数</span><br><span class="hljs-comment">// maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230410220029654.png"></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            Random r = <span class="hljs-keyword">new</span> Random();<br>                            <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            ByteBuf buffer = ctx.alloc().buffer();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-keyword">byte</span> length = (<span class="hljs-keyword">byte</span>) (r.nextInt(<span class="hljs-number">16</span>) + <span class="hljs-number">1</span>);<br>                                <span class="hljs-comment">// 先写入长度</span><br>                                buffer.writeByte(length);<br>                                <span class="hljs-comment">// 再</span><br>                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= length; j++) &#123;<br>                                    buffer.writeByte((<span class="hljs-keyword">byte</span>) c);<br>                                &#125;<br>                                c++;<br>                            &#125;<br>                            ctx.writeAndFlush(buffer);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;192.168.0.103&quot;</span>, <span class="hljs-number">9090</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 09 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 09 </span>62<span class="hljs-number"> 62 </span>62<span class="hljs-number"> 62 </span>62 |.aaaaaaaaa.bbbbb|<br>|00000010|<span class="hljs-number"> 62 </span>62<span class="hljs-number"> 62 </span>62<span class="hljs-number"> 06 </span>63<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 63 </span>08<span class="hljs-number"> 64 </span>64<span class="hljs-number"> 64 </span>64 |bbbb.cccccc.dddd|<br>|00000020|<span class="hljs-number"> 64 </span>64<span class="hljs-number"> 64 </span>64 0f<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>|dddd.eeeeeeeeeee|<br>|00000030|<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65 0d<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>|eeee.fffffffffff|<br>|00000040|<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 02 </span>67<span class="hljs-number"> 67 </span>02<span class="hljs-number"> 68 </span>68 0e<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>|ff.gg.hh.iiiiiii|<br>|00000050|<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|<br>|00000060| 6a                                              |j               |<br>+--------+-------------------------------------------------+----------------+<br>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...<br>14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...<br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED<br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE<br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]<br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 67 67                                           |gg              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 68                                           |hh              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE<br><br></code></pre></td></tr></table></figure><h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2. 协议设计与解析"></a>2. 协议设计与解析</h2><h3 id="2-1-为什么需要协议？"><a href="#2-1-为什么需要协议？" class="headerlink" title="2.1 为什么需要协议？"></a>2.1 为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p><p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p><p>例如：在网络上传输</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">下雨天留客天留我不留<br></code></pre></td></tr></table></figure><p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p><p>一种解读</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">下雨天留客，天留，我不留<br></code></pre></td></tr></table></figure><p>另一种解读</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">下雨天，留客天，留我不？留<br></code></pre></td></tr></table></figure><p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定长字节表示内容长度 + 实际内容<br></code></pre></td></tr></table></figure><p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0f</span>下雨天留客<span class="hljs-number">06</span>天留<span class="hljs-number">09</span>我不留<br></code></pre></td></tr></table></figure><blockquote><p>小故事</p><p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p><p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p><p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p><p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p><p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p></blockquote><h3 id="2-2-redis-协议举例"><a href="#2-2-redis-协议举例" class="headerlink" title="2.2 redis 协议举例"></a>2.2 redis 协议举例</h3><p>先发送<code>*N</code>，代表该指令N个参数；然后依次发送每个参数，<code>$M</code>，代表该参数M个字符，以上每个字符长度以及参数之间都使用回车换行进行隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">byte</span>[] LINE = &#123;<span class="hljs-number">13</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>    bootstrap.channel(NioSocketChannel.class);<br>    bootstrap.group(worker);<br>    bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler());<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                <span class="hljs-comment">// 会在连接 channel 建立成功后，会触发 active 事件</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>                    set(ctx);<br>                    get(ctx);<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>                    ByteBuf buf = ctx.alloc().buffer();<br>                    buf.writeBytes(<span class="hljs-string">&quot;*2&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;get&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;aaa&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    ctx.writeAndFlush(buf);<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>                    ByteBuf buf = ctx.alloc().buffer();<br>                    buf.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;aaa&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    buf.writeBytes(<span class="hljs-string">&quot;bbb&quot;</span>.getBytes());<br>                    buf.writeBytes(LINE);<br>                    ctx.writeAndFlush(buf);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(buf.toString(Charset.defaultCharset()));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>    ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>).sync(); <span class="hljs-comment">// 连接Redis客户端</span><br>    channelFuture.channel().closeFuture().sync();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    worker.shutdownGracefully();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-http-协议举例"><a href="#2-3-http-协议举例" class="headerlink" title="2.3 http 协议举例"></a>2.3 http 协议举例</h3><p>Netty已经实现好了<code>Redis</code>、<code>HTTP</code>等等协议，可以直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><span class="hljs-keyword">try</span> &#123;<br>    ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    serverBootstrap.channel(NioServerSocketChannel.class);<br>    serverBootstrap.group(boss, worker);<br>    serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec()); <span class="hljs-comment">// 对HTTP报文进行编解码，Codec就是既包含解码又包含编码</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123; <span class="hljs-comment">// 该Handler只处理泛型类型消息</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-comment">// 获取请求行</span><br>                    log.debug(msg.uri());<br>                    <span class="hljs-comment">// 获取请求头</span><br>                    log.debug(msg.headers);<br><br>                    <span class="hljs-comment">// 返回响应</span><br>                    DefaultFullHttpResponse response =<br>                            <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<br><br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();<br><br>                    response.headers().setInt(CONTENT_LENGTH, bytes.length); <span class="hljs-comment">//设置长度，HTTP1.1及其之后都是长连接，如果是短链接，发送完就关闭了，浏览器认为数据接收完了，但是长连接下不给长度标识是浏览器无法感知到底数据接收完没有。</span><br>                    response.content().writeBytes(bytes);<br><br>                    <span class="hljs-comment">// 写回响应</span><br>                    ctx.writeAndFlush(response);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span><br><span class="hljs-comment">                @Override</span><br><span class="hljs-comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="hljs-comment">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;);*/</span><br>        &#125;<br>    &#125;);<br>    ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync();<br>    channelFuture.channel().closeFuture().sync();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    boss.shutdownGracefully();<br>    worker.shutdownGracefully();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-自定义协议要素"><a href="#2-4-自定义协议要素" class="headerlink" title="2.4 自定义协议要素"></a>2.4 自定义协议要素</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 1. 4 字节的魔数</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        <span class="hljs-comment">// 2. 1 字节的版本,</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span><br>        out.writeByte(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 4. 1 字节的指令类型(虽然参数是int类型，但是ByteBuf.writeByte()把Java四个字节的有效位写进去，一个字节)</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 5. 4 个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 无意义，对齐填充，让该协议头的字节长度是2的n次方倍</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br>        <span class="hljs-comment">// 6. 获取内容的字节数组</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-keyword">byte</span>[] bytes = bos.toByteArray();<br>        <span class="hljs-comment">// 7. 长度，4 字节</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 8. 写入内容</span><br>        out.writeBytes(bytes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> magicNum = in.readInt();<br>        <span class="hljs-keyword">byte</span> version = in.readByte();<br>        <span class="hljs-keyword">byte</span> serializerType = in.readByte();<br>        <span class="hljs-keyword">byte</span> messageType = in.readByte();<br>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();<br>        in.readByte();<br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>        Message message = (Message) ois.readObject();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message);<br>        out.add(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<br>    <span class="hljs-keyword">new</span> LoggingHandler(),<br>    <span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">//防止decoder时发生半包问题</span><br>    <span class="hljs-keyword">new</span> MessageCodec()<br>);<br><span class="hljs-comment">// encode</span><br>LoginRequestMessage message = <span class="hljs-keyword">new</span> LoginRequestMessage(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>channel.writeOutbound(message);<br><br><span class="hljs-comment">// decode</span><br>ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();<br><span class="hljs-keyword">new</span> MessageCodec().encode(<span class="hljs-keyword">null</span>, message, buf);<br><br><br><span class="hljs-comment">// 下面演示半包现象。</span><br>ByteBuf s1 = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>ByteBuf s2 = buf.slice(<span class="hljs-number">100</span>, buf.readableBytes() - <span class="hljs-number">100</span>);<br>s1.retain(); <span class="hljs-comment">// 引用计数++</span><br>channel.writeInbound(s1); <span class="hljs-comment">// release 引用计数--</span><br>channel.writeInbound(s2); <span class="hljs-comment">// release 引用计数--</span><br></code></pre></td></tr></table></figure><p>解读</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230503204057998.png"></p><h4 id="💡-什么时候可以加-Sharable"><a href="#💡-什么时候可以加-Sharable" class="headerlink" title="💡 什么时候可以加 @Sharable"></a>💡 什么时候可以加 @Sharable</h4><p>可不可以创建一个Handler，将来添加到多个Channel里面，被多个Channel共享。</p><p>对于Netty中的Handler，能不能被多个Channel共享，主要看该类有没有加@Sharable注解，如果加了@Sharable注解说明，可以被多个Channel共享，比如Netty中的<code>LoggingHandler</code>类。</p><ul><li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li><li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制。因为<code>ByteToMessageCodec</code>设计之初，考虑到它的子类要保存上一次触发的状态，所以强制规定，它的子类不可以加<code>@Sharable</code>注解（**<code>ByteToMessageCodec</code>抽象类的构造器，利用反射检查，当前对象的运行类型是否加上了<code>@Sharable</code>注解，如果加上了，那么抛出异常*<em>，在</em>抽象类<em>中</em>可以有构造方法<em>，只是不能直接创建</em>抽象类<em>的实例对象，但实例化子类的时候，就会初始化父类，不管父类是不是</em>抽象类*都会调用父类的构造方法）。</li><li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodecSharable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">Message</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf out = ctx.alloc().buffer();<br>        <span class="hljs-comment">// 1. 4 字节的魔数</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        <span class="hljs-comment">// 2. 1 字节的版本,</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span><br>        out.writeByte(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 4. 1 字节的指令类型</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 5. 4 个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 无意义，对齐填充</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br>        <span class="hljs-comment">// 6. 获取内容的字节数组</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-keyword">byte</span>[] bytes = bos.toByteArray();<br>        <span class="hljs-comment">// 7. 长度</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 8. 写入内容</span><br>        out.writeBytes(bytes);<br>        outList.add(out);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> magicNum = in.readInt();<br>        <span class="hljs-keyword">byte</span> version = in.readByte();<br>        <span class="hljs-keyword">byte</span> serializerType = in.readByte();<br>        <span class="hljs-keyword">byte</span> messageType = in.readByte();<br>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();<br>        in.readByte();<br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>        Message message = (Message) ois.readObject();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message);<br>        out.add(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-聊天室案例"><a href="#3-聊天室案例" class="headerlink" title="3. 聊天室案例"></a>3. 聊天室案例</h2><h3 id="3-1-聊天室业务介绍"><a href="#3-1-聊天室业务介绍" class="headerlink" title="3.1 聊天室业务介绍"></a>3.1 聊天室业务介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户管理接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 会话管理接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Session</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Channel channel, String username)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">(Channel channel)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Channel <span class="hljs-title">getChannel</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 聊天组会话管理接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GroupSession</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">createGroup</span><span class="hljs-params">(String name, Set&lt;String&gt; members)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">joinMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeGroup</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Set&lt;String&gt; <span class="hljs-title">getMembers</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Channel&gt; <span class="hljs-title">getMembersChannel</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-聊天室业务-登录"><a href="#3-2-聊天室业务-登录" class="headerlink" title="3.2 聊天室业务-登录"></a>3.2 聊天室业务-登录</h3><h4 id="SimpleChannelInboundHandler-lt-LoginRequestMessage-gt"><a href="#SimpleChannelInboundHandler-lt-LoginRequestMessage-gt" class="headerlink" title="SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;"></a><code>SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;</code></h4><p><code>SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;</code>意思是只有泛型类型LoginRequestMessage消息类型才会触发该Handler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br>                    ch.pipeline().addLast(LOGGING_HANDLER);<br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;<br>          <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            String username = msg.getUsername();<br>                            String password = msg.getPassword();<br>                            <span class="hljs-keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);<br>                            LoginResponseMessage message;<br>                            <span class="hljs-keyword">if</span>(login) &#123;<br>                                message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>                            &#125;<br>                            ctx.writeAndFlush(message); <span class="hljs-comment">//ctx.writeAndFlush是从当前位置往前; ch.writeAndFlush是从tail往前</span><br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        CountDownLatch WAIT_FOR_LOGIN = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>        AtomicBoolean LOGIN = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br><span class="hljs-comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(<span class="hljs-string">&quot;client handler&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-comment">// 接收响应消息</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;msg: &#123;&#125;&quot;</span>, msg);<br>                            <span class="hljs-keyword">if</span> ((msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage)) &#123;<br>                                LoginResponseMessage response = (LoginResponseMessage) msg;<br>                                <span class="hljs-keyword">if</span> (response.isSuccess()) &#123;<br>                                    <span class="hljs-comment">// 如果登录成功</span><br>                                    LOGIN.set(<span class="hljs-keyword">true</span>);<br>                                &#125;<br>                                <span class="hljs-comment">// 唤醒 system in 线程</span><br>                                WAIT_FOR_LOGIN.countDown();<br>                            &#125;<br>                        &#125;<br><br>                        <span class="hljs-comment">// 在连接建立后触发 active 事件</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span><br>                            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                                Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>                                System.out.println(<span class="hljs-string">&quot;请输入用户名:&quot;</span>);<br>                                String username = scanner.nextLine();<br>                                System.out.println(<span class="hljs-string">&quot;请输入密码:&quot;</span>);<br>                                String password = scanner.nextLine();<br>                                <span class="hljs-comment">// 构造消息对象</span><br>                                LoginRequestMessage message = <span class="hljs-keyword">new</span> LoginRequestMessage(username, password);<br>                                <span class="hljs-comment">// 发送消息</span><br>                                ctx.writeAndFlush(message);<br>                                System.out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    WAIT_FOR_LOGIN.await();<br>                                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                    e.printStackTrace();<br>                                &#125;<br>                                <span class="hljs-comment">// 如果登录失败</span><br>                                <span class="hljs-keyword">if</span> (!LOGIN.get()) &#123;<br>                                    ctx.channel().close();<br>                                    <span class="hljs-keyword">return</span>;<br>                                &#125;<br>                                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                                    String command = scanner.nextLine();<br>                                    String[] s = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                                    <span class="hljs-keyword">switch</span> (s[<span class="hljs-number">0</span>])&#123;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatRequestMessage(username, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gsend&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatRequestMessage(username, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                                            Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(s[<span class="hljs-number">2</span>].split(<span class="hljs-string">&quot;,&quot;</span>)));<br>                                            set.add(username); <span class="hljs-comment">// 加入自己</span><br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateRequestMessage(s[<span class="hljs-number">1</span>], set));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersRequestMessage(s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinRequestMessage(username, s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gquit&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitRequestMessage(username, s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>                                            ctx.channel().close();<br>                                            <span class="hljs-keyword">return</span>;<br>                                    &#125;<br>                                &#125;<br>                            &#125;, <span class="hljs-string">&quot;system in&quot;</span>).start();<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-聊天室业务-单聊"><a href="#3-3-聊天室业务-单聊" class="headerlink" title="3.3 聊天室业务-单聊"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p><p>登录 handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LoginRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String username = msg.getUsername();<br>        String password = msg.getPassword();<br>        <span class="hljs-keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span>(login) &#123;<br>            SessionFactory.getSession().bind(ctx.channel(), username);<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>        &#125;<br>        ctx.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单聊 handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String to = msg.getTo();<br>        Channel channel = SessionFactory.getSession().getChannel(to);<br>        <span class="hljs-comment">// 在线</span><br>        <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>) &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));<br>        &#125;<br>        <span class="hljs-comment">// 不在线</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;对方用户不存在或者不在线&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-聊天室业务-群聊"><a href="#3-4-聊天室业务-群聊" class="headerlink" title="3.4 聊天室业务-群聊"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupCreateRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupCreateRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String groupName = msg.getGroupName();<br>        Set&lt;String&gt; members = msg.getMembers();<br>        <span class="hljs-comment">// 群管理器</span><br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        Group group = groupSession.createGroup(groupName, members);<br>        <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 发生成功消息</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, groupName + <span class="hljs-string">&quot;创建成功&quot;</span>));<br>            <span class="hljs-comment">// 发送拉群消息</span><br>            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);<br>            <span class="hljs-keyword">for</span> (Channel channel : channels) &#123;<br>                channel.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span> + groupName));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">false</span>, groupName + <span class="hljs-string">&quot;已经存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()<br>                .getMembersChannel(msg.getGroupName());<br><br>        <span class="hljs-keyword">for</span> (Channel channel : channels) &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加入群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupJoinRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupJoinRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());<br>        <span class="hljs-keyword">if</span> (group != <span class="hljs-keyword">null</span>) &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>, msg.getGroupName() + <span class="hljs-string">&quot;群加入成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>, msg.getGroupName() + <span class="hljs-string">&quot;群不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupQuitRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupQuitRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());<br>        <span class="hljs-keyword">if</span> (group != <span class="hljs-keyword">null</span>) &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;已退出群&quot;</span> + msg.getGroupName()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>, msg.getGroupName() + <span class="hljs-string">&quot;群不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupMembersRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()<br>                .getMembers(msg.getGroupName());<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersResponseMessage(members));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-聊天室业务-退出"><a href="#3-5-聊天室业务-退出" class="headerlink" title="3.5 聊天室业务-退出"></a>3.5 聊天室业务-退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">// 当连接断开时触发 inactive 事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        SessionFactory.getSession().unbind(ctx.channel());<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125; 已经断开&quot;</span>, ctx.channel());<br>    &#125;<br><br><span class="hljs-comment">// 当出现异常时触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        SessionFactory.getSession().unbind(ctx.channel());<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;</span>, ctx.channel(), cause.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-聊天室业务-空闲检测"><a href="#3-6-聊天室业务-空闲检测" class="headerlink" title="3.6 聊天室业务-空闲检测"></a>3.6 聊天室业务-空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><p>服务器端解决</p><ul><li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><h5 id="IdleStateHandler空闲状态处理器"><a href="#IdleStateHandler空闲状态处理器" class="headerlink" title="IdleStateHandler空闲状态处理器"></a><code>IdleStateHandler</code>空闲状态处理器</h5><p>用来判断是不是 读空闲时间过长，或 写空闲时间过长。根据<code>IdleStateHandler</code>的构造器来指定检测读或者写事件是否空闲时间过长。</p><p><code>IdleStateHandler</code>构造器的三个参数如下：</p><table><thead><tr><th>Property</th><th><strong>Meaning</strong></th></tr></thead><tbody><tr><td>readerIdleTime</td><td>an [<code>IdleStateEvent</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleStateEvent.html) whose state is [<code>IdleState.READER_IDLE</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleState.html#READER_IDLE) will be triggered when no read was performed for the specified period of time. Specify <code>0</code> to disable.</td></tr><tr><td>writerIdleTime</td><td>an [<code>IdleStateEvent</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleStateEvent.html) whose state is [<code>IdleState.WRITER_IDLE</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleState.html#WRITER_IDLE) will be triggered when no write was performed for the specified period of time. Specify <code>0</code> to disable.</td></tr><tr><td>allIdleTime</td><td>an [<code>IdleStateEvent</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleStateEvent.html) whose state is [<code>IdleState.ALL_IDLE</code>](dfile:///Users/jiayonggang/Library/Application Support/Dash/User Contributed/Netty/Netty5.docset/Contents/Resources/Documents/io/netty/handler/timeout/IdleState.html#ALL_IDLE) will be triggered when neither read nor write was performed for the specified period of time. Specify <code>0</code> to disable.</td></tr></tbody></table><h5 id="ChannelDuplexHandler双工处理器"><a href="#ChannelDuplexHandler双工处理器" class="headerlink" title="ChannelDuplexHandler双工处理器"></a><code>ChannelDuplexHandler</code>双工处理器</h5><p><code>ChannelDuplexHandler</code>双工处理器可以同时作为入站和出站处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="hljs-comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-comment">// 用来触发特殊事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-comment">// 触发了读空闲事件</span><br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            log.debug(<span class="hljs-string">&quot;已经 5s 没有读到数据了&quot;</span>);<br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端定时心跳</p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="hljs-comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-comment">// 用来触发特殊事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-comment">// 触发了写空闲事件</span><br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">//log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> PingMessage());<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="四-优化与源码"><a href="#四-优化与源码" class="headerlink" title="四. 优化与源码"></a>四. 优化与源码</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p><ul><li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li><li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li></ul><p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反序列化</span><br><span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[bodyLength];<br>byteByf.readBytes(body);<br>ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(body));<br>Message message = (Message) in.readObject();<br>message.setSequenceId(sequenceId);<br><br><span class="hljs-comment">// 序列化</span><br>ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br><span class="hljs-keyword">new</span> ObjectOutputStream(out).writeObject(message);<br><span class="hljs-keyword">byte</span>[] bytes = out.toByteArray();<br></code></pre></td></tr></table></figure><p>为了支持更多序列化算法，抽象一个 Serializer 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 反序列化方法</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br><br>    <span class="hljs-comment">// 序列化方法</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SerializerAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><span class="hljs-comment">// Java 实现</span><br>    Java &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ObjectInputStream in = <br>                    <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>                Object object = in.readObject();<br>                <span class="hljs-keyword">return</span> (T) object;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                <span class="hljs-keyword">new</span> ObjectOutputStream(out).writeObject(object);<br>                <span class="hljs-keyword">return</span> out.toByteArray();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;, <br>    <span class="hljs-comment">// Json 实现(引入了 Gson 依赖)</span><br>    Json &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Gson().fromJson(<span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8), clazz);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Gson().toJson(object).getBytes(StandardCharsets.UTF_8);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 需要从协议的字节中得到是哪种序列化算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SerializerAlgorithm <span class="hljs-title">getByInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        SerializerAlgorithm[] array = SerializerAlgorithm.values();<br>        <span class="hljs-keyword">if</span> (type &lt; <span class="hljs-number">0</span> || type &gt; array.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array[type];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加配置类和配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Properties properties;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="hljs-string">&quot;/application.properties&quot;</span>)) &#123;<br>            properties = <span class="hljs-keyword">new</span> Properties();<br>            properties.load(in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExceptionInInitializerError(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getServerPort</span><span class="hljs-params">()</span> </span>&#123;<br>        String value = properties.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>);<br>        <span class="hljs-keyword">if</span>(value == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8080</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.parseInt(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Serializer.<span class="hljs-function">Algorithm <span class="hljs-title">getSerializerAlgorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        String value = properties.getProperty(<span class="hljs-string">&quot;serializer.algorithm&quot;</span>);<br>        <span class="hljs-keyword">if</span>(value == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Serializer.Algorithm.Java;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Serializer.Algorithm.valueOf(value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">serializer.algorithm</span>=<span class="hljs-string">Json</span><br></code></pre></td></tr></table></figure><p>修改编解码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodecSharable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">Message</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf out = ctx.alloc().buffer();<br>        <span class="hljs-comment">// 1. 4 字节的魔数</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        <span class="hljs-comment">// 2. 1 字节的版本,</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span><br>        out.writeByte(Config.getSerializerAlgorithm().ordinal());<br>        <span class="hljs-comment">// 4. 1 字节的指令类型</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 5. 4 个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 无意义，对齐填充</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br>        <span class="hljs-comment">// 6. 获取内容的字节数组</span><br>        <span class="hljs-keyword">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);<br>        <span class="hljs-comment">// 7. 长度</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 8. 写入内容</span><br>        out.writeBytes(bytes);<br>        outList.add(out);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> magicNum = in.readInt();<br>        <span class="hljs-keyword">byte</span> version = in.readByte();<br>        <span class="hljs-keyword">byte</span> serializerAlgorithm = in.readByte(); <span class="hljs-comment">// 0 或 1</span><br>        <span class="hljs-keyword">byte</span> messageType = in.readByte(); <span class="hljs-comment">// 0,1,2...</span><br>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();<br>        in.readByte();<br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br><br>        <span class="hljs-comment">// 找到反序列化算法</span><br>        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];<br>        <span class="hljs-comment">// 确定具体消息类型</span><br>        Class&lt;? extends Message&gt; messageClass = Message.getMessageClass(messageType);<br>        Message message = algorithm.deserialize(messageClass, bytes);<br><span class="hljs-comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="hljs-comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span><br>        out.add(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据消息类型字节，获得对应的消息 class</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> messageType 消息类型字节</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 消息 class</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;? extends Message&gt; getMessageClass(<span class="hljs-keyword">int</span> messageType) &#123;<br>        <span class="hljs-keyword">return</span> messageClasses.get(messageType);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sequenceId;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> messageType;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LoginRequestMessage = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LoginResponseMessage = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ChatRequestMessage = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ChatResponseMessage = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupCreateRequestMessage = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupCreateResponseMessage = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupJoinRequestMessage = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupJoinResponseMessage = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupQuitRequestMessage = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupQuitResponseMessage = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupChatRequestMessage = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupChatResponseMessage = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupMembersRequestMessage = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GroupMembersResponseMessage = <span class="hljs-number">13</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PingMessage = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PongMessage = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);<br>        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);<br>        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);<br>        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);<br>        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);<br>        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);<br>        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);<br>        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);<br>        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);<br>        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);<br>        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);<br>        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);<br>        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);<br>        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-参数调优"><a href="#1-2-参数调优" class="headerlink" title="1.2 参数调优"></a>1.2 参数调优</h3><ul><li>服务端</li></ul><p><code>new ServerBootstrap().option()</code> //是给 ServerSocketChannel 配置参数 </p><p><code>new ServerBootstrap().childOption())</code> //给 SocketChannet配置参数</p><ul><li>客户端</li></ul><p><code>new Bootstrap().option()</code>方法给SocketChannel配置参数</p><h4 id="1）CONNECT-TIMEOUT-MILLIS"><a href="#1）CONNECT-TIMEOUT-MILLIS" class="headerlink" title="1）CONNECT_TIMEOUT_MILLIS"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul><li><p>属于 SocketChannal 参数</p></li><li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p></li><li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConnectionTimeout</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()<br>                    .group(group)<br>                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">300</span>)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler());<br>            ChannelFuture future = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>            future.sync().channel().closeFuture().sync(); <span class="hljs-comment">// 断点1</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            log.debug(<span class="hljs-string">&quot;timeout&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以故意不开服务器，使得客户端连接超时。</p><p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code>。在NioEventLoop线程里面设置定时任务，如果连接超时，该定时任务向Promise提交连接超时异常，主线程通过Promise对象异步收到异常对象，catch住该异常对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();<br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <br>                ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;<br>                ConnectTimeoutException cause =<br>                    <span class="hljs-keyword">new</span> ConnectTimeoutException(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress); <span class="hljs-comment">// 断点2</span><br>                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）SO-BACKLOG"><a href="#2）SO-BACKLOG" class="headerlink" title="2）SO_BACKLOG"></a>2）SO_BACKLOG</h4><ul><li>属于 ServerSocketChannal 参数</li></ul><pre><code class=" mermaid">sequenceDiagramparticipant c as clientparticipant s as serverparticipant sq as syns queueparticipant aq as accept queues -&gt;&gt; s : bind()s -&gt;&gt; s : listen()c -&gt;&gt; c : connect()c -&gt;&gt; s : 1. SYNNote left of c : SYN_SENDs -&gt;&gt; sq : putNote right of s : SYN_RCVDs -&gt;&gt; c : 2. SYN + ACKNote left of c : ESTABLISHEDc -&gt;&gt; s : 3. ACKsq -&gt;&gt; aq : putNote right of s : ESTABLISHEDaq --&gt;&gt; s : s -&gt;&gt; s : accept()</code></pre><ol><li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li><li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li><li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li></ol><p>其中</p><ul><li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p></li><li><p>sync queue - 半连接队列</p><ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><p>accept queue - 全连接队列</p><ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><ul><li>JDK的NIO中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><br>ServerSocketChannel open = ServerSocketChannel.open();<br>open.bind(端口, backlog);<br></code></pre></td></tr></table></figure><ul><li>netty 中</li></ul><p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小，由于Netty的NioEventLoop处理连接请求的能力很强，accept队列一有请求就被处理了，所以需要将断点设置到accept队列出队那个函数上，让其阻塞，使得accept队列一直只进不出。</p><p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><p>可以通过下面源码查看默认大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServerSocketChannelConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultChannelConfig</span></span><br><span class="hljs-class">                                              <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerSocketChannelConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> backlog = NetUtil.SOMAXCONN;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>bio 中更容易说明，不用 debug 模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>, <span class="hljs-number">2</span>);<br>        Socket accept = ss.accept();<br>        System.out.println(accept);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端启动 4 个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Socket s = <span class="hljs-keyword">new</span> Socket();<br>            System.out.println(<span class="hljs-keyword">new</span> Date()+<span class="hljs-string">&quot; connecting...&quot;</span>);<br>            s.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>),<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-keyword">new</span> Date()+<span class="hljs-string">&quot; connected...&quot;</span>);<br>            s.getOutputStream().write(<span class="hljs-number">1</span>);<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> Date()+<span class="hljs-string">&quot; connecting timeout...&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Tue Apr <span class="hljs-number">21</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2020</span> connecting...<br>Tue Apr <span class="hljs-number">21</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2020</span> connected...<br></code></pre></td></tr></table></figure><p>第 4 个客户端连接时</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Tue</span> Apr <span class="hljs-number">21</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">58</span> CST <span class="hljs-number">2020</span> connecting...<br><span class="hljs-attribute">Tue</span> Apr <span class="hljs-number">21</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">59</span> CST <span class="hljs-number">2020</span> connecting timeout...<br><span class="hljs-attribute">java</span>.net.SocketTimeoutException: connect timed out<br></code></pre></td></tr></table></figure><h4 id="3）ulimit-n-Linux命令"><a href="#3）ulimit-n-Linux命令" class="headerlink" title="3）ulimit -n    Linux命令"></a>3）ulimit -n    Linux命令</h4><ul><li>属于操作系统参数，在LInux中限制每个进程打开的最大文件描述符（FD）</li></ul><h4 id="4）TCP-NODELAY"><a href="#4）TCP-NODELAY" class="headerlink" title="4）TCP_NODELAY"></a>4）TCP_NODELAY</h4><ul><li>属于 SocketChannal 参数，Netty默认TCP_NODELAY = false，默认是开始TCP的nagle算法的。但是这里建议把TCP_NODELAY  = true，因为可能有一些小数据包，不建议打开TCP的nagle算法。</li></ul><h4 id="5）SO-SNDBUF-amp-SO-RCVBUF"><a href="#5）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="5）SO_SNDBUF &amp; SO_RCVBUF"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul><li>SO_SNDBUF 属于 SocketChannal 参数，发送缓冲区。</li><li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上），接收缓冲区。</li></ul><p><strong>操作系统实现的TCP流量控制和拥塞控制机制会自动控制这两个参数，故而不建议程序员手动设置这两个参数。</strong></p><h4 id="6）ALLOCATOR"><a href="#6）ALLOCATOR" class="headerlink" title="6）ALLOCATOR"></a>6）ALLOCATOR</h4><ul><li>属于 SocketChannal 参数</li><li>用来分配 ByteBuf， ctx.alloc()方法返回ALLOCATOR分配器对象，该对象在调用buffer()方法即可分配ByteBuf对象，在MacOS下，默认分配直接内存的池化ByteBuf对象。通过阅读源码发现在<code>ByteBufUtil.java</code>中使用系统变量<code>io.netty.allocator.type</code>决定分配池化还是非池化ByteBuf对象，可以通过在IDEA中对<code>ByteBufUtil.java</code>的虚拟机参数增加<code>-Dio.netty.allocator.type=unpooled</code>来指定分配池化还是非池化ByteBuf对象。通过阅读源码发现在<code>PlatformDependent.java</code>中使用系统变量<code>io.netty.noPerferDirect</code>决定分配直接内存还是堆内存ByteBuf对象，可以通过在IDEA中对<code>PlatformDependent.java</code>的虚拟机参数增加<code>-Dio.netty.noPerferDirect=true</code>来指定分配直接内存还是堆内存ByteBuf对象。</li></ul><h4 id="7）RCVBUF-ALLOCATOR"><a href="#7）RCVBUF-ALLOCATOR" class="headerlink" title="7）RCVBUF_ALLOCATOR"></a>7）RCVBUF_ALLOCATOR</h4><ul><li><p>属于 SocketChannal 参数</p></li><li><p>控制 netty 接收缓冲区大小</p></li><li><p>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存（<strong>因为对于IO操作，使用直接内存ByteBuf可以减少数据的复制次数已经内核态和用户态的切换次数，所以netty强制对于IO操作接收缓冲区使用直接内存ByteBuf</strong>），具体池化还是非池化由 ALLOCATOR 决定，即通过阅读源码发现在<code>ByteBufUtil.java</code>中使用系统变量<code>io.netty.allocator.type</code>决定分配池化还是非池化ByteBuf对象，可以通过在IDEA中对<code>ByteBufUtil.java</code>的虚拟机参数增加<code>-Dio.netty.allocator.type=unpooled</code>来指定分配池化还是非池化ByteBuf对象。</p><p><code>AbstractNioByteChannel.java</code>源码如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230417155338037.png"></p></li></ul><h3 id="1-3-RPC-框架"><a href="#1-3-RPC-框架" class="headerlink" title="1.3 RPC 框架"></a>1.3 RPC 框架</h3><h4 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p><p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 省略旧的代码</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>请求消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString(callSuper = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class[] parameterTypes;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object[] parameterValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RpcRequestMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setSequenceId(sequenceId);<br>        <span class="hljs-keyword">this</span>.interfaceName = interfaceName;<br>        <span class="hljs-keyword">this</span>.methodName = methodName;<br>        <span class="hljs-keyword">this</span>.returnType = returnType;<br>        <span class="hljs-keyword">this</span>.parameterTypes = parameterTypes;<br>        <span class="hljs-keyword">this</span>.parameterValue = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ToString(callSuper = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Exception exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器架子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        <br>        <span class="hljs-comment">// rpc 请求消息处理器，待实现</span><br>        RpcRequestMessageHandler RPC_HANDLER = <span class="hljs-keyword">new</span> RpcRequestMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br>                    ch.pipeline().addLast(LOGGING_HANDLER);<br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(RPC_HANDLER);<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端架子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        <br>        <span class="hljs-comment">// rpc 响应消息处理器，待实现</span><br>        RpcResponseMessageHandler RPC_HANDLER = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br>                    ch.pipeline().addLast(LOGGING_HANDLER);<br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(RPC_HANDLER);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端的 service 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServicesFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Properties properties;<br>    <span class="hljs-keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="hljs-string">&quot;/application.properties&quot;</span>)) &#123;<br>            properties = <span class="hljs-keyword">new</span> Properties();<br>            properties.load(in);<br>            Set&lt;String&gt; names = properties.stringPropertyNames();<br>            <span class="hljs-keyword">for</span> (String name : names) &#123;<br>                <span class="hljs-keyword">if</span> (name.endsWith(<span class="hljs-string">&quot;Service&quot;</span>)) &#123;<br>                    Class&lt;?&gt; interfaceClass = Class.forName(name);<br>                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));<br>                    map.put(interfaceClass, instanceClass.newInstance());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExceptionInInitializerError(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getService</span><span class="hljs-params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (T) map.get(interfaceClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相关配置 application.properties</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">serializer.algorithm=Json<br>cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.service</span>.HelloService=cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.service</span>.HelloServiceImpl<br></code></pre></td></tr></table></figure><h4 id="2）服务器-handler"><a href="#2）服务器-handler" class="headerlink" title="2）服务器 handler"></a>2）服务器 handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcRequestMessage</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> </span>&#123;<br>        RpcResponseMessage response = <span class="hljs-keyword">new</span> RpcResponseMessage();<br>        response.setSequenceId(message.getSequenceId());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取真正的实现对象</span><br>            HelloService service = (HelloService)<br>                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));<br>            <br>            <span class="hljs-comment">// 获取要调用的方法</span><br>            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());<br>            <br>            <span class="hljs-comment">// 调用方法</span><br>            Object invoke = method.invoke(service, message.getParameterValue());<br>            <span class="hljs-comment">// 调用成功</span><br>            response.setReturnValue(invoke);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">// 调用异常</span><br>            response.setExceptionValue(e);<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        ctx.writeAndFlush(response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）客户端代码第一版"><a href="#3）客户端代码第一版" class="headerlink" title="3）客户端代码第一版"></a>3）客户端代码第一版</h4><p>只发消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        RpcResponseMessageHandler RPC_HANDLER = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br>                    ch.pipeline().addLast(LOGGING_HANDLER);<br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(RPC_HANDLER);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br><br>            ChannelFuture future = channel.writeAndFlush(<span class="hljs-keyword">new</span> RpcRequestMessage(<br>                    <span class="hljs-number">1</span>,<br>                    <span class="hljs-string">&quot;cn.itcast.server.service.HelloService&quot;</span>,<br>                    <span class="hljs-string">&quot;sayHello&quot;</span>,<br>                    String.class,<br>                    <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>                    <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;张三&quot;</span>&#125;<br>            )).addListener(promise -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (!promise.isSuccess()) &#123;<br>                    Throwable cause = promise.cause();<br>                    log.error(<span class="hljs-string">&quot;error&quot;</span>, cause);<br>                &#125;<br>            &#125;);<br><br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gson不能处理Class对象"><a href="#gson不能处理Class对象" class="headerlink" title="gson不能处理Class对象"></a>gson不能处理Class对象</h5><p>解决方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.jyg.protocol;<br><br><span class="hljs-keyword">import</span> com.google.gson.*;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于扩展序列化、反序列化算法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 反序列化方法</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br><br>    <span class="hljs-comment">// 序列化方法</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Algorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><br>        Java &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>                    <span class="hljs-keyword">return</span> (T) ois.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;反序列化失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                    ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>                    oos.writeObject(object);<br>                    <span class="hljs-keyword">return</span> bos.toByteArray();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;序列化失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;,<br><br>        Json &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                Gson gson = <span class="hljs-keyword">new</span> GsonBuilder().registerTypeAdapter(Class.class, <span class="hljs-keyword">new</span> Serializer.ClassCodec()).create();<br>                String json = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                <span class="hljs-keyword">return</span> gson.fromJson(json, clazz);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>                Gson gson = <span class="hljs-keyword">new</span> GsonBuilder().registerTypeAdapter(Class.class, <span class="hljs-keyword">new</span> Serializer.ClassCodec()).create();<br>                String json = gson.toJson(object);<br>                <span class="hljs-keyword">return</span> json.getBytes(StandardCharsets.UTF_8);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JsonSerializer</span>&lt;<span class="hljs-title">Class</span>&lt;?&gt;&gt;, <span class="hljs-title">JsonDeserializer</span>&lt;<span class="hljs-title">Class</span>&lt;?&gt;&gt; </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="hljs-keyword">throws</span> JsonParseException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String str = json.getAsString();<br>                <span class="hljs-keyword">return</span> Class.forName(str);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JsonParseException(e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span>             <span class="hljs-comment">//   String.class</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> JsonElement <span class="hljs-title">serialize</span><span class="hljs-params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> </span>&#123;<br>            <span class="hljs-comment">// class -&gt; json</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonPrimitive(src.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）客户端-handler-第一版"><a href="#4）客户端-handler-第一版" class="headerlink" title="4）客户端 handler 第一版"></a>4）客户端 handler 第一版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）客户端代码-第二版"><a href="#5）客户端代码-第二版" class="headerlink" title="5）客户端代码 第二版"></a>5）客户端代码 第二版</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230423212427037.png"></p><p>包括 channel 管理，代理，接收结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcClientManager</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloService service = getProxyService(HelloService.class);<br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;zhangsan&quot;</span>));<br><span class="hljs-comment">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span><br><span class="hljs-comment">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span><br>    &#125;<br><br>    <span class="hljs-comment">// 创建代理类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxyService</span><span class="hljs-params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;<br>        ClassLoader loader = serviceClass.getClassLoader();<br>        Class&lt;?&gt;[] interfaces = <span class="hljs-keyword">new</span> Class[]&#123;serviceClass&#125;;<br>        <span class="hljs-comment">//                                                            sayHello  &quot;张三&quot;</span><br>        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 将方法调用转换为 消息对象</span><br>            <span class="hljs-keyword">int</span> sequenceId = SequenceIdGenerator.nextId();<br>            RpcRequestMessage msg = <span class="hljs-keyword">new</span> RpcRequestMessage(<br>                    sequenceId,<br>                    serviceClass.getName(),<br>                    method.getName(),<br>                    method.getReturnType(),<br>                    method.getParameterTypes(),<br>                    args<br>            );<br>            <span class="hljs-comment">// 2. 将消息对象发送出去</span><br>            getChannel().writeAndFlush(msg);<br><br>            <span class="hljs-comment">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span><br>            DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br>            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);<br><br><span class="hljs-comment">//            promise.addListener(future -&gt; &#123;</span><br><span class="hljs-comment">//                // 线程</span><br><span class="hljs-comment">//            &#125;);</span><br><br>            <span class="hljs-comment">// 4. 等待 promise 结果</span><br>            promise.await();<br>            <span class="hljs-keyword">if</span>(promise.isSuccess()) &#123;<br>                <span class="hljs-comment">// 调用正常</span><br>                <span class="hljs-keyword">return</span> promise.getNow();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 调用失败</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> (T) o;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-comment">// 获取唯一的 channel 对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> channel;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123; <span class="hljs-comment">//  t2</span><br>            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                <span class="hljs-keyword">return</span> channel;<br>            &#125;<br>            initChannel();<br>            <span class="hljs-keyword">return</span> channel;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 channel 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler LOGGING_HANDLER = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageCodecSharable MESSAGE_CODEC = <span class="hljs-keyword">new</span> MessageCodecSharable();<br>        RpcResponseMessageHandler RPC_HANDLER = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.group(group);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProcotolFrameDecoder());<br>                ch.pipeline().addLast(LOGGING_HANDLER);<br>                ch.pipeline().addLast(MESSAGE_CODEC);<br>                ch.pipeline().addLast(RPC_HANDLER);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().addListener(future -&gt; &#123;<br>                group.shutdownGracefully();<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6）客户端-handler-第二版"><a href="#6）客户端-handler-第二版" class="headerlink" title="6）客户端 handler 第二版"></a>6）客户端 handler 第二版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//                       序号      用来接收结果的 promise 对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-comment">// 拿到空的 promise</span><br>        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());<br>        <span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;<br>            Object returnValue = msg.getReturnValue();<br>            Exception exceptionValue = msg.getExceptionValue();<br>            <span class="hljs-keyword">if</span>(exceptionValue != <span class="hljs-keyword">null</span>) &#123;<br>                promise.setFailure(exceptionValue);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setSuccess(returnValue);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-启动剖析"><a href="#2-1-启动剖析" class="headerlink" title="2.1 启动剖析"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的，理论上应该有以下7步来建立连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装 线程 和 selector</span><br>Selector selector = Selector.open(); <br><br><span class="hljs-comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> NioServerSocketChannel();<br><br><span class="hljs-comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); <br>serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br><span class="hljs-comment">//4 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件。使用附件，将java原生的ServerSocketChannel和Netty的NioServerSocketChannel关联起来</span><br>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">//7 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>实际上，Netty的流程图如下所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230424140507532.png"></p><p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br><span class="hljs-comment">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span><br>    <span class="hljs-comment">// 2.1 如果已经完成</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        ChannelPromise promise = channel.newPromise();<br>        <span class="hljs-comment">// 3.1 立刻调用 doBind0，在main线程中执行</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <br>    <span class="hljs-comment">// 2.2 还没有完成</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);<br>        <span class="hljs-comment">// 3.2 回调 doBind0，在nio-thread线程回调执行。</span><br>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Throwable cause = future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 处理异常...</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.registered();<br><span class="hljs-comment">// 3. 由注册线程去执行 doBind0</span><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;<br>    Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel(); <span class="hljs-comment">// 创建JDK的ServerSocketChannel</span><br>        <span class="hljs-comment">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 处理异常...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-comment">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 处理异常...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里 channel 实际上是 NioServerSocketChannel</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();<br>    <span class="hljs-keyword">synchronized</span> (options) &#123;<br>        setChannelOptions(channel, options, logger);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();<br>    <span class="hljs-keyword">synchronized</span> (attrs) &#123;<br>        <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();<br>            channel.attr(key).set(e.getValue());<br>        &#125;<br>    &#125;<br><br>    ChannelPipeline p = channel.pipeline();<br><br>    <span class="hljs-keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<br>    <span class="hljs-keyword">final</span> ChannelHandler currentChildHandler = childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;<br>    <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (childAttrs) &#123;<br>        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 1.1 为 NioServerSocketChannel 添加初始化器，等待调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler handler = config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            <span class="hljs-comment">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); <span class="hljs-comment">// ServerBootstrapAcceptor的作用是accept事件发生后建立连接</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 一些检查，略...</span><br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123; <span class="hljs-comment">// inEventLoop()检查当前线程是否等于Nio线程，第一次执行是main线程在执行，所以是false</span><br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span><br>            <span class="hljs-comment">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span><br>            <span class="hljs-comment">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// 日志记录...</span><br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> firstRegistration = neverRegistered;<br>        doRegister();<span class="hljs-comment">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span><br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 1.2.2 执行1.1处的 NioServerSocketChannel 初始化器的 initChannel</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        <span class="hljs-comment">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-comment">// 对应 server socket channel 还未绑定，isActive 为 false</span><br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// Close the channel directly to avoid FD leak.</span><br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.2.2.1 执行初始化 执行1.1处的NioServerSocketChannel 初始化器的 initChannel</span><br>            initChannel((C) ctx.channel());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>            exceptionCaught(ctx, cause);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 1.2.2.2 移除初始化器</span><br>            ChannelPipeline pipeline = ctx.pipeline();<br>            <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.remove(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.1 或 3.2 执行 doBind0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br><br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;<br>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setFailure(regFuture.cause());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    assertEventLoop();<br><br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;<br>        localAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress &amp;&amp;<br>        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;<br>        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;<br>        <span class="hljs-comment">// 记录日志...</span><br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> wasActive = isActive();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 3.3 执行端口绑定</span><br>        doBind(localAddress);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        safeSetFailure(promise, t);<br>        closeIfClosed();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123; <span class="hljs-comment">// 判断当前ServerSocketChannel是否可用</span><br>        invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 3.4 触发 active 事件，此时ServerSocketChannel上只有三个handler，分别是head -&gt; accpetor -&gt; tail</span><br>                <span class="hljs-comment">// 但是只有head handler做了工作，其余两个没有做工作，所以这里只看head handler</span><br>                pipeline.fireChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    safeSetSuccess(promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123; <span class="hljs-comment">//JDK7及以上</span><br>        javaChannel().bind(localAddress, config.getBacklog()); <span class="hljs-comment">//ServerSocketChannel绑定端口，打印日志</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    ctx.fireChannelActive();<br><span class="hljs-comment">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span><br>    readIfIsAutoRead(); <span class="hljs-comment">// ServerSocketChannel上绑定OP_ACCPET事件，即下面的doBeginRead方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-comment">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-NioEventLoop-剖析"><a href="#2-2-NioEventLoop-剖析" class="headerlink" title="2.2 NioEventLoop 剖析"></a>2.2 NioEventLoop 剖析</h3><p>再强调一遍： </p><ul><li><p>NioEventLoop的重要组成： selector， 线程，任务队列，定时任务队列</p></li><li><p>NioEventLoop既会处理io事件，也会处理普通任务和定时任务 </p></li></ul><ol><li><p>selector 何时创建  在NioEventLoop的构造器中创建Selector对象</p><p>1.1 NioEventLoop类中 为何有两个 selector 成员？ 第一个selector是成员变量unwrappedSelector，原本JDK中的selectedKeys的底层是哈希表HashSet，哈希表的遍历时间复杂度高。所以Netty进行改进了，第二selector是成员变量selector，底层的selectedKeys是数组，遍历性能好。</p></li><li><p>nio 线程在何时启动 </p><ul><li>首次调用EventLoop对象的execute方法时启动nio线程，通过NioEventLoop父类中的成员变量state状态位控制nio线程只会启动一次。</li></ul></li><li><p>提交普通任务会不会结束 select 阻塞？ </p><p>回答：会，如果提交普通任务，会使用NioEventLoop的wakeup方法唤醒被selector方法阻塞的Nio线程。</p></li></ol><ul><li><p>3.1 wakeup方法中的代码如何理解 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;<br>    <span class="hljs-comment">// inEventLoop指的是，当前提交任务（也就是执行execute方法）的线程是否是Nio线程，只有不是Nio线程才有可能进入if块</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        selector.wakeup(); <span class="hljs-comment">// 所以提交普通任务也会唤醒Nio线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>inEventLoop指的是，当前提交任务（也就是执行execute方法）的线程是否是Nio线程，只有不是Nio线程才有可能进入if块</p></li><li><p>3.2 wakenUp变量的作用是什么 </p><p>因为多个 IO 线程或者提交任务线程都有可能执行 wakeup，而 Nio线程的wakeup方法 属于比较昂贵的操作，为了避免Nio线程的wakeup方法频繁被调用，所以使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒。由于CAS操作，同一时间只允许一个线程设置成功，这样就避免了同时又多个多个线程同时提交任务，多次执行Nio线程的wakeup方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;<br>    <span class="hljs-comment">// inEventLoop指的是，当前提交任务（也就是执行execute方法）的线程是否是Nio线程，只有不是Nio线程才有可能进入if块</span><br>    <span class="hljs-comment">// 因为多个 IO 线程或者提交任务线程都有可能执行 wakeup，而 Nio线程的wakeup方法 属于比较昂贵的操作，为了避免Nio线程的wakeup方法频繁被调用，所以使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒。由于CAS操作，同一时间只允许一个线程设置成功，这样就避免了同时又多个多个线程同时提交任务，多次执行Nio线程的wakeup方法。</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        selector.wakeup(); <span class="hljs-comment">// 所以提交普通任务也会唤醒Nio线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>每次循环时，什么时候会进入SelectStrategy.SELECT 分支 </p><p>只有没有任务时,才会进入 SelectStrategy.SELECT。即下图中的<code>hasTasks()</code>方法获取是否有任务， 当没有任务时，返回SelectStrategy.SELECT，进入该分支。</p><p>当有任务时,会调用 selectNow方法,顺便拿到io事件。即下图中的selectNowSupplier调用get()方法中调用了selector.selectNow()方法获取io事件。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20230424154634148.png"></p><p>4.1何时会 select 阻塞，阻塞多久?</p><p>如果没有scheduleTask，那么只会最大阻塞时间就是 1s + 0.5ms，有 scheduledTask，那么最大阻塞时间就是为 <code>下一个定时任务执行时间 - 当前时间</code> + 0.5ms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Selector selector = <span class="hljs-keyword">this</span>.selector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();<br>        <span class="hljs-comment">// 计算等待时间</span><br>        <span class="hljs-comment">// * 没有 scheduledTask，超时时间为 1s</span><br>        <span class="hljs-comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span><br>        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>) / <span class="hljs-number">1000000L</span>; <br>            <span class="hljs-comment">// 如果没有scheduleTask那么只会最大阻塞时间就是 1s + 0.5ms</span><br>            <span class="hljs-comment">// 如果超时，退出循环</span><br>            <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (selectCnt == <span class="hljs-number">0</span>) &#123;<br>                    selector.selectNow();<br>                    selectCnt = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span><br>            <span class="hljs-comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span><br>            <span class="hljs-keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                selector.selectNow();<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// select 有限时阻塞</span><br>            <span class="hljs-comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有事件发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span><br>            <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<br>            <span class="hljs-comment">// 计数加 1</span><br>            selectCnt ++;<br><br>            <span class="hljs-comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span><br>            <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>               <span class="hljs-comment">// 线程被打断，退出循环</span><br>                <span class="hljs-comment">// 记录日志</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">long</span> time = System.nanoTime();<br>            <span class="hljs-keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;<br>                <span class="hljs-comment">// 如果超时，计数重置为 1，下次循环就会 break</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>            &#125; <br>            <span class="hljs-comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span><br>            <span class="hljs-comment">// 这是为了解决 nio 空轮询 bug</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>                selector = selectRebuildSelector(selectCnt);  <span class="hljs-comment">// 重建 selector对象，</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            currentTimeNanos = time;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;<br>            <span class="hljs-comment">// 记录日志</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>        <span class="hljs-comment">// 记录日志</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有定时任务时间到了、期间有新任务被提交了、或者有IO事件了等等，都会退出死循环。</p></li><li><p>nio空轮询 bug 在哪里体现，如何解决 </p><p>注意 nio 有 bug，当 bug 出现（bug发生概率较小）时，select 方法即使没有事件发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%。使用selectCnt变量计算，如果selectCnt大于设置的阈值，那么退出死循环，不要继续空轮询了。</p><p>由于JDK（linux版本）中的Nio中的Selector上有bug，所以重新创建了一个Selector对象，把原来旧的Selector对象上绑定的SelectionKeys和附件移到新的Selector对象上。</p><p><strong>当然，Netty还有一个解决方法，就是Netty重写了Selector类，不使用JDK的Selector类。</strong></p></li><li><p>ioRatio 控制什么，设置为 100 有何作用？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// calculateStrategy 的逻辑如下：</span><br>                <span class="hljs-comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span><br>                <span class="hljs-comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span><br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                        <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                        <span class="hljs-comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span><br>                        <span class="hljs-comment">// 进行 select 阻塞，并设置唤醒状态为 false</span><br>                        <span class="hljs-keyword">boolean</span> oldWakenUp = wakenUp.getAndSet(<span class="hljs-keyword">false</span>);<br>                        <br>                        <span class="hljs-comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span><br>                        <span class="hljs-comment">// 下面的 select 方法不会阻塞</span><br>                        <span class="hljs-comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span><br>                        <span class="hljs-comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span><br>                        <span class="hljs-comment">// 才能执行，让 select 方法无谓阻塞</span><br>                        select(oldWakenUp);<br><br>                        <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                            selector.wakeup();<br>                        &#125;<br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// ioRatio 默认是 50</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;                <br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys(); <span class="hljs-comment">// 处理所有IO事件</span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 记录 io 事件处理耗时</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    <span class="hljs-comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span><br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio); <span class="hljs-comment">// 处理普通任务</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有任务，那么会跳出switch-case块，但是为了防止非IO任务占用大量时间，所以设计了ioratio变量，ioRatio 控制处理io事件所占用的时间比例，默认是50。</p><p>如果ioRatio设置为100，那么就是总是运行完所有非 IO 任务。</p></li><li><p>selectedKeys 优化是怎么回事？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span><br>        <span class="hljs-comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个selector是成员变量unwrappedSelector，原本JDK中的selectedKeys的底层是哈希表HashSet，哈希表的遍历时间复杂度高。所以Netty进行改进了，第二selector是成员变量selector，底层的selectedKeys是数组，遍历性能好。</p></li><li><p>在哪里区分不同事件类型</p><p>在processSelectedKey()方法中区分不同事件类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<br>    <span class="hljs-comment">// 当 key 取消或关闭时会导致这个 key 无效</span><br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-comment">// 无效时处理...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// 连接事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// 可写事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// 可读或可接入事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span><br>            <span class="hljs-comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span><br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p><p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();<br>    <span class="hljs-comment">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span><br>    addTask(task);<br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span><br>        startThread();<br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-comment">// 如果已经 shutdown，做拒绝逻辑，代码略...</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        <span class="hljs-comment">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span><br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;<br>    <span class="hljs-comment">// inEventLoop指的是，当前提交任务（也就是执行execute方法）的线程是否是Nio线程，只有不是Nio线程才有可能进入if块</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        selector.wakeup(); <span class="hljs-comment">// 所以提交普通任务也会唤醒Nio线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;<br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 将线程池的当前线程（其实就是NioEventLoop线程）保存在成员变量中，以便后续使用</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span><br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Unexpected exception from an event executor: &quot;</span>, t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 清理工作，代码略...</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// calculateStrategy 的逻辑如下：</span><br>                <span class="hljs-comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span><br>                <span class="hljs-comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span><br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                        <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                        <span class="hljs-comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span><br>                        <span class="hljs-comment">// 进行 select 阻塞，并设置唤醒状态为 false</span><br>                        <span class="hljs-keyword">boolean</span> oldWakenUp = wakenUp.getAndSet(<span class="hljs-keyword">false</span>);<br>                        <br>                        <span class="hljs-comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span><br>                        <span class="hljs-comment">// 下面的 select 方法不会阻塞</span><br>                        <span class="hljs-comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span><br>                        <span class="hljs-comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span><br>                        <span class="hljs-comment">// 才能执行，让 select 方法无谓阻塞</span><br>                        select(oldWakenUp);<br><br>                        <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                            selector.wakeup();<br>                        &#125;<br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// ioRatio 默认是 50</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;                <br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys(); <span class="hljs-comment">// 处理所有IO事件</span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 记录 io 事件处理耗时</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    <span class="hljs-comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span><br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio); <span class="hljs-comment">// 处理普通任务</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h4><blockquote><p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p><ul><li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li><li>由 EventLoop 自己调用，本次的 wakeup 会取消下一次的 select 操作</li></ul></blockquote><p>参考下图</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/0032.png"  /><p><code>io.netty.channel.nio.NioEventLoop#select</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Selector selector = <span class="hljs-keyword">this</span>.selector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();<br>        <span class="hljs-comment">// 计算等待时间</span><br>        <span class="hljs-comment">// * 没有 scheduledTask，超时时间为 1s</span><br>        <span class="hljs-comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span><br>        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>) / <span class="hljs-number">1000000L</span>; <br>            <span class="hljs-comment">// 如果没有scheduleTask那么只会最大阻塞时间就是 1s + 0.5ms</span><br>            <span class="hljs-comment">// 如果超时，退出循环</span><br>            <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (selectCnt == <span class="hljs-number">0</span>) &#123;<br>                    selector.selectNow();<br>                    selectCnt = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span><br>            <span class="hljs-comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span><br>            <span class="hljs-keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                selector.selectNow();<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// select 有限时阻塞</span><br>            <span class="hljs-comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span><br>            <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<br>            <span class="hljs-comment">// 计数加 1</span><br>            selectCnt ++;<br><br>            <span class="hljs-comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span><br>            <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>               <span class="hljs-comment">// 线程被打断，退出循环</span><br>                <span class="hljs-comment">// 记录日志</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">long</span> time = System.nanoTime();<br>            <span class="hljs-keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;<br>                <span class="hljs-comment">// 如果超时，计数重置为 1，下次循环就会 break</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>            &#125; <br>            <span class="hljs-comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span><br>            <span class="hljs-comment">// 这是为了解决 nio 空轮询 bug</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>                <span class="hljs-comment">// 重建 selector</span><br>                selector = selectRebuildSelector(selectCnt);<br>                selectCnt = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            currentTimeNanos = time;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;<br>            <span class="hljs-comment">// 记录日志</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>        <span class="hljs-comment">// 记录日志</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span><br>        <span class="hljs-comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<br>    <span class="hljs-comment">// 当 key 取消或关闭时会导致这个 key 无效</span><br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-comment">// 无效时处理...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// 连接事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// 可写事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// 可读或可接入事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span><br>            <span class="hljs-comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span><br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-accept-剖析"><a href="#2-3-accept-剖析" class="headerlink" title="2.3 accept 剖析"></a>2.3 accept 剖析</h3><p>accept 流程：</p><ul><li><p>Step1: selector.select()阻塞直到事件发生 </p></li><li><p>Step2: 遍历处理 selectedKeys </p></li><li><p>Step3: 拿到一个 key，判断事件类型是否为accept </p></li><li><p>Step4: 创建 SocketChannel， 设置非阻塞 ，即创建NioSocketChannel</p></li><li><p>Step5: 将SocketChannel 注册至 selector </p><p>sc.register(eventLoop的选择器,0, NioSocketChannel）</p><p>调用NioSocketChannel 上的初始化器，即给SocketChannel加上一些handler</p></li><li><p>Step6: 关注 selection Key 的 read事件</p></li></ul><p>nio 中如下代码，在 netty 中的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 阻塞直到事件发生</span><br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-comment">//2 拿到一个事件</span><br>    SelectionKey key = iter.next();<br>    <br>    <span class="hljs-comment">//3 如果是 accept 事件</span><br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-comment">//4 执行 accept</span><br>        SocketChannel channel = serverSocketChannel.accept();<br>        channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <br>        <span class="hljs-comment">//5 关注 read 事件</span><br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Step1 - 3,在NioEventLoop里面已经讲明，接下来从Step4开始讲起，即NioEventLoop中的processSelectedKey()中的unsafe.read()方法讲起。</p><p>先来看可接入事件处理（accept）</p><p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span>.<span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();    <br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    <span class="hljs-keyword">boolean</span> closed = <span class="hljs-keyword">false</span>;<br>    Throwable exception = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf，完成Step4</span><br>                <span class="hljs-comment">// readBuf 是一个 ArrayList 用来缓存消息</span><br>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);<br>                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                    closed = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><span class="hljs-comment">// localRead 为 1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.incMessagesRead(localRead);<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = readBuf.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发 read 事件，让 pipeline 上的 handler 处理，从head handler开始，到tail handler结束，中间有一个accept handler来处理accept事件，这个accept handler是在启动流程中加入到ServerSocketChannel的pipeline上的。即io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        readBuf.clear();<br>        allocHandle.readComplete();<br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>            closed = closeOnReadError(exception);<br><br>            pipeline.fireExceptionCaught(exception);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (closed) &#123;<br>            inputShutdown = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                close(voidPromise());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    <span class="hljs-comment">// 这时的 msg 是 NioSocketChannel</span><br>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel 添加  childHandler 即初始化器</span><br>    child.pipeline().addLast(childHandler);<br><br>    <span class="hljs-comment">// 设置选项</span><br>    setChannelOptions(child, childOptions, logger);<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel 到 nio worker 线程（这里面也包括将NioSocketChannel注册到selector上），接下来的处理也移交至 nio worker 线程，完成Step5</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 一些检查，略...</span><br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的事情是 nio boss -&gt; nio worker 线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// 日志记录...</span><br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> firstRegistration = neverRegistered;<br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invokeHandlerAddedIfNeeded(); <span class="hljs-comment">// 触发SocketChannel上的初始化操作。</span><br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发 pipeline 上 active 事件</span><br>                pipeline.fireChannelActive(); <span class="hljs-comment">// 关注 selection Key 的 read事件上，完成Step6</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    ctx.fireChannelActive();<br><span class="hljs-comment">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span><br>    readIfIsAutoRead();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 这时候 interestOps 是 0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注 read 事件</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-read-剖析"><a href="#2-4-read-剖析" class="headerlink" title="2.4 read 剖析"></a>2.4 read 剖析</h3><p>read 流程 </p><ul><li>selector.select()阻塞直到事件发生 </li><li>遍历处理 selectedKeys </li><li>拿到一个key，判断事件类型是否为read </li><li>读取操作</li></ul><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>    <span class="hljs-comment">// io.netty.allocator.type 决定 allocator 的实现</span><br>    <span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release();<br>                byteBuf = <span class="hljs-keyword">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-keyword">null</span>;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 触发 read complete 事件</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">continueReading</span><span class="hljs-params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <br>           <span class="hljs-comment">// 一般为 true</span><br>           config.isAutoRead() &amp;&amp;<br>           <span class="hljs-comment">// respectMaybeMoreData 默认为 true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span><br>           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;<br>           <span class="hljs-comment">// 小于最大次数，maxMessagePerRead 默认 16</span><br>           totalMessages &lt; maxMessagePerRead &amp;&amp;<br>           <span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2022/03/25/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/25/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="第01章-数据库概述"><a href="#第01章-数据库概述" class="headerlink" title="第01章_数据库概述"></a>第01章_数据库概述</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><ul><li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘上加以”固化”</strong>，而持久化的实现过程大多通过各种关系数据库来完成。</li><li>持久化的主要作用是<strong>将内存中的数据存储在关系型数据库中</strong>，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211020202152071.png" alt="" style="zoom:50%;" /><p>生活中的例子：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image_20211020132711.jpg"></p><h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2.1 数据库的相关概念"></a>2.1 数据库的相关概念</h3><table><thead><tr><th><strong>DB：数据库（Database）</strong></th></tr></thead><tbody><tr><td>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</td></tr><tr><td><strong>DBMS：数据库管理系统（Database Management System）</strong></td></tr><tr><td>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</td></tr><tr><td><strong>SQL：结构化查询语言（Structured Query Language）</strong></td></tr><tr><td>专门用来与数据库通信的语言。</td></tr></tbody></table><h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2.2 数据库与数据库管理系统的关系"></a>2.2 数据库与数据库管理系统的关系</h3><p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。 </p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211013202511233.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210915112546261.png"></p><h3 id="2-3-常见的数据库管理系统排名-DBMS"><a href="#2-3-常见的数据库管理系统排名-DBMS" class="headerlink" title="2.3 常见的数据库管理系统排名(DBMS)"></a>2.3 常见的数据库管理系统排名(DBMS)</h3><p>目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年<strong>DB-Engines Ranking</strong> 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:<a href="https://db-engines.com/en/ranking%EF%BC%89">https://db-engines.com/en/ranking）</a></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211013202815851.png"></p><p>… …</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211013202940798.png"></p><p>对应的走势图：（<a href="https://db-engines.com/en/ranking_trend%EF%BC%89">https://db-engines.com/en/ranking_trend）</a></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211013203029492.png"></p><h3 id="2-4-常见的数据库介绍"><a href="#2-4-常见的数据库介绍" class="headerlink" title="2.4 常见的数据库介绍"></a>2.4 常见的数据库介绍</h3><p><strong>Oracle</strong></p><p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。</p><p>2007年，总计85亿美金收购BEA Systems。</p><p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p><p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p><p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p><p><strong>SQL Server</strong></p><p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。</p><p><strong>DB2</strong></p><p>IBM公司的数据库产品,收费的。常应用在银行系统中。</p><p><strong>PostgreSQL</strong></p><p>PostgreSQL 的稳定性极强，<strong>最符合SQL标准</strong>，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。</p><p><strong>SyBase</strong></p><p>已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。 </p><p><strong>SQLite</strong></p><p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p><p><strong>informix</strong></p><p>IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。  </p><h2 id="3-MySQL介绍"><a href="#3-MySQL介绍" class="headerlink" title="3. MySQL介绍"></a>3. MySQL介绍</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210829230656830.png"></p><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul><li>MySQL是一个<code>开放源代码的关系型数据库管理系统</code>，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。</li><li>2008被<code>Sun</code>收购（10亿美金），2009年Sun被<code>Oracle</code>收购。<code>MariaDB</code>应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）</li><li>MySQL6.x 版本之后分为<code>社区版</code>和<code>商业版</code>。</li><li>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性（分库分表）。</li><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL是可以定制的，采用了<code>GPL（GNU General Public License）</code>协议，你可以修改源码来开发自己的MySQL系统。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持<code>4GB</code>，64位系统支持最大的表文件为<code>8TB</code>。</li><li>MySQL使用<code>标准的SQL数据语言</code>形式。</li><li>MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。</li></ul><h3 id="3-2-MySQL发展史重大事件"><a href="#3-2-MySQL发展史重大事件" class="headerlink" title="3.2 MySQL发展史重大事件"></a>3.2 MySQL发展史重大事件</h3><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210730161043856.png"></p><h3 id="1-4-关于MySQL-8-0"><a href="#1-4-关于MySQL-8-0" class="headerlink" title="1.4 关于MySQL 8.0"></a>1.4 关于MySQL 8.0</h3><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="1-5-Why-choose-MySQL"><a href="#1-5-Why-choose-MySQL" class="headerlink" title="1.5 Why choose MySQL?"></a>1.5 Why choose MySQL?</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211013210429011.png"></p><p>为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：    </p><ol><li><p>   开放源代码，使用成本低。</p></li><li><p>   性能卓越，服务稳定。</p></li><li><p>   软件体积小，使用简单，并且易于维护。</p></li><li><p>   历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</p></li><li><p>   许多互联网公司在用，经过了时间的验证。</p></li></ol><h3 id="1-6-Oracle-vs-MySQL"><a href="#1-6-Oracle-vs-MySQL" class="headerlink" title="1.6 Oracle vs MySQL"></a>1.6 Oracle vs MySQL</h3><p>Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。</p><p>MySQL 由于其<strong>体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库</strong>（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。</p><h2 id="4-RDBMS-与-非RDBMS"><a href="#4-RDBMS-与-非RDBMS" class="headerlink" title="4. RDBMS 与 非RDBMS"></a>4. RDBMS 与 非RDBMS</h2><p>从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。</p><h3 id="4-1-关系型数据库-RDBMS"><a href="#4-1-关系型数据库-RDBMS" class="headerlink" title="4.1 关系型数据库(RDBMS)"></a>4.1 关系型数据库(RDBMS)</h3><h4 id="4-1-1-实质"><a href="#4-1-1-实质" class="headerlink" title="4.1.1 实质"></a>4.1.1 实质</h4><ul><li><p>这种类型的数据库是<code>最古老</code>的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的<code>二元关系</code>（即二维表格形式）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211020145811031.png"></p></li><li><p>关系型数据库以<code>行(row)</code>和<code>列(column)</code>的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表(table)</code>，一组表组成了一个库(database)。</p></li><li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用<code>关系模型</code>来表示。关系型数据库，就是建立在<code>关系模型</code>基础上的数据库。</p></li><li><p>SQL 就是关系型数据库的查询语言。</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235413708.png"></p><h4 id="4-1-2-优势"><a href="#4-1-2-优势" class="headerlink" title="4.1.2 优势"></a>4.1.2 优势</h4><ul><li><strong>复杂查询</strong><br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持</strong><br>使得对于安全性能很高的数据访问要求得以实现。</li></ul><h3 id="4-2-非关系型数据库-非RDBMS"><a href="#4-2-非关系型数据库-非RDBMS" class="headerlink" title="4.2 非关系型数据库(非RDBMS)"></a>4.2 非关系型数据库(非RDBMS)</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过SQL层的解析，<code>性能非常高</code>。同时，通过减少不常用的功能，进一步提高性能。</p><p>目前基本上大部分主流的非关系型数据库都是免费的。</p><h4 id="4-2-2-有哪些非关系型数据库"><a href="#4-2-2-有哪些非关系型数据库" class="headerlink" title="4.2.2 有哪些非关系型数据库"></a>4.2.2 有哪些非关系型数据库</h4><p>相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</p><p><strong>键值型数据库</strong></p><p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis </code>是最流行的键值型数据库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211020172958427.png"></p><p><strong>文档型数据库</strong></p><p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。<code>MongoDB</code> 是最流行的文档型数据库。此外，还有CouchDB等。</p><p><strong>搜索引擎数据库</strong></p><p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品：Solr、<code>Elasticsearch</code>、Splunk 等。</p><p><strong>列式数据库</strong></p><p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以<strong>大量降低系统的 I/O</strong>，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><p>关于列式数据库为什么可以大量降低系统的I/O？这是因为在查询时，往往只关心某几个字段的值，但是行式存储会读取全部字段的值（因为其是按行存储的），但是列式存储可以只读取特定字段的值，大大降低了数据的冗余。所以列式数据库可以大量降低系统的I/O，大幅度地提高性能。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211020173921726.png"></p><p><strong>图形数据库</strong></p><p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p><p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211020180934455.png" alt="" style="zoom:80%;" /><h4 id="4-2-3-NoSQL的演变"><a href="#4-2-3-NoSQL的演变" class="headerlink" title="4.2.3 NoSQL的演变"></a>4.2.3 NoSQL的演变</h4><p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 <code>NoSQL 功能的演变</code>：</p><p>1970：NoSQL = We have no SQL</p><p>1980：NoSQL = Know SQL</p><p>2000：NoSQL = No SQL!</p><p>2005：NoSQL = Not only SQL</p><p>2013：NoSQL = No, SQL!</p><p>NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用<code>性能更高</code>、<code>成本更低</code>的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。整套课程将围绕 SQL 展开。</p><h2 id="5-关系型数据库设计规则"><a href="#5-关系型数据库设计规则" class="headerlink" title="5. 关系型数据库设计规则"></a>5. 关系型数据库设计规则</h2><ul><li><p>关系型数据库的典型数据结构就是<code>数据表</code>，这些数据表的组成都是结构化的（Structured）。</p></li><li><p>将数据放到表中，表再放到库中。</p></li><li><p>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</p></li><li><p>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</p></li></ul><h3 id="5-1-表、记录、字段"><a href="#5-1-表、记录、字段" class="headerlink" title="5.1 表、记录、字段"></a>5.1 表、记录、字段</h3><ul><li><p>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</p></li><li><p>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235450032-1634141235163.png"></p><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">ORM思想 (Object Relational Mapping / 对象关系映射)体现：<br>数据库中的一个表  &lt;---&gt; Java或Python中的一个类<br>表中的一条数据  &lt;---&gt; 类中的一个对象（或实体）<br>表中的一个列  &lt;---&gt; 类中的一个字段、属性(field)<br></code></pre></td></tr></table></figure><h3 id="5-2-表的关联关系"><a href="#5-2-表的关联关系" class="headerlink" title="5.2 表的关联关系"></a>5.2 表的关联关系</h3><ul><li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</p></li><li><p>四种：一对一关联、一对多关联、多对多关联、自我引用</p></li></ul><h4 id="5-2-1-一对一关联（one-to-one）"><a href="#5-2-1-一对一关联（one-to-one）" class="headerlink" title="5.2.1 一对一关联（one-to-one）"></a>5.2.1 一对一关联（one-to-one）</h4><ul><li><p>在实际的开发中应用不多，因为一对一可以创建成一张表。</p></li><li><p>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…</p><ul><li><p>拆为两个表：两个表的记录是一一对应关系。</p></li><li><p><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</p></li><li><p><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</p></li></ul></li><li><p>两种建表原则： </p><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 </li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235534452.png"></p><h4 id="5-2-2-一对多关系（one-to-many）"><a href="#5-2-2-一对多关系（one-to-many）" class="headerlink" title="5.2.2 一对多关系（one-to-many）"></a>5.2.2 一对多关系（one-to-many）</h4><ul><li><p>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</p></li><li><p>举例：</p><ul><li><p>员工表：编号、姓名、…、所属部门</p></li><li><p>部门表：编号、名称、简介</p></li></ul></li><li><p>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210915001013524.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235610597.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210915084623432.png"></p><h4 id="5-2-3-多对多（many-to-many）"><a href="#5-2-3-多对多（many-to-many）" class="headerlink" title="5.2.3 多对多（many-to-many）"></a>5.2.3 多对多（many-to-many）</h4><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210915001048215.png"></p><ul><li><p><strong>举例1：学生-课程</strong></p><ul><li><p><code>学生信息表</code>：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）</p></li><li><p><code>课程信息表</code>：一行代表一个课程的信息（课程编号、授课老师、简介…）</p></li><li><p><code>选课信息表</code>：一个学生可以选多门课，一门课可以被多个学生选择</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">学号</span>     <span class="hljs-string">课程编号</span>  <br><span class="hljs-number">1</span>        <span class="hljs-number">1001</span><br><span class="hljs-number">2</span>        <span class="hljs-number">1001</span><br><span class="hljs-number">1</span>        <span class="hljs-number">1002</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>举例2：产品-订单</strong></p><p>“订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。</p><ul><li><code>产品表</code>：“产品”表中的每条记录表示一个产品。</li><li><code>订单表</code>：“订单”表中的每条记录表示一个订单。</li><li><code>订单明细表</code>：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235637068.png"></p><ul><li><strong>举例3：用户-角色</strong></li><li>多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210915084707586.png"></p><h4 id="5-3-4-自我引用-Self-reference"><a href="#5-3-4-自我引用-Self-reference" class="headerlink" title="5.3.4 自我引用(Self reference)"></a>5.3.4 自我引用(Self reference)</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914235651997.png"></p><h1 id="第02章-MySQL环境搭建"><a href="#第02章-MySQL环境搭建" class="headerlink" title="第02章_MySQL环境搭建"></a>第02章_MySQL环境搭建</h1><h2 id="1-MySQL的卸载"><a href="#1-MySQL的卸载" class="headerlink" title="1. MySQL的卸载"></a>1. MySQL的卸载</h2><h3 id="步骤1：停止MySQL服务"><a href="#步骤1：停止MySQL服务" class="headerlink" title="步骤1：停止MySQL服务"></a>步骤1：停止MySQL服务</h3><p>在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014153604802.png"></p><h3 id="步骤2：软件的卸载"><a href="#步骤2：软件的卸载" class="headerlink" title="步骤2：软件的卸载"></a>步骤2：软件的卸载</h3><p><strong>方式1：通过控制面板方式</strong></p><p>卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014153657668.png"></p><p><strong>方式2：通过360或电脑管家等软件卸载</strong></p><p>略</p><p><strong>方式3：通过安装包提供的卸载功能卸载</strong></p><p>你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。</p><p>① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。</p><p>② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014153722683.png"></p><p>③ 单击“Next”（下一步）按钮，确认卸载。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014153747283.png"></p><p>④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the data directory”，如图所示。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014154112574.png" alt="" style="zoom:80%;" /><p>⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014154006530.png" alt="" style="zoom:90%;" /><p>⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes，Uninstall MySQL Installer”即可，如图所示。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014154046268.png" alt="" style="zoom:80%;" /><h3 id="步骤3：残余文件的清理"><a href="#步骤3：残余文件的清理" class="headerlink" title="步骤3：残余文件的清理"></a>步骤3：残余文件的清理</h3><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。</p><p>（1）服务目录：mysql服务的安装目录</p><p>（2）数据目录：默认在C:\ProgramData\MySQL</p><p>如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。</p><blockquote><p>注意：请在卸载前做好数据备份</p><p>在操作完以后，需要重启计算机，然后进行安装即可。<strong>如果仍然安装失败，需要继续操作如下步骤4。</strong></p></blockquote><h3 id="步骤4：清理注册表（选做）"><a href="#步骤4：清理注册表（选做）" class="headerlink" title="步骤4：清理注册表（选做）"></a>步骤4：清理注册表（选做）</h3><p>如果前几步做了，再次安装还是失败，那么可以清理注册表。</p><p>如何打开注册表编辑器：在系统的搜索框中输入<code>regedit</code></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>ontrolSet001<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\E</span>ventlog<span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\M</span>ySQL服务 目录删除<br><br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>ontrolSet001<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\M</span>ySQL服务 目录删除<br><br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>ontrolSet002<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\E</span>ventlog<span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\M</span>ySQL服务 目录删除<br><br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>ontrolSet002<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\M</span>ySQL服务 目录删除<br><br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>urrentControlSet<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\E</span>ventlog<span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\M</span>ySQL服务目录删除<br><br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>urrentControlSet<span class="hljs-symbol">\S</span>ervices<span class="hljs-symbol">\M</span>ySQL服务删除<br></code></pre></td></tr></table></figure><blockquote><p>注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类</p></blockquote><h3 id="步骤5：删除环境变量配置"><a href="#步骤5：删除环境变量配置" class="headerlink" title="步骤5：删除环境变量配置"></a>步骤5：删除环境变量配置</h3><p>找到path环境变量，将其中关于mysql的环境变量删除，<strong>切记不要全部删除。</strong></p><p>例如：删除  D:\develop_tools\mysql\MySQLServer8.0.26\bin;  这个部分</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1575694476072.png"></p><h2 id="2-MySQL的下载、安装、配置"><a href="#2-MySQL的下载、安装、配置" class="headerlink" title="2. MySQL的下载、安装、配置"></a>2. MySQL的下载、安装、配置</h2><h3 id="2-1-MySQL的4大版本"><a href="#2-1-MySQL的4大版本" class="headerlink" title="2.1 MySQL的4大版本"></a>2.1 MySQL的4大版本</h3><blockquote><ul><li><p><strong>MySQL Community Server 社区版本</strong>，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。</p></li><li><p><strong>MySQL Enterprise Edition 企业版本</strong>，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。</p></li><li><p><strong>MySQL Cluster 集群版</strong>，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。</p></li><li><p><strong>MySQL Cluster CGE 高级集群版</strong>，需付费。</p></li></ul></blockquote><ul><li>目前最新版本为<code>8.0.27</code>，发布时间<code>2021年10月</code>。此前，8.0.0 在 2016.9.12日就发布了。</li></ul><ul><li>本课程中使用<code>8.0.26版本</code>。</li></ul><p>此外，官方还提供了<code>MySQL Workbench</code>（GUITOOL）一款专为MySQL设计的<code>图形界面管理工具</code>。MySQLWorkbench又分为两个版本，分别是<code>社区版</code>（MySQL Workbench OSS）、<code>商用版</code>（MySQL WorkbenchSE）。</p><h3 id="2-2-软件的下载"><a href="#2-2-软件的下载" class="headerlink" title="2.2 软件的下载"></a>2.2 软件的下载</h3><p><strong>1. 下载地址</strong></p><p>官网：<a href="https://www.mysql.com/">https://www.mysql.com</a></p><p><strong>2. 打开官网，点击DOWNLOADS</strong></p><p>然后，点击<code>MySQL Community(GPL) Downloads</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210817185920150.png"></p><p><strong>3. 点击 MySQL Community Server</strong></p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210817185955123.png" alt="" style="zoom:80%;" /><p><strong>4. 在General Availability(GA) Releases中选择适合的版本</strong></p><p>Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。</p><ul><li>这里在Windows 系统下推荐下载<code>MSI安装程序</code>；点击<code>Go to Download Page</code>进行下载即可</li></ul> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210727192819147.png" alt="" style="zoom:67%;" /><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014163001964.png"></p><ul><li>Windows下的MySQL8.0安装有两种安装程序<ul><li><code>mysql-installer-web-community-8.0.26.0.msi</code> 下载程序大小：2.4M；安装时需要联网安装组件。</li><li><code>mysql-installer-community-8.0.26.0.msi</code> 下载程序大小：450.7M；安装时离线安装即可。<strong>推荐。</strong></li></ul></li><li>如果安装MySQL5.7版本的话，选择<code>Archives</code>，接着选择MySQL5.7的相应版本即可。这里下载最近期的MySQL5.7.34版本。</li></ul><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014163228051.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014163353156.png"></p><h3 id="2-3-MySQL8-0-版本的安装"><a href="#2-3-MySQL8-0-版本的安装" class="headerlink" title="2.3 MySQL8.0 版本的安装"></a>2.3 MySQL8.0 版本的安装</h3><p>MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。</p><p>步骤1：双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。</p><p>步骤2：打开“Choosing a Setup Type”（选择安装类型）窗口，在其中列出了5种安装类型，分别是Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、Full（完全安装）、Custom（自定义安装）。这里选择“Custom（自定义安装）”类型按钮，单击“Next(下一步)”按钮。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014170553535.png" alt="" style="zoom:90%;" /><p>步骤3：打开“Select Products” （选择产品）窗口，可以定制需要安装的产品清单。例如，选择“MySQL Server 8.0.26-X64”后，单击“→”添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014170638699.png" alt="" style="zoom:80%;" /><p>此时如果直接“Next”（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014170814386.png" alt="" style="zoom:80%;" /><p>单击“Advanced Options”（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的Program Files目录和ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014170857263.png" alt="" style="zoom:80%;" /><p>步骤4：在上一步选择好要安装的产品之后，单击“Next”（下一步）进入确认窗口，如图所示。单击“Execute”（执行）按钮开始安装。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014170934889.png" alt="" style="zoom:90%;" /><p>步骤5：安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014171002259.png" alt="" style="zoom:90%;" /><h3 id="2-4-配置MySQL8-0"><a href="#2-4-配置MySQL8-0" class="headerlink" title="2.4 配置MySQL8.0"></a>2.4 配置MySQL8.0</h3><p>MySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。</p><p>步骤1：在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image002-1634203188594.jpg" alt="" style="zoom:80%;" /><p>步骤2：单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image004-1634203188595.jpg" alt="" style="zoom:80%;" /><p>其中，“Config Type”选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image006-1634203188595.jpg" alt="" style="zoom:80%;" /><ul><li><p><code>Development Machine（开发机器）</code>：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源。</p></li><li><p><code>Server Machine（服务器）</code>：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。</p></li><li><p><code>Dedicated Machine（专用服务器）</code>：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。</p></li></ul><p>步骤3：单击“Next”（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image008-1634203188595.jpg" alt="" style="zoom:80%;" /><p>步骤4：单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image010-1634203188595.jpg" alt="" style="zoom:80%;" /><p>步骤5：单击“Next”（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选“Start the MySQL Server at System Startup”选项（推荐）。</p><p>下面是选择以什么方式运行服务？可以选择“Standard System Account”(标准系统用户)或者“Custom User”(自定义用户)中的一个。这里推荐前者。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image012-1634203188596.jpg" alt="" style="zoom:80%;" /><p>步骤6：单击“Next”（下一步）按钮，打开确认设置服务器窗口，单击“Execute”（执行）按钮。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image014-1634203188596.jpg" alt="" style="zoom:80%;" /><p>步骤7：完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image016.jpg" alt="" style="zoom:80%;" /><p>步骤8：如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择“Next”（下一步），直接完成整个安装和配置过程。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image018.jpg" alt="" style="zoom:80%;" /><p>步骤9：结束安装和配置。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image020.jpg" alt="" style="zoom:80%;" /><h3 id="2-5-配置MySQL8-0-环境变量"><a href="#2-5-配置MySQL8-0-环境变量" class="headerlink" title="2.5 配置MySQL8.0 环境变量"></a>2.5 配置MySQL8.0 环境变量</h3><p>如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境变量：</p><p>步骤1：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。<br>步骤2：打开【系统】窗口，单击【高级系统设置】链接。<br>步骤3：打开【系统属性】对话框，选择【高级】选项卡，然后单击【环境变量】按钮。<br>步骤4：打开【环境变量】对话框，在系统变量列表中选择path变量。<br>步骤5：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\Program Files\MySQL\MySQL Server 8.0\bin）添加到变量值中，用分号将其与其他路径分隔开。<br>步骤6：添加完成之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录数据库了。</p><h3 id="2-6-MySQL5-7-版本的安装、配置"><a href="#2-6-MySQL5-7-版本的安装、配置" class="headerlink" title="2.6 MySQL5.7 版本的安装、配置"></a>2.6 MySQL5.7 版本的安装、配置</h3><ul><li><strong>安装</strong></li></ul><p>此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。所以这里省略了MySQL5.7.34版本的安装截图。</p><ul><li><strong>配置</strong></li></ul><p>配置环节与MySQL8.0版本确有细微不同。大部分情况下直接选择“Next”即可，不影响整理使用。</p><p>这里配置MySQL5.7时，重点强调：<strong>与前面安装好的MySQL8.0不能使用相同的端口号。</strong></p><h3 id="2-7-安装失败问题"><a href="#2-7-安装失败问题" class="headerlink" title="2.7 安装失败问题"></a>2.7 安装失败问题</h3><p>MySQL的安装和配置是一件非常简单的事，但是在操作过程中也可能出现问题，特别是初学者。</p><p><strong>问题1：无法打开MySQL8.0软件安装包或者安装过程中失败，如何解决？</strong></p><p>在运行MySQL8.0软件安装包之前，用户需要确保系统中已经安装了.Net Framework相关软件，如果缺少此软件，将不能正常地安装MySQL8.0软件。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image002.gif" alt="" style="zoom:80%;" /><p>解决方案：到这个地址<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42642%E4%B8%8B%E8%BD%BDMicrosoft">https://www.microsoft.com/en-us/download/details.aspx?id=42642下载Microsoft</a> .NET Framework 4.5并安装后，再去安装MySQL。</p><p>另外，还要确保Windows Installer正常安装。windows上安装mysql8.0需要操作系统提前已安装好Microsoft Visual C++ 2015-2019。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image004.gif" alt="" style="zoom:75%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/clip_image006.gif" alt="" style="zoom:75%;" /><p>解决方案同样是，提前到微软官网<a href="https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%9A%84%E7%8E%AF%E5%A2%83%E3%80%82">https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0，下载相应的环境。</a></p><p><strong>问题2：卸载重装MySQL失败？</strong></p><p>该问题通常是因为MySQL卸载时，没有完全清除相关信息导致的。</p><p>解决办法是，把以前的安装目录删除。如果之前安装并未单独指定过服务安装目录，则默认安装目录是“C:\Program Files\MySQL”，彻底删除该目录。同时删除MySQL的Data目录，如果之前安装并未单独指定过数据目录，则默认安装目录是“C:\ProgramData\MySQL”，该目录一般为隐藏目录。删除后，重新安装即可。</p><p><strong>问题3：如何在Windows系统删除之前的未卸载干净的MySQL服务列表？</strong></p><p>操作方法如下，在系统“搜索框”中输入“cmd”，按“Enter”（回车）键确认，弹出命令提示符界面。然后输入“sc delete MySQL服务名”,按“Enter”（回车）键，就能彻底删除残余的MySQL服务了。</p><h2 id="3-MySQL的登录"><a href="#3-MySQL的登录" class="headerlink" title="3. MySQL的登录"></a>3. MySQL的登录</h2><h3 id="3-1-服务的启动与停止"><a href="#3-1-服务的启动与停止" class="headerlink" title="3.1 服务的启动与停止"></a>3.1 服务的启动与停止</h3><p>MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。</p><p>在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。</p><h4 id="方式1：使用图形界面工具"><a href="#方式1：使用图形界面工具" class="headerlink" title="方式1：使用图形界面工具"></a>方式1：使用图形界面工具</h4><ul><li><p>步骤1：打开windows服务</p><ul><li>方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击）</li><li>方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）</li><li>方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）</li><li>方式4：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认 </li></ul></li><li><p>步骤2：找到MySQL80（点击鼠标右键）→ 启动或停止（点击）</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014183908375.png"></p><h4 id="方式2：使用命令行工具"><a href="#方式2：使用命令行工具" class="headerlink" title="方式2：使用命令行工具"></a>方式2：使用命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 启动 MySQL 服务命令：<br>net start MySQL服务名<br><br># 停止 MySQL 服务命令：<br>net stop MySQL服务名<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014184037414.png" alt="" style="zoom:80%;" /><p>说明：</p><ol><li><p>start和stop后面的服务名应与之前配置时指定的服务名一致。</p></li><li><p>如果当你输入命令后，提示“拒绝服务”，请以<code>系统管理员身份</code>打开命令提示符界面重新尝试。</p></li></ol><h3 id="3-2-自带客户端的登录与退出"><a href="#3-2-自带客户端的登录与退出" class="headerlink" title="3.2 自带客户端的登录与退出"></a>3.2 自带客户端的登录与退出</h3><p>当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。</p><h4 id="登录方式1：MySQL自带客户端"><a href="#登录方式1：MySQL自带客户端" class="headerlink" title="登录方式1：MySQL自带客户端"></a>登录方式1：MySQL自带客户端</h4><p>开始菜单 → 所有程序 → MySQL → MySQL 8.0 Command Line Client</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014184425147.png" alt="" style="zoom:80%;" /><blockquote><p>说明：仅限于root用户</p></blockquote><h4 id="登录方式2：windows命令行"><a href="#登录方式2：windows命令行" class="headerlink" title="登录方式2：windows命令行"></a>登录方式2：windows命令行</h4><ul><li>格式：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h 主机名 -<span class="hljs-selector-tag">P</span> 端口号 -u 用户名 -<span class="hljs-selector-tag">p</span>密码<br></code></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -h localhost -P 3306 -u root -pabc123  # 这里我设置的root用户的密码是abc123<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014185035137.png" alt="" style="zoom:80%;" /><p>注意：</p><p>（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>hlocalhost <span class="hljs-operator">-</span>P3306 <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>pabc123<br></code></pre></td></tr></table></figure><p>（2）密码建议在下一行输入，保证安全</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h localhost <span class="hljs-operator">-</span>P <span class="hljs-number">3306</span> <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br>Enter password:<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>（3）客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机：<br>-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</p><p>  简写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br>Enter password:<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。</p><p>也可以在命令行通过以下方式获取MySQL Server服务版本的信息：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">c:</span>\&gt; mysql -V<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">c:\&gt; mysql <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>或<strong>登录</strong>后，通过以下方式查看当前版本信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">mysql&gt; <span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">version</span>(<span class="hljs-params"></span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br>或<br>quit<br></code></pre></td></tr></table></figure><h2 id="4-MySQL演示使用"><a href="#4-MySQL演示使用" class="headerlink" title="4. MySQL演示使用"></a>4. MySQL演示使用</h2><h3 id="4-1-MySQL的使用演示"><a href="#4-1-MySQL的使用演示" class="headerlink" title="4.1 MySQL的使用演示"></a>4.1 MySQL的使用演示</h3><p>1、查看所有的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure><blockquote><p>“information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等</p><p>“performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。 </p><p>“sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。 </p><p>“mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等</p></blockquote><p>为什么 Workbench 里面我们只能看到“demo”和“sys”这 2 个数据库呢？ </p><p>这是因为，Workbench 是图形化的管理工具，主要面向开发人 员，“demo”和“sys”这 2 个数据库已经够用了。如果有特殊需求，比如，需要监控 MySQL 数据库各项性能指标、直接操作 MySQL 数据库系统文件等，可以由 DBA 通过 SQL 语句，查看其它的系统数据库。</p><p>2、创建自己的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database 数据库名;<br><br>#创建atguigudb数据库，该名称不能与已经存在的数据库重名。<br>create database atguigudb;<br></code></pre></td></tr></table></figure><p>3、使用自己的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名;<br><br>#使用atguigudb数据库<br>use atguigudb;<br></code></pre></td></tr></table></figure><p>说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046 (3D000): No database selected”（没有选择数据库）</p><p>使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。</p><p>4、查看某个库的所有表格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;  #要求前面有use语句<br><br>show tables from 数据库名;<br></code></pre></td></tr></table></figure><p>5、创建新的表格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型,<br>字段名 数据类型<br>);<br></code></pre></td></tr></table></figure><p>说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建学生表<br>create table student(<br>id int,<br>    name varchar(20)  #说名字最长不超过20个字符<br>);<br></code></pre></td></tr></table></figure><p>6、查看一个表的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 数据库表名称;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看学生表的数据<br>select * from student;<br></code></pre></td></tr></table></figure><p>7、添加一条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名称 values(值列表);<br><br>#添加两条记录到student表中<br>insert into student values(1,&#x27;张三&#x27;);<br>insert into student values(2,&#x27;李四&#x27;);<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; insert into student values(1,&#x27;张三&#x27;);<br>ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;name&#x27; at row 1<br>mysql&gt; insert into student values(2,&#x27;李四&#x27;);<br>ERROR 1366 (HY000): Incorrect string value: &#x27;\xC0\xEE\xCB\xC4&#x27; for column &#x27;name&#x27; at row 1<br>mysql&gt; show create table student;<br></code></pre></td></tr></table></figure><p>字符集的问题。</p><p>8、查看表的创建信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table 表名称;<br><br><br>#查看student表的详细创建信息<br>show create table student;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#结果如下<br>*************************** 1. row ***************************<br>       Table: student<br>Create Table: CREATE TABLE `student` (<br>  `id` int(11) DEFAULT NULL,<br>  `name` varchar(20) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>上面的结果显示student的表格的默认字符集是“latin1”不支持中文。</p><p>9、查看数据库的创建信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create database 数据库名;<br><br>#查看atguigudb数据库的详细创建信息<br>show create database atguigudb;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#结果如下<br>*************************** 1. row ***************************<br>       Database: atguigudb<br>Create Database: CREATE DATABASE `atguigudb` /*!40100 DEFAULT CHARACTER SET latin1 */<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>上面的结果显示atguigudb数据库也不支持中文，字符集默认是latin1。</p><p>10、删除表格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名称;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除学生表<br>drop table student;<br></code></pre></td></tr></table></figure><p>11、删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除atguigudb数据库<br>drop database atguigudb;<br></code></pre></td></tr></table></figure><h3 id="4-2-MySQL的编码设置"><a href="#4-2-MySQL的编码设置" class="headerlink" title="4.2 MySQL的编码设置"></a>4.2 MySQL的编码设置</h3><h4 id="MySQL5-7中"><a href="#MySQL5-7中" class="headerlink" title="MySQL5.7中"></a>MySQL5.7中</h4><p><strong>问题再现：命令行操作sql乱码问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO t_stu VALUES(1,&#x27;张三&#x27;,&#x27;男&#x27;);<br>ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;sname&#x27; at row 1<br></code></pre></td></tr></table></figure><p><strong>问题解决</strong></p><p>步骤1：查看编码命令</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;character_%&#x27;</span>;<br>show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;collation_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>步骤2：修改mysql的数据目录下的my.ini配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysql]</span>  <span class="hljs-comment">#大概在63行左右，在其下添加</span><br>... <br><span class="hljs-attr">default-character-set</span>=utf8  <span class="hljs-comment">#默认字符集</span><br><br><span class="hljs-section">[mysqld]</span>  <span class="hljs-comment"># 大概在76行左右，在其下添加</span><br>...<br><span class="hljs-attr">character-set-server</span>=utf8<br><span class="hljs-attr">collation-server</span>=utf8_general_ci<br></code></pre></td></tr></table></figure><blockquote><p>注意：建议修改配置文件使用notepad++等高级文本编辑器，使用记事本等软件打开修改后可能会导致文件编码修改为“含BOM头”的编码，从而服务重启失败。</p></blockquote><p>步骤3：重启服务</p><p>步骤4：查看编码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;character_%&#x27;</span>;<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;collation_%&#x27;</span>;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/MySQL%E7%BC%96%E7%A0%811.jpg" style="zoom:90%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/MySQL%E7%BC%96%E7%A0%812.jpg" style="zoom:90%;" /><ul><li>如果是以上配置就说明对了。接着我们就可以新创建数据库、新创建数据表，接着添加包含中文的数据了。</li></ul><h4 id="MySQL8-0中"><a href="#MySQL8-0中" class="headerlink" title="MySQL8.0中"></a>MySQL8.0中</h4><p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3(每三个字节对应一个字符）。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为<code>utf8mb4</code>（每四个字节对应一个字符），从而避免了上述的乱码问题。</p><h2 id="5-MySQL图形化管理工具"><a href="#5-MySQL图形化管理工具" class="headerlink" title="5. MySQL图形化管理工具"></a>5. MySQL图形化管理工具</h2><p>MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBC Connector。</p><h3 id="工具1-MySQL-Workbench"><a href="#工具1-MySQL-Workbench" class="headerlink" title="工具1. MySQL Workbench"></a>工具1. MySQL Workbench</h3><p>MySQL官方提供的图形化管理工具MySQL Workbench完全支持MySQL 5.0以上的版本。MySQL Workbench分为社区版和商业版，社区版完全免费，而商业版则是按年收费。</p><p>MySQL Workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间的、难以变更和管理的文档任务。</p><p>下载地址：<a href="http://dev.mysql.com/downloads/workbench/%E3%80%82">http://dev.mysql.com/downloads/workbench/。</a></p><p>使用：</p><p>首先，我们点击 Windows 左下角的“开始”按钮，如果你是 Win10 系统，可以直接看到所有程序。接着，找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开 Workbench，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211007153522427.png"></p><p>左下角有个本地连接，点击，录入 Root 的密码，登录本地 MySQL 数据库服务器，如下图所示：</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195108502.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195129219.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195142849.png" alt="" style="zoom:80%;" /><p>这是一个图形化的界面，我来给你介绍下这个界面。 </p><ul><li><p>上方是菜单。左上方是导航栏，这里我们可以看到 MySQL 数据库服务器里面的数据 库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信息。 </p></li><li><p>中间上方是工作区，你可以在这里写 SQL 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执行工作区的 SQL 语句了。 </p></li><li><p>中间下方是输出区，用来显示 SQL 语句的运行情况，包括什么时间开始运行的、运行的 内容、运行的输出，以及所花费的时长等信息。</p></li></ul><p>好了，下面我们就用 Workbench 实际创建一个数据库，并且导入一个 Excel 数据文件， 来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。 </p><h3 id="工具2-Navicat"><a href="#工具2-Navicat" class="headerlink" title="工具2. Navicat"></a>工具2. Navicat</h3><p>Navicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。其精心设计的图形用户界面（GUI）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。Navicat支持中文，有免费版本提供。<br>下载地址：<a href="http://www.navicat.com/%E3%80%82">http://www.navicat.com/。</a></p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1557378069584.png" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210913180359685.png" alt="" style="zoom:80%;" /><h3 id="工具3-SQLyog"><a href="#工具3-SQLyog" class="headerlink" title="工具3. SQLyog"></a>工具3. SQLyog</h3><p>SQLyog 是业界著名的 Webyog 公司出品的一款简洁高效、功能强大的图形化 MySQL 数据库管理工具。这款工具是使用C++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过SQL文件进行大量文件的导入和导出，还可以导入和导出XML、HTML和CSV等多种格式的数据。<br>下载地址：<a href="http://www.webyog.com/%EF%BC%8C%E8%AF%BB%E8%80%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E7%89%88%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82">http://www.webyog.com/，读者也可以搜索中文版的下载地址。</a></p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014213018979.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014213036470.png" alt="" style="zoom:80%;" /><h3 id="工具4：dbeaver"><a href="#工具4：dbeaver" class="headerlink" title="工具4：dbeaver"></a>工具4：dbeaver</h3><p>DBeaver是一个通用的数据库管理工具和 SQL 客户端，支持所有流行的数据库：MySQL、PostgreSQL、SQLite、Oracle、DB2、SQL Server、 Sybase、MS Access、Teradata、 Firebird、Apache Hive、Phoenix、Presto等。DBeaver比大多数的SQL管理工具要轻量，而且支持中文界面。DBeaver社区版作为一个免费开源的产品，和其他类似的软件相比，在功能和易用性上都毫不逊色。</p><p>唯一需要注意是 DBeaver 是用Java编程语言开发的，所以需要拥有 JDK（Java Development ToolKit）环境。如果电脑上没有JDK，在选择安装DBeaver组件时，勾选“Include Java”即可。</p><p>下载地址：<a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195237457.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195251371.png" alt="" style="zoom:75%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195300510.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014195309805.png" alt="" style="zoom:70%;" /><h3 id="可能出现连接问题："><a href="#可能出现连接问题：" class="headerlink" title="可能出现连接问题："></a>可能出现连接问题：</h3><p>有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin ‘caching_sha2_password’ cannot be loaded”错误。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211019215249254.png" alt="" style="zoom:80%;" /><p>出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。</p><p>第二种解决方案如下，用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#使用mysql数据库<br>USE mysql; <br><br>#修改&#x27;root&#x27;@&#x27;localhost&#x27;用户的密码规则和密码<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;; <br><br>#刷新权限<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211019215408965.png" alt="" style="zoom:80%;" /><h2 id="6-MySQL目录结构与源码"><a href="#6-MySQL目录结构与源码" class="headerlink" title="6. MySQL目录结构与源码"></a>6. MySQL目录结构与源码</h2><h3 id="6-1-主要目录结构"><a href="#6-1-主要目录结构" class="headerlink" title="6.1 主要目录结构"></a>6.1 主要目录结构</h3><table><thead><tr><th>MySQL的目录结构</th><th>说明</th></tr></thead><tbody><tr><td>bin目录</td><td>所有MySQL的可执行文件。如：mysql.exe</td></tr><tr><td>MySQLInstanceConfig.exe</td><td>数据库的配置向导，在安装时出现的内容</td></tr><tr><td>data目录</td><td>系统数据库所在的目录</td></tr><tr><td>my.ini文件</td><td>MySQL的主要配置文件</td></tr><tr><td>c:\ProgramData\MySQL\MySQL Server 8.0\data\</td><td>用户创建的数据库所在的目录</td></tr></tbody></table><h3 id="6-2-MySQL-源代码获取"><a href="#6-2-MySQL-源代码获取" class="headerlink" title="6.2 MySQL 源代码获取"></a>6.2 MySQL 源代码获取</h3><p>首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。 </p><p>接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。</p><p>MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。 </p><p>mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码： </p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211007154113052.png"></p><ul><li><p>sql 子目录是 MySQL 核心代码；</p></li><li><p>libmysql 子目录是客户端程序 API；</p></li><li><p>mysql-test 子目录是测试工具；</p></li><li><p>mysys 子目录是操作系统相关函数和辅助函数；</p></li></ul><p>源代码可以用记事本打开查看，如果你有 C++ 的开发环境，也可以在开发环境中打开查看。 </p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211007154213156.png"></p><p>如上图所示，源代码并不神秘，就是普通的 C++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 MySQL 的开发人员对话一样，十分有趣。</p><h2 id="7-常见问题的解决-课外内容"><a href="#7-常见问题的解决-课外内容" class="headerlink" title="7. 常见问题的解决(课外内容)"></a>7. 常见问题的解决(课外内容)</h2><h3 id="问题1：root用户密码忘记，重置的操作"><a href="#问题1：root用户密码忘记，重置的操作" class="headerlink" title="问题1：root用户密码忘记，重置的操作"></a>问题1：root用户密码忘记，重置的操作</h3><p>1: 通过任务管理器或者服务管理，关掉mysqld(服务进程)<br>2: 通过命令行+特殊参数开启mysqld<br>mysqld –defaults-file=”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables</p><p>3: 此时，mysqld服务进程已经打开。并且不需要权限检查<br>4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行<br>5: 修改权限表<br>（1） use mysql;<br>（2）update user set authentication_string=password(‘新密码’) where user=’root’ and Host=’localhost’;<br>（3）flush privileges;<br>6: 通过任务管理器，关掉mysqld服务进程。<br>7: 再次通过服务管理，打开mysql服务。<br>8: 即可用修改后的新密码登陆。</p><h3 id="问题2：mysql命令报“不是内部或外部命令”"><a href="#问题2：mysql命令报“不是内部或外部命令”" class="headerlink" title="问题2：mysql命令报“不是内部或外部命令”"></a>问题2：mysql命令报“不是内部或外部命令”</h3><p>如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914093150145.png"></p><h3 id="问题3：错误ERROR-：没有选择数据库就操作表格和数据"><a href="#问题3：错误ERROR-：没有选择数据库就操作表格和数据" class="headerlink" title="问题3：错误ERROR ：没有选择数据库就操作表格和数据"></a>问题3：错误ERROR ：没有选择数据库就操作表格和数据</h3><table><thead><tr><th>ERROR 1046 (3D000): No database selected</th></tr></thead><tbody><tr><td>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</td></tr><tr><td>解决方案二：就是所有的表对象前面都加上“数据库.”</td></tr></tbody></table><h3 id="问题4：命令行客户端的字符集问题"><a href="#问题4：命令行客户端的字符集问题" class="headerlink" title="问题4：命令行客户端的字符集问题"></a>问题4：命令行客户端的字符集问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO t_stu VALUES(1,&#x27;张三&#x27;,&#x27;男&#x27;);<br>ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;sname&#x27; at row 1<br></code></pre></td></tr></table></figure><p>原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554912924219.png"></p><p>查看所有字符集：<strong>SHOW VARIABLES LIKE ‘character_set_%’;</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554912943186.png"></p><p>解决方案，设置当前连接的客户端字符集 <strong>“SET NAMES GBK;”</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554912957353.png"></p><h3 id="问题5：修改数据库和表的字符编码"><a href="#问题5：修改数据库和表的字符编码" class="headerlink" title="问题5：修改数据库和表的字符编码"></a>问题5：修改数据库和表的字符编码</h3><p>修改编码：</p><p>（1)先停止服务，（2）修改my.ini文件（3）重新启动服务</p><p>说明：</p><p>如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database 0728db charset Latin1;<br>Query OK, 1 row affected (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysql&gt; use <span class="hljs-number">0728</span>db<span class="hljs-comment">;</span><br>Database changed<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table student (id int , name varchar(20)) charset Latin1;<br>Query OK, 0 rows affected (0.02 sec)<br><br><br>mysql&gt; show create table student\G<br>*************************** 1. row ***************************<br>       Table: student<br>Create Table: CREATE TABLE `student` (<br>  `id` int(11) NOT NULL,<br>  `name` varchar(20) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table student charset utf8; #修改表字符编码为UTF8<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br><br>mysql&gt; show create table student\G<br>*************************** 1. row ***************************<br>       Table: student<br>Create Table: CREATE TABLE `student` (<br>  `id` int(11) NOT NULL,<br>  `name` varchar(20) CHARACTER SET latin1 DEFAULT NULL,  #字段仍然是latin1编码<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br>1 row in set (0.00 sec)<br><br><br>mysql&gt; alter table student modify name varchar(20) charset utf8; #修改字段字符编码为UTF8<br>Query OK, 0 rows affected (0.05 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br><br>mysql&gt; show create table student\G<br>*************************** 1. row ***************************<br>       Table: student<br>Create Table: CREATE TABLE `student` (<br>  `id` int(11) NOT NULL,<br>  `name` varchar(20) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show create database 0728db;;<br>+--------+-----------------------------------------------------------------+<br>|Database| Create Database                                                 |<br>+------+-------------------------------------------------------------------+<br>|0728db| CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET latin1 */ |<br>+------+-------------------------------------------------------------------+<br>1 row in set (0.00 sec)<br><br><br>mysql&gt; alter database 0728db charset utf8; #修改数据库的字符编码为utf8<br>Query OK, 1 row affected (0.00 sec)<br><br><br>mysql&gt; show create database 0728db;<br>+--------+-----------------------------------------------------------------+<br>|Database| Create Database                                                 |<br>+--------+-----------------------------------------------------------------+<br>| 0728db | CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET utf8 */ |<br>+--------+-----------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章_基本的SELECT语句"></a>第03章_基本的SELECT语句</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL概述</h2><h3 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1.1 SQL背景知识"></a>1.1 SQL背景知识</h3><ul><li><p>1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。</p><ul><li>45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，<code>SQL 的半衰期可以说是非常长</code>了。</li></ul></li><li><p>不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。</p></li><li><p>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，<code>与数据直接打交道</code>，由<code>IBM</code>上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有<code>SQL-86</code>，<code>SQL-89</code>，<code>SQL-92</code>，<code>SQL-99</code>等标准。</p><ul><li>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。</li></ul></li><li><p>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p></li></ul><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/SQLisputonghua.jpg" alt="" style="zoom:67%;" /><h3 id="1-2-SQL语言排行榜"><a href="#1-2-SQL语言排行榜" class="headerlink" title="1.2 SQL语言排行榜"></a>1.2 SQL语言排行榜</h3><p>自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211014230114639.png" alt="" style="zoom:80%;" /><h3 id="1-3-SQL-分类"><a href="#1-3-SQL-分类" class="headerlink" title="1.3 SQL 分类"></a>1.3 SQL 分类</h3><p>SQL语言在功能上主要分为如下3大类：</p><ul><li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p><ul><li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>、<code>RENAME</code>、<code>TRUNCATE(清空表，但是表结构还在)</code>等。</li></ul></li><li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p><ul><li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li><li><strong>SELECT是SQL语言的基础，最为重要。</strong></li></ul></li><li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p><ul><li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVE POINT</code>等。</li></ul></li></ul><blockquote><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p><p>还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p></blockquote><h2 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL语言的规则与规范</h2><h3 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h3><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束（<strong>\g 的作用是分号和在sql语句中写’;’是等效的；\G 的作用是将查到的结构旋转90度变成纵向</strong>）</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li><li>列的别名，尽量不要使用双引号（” “）（因为使用双引号的别名在mysql的orderby中会出错），而且不建议省略as</li></ul></li></ul><h3 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2.2 SQL大小写规范 （建议遵守）"></a>2.2 SQL大小写规范 （建议遵守）</h3><ul><li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li><li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li><strong>推荐采用统一的书写规范：</strong><ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><h3 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2.3 注 释"></a>2.3 注 释</h3><p>可以使用如下格式的注释结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">单行注释：#注释文字(MySQL特有的方式)<br>单行注释：-- 注释文字(--后面必须包含一个空格。)<br>多行注释：/* 注释文字  */<br></code></pre></td></tr></table></figure><h3 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2.4 命名规则（暂时了解）"></a>2.4 命名规则（暂时了解）</h3><ul><li>数据库、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#以下两句是一样的，不区分大小写<br>show databases;<br>SHOW DATABASES;<br><br>#创建表格<br>#create table student info(...); #表名错误，因为表名有空格<br>create table student_info(...); <br><br>#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了<br>CREATE TABLE `order`(<br>    id INT,<br>    lname VARCHAR(20)<br>);<br><br>select id as &quot;编号&quot;, `name` as &quot;姓名&quot; from t_stu; #起别名时，as都可以省略<br>select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略&quot;&quot;<br>select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略&quot;&quot;<br></code></pre></td></tr></table></figure><h3 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2.5 数据导入指令"></a>2.5 数据导入指令</h3><p>在命令行客户端登录mysql，使用source指令导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; source d:\mysqldb.sql<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employees;<br>+----------------+-------------+------+-----+---------+-------+<br>| Field          | Type        | Null | Key | Default | Extra |<br>+----------------+-------------+------+-----+---------+-------+<br>| employee_id    | int(6)      | NO   | PRI | 0       |       |<br>| first_name     | varchar(20) | YES  |     | NULL    |       |<br>| last_name      | varchar(25) | NO   |     | NULL    |       |<br>| email          | varchar(25) | NO   | UNI | NULL    |       |<br>| phone_number   | varchar(20) | YES  |     | NULL    |       |<br>| hire_date      | date        | NO   |     | NULL    |       |<br>| job_id         | varchar(10) | NO   | MUL | NULL    |       |<br>| salary         | double(8,2) | YES  |     | NULL    |       |<br>| commission_pct | double(2,2) | YES  |     | NULL    |       |<br>| manager_id     | int(6)      | YES  | MUL | NULL    |       |<br>| department_id  | int(4)      | YES  | MUL | NULL    |       |<br>+----------------+-------------+------+-----+---------+-------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3. 基本的SELECT语句"></a>3. 基本的SELECT语句</h2><h3 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3.0 SELECT…"></a>3.0 SELECT…</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 1; #没有任何子句<br>SELECT 9/2; #没有任何子句<br>SELECCT 1 + 1 FROM DUAL;  #dual伪表<br></code></pre></td></tr></table></figure><h3 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3.1 SELECT … FROM"></a>3.1 SELECT … FROM</h3><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   标识选择哪些列<br><span class="hljs-keyword">FROM</span>     标识从哪个表中选择<br></code></pre></td></tr></table></figure><ul><li>选择全部列：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span>   departments;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554950890895.png"></p><blockquote><p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p><p>在生产环境下，不推荐你直接使用<code>SELECT *</code>进行查询。</p></blockquote><ul><li>选择特定的列：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, location_id<br><span class="hljs-keyword">FROM</span>   departments;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554950947969.png"></p><blockquote><p>MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。</p></blockquote><h3 id="3-2-列的别名-as-alias"><a href="#3-2-列的别名-as-alias" class="headerlink" title="3.2 列的别名(as:alias)"></a>3.2 列的别名(as:alias)</h3><ul><li><p>重命名一个列</p></li><li><p>便于计算</p></li><li><p>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号(不要使用单引号，sql规范是单引号）</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</p></li><li><p>AS 可以省略】</p></li><li><p><strong>十分需要注意的是，MySQL对于“”的处理会使得使用列的别名的排序失效，所以起别名时尽量不要使用单引号或者双引号。这种情况的发生应该是MySQL对“”的处理问题，处理方法是可以修改别名，尽量选择不使用“”来命名，也就是尽量在别名中不要包含空格，使用下划线_来连接单词，这样可以不用引号修饰别名，从而避免掉MySQL对“”的解析出错问题。</strong></p></li><li><p>建议别名简短，见名知意</p></li><li><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name AS name, commission_pct comm<br>FROM   employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951616598.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951622467.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;<br>FROM   employees;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951648377.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951622467-20220325172722675.png"></p><h3 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3.3 去除重复行"></a>3.3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id<br><span class="hljs-keyword">FROM</span>   employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951711115.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951622467-20220325172815528.png"></p><p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id<br><span class="hljs-keyword">FROM</span>   employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951796570.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554951801044.png"></p><p>针对于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT department_id,salary <br>FROM employees;<br></code></pre></td></tr></table></figure><p>这里有两点需要注意：</p><ol><li>DISTINCT 需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</li><li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</li></ol><h3 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a>3.4 空值参与运算</h3><ul><li>所有运算符或列值遇到null值，运算的结果都为null</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,salary,commission_pct,<br><span class="hljs-number">12</span> <span class="hljs-operator">*</span> salary <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> commission_pct) &quot;annual_sal&quot;<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串，同样也不等同于0（空值是未知的意思）。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p><h3 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3.5 着重号"></a>3.5 着重号</h3><ul><li>错误的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM ORDER;<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;ORDER&#x27; at line 1<br></code></pre></td></tr></table></figure><ul><li>正确的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM `ORDER`;<br>+----------+------------+<br>| order_id | order_name |<br>+----------+------------+<br>|        1 | shkstart   |<br>|        2 | tomcat     |<br>|        3 | dubbo      |<br>+----------+------------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; SELECT * FROM `order`;<br>+----------+------------+<br>| order_id | order_name |<br>+----------+------------+<br>|        1 | shkstart   |<br>|        2 | tomcat     |<br>|        3 | dubbo      |<br>+----------+------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><ul><li>结论</li></ul><p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。</p><h3 id="3-6-5、查询常数"><a href="#3-6-5、查询常数" class="headerlink" title="3.6 5、查询常数"></a>3.6 5、查询常数</h3><p>SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p><p>你可能会问为什么我们还要对常数进行查询呢？</p><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p><p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段<code>corporation</code>，这个字段固定值为“尚硅谷”，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#x27;尚硅谷&#x27; as corporation, last_name FROM employees;<br></code></pre></td></tr></table></figure><p>注意，常量需要使用单引号引起来，否则有语法错误。</p><h2 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a>4. 显示表结构</h2><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESCRIBE employees;<br>或<br>DESC employees;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employees;<br>+----------------+-------------+------+-----+---------+-------+<br>| Field          | Type        | Null | Key | Default | Extra |<br>+----------------+-------------+------+-----+---------+-------+<br>| employee_id    | int(6)      | NO   | PRI | 0       |       |<br>| first_name     | varchar(20) | YES  |     | NULL    |       |<br>| last_name      | varchar(25) | NO   |     | NULL    |       |<br>| email          | varchar(25) | NO   | UNI | NULL    |       |<br>| phone_number   | varchar(20) | YES  |     | NULL    |       |<br>| hire_date      | date        | NO   |     | NULL    |       |<br>| job_id         | varchar(10) | NO   | MUL | NULL    |       |<br>| salary         | double(8,2) | YES  |     | NULL    |       |<br>| commission_pct | double(2,2) | YES  |     | NULL    |       |<br>| manager_id     | int(6)      | YES  | MUL | NULL    |       |<br>| department_id  | int(4)      | YES  | MUL | NULL    |       |<br>+----------------+-------------+------+-----+---------+-------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>其中，各个字段的含义分别解释如下：</p><ul><li>Field：表示字段名称。 </li><li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li><li>Null：表示该列是否可以存储NULL值。</li><li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。</li><li>Default：表示该列是否有默认值，如果有，那么值是多少。</li><li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li></ul><h2 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a>5. 过滤数据</h2><ul><li>背景：</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554952199742.png"></p><ul><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段1,字段2<br>FROM 表名<br>WHERE 过滤条件<br></code></pre></td></tr></table></figure><ul><li>使用WHERE 子句，将不满足条件的行过滤掉</li><li><strong>WHERE子句紧随 FROM子句</strong></li><li>MySQL对字段值大小写不敏感，但是SQL规范要求敏感，所以建议查询时区分大小写</li><li>WHERE中不可以使用列的别名</li></ul></li><li><p>举例</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, job_id, department_id<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> <span class="hljs-number">90</span> ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554952277028.png"></p><h3 id="6-SELECT语句执行顺序"><a href="#6-SELECT语句执行顺序" class="headerlink" title="6.SELECT语句执行顺序"></a>6.SELECT语句执行顺序</h3><ol><li>FROM</li><li>WHERE</li><li>SELECT</li><li>ORDER BY</li></ol><p>所以，WHERE中不可以使用列的别名</p><p>SELECT语句格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">DESC</span>;<br>LIMIT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章_运算符"></a>第04章_运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012100749193.png"></p><p><strong>1．加法与减法运算符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;<br>+-----+---------+---------+----------+--------------+------------+------------+<br>| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |<br>+-----+---------+---------+----------+--------------+------------+------------+<br>| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |<br>+-----+---------+---------+----------+--------------+------------+------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 100 + &#x27;1&#x27;<br>     -&gt; from dual;<br>+-----------+<br>| 100 + &#x27;1&#x27; |<br>+-----------+<br>|       101 |<br>+-----------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 100 + &#x27;a&#x27;    <br> -&gt; from dual;<br>+-----------+<br>| 100 + &#x27;a&#x27; |<br>+-----------+<br>|       100 |<br>+-----------+<br>1 row in set, 1 warning (0.00 sec)<br><br>mysql&gt; select 100 + null<br>    -&gt; from dual;<br>+------------+<br>| 100 + null |<br>+------------+<br>|       NULL |<br>+------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>由运算结果可以得出如下结论：</p><blockquote><ul><li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li><li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li><li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li><li>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</li></ul></blockquote><p><strong>2．乘法与除法运算符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;<br>+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+<br>| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3  | 100 DIV 0 |<br>+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+<br>| 100 |     100 |     100.0 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |<br>+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT 100 / 3;<br>+---------+<br>| 100 / 3 |<br>+---------+<br>| 33.3333 |<br>+---------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT 100 DIV 3;<br>+-----------+<br>| 100 DIV 3 |<br>+-----------+<br>|        33 |<br>+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#计算出员工的年基本工资<br>SELECT employee_id,salary,salary * 12 annual_sal <br>FROM employees;<br></code></pre></td></tr></table></figure><p>由运算结果可以得出如下结论：</p><blockquote><ul><li>一个数乘以整数1和除以整数1后仍得原数；</li><li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li><li>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</li><li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li><li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li><li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</li><li>DIV是向上取整，/是保留小数点后四位。</li></ul></blockquote><p><strong>3．求模（求余）运算符</strong><br>将t22表中的字段i对3和5进行求模（求余）运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual;<br>+--------+----------+<br>| 12 % 3 | 12 MOD 5 |<br>+--------+----------+<br>|      0 |        2 |<br>+--------+----------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT 12 % 3, 12 % 5, 12 MOD -5, -12 % 5, -12 % -5;<br>+--------+--------+-----------+---------+----------+<br>| 12 % 3 | 12 % 5 | 12 MOD -5 | -12 % 5 | -12 % -5 |<br>+--------+--------+-----------+---------+----------+<br>|      0 |      2 |         2 |      -2 |       -2 |<br>+--------+--------+-----------+---------+----------+<br>1 row in set (0.00 sec)<br>#取模结果与被模数符号相同<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#筛选出employee_id是偶数的员工<br>SELECT * <br>FROM employees<br>WHERE employee_id MOD 2 = 0;<br></code></pre></td></tr></table></figure><p>可以看到，100对3求模后的结果为3，对5求模后的结果为0。</p><h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。过滤只显示结果为1的，结果为0或者NULL，WHERE过滤后不显示。</p><p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012101110021.png" alt="" /><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012104955094.png"></p><p><strong>1．等号运算符</strong></p><ul><li><p>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</p></li><li><p>在使用等号运算符时，遵循如下规则：</p><ul><li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li><li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li><li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较（如果字符串不能转化为数字，那么就转化成0）。</li><li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li></ul></li><li><p>对比：SQL中赋值符号使用 := </p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 = 1, 1 = &#x27;1&#x27;, 1 = 0, &#x27;a&#x27; = &#x27;a&#x27;, (5 + 3) = (2 + 6), &#x27;&#x27; = NULL , NULL = NULL; <br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>| 1 = 1 | 1 = &#x27;1&#x27; | 1 = 0 | &#x27;a&#x27; = &#x27;a&#x27; | (5 + 3) = (2 + 6) | &#x27;&#x27; = NULL | NULL = NULL |<br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>|    1  |     1   |   0   |      1    |             1     |    NULL   |        NULL  |<br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT &#x27;a&#x27; = 1, &#x27;a&#x27; = 0, &#x27;a&#x27; = &#x27;b&#x27;;<br>+---------+---------+-----------+<br>| &#x27;a&#x27; = 1 | &#x27;a&#x27; = 0 | &#x27;a&#x27; = &#x27;b&#x27; |<br>+---------+---------+-----------+<br>|       0 |       1 |         0 |<br>+---------+---------+-----------+<br>1 row in set, 2 warnings (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 = 2, 0 = &#x27;abc&#x27;, 1 = &#x27;abc&#x27; FROM dual;<br>+-------+-----------+-----------+<br>| 1 = 2 | 0 = &#x27;abc&#x27; | 1 = &#x27;abc&#x27; |<br>+-------+-----------+-----------+<br>|     0 |         1 |         0 |<br>+-------+-----------+-----------+<br>1 row in set, 2 warnings (0.00 sec)<br><br>mysql&gt; SELECT &#x27;A&#x27; = &#x27;A      &#x27;;<br>+-----------------+<br>| &#x27;A&#x27; = &#x27;A      &#x27; |<br>+-----------------+<br>|               1 |<br>+-----------------+<br>1 row in set (0.00 sec)<br>#忽略字符串最后的空格<br><br>mysql&gt; SELECT &#x27;       A&#x27; = &#x27;A&#x27;;<br>+------------------+<br>| &#x27;       A&#x27; = &#x27;A&#x27; |<br>+------------------+<br>|                0 |<br>+------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询salary=10000，注意在Java中比较是==<br>SELECT employee_id,salary <br>FROM employees <br>WHERE salary = 10000;<br></code></pre></td></tr></table></figure><p><strong>2．安全等于运算符（为NULL而生）</strong><br>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，<code>唯一的区别</code>是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &lt;=&gt; &#x27;1&#x27;, 1 &lt;=&gt; 0, &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27;, (5 + 3) &lt;=&gt; (2 + 6), &#x27;&#x27; &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>| 1 &lt;=&gt; &#x27;1&#x27; | 1 &lt;=&gt; 0 | &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27; | (5 + 3) &lt;=&gt; (2 + 6) | &#x27;&#x27; &lt;=&gt; NULL | NULL &lt;=&gt; NULL |<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>|         1 |       0 |           1 |                   1 |           0 |             1 |<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询commission_pct等于0.40<br>SELECT employee_id,commission_pct <br>FROM employees <br>WHERE commission_pct = 0.40;<br><br>SELECT employee_id,commission_pct <br>FROM employees <br>WHERE commission_pct &lt;=&gt; 0.40;<br><br>#如果把0.40改成 NULL 呢？<br></code></pre></td></tr></table></figure><p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。</p><p><strong>3．不等于运算符</strong><br>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。<br>SQL语句示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, &#x27;a&#x27; != &#x27;b&#x27;, (3+4) &lt;&gt; (2+6), &#x27;a&#x27; != NULL, NULL &lt;&gt; NULL; <br>+--------+--------+------------+----------------+-------------+--------------+<br>| 1 &lt;&gt; 1 | 1 != 2 | &#x27;a&#x27; != &#x27;b&#x27; | (3+4) &lt;&gt; (2+6) | &#x27;a&#x27; != NULL | NULL &lt;&gt; NULL |<br>+--------+--------+------------+----------------+-------------+--------------+<br>|      0 |   1    |       1    |            1   |     NULL    |         NULL |<br>+--------+--------+------------+----------------+-------------+--------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>此外，还有非符号  类型的运算符：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012105303219.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012105030527.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012105052456.png"></p><p><strong>4. 空运算符</strong><br>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。ISNULL更相当于一个函数，需要把值用（）包起来。<br>SQL语句示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#x27;a&#x27;), 1 IS NULL;<br>+--------------+--------------+-------------+-----------+<br>| NULL IS NULL | ISNULL(NULL) | ISNULL(&#x27;a&#x27;) | 1 IS NULL |<br>+--------------+--------------+-------------+-----------+<br>|            1 |            1 |           0 |         0 |<br>+--------------+--------------+-------------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询commission_pct等于NULL。比较如下的三种写法<br>SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;<br>SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;<br>SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name, manager_id<br>FROM   employees<br>WHERE  manager_id IS NULL;<br></code></pre></td></tr></table></figure><p><strong>5. 非空运算符</strong><br>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。<br>SQL语句示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NULL IS NOT NULL, &#x27;a&#x27; IS NOT NULL,  1 IS NOT NULL; <br>+------------------+-----------------+---------------+<br>| NULL IS NOT NULL | &#x27;a&#x27; IS NOT NULL | 1 IS NOT NULL |<br>+------------------+-----------------+---------------+<br>|                0 |               1 |             1 |<br>+------------------+-----------------+---------------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询commission_pct不等于NULL<br>SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;<br>SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL;<br>SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);<br></code></pre></td></tr></table></figure><p><strong>6. 最小值运算符</strong><br>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);<br>+---------------+--------------------+-----------------+<br>| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |<br>+---------------+--------------------+-----------------+<br>|       0       |        a           |      NULL       |<br>+---------------+--------------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>7. 最大值运算符</strong><br>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);<br>+-----------------+-----------------------+--------------------+<br>| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |<br>+-----------------+-----------------------+--------------------+<br>|               2 | c                     |               NULL |<br>+-----------------+-----------------------+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>8. BETWEEN AND运算符</strong><br>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27;;<br>+-------------------+----------------------+-------------------------+<br>| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27; |<br>+-------------------+----------------------+-------------------------+<br>|                 1 |                    0 |                       1 |<br>+-------------------+----------------------+-------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name, salary<br>FROM   employees<br>WHERE  salary BETWEEN 2500 AND 3500;<br></code></pre></td></tr></table></figure><p><strong>9. IN运算符</strong><br>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);<br>+----------------------+------------+-------------------+--------------------+<br>| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |<br>+----------------------+------------+-------------------+--------------------+<br>|            1         |        0   |         NULL      |         1          |<br>+----------------------+------------+-------------------+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, salary, manager_id<br>FROM   employees<br>WHERE  manager_id IN (100, 101, 201);<br></code></pre></td></tr></table></figure><p><strong>主要注意的是，值需要放在一个（）中，否则语法错误</strong></p><p><strong>10. NOT IN运算符</strong><br>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 NOT IN (2,3);<br>+--------------------------+----------------+<br>| &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 NOT IN (2,3) |<br>+--------------------------+----------------+<br>|                 0        |            1   |<br>+--------------------------+----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>11. LIKE运算符</strong><br>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p><p>LIKE运算符通常使用如下通配符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">“%”：匹配0个或多个字符。<br>“_”：只能匹配一个字符。<br></code></pre></td></tr></table></figure><p>SQL语句示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NULL LIKE &#x27;abc&#x27;, &#x27;abc&#x27; LIKE NULL;  <br>+-----------------+-----------------+<br>| NULL LIKE &#x27;abc&#x27; | &#x27;abc&#x27; LIKE NULL |<br>+-----------------+-----------------+<br>|          NULL   |          NULL   |<br>+-----------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECTfirst_name<br>FROM employees<br>WHEREfirst_name LIKE &#x27;S%&#x27;;<br>#以S、s打头，MySQL不区分字段值的大小写，但是SQL规范要去区分<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name<br>FROM   employees<br>WHERE  last_name LIKE &#x27;_o%&#x27;;<br>#第二个字符为o、O的字段值<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#last_name包含<span class="hljs-string">&#x27;a&#x27;</span>并且包含<span class="hljs-string">&#x27;e&#x27;</span>的last_name<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span> <span class="hljs-keyword">AND</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%e%&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%e%&#x27;</span> <span class="hljs-keyword">OR</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%e%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>ESCAPE</strong></p><ul><li>回避特殊符号的：**使用转义符\**。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT job_id<br>FROM   jobs<br>WHERE  job_id LIKE ‘IT\_%‘;<br></code></pre></td></tr></table></figure><ul><li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT job_id<br>FROM   jobs<br>WHERE  job_id LIKE ‘IT$_%‘ escape ‘$‘;<br></code></pre></td></tr></table></figure><p><strong>12. REGEXP \ RLIKE运算符</strong></p><p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。</p><p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">（1）‘^’匹配以该字符后面的字符开头的字符串。<br>（2）‘$’匹配以该字符前面的字符结尾的字符串。<br>（3）‘.’匹配任何一个单字符。<br>（4）“<span class="hljs-comment">[...]</span>”匹配在方括号内的任何字符。例如，“<span class="hljs-comment">[abc]</span>”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“<span class="hljs-comment">[a-z]</span>”匹配任何字母，而“<span class="hljs-comment">[0-9]</span>”匹配任何数字。<br>（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“<span class="hljs-comment">[0-9]</span>*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。<br></code></pre></td></tr></table></figure><p>SQL语句示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;<br>+------------------------+------------------------+-------------------------+<br>| &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;  |<br>+------------------------+------------------------+-------------------------+<br>|                      1 |                      1 |                       1 |<br>+------------------------+------------------------+-------------------------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;, &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;;<br>+--------------------------+-------------------------+<br>| &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27; | &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27; |<br>+--------------------------+-------------------------+<br>|                        1 |                       1 |<br>+--------------------------+-------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。</p><p>MySQL中支持4种逻辑运算符如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012110241418.png"></p><p>需要注意的是逻辑与、或连接的表达式都必须是完整的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">30</span><br>#是错误的，正确如下：<br><span class="hljs-keyword">SELECT</span> last_name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OR</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>1．逻辑非运算符</strong><br>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;    <br>+-------+-------+----------+--------+----------+<br>| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |<br>+-------+-------+----------+--------+----------+<br>|     0 |     1 |        0 |      1 |     NULL |<br>+-------+-------+----------+--------+----------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id<br>FROM   employees<br>WHERE  job_id NOT IN (&#x27;IT_PROG&#x27;, &#x27;ST_CLERK&#x27;, &#x27;SA_REP&#x27;);<br></code></pre></td></tr></table></figure><p><strong>2．逻辑与运算符</strong><br>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;<br>+----------+---------+------------+------------+<br>| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |<br>+----------+---------+------------+------------+<br>|        1 |       0 |          0 |       NULL |<br>+----------+---------+------------+------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, job_id, salary<br>FROM   employees<br>WHERE  salary &gt;=10000<br>AND    job_id LIKE &#x27;%MAN%&#x27;;<br></code></pre></td></tr></table></figure><p><strong>3．逻辑或运算符</strong><br>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;     <br>+---------+--------+-----------+-----------+--------------+<br>| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |<br>+---------+--------+-----------+-----------+--------------+<br>|       1 |      1 |         1 |    NULL   |       NULL   |<br>+---------+--------+-----------+-----------+--------------+<br>1 row in set, 2 warnings (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询基本薪资不在9000-12000之间的员工编号和基本薪资<br>SELECT employee_id,salary FROM employees <br>WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);<br><br>SELECT employee_id,salary FROM employees <br>WHERE salary &lt;9000 OR salary &gt; 12000;<br><br>SELECT employee_id,salary FROM employees <br>WHERE salary NOT BETWEEN 9000 AND 12000;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, job_id, salary<br>FROM   employees<br>WHERE  salary &gt;= 10000<br>OR     job_id LIKE &#x27;%MAN%&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p></blockquote><p><strong>4．逻辑异或运算符</strong><br>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;<br>+----------+---------+---------+------------+---------------+---------------+<br>| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |<br>+----------+---------+---------+------------+---------------+---------------+<br>|        0 |       1 |       0 |       NULL |             1 |             0 |<br>+----------+---------+---------+------------+---------------+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select last_name,department_id,salary <br>from employees<br>where department_id in (10,20) XOR salary &gt; 8000;<br></code></pre></td></tr></table></figure><h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p><p>MySQL支持的位运算符如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012110511223.png"></p><p><strong>1．按位与运算符</strong><br>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &amp; 10, 20 &amp; 30;<br>+--------+---------+<br>| 1 &amp; 10 | 20 &amp; 30 |<br>+--------+---------+<br>|      0 |      20 |<br>+--------+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。</p><p><strong>2. 按位或运算符</strong><br>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 | 10, 20 | 30; <br>+--------+---------+<br>| 1 | 10 | 20 | 30 |<br>+--------+---------+<br>|     11 |      30 |<br>+--------+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。</p><p><strong>3. 按位异或运算符</strong><br>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 ^ 10, 20 ^ 30; <br>+--------+---------+<br>| 1 ^ 10 | 20 ^ 30 |<br>+--------+---------+<br>|     11 |      10 |<br>+--------+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。</p><p>再举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 12 &amp; 5, 12 | 5,12 ^ 5 FROM DUAL;<br>+--------+--------+--------+<br>| 12 &amp; 5 | 12 | 5 | 12 ^ 5 |<br>+--------+--------+--------+<br>|      4 |     13 |      9 |<br>+--------+--------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211023115738415.png" alt="" style="zoom:80%;" /><p><strong>4. 按位取反运算符</strong><br>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 10 &amp; ~1;<br>+---------+<br>| 10 &amp; ~1 |<br>+---------+<br>|      10 |<br>+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10 &amp; ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。</p><p><strong>5. 按位右移运算符</strong><br>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &gt;&gt; 2, 4 &gt;&gt; 2;<br>+--------+--------+<br>| 1 &gt;&gt; 2 | 4 &gt;&gt; 2 |<br>+--------+--------+<br>|      0 |      1 |<br>+--------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。</p><p><strong>6. 按位左移运算符</strong><br>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &lt;&lt; 2, 4 &lt;&lt; 2;  <br>+--------+--------+<br>| 1 &lt;&lt; 2 | 4 &lt;&lt; 2 |<br>+--------+--------+<br>|      4 |     16 |<br>+--------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。</p><h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012111042395.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012110731059.png"></p><p>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p><h2 id="拓展：使用正则表达式查询"><a href="#拓展：使用正则表达式查询" class="headerlink" title="拓展：使用正则表达式查询"></a>拓展：使用正则表达式查询</h2><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。</p><p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210926151249943.png"></p><p><strong>1. 查询以特定字符或字符串开头的记录</strong><br>字符‘^’匹配以特定字符或者字符串开头的文本。</p><p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;<br></code></pre></td></tr></table></figure><p><strong>2. 查询以特定字符或字符串结尾的记录</strong><br>字符‘$’匹配以特定字符或者字符串结尾的文本。</p><p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;<br></code></pre></td></tr></table></figure><p><strong>3. 用符号”.”来替代字符串中的任意一个字符</strong><br>字符‘.’匹配任意一个字符。<br>在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;<br></code></pre></td></tr></table></figure><p><strong>4. 使用”*”和”+”来匹配多个字符</strong><br>星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。</p><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;;<br></code></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;<br></code></pre></td></tr></table></figure><p><strong>5. 匹配指定字符串</strong><br>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。</p><p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;;<br></code></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;<br></code></pre></td></tr></table></figure><p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p><p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;<br>Empty set(0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>6. 匹配指定字符中的任意一个</strong><br>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。</p><p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;<br></code></pre></td></tr></table></figure><p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;;<br></code></pre></td></tr></table></figure><p><strong>7. 匹配指定字符以外的字符</strong><br><code>“[^字符集合]”</code>匹配不在指定集合中的任何字符。</p><p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;<br></code></pre></td></tr></table></figure><p><strong>8. 使用{n,}或者{n,m}来指定字符串连续出现的次数</strong><br>“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</p><p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;<br></code></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;<br></code></pre></td></tr></table></figure><h1 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章_排序与分页"></a>第05章_排序与分页</h1><h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a>1.1 排序规则</h3><ul><li>使用 ORDER BY 子句排序<ul><li><strong>ASC（ascend）: 升序</strong>(默认就是升序)</li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><strong>ORDER BY 子句在SELECT语句的结尾。</strong></li><li>如果没有使用排序操作，默认情况是按照添加的顺序显示。</li><li>默认就是升序。</li><li>也可以使用列的别名进行排序，<strong>需要注意的是，当使用别名排序时，不要使用“”引起别名，这样会使消，具体原因未知</strong>。</li><li>也可以使用没有表中被SELECT的字段进行排序</li></ul><h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1.2 单列排序"></a>1.2 单列排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT   last_name, job_id, department_id, hire_date<br>FROM     employees<br>ORDER BY hire_date ;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974255957.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974827522.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT   last_name, job_id, department_id, hire_date<br>FROM     employees<br>ORDER BY hire_date DESC ;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974822229.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974827522-20220325171314947.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, salary*12 annsal<br>FROM   employees<br>ORDER BY annsal;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974853194.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974827522-20220325171319229.png"></p><h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1.3 多列排序"></a>1.3 多列排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name, department_id, salary<br>FROM   employees<br>ORDER BY department_id, salary DESC;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974901572.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974827522-20220325171322924.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#先按照department_id降序，后salary升序<br><span class="hljs-keyword">SELECT</span> last_name, department_id, salary<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">DESC</span>, salary <span class="hljs-keyword">ASC</span>;<br><br>#先按照salary升序，再按照department_id降序<br><span class="hljs-keyword">SELECT</span> last_name, department_id, salary<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">ASC</span>, department_id <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><ul><li>可以使用不在SELECT列表中的列排序。</li><li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li></ul><p>即使用WHERE又使用ORDER BY，格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h3><p>背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p><p>背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？</p><h3 id="2-2-实现规则"><a href="#2-2-实现规则" class="headerlink" title="2.2 实现规则"></a>2.2 实现规则</h3><ul><li><p>分页原理</p><p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p></li><li><p><strong>MySQL中使用 LIMIT 实现分页</strong></p></li><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LIMIT [位置偏移量,] 行数 #如果位置偏移量是0，可以省略，其他值不可省略<br></code></pre></td></tr></table></figure><p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</p></li><li><p>举例</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--前10条记录：<br>SELECT * FROM 表名 LIMIT 0,10;<br>或者<br>SELECT * FROM 表名 LIMIT 10;<br><br>--第11至20条记录：<br>SELECT * FROM 表名 LIMIT 10,10;<br><br>--第21至30条记录： <br>SELECT * FROM 表名 LIMIT 20,10;<br></code></pre></td></tr></table></figure><blockquote><p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p></blockquote><ul><li>分页显式公式<strong>：（当前页数-1）*每页条数，每页条数</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * <br>FROM table <br>LIMIT (PageNo - 1) * PageSize, PageSize;<br></code></pre></td></tr></table></figure><ul><li><strong>注意：LIMIT 子句必须放在整个SELECT语句的最后！</strong></li><li>使用 LIMIT 的好处</li></ul><p>约束返回结果的数量可以<code>减少数据表的网络传输量</code>，也可以<code>提升查询效率</code>。如果我们知道返回结果只有 1 条，就可以使用<code>LIMIT 1</code>，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p><h3 id="2-3-拓展"><a href="#2-3-拓展" class="headerlink" title="2.3 拓展"></a>2.3 拓展</h3><p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。</p><ul><li>如果是 SQL Server 和 Access，需要使用 <code>TOP</code> 关键字，比如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC<br></code></pre></td></tr></table></figure><ul><li>如果是 DB2，使用<code>FETCH FIRST 5 ROWS ONLY</code>这样的关键字：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, hp_max <span class="hljs-keyword">FROM</span> heros <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hp_max <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">FIRST</span> <span class="hljs-number">5</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span><br></code></pre></td></tr></table></figure><ul><li>如果是 Oracle，你需要基于 <code>ROWNUM</code> (伪列)来统计行数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;<br></code></pre></td></tr></table></figure><p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT rownum, last_name,salary<br>FROM (<br>    SELECT last_name,salary<br>    FROM employees<br>    ORDER BY salary DESC)<br>WHERE rownum &lt; 10;<br></code></pre></td></tr></table></figure><p>得到与上述方法一致的结果。</p><h1 id="第06章-多表查询"><a href="#第06章-多表查询" class="headerlink" title="第06章_多表查询"></a>第06章_多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a>1. 一个案例引发的多表连接</h2><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1.1 案例说明"></a>1.1 案例说明</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554974984600.png"></p><p>关于为什么要拆分成多个表，而不是一个大表？</p><ol><li>减少数据冗余</li><li>减少io次数，一个表字段越多，一次io加载的条数越少，io速度慢，很影响效率。</li><li>设计成多个表，可以多个事务同时读写，若是一个表由于锁的存在只能每次只能一个事务读写</li><li>大表维护的时候也很复杂</li></ol><p>从多个表中获取数据：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975020388.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#案例：查询员工的姓名及其部门名称<br>SELECT last_name, department_name<br>FROM employees, departments;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975097631.png"></p><p>查询结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+-----------+----------------------+<br>| last_name | department_name      |<br>+-----------+----------------------+<br>| King      | Administration       |<br>| King      | Marketing            |<br>| King      | Purchasing           |<br>| King      | Human Resources      |<br>| King      | Shipping             |<br>| King      | IT                   |<br>| King      | Public Relations     |<br>| King      | Sales                |<br>| King      | Executive            |<br>| King      | Finance              |<br>| King      | Accounting           |<br>| King      | Treasury             |<br>...<br>| Gietz     | IT Support           |<br>| Gietz     | NOC                  |<br>| Gietz     | IT Helpdesk          |<br>| Gietz     | Government Sales     |<br>| Gietz     | Retail Sales         |<br>| Gietz     | Recruiting           |<br>| Gietz     | Payroll              |<br>+-----------+----------------------+<br>2889 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>分析错误情况：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(employee_id) FROM employees;<br>#输出107行<br><br>SELECT COUNT(department_id)FROM departments;<br>#输出27行<br><br>SELECT 107*27 FROM dual;<br>#每个员工和每个公司都匹配了一次<br></code></pre></td></tr></table></figure><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。</p><h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.2 笛卡尔积（或交叉连接）的理解"></a>1.2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/302046364841977.jpg" alt="" style="zoom:80%;" /><p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是 <code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询员工姓名和所在部门名称<br>SELECT last_name,department_name FROM employees,departments;<br>SELECT last_name,department_name FROM employees CROSS JOIN departments;<br>SELECT last_name,department_name FROM employees INNER JOIN departments;<br>SELECT last_name,department_name FROM employees JOIN departments;<br></code></pre></td></tr></table></figure><h3 id="1-3-案例分析与问题解决"><a href="#1-3-案例分析与问题解决" class="headerlink" title="1.3 案例分析与问题解决"></a>1.3 案例分析与问题解决</h3><ul><li><p><strong>笛卡尔积的错误会在下面条件下产生</strong>：</p><ul><li>省略多个表的连接条件（或关联条件）</li><li>连接条件（或关联条件）无效</li><li>所有表中的所有行互相连接</li></ul></li><li><p>为了避免笛卡尔积， 可以<strong>在 WHERE 加入有效的连接条件。</strong></p></li><li><p>加入连接条件后，查询语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECTtable1.column, table2.column<br>FROMtable1, table2<br>WHEREtable1.column1 = table2.column2;  #连接条件<br></code></pre></td></tr></table></figure><ul><li><strong>在 WHERE子句中写入连接条件。</strong></li></ul></li><li><p>正确写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#案例：查询员工的姓名及其部门名称<br>SELECT last_name, department_name<br>FROM employees, departments<br>WHERE employees.department_id = departments.department_id;<br></code></pre></td></tr></table></figure></li><li><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong>并且，从sql优化的角度，建议多表查询时，每个字段前都指明其所在的表（减去查找的时间）。</p></li></ul><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975496900.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employees.employee_id, employees.last_name, <br>       employees.department_id, departments.department_id,<br>       departments.location_id<br>FROM   employees, departments<br>WHERE  employees.department_id = departments.department_id;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975522600.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975526339.png"></p><p><strong>拓展1：多个连接条件与 AND 操作符</strong> </p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554975606231.png"></p><p><strong>拓展2：区分重复的列名</strong></p><ul><li><strong>多个表中有相同列时，必须在列名之前加上表名前缀。</strong>并且，从sql优化的角度，建议多表查询时，每个字段前都指明其所在的表（减去查找的时间）。</li><li>在不同表中具有相同列名的列可以用<code>表名</code>加以区分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employees.last_name, departments.department_name,employees.department_id<br>FROM employees, departments<br>WHERE employees.department_id = departments.department_id;<br></code></pre></td></tr></table></figure><p><strong>拓展3：表的别名</strong></p><ul><li><p>使用别名可以简化查询。</p></li><li><p>列名前使用表名前缀可以提高查询效率。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.employee_id, e.last_name, e.department_id,<br>       d.department_id, d.location_id<br>FROM   employees e , departments d<br>WHERE  e.department_id = d.department_id;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p></blockquote><blockquote><p><code>阿里开发规范</code>：</p><p>【<code>强制</code>】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。 </p><p><code>说明</code>：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。 </p><p><code>正例</code>：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id; </p><p><code>反例</code>：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column  ‘name’ in field list is ambiguous。</p></blockquote><p><strong>拓展4：连接多个表</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978354431.png"></p><p><strong>总结：连接 n个表,至少需要n-1个连接条件。</strong>比如，连接三个表，至少需要两个连接条件。</p><p>练习：查询出公司员工的 last_name,department_name, city</p><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978442447.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.last_name, e.salary, j.grade_level<br>FROM   employees e, job_grades j<br>WHERE  e.salary BETWEEN j.lowest_sal AND j.highest_sal;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978477013.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978482652.png"></p><h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978514321.png"></p><ul><li>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。</li></ul><p><strong>题目：查询employees表，返回“Xxx  works for Xxx”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(worker.last_name ,&#x27; works for &#x27; <br>       , manager.last_name)<br>FROM   employees worker, employees manager<br>WHERE  worker.manager_id = manager.employee_id ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978684947.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978690764.png">练习：查询出last_name为 ‘Chen’ 的员工的 manager 的信息。</p><h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978955659.png"></p><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行</strong> <strong>，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。若是除了返回满足连接条件的行以外，即返回了左表中不满足条件的行同时也返回了右表中不满足条件的行，称为满外连接。</p></li><li><p>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</p><p>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</p></li></ul><h4 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h4><ul><li><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。（因为从表在逻辑上相当于加上了一些NULL值）</p></li><li><p>Oracle 对 SQL92 支持较好，而 <strong>MySQL 则不支持 SQL92 的外连接</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询所有员工的姓名以及他的部门<br>#左外连接<br>SELECT last_name,department_name<br>FROM employees ,departments<br>WHERE employees.department_id = departments.department_id(+);<br><br>查询所有部门的员工姓名以及部门名称<br>#右外连接<br>SELECT last_name,department_name<br>FROM employees ,departments<br>WHERE employees.department_id(+) = departments.department_id;<br></code></pre></td></tr></table></figure></li><li><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p></li></ul><h2 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h3><ul><li><p>使用JOIN…ON子句创建连接的语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table1.column, table2.column,table3.column<br>FROM table1<br>    JOIN table2 ON table1 和 table2 的连接条件<br>        JOIN table3 ON table2 和 table3 的连接条件<br></code></pre></td></tr></table></figure><p>它的嵌套逻辑类似我们使用的 FOR 循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">for t1 in table1:<br>    for t2 in table2:<br>       if condition1:<br>           for t3 in table3:<br>              if condition2:<br>                  output t1 + t2 + t3<br></code></pre></td></tr></table></figure><p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。</p></li><li><p>语法说明：</p><ul><li><strong>可以使用</strong> <strong>ON</strong> <strong>子句指定额外的连接条件</strong>。</li><li>这个连接条件是与其它条件分开的。</li><li><strong>ON</strong> <strong>子句使语句具有更高的易读性</strong>。</li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接</li></ul></li></ul><h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a>3.2 内连接(INNER JOIN)的实现</h3><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表<br>FROM A表 INNER JOIN B表 #INNER可以省略<br>ON 关联条件<br>WHERE 等其他子句;<br></code></pre></td></tr></table></figure><p>题目1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.employee_id, e.last_name, e.department_id, <br>       d.department_id, d.location_id<br>FROM   employees e JOIN departments d<br>ON     (e.department_id = d.department_id);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979073996.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978690764-20220325171607085.png"></p><p>题目2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id, city, department_name<br>FROM   employees e <br>JOIN   departments d<br>ON     d.department_id = e.department_id <br>JOIN   locations l<br>ON     d.location_id = l.location_id;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979110008.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554978690764-20220325171615834.png"></p><h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a>3.3 外连接(OUTER JOIN)的实现</h3><p><strong>当题目中出现每个，所有等限定词时，需要考虑是不是左外连接右外连接，甚至满外连接</strong></p><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a>3.3.1 左外连接(LEFT OUTER JOIN)</h4><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现查询结果是A<br>SELECT 字段列表<br>FROM A表 LEFT JOIN B表 #LEFT可以省略<br>ON 关联条件<br>WHERE 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.last_name, e.department_id, d.department_name<br>FROM   employees e<br>LEFT OUTER JOIN departments d<br>ON   (e.department_id = d.department_id) ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979200961.png"></p><h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3.3.2 右外连接(RIGHT OUTER JOIN)"></a>3.3.2 右外连接(RIGHT OUTER JOIN)</h4><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现查询结果是B<br>SELECT 字段列表<br>FROM A表 RIGHT JOIN B表 #OUTER可以省略<br>ON 关联条件<br>WHERE 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.last_name, e.department_id, d.department_name<br>FROM   employees e<br>RIGHT OUTER JOIN departments d<br>ON    (e.department_id = d.department_id) ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979243194.png"></p><blockquote><p>需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用 (+) 表示。</p></blockquote><h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3.3.3 满外连接(FULL OUTER JOIN)"></a>3.3.3 满外连接(FULL OUTER JOIN)</h4><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li><li>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN <strong>UNION</strong> RIGHT join代替。</li></ul><h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><p><strong>合并查询结果</strong><br>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，<strong>两个表对应的列数和数据类型必须相同</strong>，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column,... FROM table1<br>UNION [ALL]<br>SELECT column,... FROM table2<br></code></pre></td></tr></table></figure><p><strong>UNION操作符</strong></p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979317187.png" alt="" style="zoom: 67%;" /><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p><p><strong>UNION ALL操作符</strong></p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979343634.png" alt="" style="zoom: 67%;" /><p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p><blockquote><p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p></blockquote><p>举例：查询部门编号&gt;90或邮箱包含a的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1<br>SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式2<br>SELECT * FROM employees  WHERE email LIKE &#x27;%a%&#x27;<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;<br></code></pre></td></tr></table></figure><p>举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,cname FROM t_chinamale WHERE csex=&#x27;男&#x27;<br>UNION ALL<br>SELECT id,tname FROM t_usmale WHERE tGender=&#x27;male&#x27;;<br></code></pre></td></tr></table></figure><h2 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5. 7种SQL JOINS的实现"></a>5. 7种SQL JOINS的实现</h2><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979255233.png" alt="" style="zoom:80%;" /><h3 id="5-7-1-代码实现"><a href="#5-7-1-代码实现" class="headerlink" title="5.7.1 代码实现"></a>5.7.1 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#中图：内连接 A∩B<br>SELECT employee_id,last_name,department_name<br>FROM employees e JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#左上图：左外连接<br>SELECT employee_id,last_name,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#右上图：右外连接<br>SELECT employee_id,last_name,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#左中图：A - A∩B<br>SELECT employee_id,last_name,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL<br><br>或者<br><br>SELECT employee_id,last_name,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE NOT d.`department_id` IS NOT NULL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#右中图：B-A∩B<br>SELECT employee_id,last_name,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#左下图：满外连接<br># 左中图 + 右上图  A∪B<br>SELECT employee_id,last_name,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL<br>UNION ALL  #没有去重操作，效率高<br>SELECT employee_id,last_name,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#右下图<br>#左中图 + 右中图  A∪B - A∩B 或者 (A -  A∩B) ∪ （B - A∩B）<br>SELECT employee_id,last_name,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL<br>UNION ALL<br>SELECT employee_id,last_name,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL<br></code></pre></td></tr></table></figure><h3 id="5-7-2-语法格式小结"><a href="#5-7-2-语法格式小结" class="headerlink" title="5.7.2 语法格式小结"></a>5.7.2 语法格式小结</h3><ul><li>左中图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现A -  A∩B<br>select 字段列表<br>from A表 left join B表<br>on 关联条件<br>where 从表关联字段 is null and 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>右中图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现B -  A∩B<br>select 字段列表<br>from A表 right join B表<br>on 关联条件<br>where 从表关联字段 is null and 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>左下图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现查询结果是A∪B<br>#用左外的A，union 右外的B<br>select 字段列表<br>from A表 left join B表<br>on 关联条件<br>where 等其他子句<br><br>union <br><br>select 字段列表<br>from A表 right join B表<br>on 关联条件<br>where 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>右下图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#实现A∪B -  A∩B  或   (A -  A∩B) ∪ （B - A∩B）<br>#使用左外的 (A -  A∩B)  union 右外的（B - A∩B）<br>select 字段列表<br>from A表 left join B表<br>on 关联条件<br>where 从表关联字段 is null and 等其他子句<br><br>union<br><br>select 字段列表<br>from A表 right join B表<br>on 关联条件<br>where 从表关联字段 is null and 等其他子句<br></code></pre></td></tr></table></figure><h2 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a>6. SQL99语法新特性</h2><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a>6.1 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中<code>所有相同的字段</code>，然后进行<code>等值连接</code>。</p><p>在SQL92标准中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>AND e.`manager_id` = d.`manager_id`;<br></code></pre></td></tr></table></figure><p>在 SQL99 中你可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e NATURAL JOIN departments d;<br></code></pre></td></tr></table></figure><h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a>6.2 USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的<code>同名字段</code>进行等值连接。但是只能配合JOIN一起使用。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e JOIN departments d<br>USING (department_id);<br></code></pre></td></tr></table></figure><p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e ,departments d<br>WHERE e.department_id = d.department_id;<br></code></pre></td></tr></table></figure><p>需要注意的是，可以不使用<code>NATURAL JION</code>和<code>USING</code>，只使用<code>JION ON</code>因为其表达清楚，适用范围广。</p><h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p><ul><li><p>WHERE：适用于所有关联查询</p></li><li><p><code>ON</code>：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。<strong>推荐</strong></p></li><li><p>USING：只能和JOIN一起使用，而且要求<strong>两个</strong>关联字段在关联表中名称一致，而且只能表示关联字段值相等</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#关联条件<br>#把关联条件写在where后面<br>SELECT last_name,department_name <br>FROM employees,departments <br>WHERE employees.department_id = departments.department_id;<br><br>#把关联条件写在on后面，只能和JOIN一起使用<br>SELECT last_name,department_name <br>FROM employees INNER JOIN departments <br>ON employees.department_id = departments.department_id;<br><br>SELECT last_name,department_name <br>FROM employees CROSS JOIN departments <br>ON employees.department_id = departments.department_id;<br><br>SELECT last_name,department_name  <br>FROM employees JOIN departments <br>ON employees.department_id = departments.department_id;<br><br>#把关联字段写在using()中，只能和JOIN一起使用<br>#而且两个表中的关联字段必须名称相同，而且只能表示=<br>#查询员工姓名与基本工资<br>SELECT last_name,job_title<br>FROM employees INNER JOIN jobs USING(job_id);<br><br>#n张表关联，需要n-1个关联条件<br>#查询员工姓名，基本工资，部门名称<br>SELECT last_name,job_title,department_name FROM employees,departments,jobs <br>WHERE employees.department_id = departments.department_id <br>AND employees.job_id = jobs.job_id;<br><br>SELECT last_name,job_title,department_name <br>FROM employees INNER JOIN departments INNER JOIN jobs <br>ON employees.department_id = departments.department_id <br>AND employees.job_id = jobs.job_id;<br><br>#或者，这两种形式MySQL都支持<br><br>SELECT e.last_name, d.department_name, d.location_id, l.city<br>FROM employees e LEFT JOIN departments d<br>ON e.department_id = d.department_id<br>LEFT JOIN locations l<br>ON d.location_id = l.location_id<br>WHERE e.commission_pct IS NOT NULL<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>我们要<code>控制连接表的数量</code>。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p><blockquote><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 </p><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p><p>来源：阿里巴巴《Java开发手册》</p></blockquote><h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p><p>SQL 有两个主要的标准，分别是 <code>SQL92</code> 和 <code>SQL99</code>。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p><p>这么多标准，到底该学习哪个呢？<strong>实际上最重要的 SQL 标准就是 SQL92 和 SQL99</strong>。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。</p><p><strong>SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。</strong>也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。</p><h1 id="第07章-单行函数"><a href="#第07章-单行函数" class="headerlink" title="第07章_单行函数"></a>第07章_单行函数</h1><h2 id="1-函数的理解"><a href="#1-函数的理解" class="headerlink" title="1. 函数的理解"></a>1. 函数的理解</h2><h3 id="1-1-什么是函数"><a href="#1-1-什么是函数" class="headerlink" title="1.1 什么是函数"></a>1.1 什么是函数</h3><p>函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既<code>提高了代码效率</code>，又<code>提高了可维护性</code>。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地<code>提高用户对数据库的管理效率</code>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554979529525.png"></p><p>从函数定义的角度出发，我们可以将函数分成<code>内置函数</code>和<code>自定义函数</code>。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。</p><h3 id="1-2-不同DBMS函数的差异"><a href="#1-2-不同DBMS函数的差异" class="headerlink" title="1.2 不同DBMS函数的差异"></a>1.2 不同DBMS函数的差异</h3><p>我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。<strong>DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。</strong>实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着<strong>采用 SQL 函数的代码可移植性是很差的</strong>，因此在使用函数的时候需要特别注意。</p><h3 id="1-3-MySQL的内置函数及分类"><a href="#1-3-MySQL的内置函数及分类" class="headerlink" title="1.3 MySQL的内置函数及分类"></a>1.3 MySQL的内置函数及分类</h3><p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p><p>MySQL提供的内置函数从<code>实现的功能角度</code>可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：<code>单行函数</code>、<code>聚合函数（或分组函数）</code>。</p><p><strong>两种SQL函数</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555433204337.png"></p><p><strong>单行函数</strong></p><ul><li>操作数据对象</li><li>接受参数返回一个结果</li><li><strong>只对一行进行变换</strong></li><li><strong>每行返回一个结果</strong></li><li>可以嵌套</li><li>参数可以是一列或一个值</li></ul><h2 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h2><h3 id="2-1-基本函数"><a href="#2-1-基本函数" class="headerlink" title="2.1 基本函数"></a>2.1 基本函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIGN(X)</td><td>返回X的符号。正数返回1，负数返回-1，0返回0</td></tr><tr><td>PI()</td><td>返回圆周率的值</td></tr><tr><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr><td>RAND()</td><td>返回0~1的随机值</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</td></tr><tr><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位(y为负数，则舍去对应位的整数位)</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),<br>FLOOR(-43.23),MOD(12,5)<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025162304844.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1)<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025162538958.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025162730421.png"></p><h3 id="2-2-角度与弧度互换函数"><a href="#2-2-角度与弧度互换函数" class="headerlink" title="2.2 角度与弧度互换函数"></a>2.2 角度与弧度互换函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))<br>FROM DUAL;<br></code></pre></td></tr></table></figure><h3 id="2-3-三角函数"><a href="#2-3-三角函数" class="headerlink" title="2.3 三角函数"></a>2.3 三角函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>SIN(x)</td><td>返回x的正弦值，其中，参数x为弧度值</td></tr><tr><td>ASIN(x)</td><td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr><td>COS(x)</td><td>返回x的余弦值，其中，参数x为弧度值</td></tr><tr><td>ACOS(x)</td><td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr><td>TAN(x)</td><td>返回x的正切值，其中，参数x为弧度值</td></tr><tr><td>ATAN(x)</td><td>返回x的反正切值，即返回正切值为x的值</td></tr><tr><td>ATAN2(m,n)</td><td>返回两个参数的反正切值</td></tr><tr><td>COT(x)</td><td>返回x的余切值，其中，X为弧度值</td></tr></tbody></table><p>举例：</p><p>ATAN2(M,N)函数返回两个参数的反正切值。<br>与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。</p><p>ATAN2(M,N)函数的使用示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025163846974.png"></p><h3 id="2-4-指数与对数"><a href="#2-4-指数与对数" class="headerlink" title="2.4 指数与对数"></a>2.4 指数与对数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>POW(x,y)，POWER(X,Y)</td><td>返回x的y次方</td></tr><tr><td>EXP(X)</td><td>返回e的X次方，其中e是一个常数，2.718281828459045</td></tr><tr><td>LN(X)，LOG(X)</td><td>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr><td>LOG10(X)</td><td>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr><td>LOG2(X)</td><td>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)<br>    -&gt; FROM DUAL;<br>+----------+------------+------------------+-------------------+-----------+---------+<br>| POW(2,5) | POWER(2,4) | EXP(2)           | LN(10)            | LOG10(10) | LOG2(4) |<br>+----------+------------+------------------+-------------------+-----------+---------+<br>|       32 |         16 | 7.38905609893065 | 2.302585092994046 |         1 |       2 |<br>+----------+------------+------------------+-------------------+-----------+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="2-5-进制间的转换"><a href="#2-5-进制间的转换" class="headerlink" title="2.5 进制间的转换"></a>2.5 进制间的转换</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)<br>    -&gt; FROM DUAL;<br>+---------+---------+---------+--------------+<br>| BIN(10) | HEX(10) | OCT(10) | CONV(10,2,8) |<br>+---------+---------+---------+--------------+<br>| 1010    | A       | 12      | 2            |<br>+---------+---------+---------+--------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3. 字符串函数"></a>3. 字符串函数</h2><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1,s2,……,sn)</td><td>连接s1,s2,……,sn为一个字符串</td></tr><tr><td>CONCAT_WS(x, s1,s2,……,sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td></tr><tr><td>INSERT(str, idx, len, replacestr)</td><td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr（注意这里的字符串索引是从1开始的）</td></tr><tr><td>REPLACE(str, a, b)</td><td>用字符串b替换字符串str中<strong>所有</strong>出现的字符串a</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s)  或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr><td>TRIM(s1 FROM s)</td><td>去掉字符串s开始与结尾的s1</td></tr><tr><td>TRIM(LEADING s1 FROM s)</td><td>去掉字符串s开始处的s1</td></tr><tr><td>TRIM(TRAILING s1 FROM s)</td><td>去掉字符串s结尾处的s1</td></tr><tr><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr><td>SPACE(n)</td><td>返回n个空格</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2的ASCII码值的大小（s1 &gt; s2：返回1，s1 &lt; s2:返回-1，否则：返回0）</td></tr><tr><td>SUBSTR(s,index,len)</td><td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td></tr><tr><td>LOCATE(substr,str)</td><td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td></tr><tr><td>ELT(m,s1,s2,…,sn)</td><td>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn</td></tr><tr><td>FIELD(s,s1,s2,…,sn)</td><td>返回字符串s在字符串列表中第一次出现的位置</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td></tr><tr><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td></tr></tbody></table><blockquote><p>注意：MySQL中，字符串的位置是从1开始的。</p><p>MySQL在合适的时候，数字和字符串会自动转换。</p></blockquote><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT FIELD(&#x27;mm&#x27;,&#x27;hello&#x27;,&#x27;msm&#x27;,&#x27;amma&#x27;),FIND_IN_SET(&#x27;mm&#x27;,&#x27;hello,mm,amma&#x27;)<br>    -&gt; FROM DUAL;<br>+----------------------------------+-----------------------------------+<br>| FIELD(&#x27;mm&#x27;,&#x27;hello&#x27;,&#x27;msm&#x27;,&#x27;amma&#x27;) | FIND_IN_SET(&#x27;mm&#x27;,&#x27;hello,mm,amma&#x27;) |<br>+----------------------------------+-----------------------------------+<br>|                                0 |                                 2 |<br>+----------------------------------+-----------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NULLIF(&#x27;mysql&#x27;,&#x27;mysql&#x27;),NULLIF(&#x27;mysql&#x27;, &#x27;&#x27;);<br>+-------------------------+---------------------+<br>| NULLIF(&#x27;mysql&#x27;,&#x27;mysql&#x27;) | NULLIF(&#x27;mysql&#x27;, &#x27;&#x27;) |<br>+-------------------------+---------------------+<br>| NULL                    | mysql               |<br>+-------------------------+---------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4-日期和时间函数"><a href="#4-日期和时间函数" class="headerlink" title="4. 日期和时间函数"></a>4. 日期和时间函数</h2><h3 id="4-1-获取日期、时间"><a href="#4-1-获取日期、时间" class="headerlink" title="4.1 获取日期、时间"></a>4.1 获取日期、时间</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td><strong>CURDATE()</strong> ，CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr><td><strong>CURTIME()</strong> ， CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td><strong>NOW()</strong> / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()</td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间（英国时间）</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025193742633.png"></p><h3 id="4-2-日期与时间戳的转换"><a href="#4-2-日期与时间戳的转换" class="headerlink" title="4.2 日期与时间戳的转换"></a>4.2 日期与时间戳的转换</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>UNIX_TIMESTAMP()</td><td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>将时间date以UNIX时间戳的形式返回。(date以MySQL时间标准格式给出如：’2022-03-06 16:36:35’)</td></tr><tr><td>FROM_UNIXTIME(timestamp)</td><td>将UNIX时间戳的时间转换为普通格式的时间</td></tr></tbody></table><p>时间戳是指1970-1-1 00:00:00(UTC)到现在的毫秒数。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT UNIX_TIMESTAMP(now());<br>+-----------------------+<br>| UNIX_TIMESTAMP(now()) |<br>+-----------------------+<br>|            1576380910 |<br>+-----------------------+<br>1 row in set (0.01 sec)<br><br>mysql&gt; SELECT UNIX_TIMESTAMP(CURDATE());<br>+---------------------------+<br>| UNIX_TIMESTAMP(CURDATE()) |<br>+---------------------------+<br>|                1576339200 |<br>+---------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT UNIX_TIMESTAMP(CURTIME());<br>+---------------------------+<br>| UNIX_TIMESTAMP(CURTIME()) |<br>+---------------------------+<br>|                1576380969 |<br>+---------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT UNIX_TIMESTAMP(&#x27;2011-11-11 11:11:11&#x27;)<br>+---------------------------------------+<br>| UNIX_TIMESTAMP(&#x27;2011-11-11 11:11:11&#x27;) |<br>+---------------------------------------+<br>|                            1320981071 |<br>+---------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT FROM_UNIXTIME(1576380910);<br>+---------------------------+<br>| FROM_UNIXTIME(1576380910) |<br>+---------------------------+<br>| 2019-12-15 11:35:10       |<br>+---------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="4-3-获取月份、星期、星期数、天数等函数"><a href="#4-3-获取月份、星期、星期数、天数等函数" class="headerlink" title="4.3 获取月份、星期、星期数、天数等函数"></a>4.3 获取月份、星期、星期数、天数等函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>YEAR(date) / MONTH(date) / DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time) / MINUTE(time) / SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，…</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，。。。周日是6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为1～4</td></tr><tr><td>WEEK(date) ， WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是1，周一是2，。。。周六是7</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),<br>HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025213504115.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MONTHNAME(&#x27;2021-10-26&#x27;),DAYNAME(&#x27;2021-10-26&#x27;),WEEKDAY(&#x27;2021-10-26&#x27;), #此处包含隐式转换，从字符串到日期类型<br>QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),<br>DAYOFMONTH(NOW()),DAYOFWEEK(NOW())<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211025214818623.png"></p><h3 id="4-4-日期的操作函数"><a href="#4-4-日期的操作函数" class="headerlink" title="4.4 日期的操作函数"></a>4.4 日期的操作函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type指定返回的值</td></tr></tbody></table><p>EXTRACT(type FROM date)函数中type的取值与含义：（注意下面的microsecond都是微秒，这里写错了。1microsecond = 1e-6 second）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012142639469.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012142746444.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),<br>EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())<br>FROM DUAL;<br><br>#MySQL 较新的版本中（MySQL 6.0.5），也还没有产生微秒的函数，now() 只能精确到秒。 MySQL 中也没有存储带有毫秒、微秒的日期时间类型。想在 MySQL 获得毫秒、微秒还是要在应用层程序中想办法。<br>select extract(microsecond from &#x27;12:00:00.123456&#x27;);             -- 123456<br>select extract(microsecond from &#x27;1997-12-31 23:59:59.000010&#x27;);  -- 10<br></code></pre></td></tr></table></figure><h3 id="4-5-时间和秒钟转换的函数"><a href="#4-5-时间和秒钟转换的函数" class="headerlink" title="4.5 时间和秒钟转换的函数"></a>4.5 时间和秒钟转换的函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>TIME_TO_SEC(time)</td><td>将 time 转化为秒并返回结果值。转化的公式为：<code>小时*3600+分钟*60+秒</code></td></tr><tr><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT TIME_TO_SEC(NOW());<br>+--------------------+<br>| TIME_TO_SEC(NOW()) |<br>+--------------------+<br>|               78774 |<br>+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SEC_TO_TIME(78774);<br>+--------------------+<br>| SEC_TO_TIME(78774) |<br>+--------------------+<br>| 21:52:54            |<br>+--------------------+<br>1 row in set (0.12 sec)<br></code></pre></td></tr></table></figure><h3 id="4-6-计算日期和时间的函数"><a href="#4-6-计算日期和时间的函数" class="headerlink" title="4.6 计算日期和时间的函数"></a>4.6 计算日期和时间的函数</h3><p><strong>第1组：</strong></p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_ADD(datetime, INTERVAL  expr type)，ADDDATE(date,INTERVAL expr type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr><td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td><td>返回与date相差INTERVAL时间间隔的日期</td></tr></tbody></table><p>上述函数中type的取值：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012143203355.png"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL 1 SECOND) AS col2,<br>ADDDATE(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL 1 SECOND) AS col3,<br>DATE_ADD(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL &#x27;1_1&#x27; MINUTE_SECOND) AS col4,<br>DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数<br>DATE_ADD(NOW(), INTERVAL &#x27;1_1&#x27; YEAR_MONTH) AS col6 #需要单引号<br>FROM DUAL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_SUB(&#x27;2021-01-21&#x27;,INTERVAL 31 DAY) AS col1,<br>SUBDATE(&#x27;2021-01-21&#x27;,INTERVAL 31 DAY) AS col2,<br>DATE_SUB(&#x27;2021-01-21 02:01:01&#x27;,INTERVAL &#x27;1 1&#x27; DAY_HOUR) AS col3<br>FROM DUAL;<br></code></pre></td></tr></table></figure><p><strong>第2组：</strong></p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ADDTIME(time1,time2)</td><td>返回time1加上time2的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td></tr><tr><td>SUBTIME(time1,time2)</td><td>返回time1减去time2后的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回date1 - date2的日期间隔天数</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>返回time1 - time2的时间间A隔</td></tr><tr><td>FROM_DAYS(N)</td><td>返回从0000年1月1日起，N天以后的日期</td></tr><tr><td>TO_DAYS(date)</td><td>返回日期date距离0000年1月1日的天数</td></tr><tr><td>LAST_DAY(date)</td><td>返回date所在月份的最后一天的日期</td></tr><tr><td>MAKEDATE(year,n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr><td>MAKETIME(hour,minute,second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr><td>PERIOD_ADD(time,n)</td><td>返回time加上n后的时间</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),&#x27;1:1:3&#x27;),DATEDIFF(NOW(),&#x27;2021-10-01&#x27;),<br>TIMEDIFF(NOW(),&#x27;2021-10-25 22:10:10&#x27;),FROM_DAYS(366),TO_DAYS(&#x27;0000-12-25&#x27;),<br>LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101,10) #NOW() + 0 转化为数字<br>FROM DUAL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ADDTIME(NOW(), 50);<br>+---------------------+<br>| ADDTIME(NOW(), 50)  |<br>+---------------------+<br>| 2019-12-15 22:17:47 |<br>+---------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT ADDTIME(NOW(), &#x27;1:1:1&#x27;);<br>+-------------------------+<br>| ADDTIME(NOW(), &#x27;1:1:1&#x27;) |<br>+-------------------------+<br>| 2019-12-15 23:18:46     |<br>+-------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUBTIME(NOW(), &#x27;1:1:1&#x27;);<br>+-------------------------+<br>| SUBTIME(NOW(), &#x27;1:1:1&#x27;) |<br>+-------------------------+<br>| 2019-12-15 21:23:50     |<br>+-------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT SUBTIME(NOW(), &#x27;-1:-1:-1&#x27;); <br>+----------------------------+<br>| SUBTIME(NOW(), &#x27;-1:-1:-1&#x27;) |<br>+----------------------------+<br>| 2019-12-15 22:25:11        |<br>+----------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT FROM_DAYS(366);<br>+----------------+<br>| FROM_DAYS(366) |<br>+----------------+<br>| 0001-01-01     |<br>+----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT MAKEDATE(2020,1);<br>+------------------+<br>| MAKEDATE(2020,1) |<br>+------------------+<br>| 2020-01-01       |<br>+------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT MAKEDATE(2020,32);<br>+-------------------+<br>| MAKEDATE(2020,32) |<br>+-------------------+<br>| 2020-02-01        |<br>+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT MAKETIME(1,1,1);<br>+-----------------+<br>| MAKETIME(1,1,1) |<br>+-----------------+<br>| 01:01:01        |<br>+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT PERIOD_ADD(20200101010101,1);<br>+------------------------------+<br>| PERIOD_ADD(20200101010101,1) |<br>+------------------------------+<br>|               20200101010102 |<br>+------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT TO_DAYS(NOW());<br>+----------------+<br>| TO_DAYS(NOW()) |<br>+----------------+<br>|          737773 |<br>+----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>举例：查询 7 天内的新增用户数有多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)&lt;=7<br></code></pre></td></tr></table></figure><h3 id="4-7-日期的格式化与解析"><a href="#4-7-日期的格式化与解析" class="headerlink" title="4.7 日期的格式化与解析"></a>4.7 日期的格式化与解析</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_FORMAT(date,fmt)</td><td>按照字符串fmt格式化日期date值</td></tr><tr><td>TIME_FORMAT(time,fmt)</td><td>按照字符串fmt格式化时间time值</td></tr><tr><td>GET_FORMAT(date_type,format_type)</td><td>返回日期字符串的显示格式</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p><table><thead><tr><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January,….）</td><td>%m</td><td>两位数字表示月份（01,02,03。。。）</td></tr><tr><td>%b</td><td>缩写的月名（Jan.，Feb.，….）</td><td>%c</td><td>数字表示月份（1,2,3,…）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td><td>%d</td><td>两位数字表示月中的天数(01,02…)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5…..）</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数，24小时制（01,02..）</td><td>%h和%I</td><td>两位数字表示小时，12小时制（01,02..）</td></tr><tr><td>%k</td><td>数字形式的小时，24小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时，12小时制（1,2,3,4….）</td></tr><tr><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02…)</td></tr><tr><td>%W</td><td>一周中的星期名称（Sunday…）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td></tr><tr><td>%w</td><td>以数字表示周中的天数(0=Sunday,1=Monday….)</td><td></td><td></td></tr><tr><td>%j</td><td>以3位数字表示年中的天数(001,002…)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24小时制</td><td>%r</td><td>12小时制</td></tr><tr><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><p>GET_FORMAT函数中date_type和format_type参数取值如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012145231321.png"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DATE_FORMAT(NOW(), &#x27;%H:%i:%s&#x27;);<br>+--------------------------------+<br>| DATE_FORMAT(NOW(), &#x27;%H:%i:%s&#x27;) |<br>+--------------------------------+<br>| 22:57:34                        |<br>+--------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT STR_TO_DATE(&#x27;09/01/2009&#x27;,&#x27;%m/%d/%Y&#x27;)<br>FROM DUAL;<br><br>SELECT STR_TO_DATE(&#x27;20140422154706&#x27;,&#x27;%Y%m%d%H%i%s&#x27;)<br>FROM DUAL;<br><br>SELECT STR_TO_DATE(&#x27;2014-04-22 15:47:06&#x27;,&#x27;%Y-%m-%d %H:%i:%s&#x27;)<br>FROM DUAL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT GET_FORMAT(DATE, &#x27;USA&#x27;);<br>+-------------------------+<br>| GET_FORMAT(DATE, &#x27;USA&#x27;) |<br>+-------------------------+<br>| %m.%d.%Y                |<br>+-------------------------+<br>1 row in set (0.00 sec)<br><br>SELECT DATE_FORMAT(NOW(),GET_FORMAT(DATE,&#x27;USA&#x27;)),<br>FROM DUAL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT STR_TO_DATE(&#x27;2020-01-01 00:00:00&#x27;,&#x27;%Y-%m-%d&#x27;); <br>+-----------------------------------------------+<br>| STR_TO_DATE(&#x27;2020-01-01 00:00:00&#x27;,&#x27;%Y-%m-%d&#x27;) |<br>+-----------------------------------------------+<br>| 2020-01-01                                    |<br>+-----------------------------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5. 流程控制函数"></a>5. 流程控制函数</h2><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>IF(value,value1,wvalue2)</td><td>如果value的值为TRUE，返回value1，否则返回value2</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为NULL，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END</td><td>相当于Java的if…else if…else…</td></tr><tr><td>CASE  expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td><td>相当于Java的switch…case…</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IF(1 &gt; 0,&#x27;正确&#x27;,&#x27;错误&#x27;)    <br>-&gt;正确<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL(null,&#x27;Hello Word&#x27;)<br>-&gt;Hello Word<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CASE <br>　　WHEN 1 &gt; 0<br>　　THEN &#x27;1 &gt; 0&#x27;<br>　　WHEN 2 &gt; 0<br>　　THEN &#x27;2 &gt; 0&#x27;<br>　　ELSE &#x27;3 &gt; 0&#x27;<br>　　END<br>-&gt;1 &gt; 0<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CASE 1 <br>　　WHEN 1 THEN &#x27;我是1&#x27;<br>　　WHEN 2 THEN &#x27;我是2&#x27;<br>ELSE &#x27;你是谁&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27; <br>  WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;  <br>  WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27; <br>  ELSE &#x27;草根&#x27; END  &quot;描述&quot;<br>FROM employees; <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT oid,`status`, CASE `status` WHEN 1 THEN &#x27;未付款&#x27; <br>   WHEN 2 THEN &#x27;已付款&#x27; <br>   WHEN 3 THEN &#x27;已发货&#x27;  <br>   WHEN 4 THEN &#x27;确认收货&#x27;  <br>   ELSE &#x27;无效订单&#x27; END <br>FROM t_order;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;<br>+---------------------------------------------------------------------+<br>| CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |<br>+---------------------------------------------------------------------+<br>| yes                                                                  |<br>+---------------------------------------------------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;  <br>+--------------------------------------------------------------------+<br>| CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |<br>+--------------------------------------------------------------------+<br>| unknown                                                             |<br>+--------------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;<br>+------------------------------------------------+<br>| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |<br>+------------------------------------------------+<br>|                                               1 |<br>+------------------------------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;<br>+-------------------------------------------------+<br>| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |<br>+-------------------------------------------------+<br>|                                               -1 |<br>+-------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))<br>FROM employees;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id, salary,<br>       CASE job_id WHEN &#x27;IT_PROG&#x27;  THEN  1.10*salary<br>                   WHEN &#x27;ST_CLERK&#x27; THEN  1.15*salary<br>                   WHEN &#x27;SA_REP&#x27;   THEN  1.20*salary<br>          ELSE      salary END     &quot;REVISED_SALARY&quot;<br>FROM   employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554980865631.png"></p><p><strong>练习：查询部门号为 10,20, 30 的员工信息, 若部门号为 10, 则打印其工资的 1.1 倍, 20 号部门, 则打印其工资的 1.2 倍, 30 号部门打印其工资的 1.3 倍数。</strong></p><h2 id="6-加密与解密函数"><a href="#6-加密与解密函数" class="headerlink" title="6. 加密与解密函数"></a>6. 加密与解密函数</h2><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本，41位长的字符串。加密结果<code>不可逆</code>，常用于用户的密码加密。（在MySQL8.0中被弃用，使用会报错）</td></tr><tr><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式（不可逆）。若参数为NULL，则会返回NULL</td></tr><tr><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。<code>SHA加密算法比MD5更加安全</code>。</td></tr><tr><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value（在MySQL8.0中被弃用，使用会报错）</td></tr><tr><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value（在MySQL8.0中被弃用，使用会报错）</td></tr></tbody></table><p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT PASSWORD(&#x27;mysql&#x27;), PASSWORD(NULL);<br>+-------------------------------------------+----------------+<br>| PASSWORD(&#x27;mysql&#x27;)                         | PASSWORD(NULL) |<br>+-------------------------------------------+----------------+<br>| *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA |                |<br>+-------------------------------------------+----------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT md5(&#x27;123&#x27;)<br>-&gt;202cb962ac59075b964b07152d234b70<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SHA(&#x27;Tom123&#x27;)<br>-&gt;c7c506980abc31cc390a2438c90861d0f1216d50<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ENCODE(&#x27;mysql&#x27;, &#x27;mysql&#x27;);<br>+--------------------------+<br>| ENCODE(&#x27;mysql&#x27;, &#x27;mysql&#x27;) |<br>+--------------------------+<br>| íg　¼　ìÉ                  |<br>+--------------------------+<br>1 row in set, 1 warning (0.01 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DECODE(ENCODE(&#x27;mysql&#x27;,&#x27;mysql&#x27;),&#x27;mysql&#x27;);<br>+-----------------------------------------+<br>| DECODE(ENCODE(&#x27;mysql&#x27;,&#x27;mysql&#x27;),&#x27;mysql&#x27;) |<br>+-----------------------------------------+<br>| mysql                                   |<br>+-----------------------------------------+<br>1 row in set, 2 warnings (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="7-MySQL信息函数"><a href="#7-MySQL信息函数" class="headerlink" title="7. MySQL信息函数"></a>7. MySQL信息函数</h2><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接id</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DATABASE();<br>+------------+<br>| DATABASE() |<br>+------------+<br>| test       |<br>+------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT DATABASE();<br>+------------+<br>| DATABASE() |<br>+------------+<br>| test       |<br>+------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();<br>+----------------+----------------+----------------+----------------+<br>| USER()         | CURRENT_USER() | SYSTEM_USER()  | SESSION_USER() |<br>+----------------+----------------+----------------+----------------+<br>| root@localhost | root@localhost | root@localhost | root@localhost |<br>+----------------+----------------+----------------+----------------+<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CHARSET(&#x27;ABC&#x27;);<br>+----------------+<br>| CHARSET(&#x27;ABC&#x27;) |<br>+----------------+<br>| utf8mb4        |<br>+----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT COLLATION(&#x27;ABC&#x27;);<br>+--------------------+<br>| COLLATION(&#x27;ABC&#x27;)   |<br>+--------------------+<br>| utf8mb4_general_ci |<br>+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="8-其他函数"><a href="#8-其他函数" class="headerlink" title="8. 其他函数"></a>8. 其他函数</h2><p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位   (如果n的值小于或者等于0，则只保留整数部分)</td></tr><tr><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 如果n的值小于或者等于0，则只保留整数部分<br>mysql&gt; SELECT FORMAT(123.123, 2), FORMAT(123.523, 0), FORMAT(123.123, -2); <br>+--------------------+--------------------+---------------------+<br>| FORMAT(123.123, 2) | FORMAT(123.523, 0) | FORMAT(123.123, -2) |<br>+--------------------+--------------------+---------------------+<br>| 123.12             | 124                | 123                 |<br>+--------------------+--------------------+---------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CONV(16, 10, 2), CONV(8888,10,16), CONV(NULL, 10, 2);<br>+-----------------+------------------+-------------------+<br>| CONV(16, 10, 2) | CONV(8888,10,16) | CONV(NULL, 10, 2) |<br>+-----------------+------------------+-------------------+<br>| 10000           | 22B8             | NULL              |<br>+-----------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT INET_ATON(&#x27;192.168.1.100&#x27;);<br>+----------------------------+<br>| INET_ATON(&#x27;192.168.1.100&#x27;) |<br>+----------------------------+<br>|                 3232235876 |<br>+----------------------------+<br>1 row in set (0.00 sec)<br><br># 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上100。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT INET_NTOA(3232235876);<br>+-----------------------+<br>| INET_NTOA(3232235876) |<br>+-----------------------+<br>| 192.168.1.100         |<br>+-----------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT BENCHMARK(1, MD5(&#x27;mysql&#x27;));<br>+----------------------------+<br>| BENCHMARK(1, MD5(&#x27;mysql&#x27;)) |<br>+----------------------------+<br>|                          0 |<br>+----------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT BENCHMARK(1000000, MD5(&#x27;mysql&#x27;)); <br>+----------------------------------+<br>| BENCHMARK(1000000, MD5(&#x27;mysql&#x27;)) |<br>+----------------------------------+<br>|                                0 |<br>+----------------------------------+<br>1 row in set (0.20 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CHARSET(&#x27;mysql&#x27;), CHARSET(CONVERT(&#x27;mysql&#x27; USING &#x27;utf8&#x27;));<br>+------------------+----------------------------------------+<br>| CHARSET(&#x27;mysql&#x27;) | CHARSET(CONVERT(&#x27;mysql&#x27; USING &#x27;utf8&#x27;)) |<br>+------------------+----------------------------------------+<br>| utf8mb4          | utf8                                   |<br>+------------------+----------------------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h1 id="第08章-聚合函数"><a href="#第08章-聚合函数" class="headerlink" title="第08章_聚合函数"></a>第08章_聚合函数</h1><p>我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p><h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul><li><strong>什么是聚合函数</strong></li></ul><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554980924940.png"></p><ul><li><p><strong>聚合函数类型</strong></p><ul><li><strong>AVG()</strong> </li><li><strong>SUM()</strong></li><li><strong>MAX()</strong> </li><li><strong>MIN()</strong> </li><li>**COUNT() **</li></ul></li><li><p>聚合函数语法</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981029920.png"></p><ul><li>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</li></ul><h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1.1 AVG和SUM函数"></a>1.1 AVG和SUM函数</h3><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。对于不是数值类型的，结果无意义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary), <span class="hljs-built_in">MAX</span>(salary),<span class="hljs-built_in">MIN</span>(salary), <span class="hljs-built_in">SUM</span>(salary)<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  job_id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%REP%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981279723.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">AVG</span>(<span class="hljs-keyword">DISTINCT</span> expression)<br></code></pre></td></tr></table></figure><p>您可以使用AVG()函数中的<a href="http://www.yiibai.com/mysql/distinct.html">DISTINCT</a><a href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">运算符</a>来计算不同值的平均值。 例如，如果您有一组值<code>1</code>,<code>1</code>,<code>2</code>,<code>3</code>，具有<code>DISTINCT</code>操作的AVG()函数将返回不同值的和，即：<code>(1 + 2 + 3)/3 = 2.00</code>。</p><h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1.2 MIN和MAX函数"></a>1.2 MIN和MAX函数</h3><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。字符串由于有比较规则，所以可以使用MIN / MAX函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(hire_date), <span class="hljs-built_in">MAX</span>(hire_date)<br><span class="hljs-keyword">FROM</span>  employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981253194.png"></p><h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1.3 COUNT函数"></a>1.3 COUNT函数</h3><ul><li>COUNT(*)返回表中记录总数，适用于<strong>任意数据类型</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span>  employees<br><span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981241299.png"></p><ul><li>COUNT(expr) 返回<strong>expr不为空</strong>的记录总数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(commission_pct)<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981328678.png"></p><ul><li><p><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></p><p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p><p>Innodb引擎的表用count(<em>),count(1),count(2)……直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。*<em>count(null)是0。</em></em></p></li><li><p><strong>问题：能不能使用count(列名)替换count(*)?</strong></p><p>不要使用 count(列名)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 </p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary), <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(salary), <span class="hljs-built_in">AVG</span>(commission_pct), <span class="hljs-built_in">SUM</span>(commission_pct) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(commission_pct), <span class="hljs-built_in">SUM</span>(commission_pct) <span class="hljs-operator">/</span> <span class="hljs-number">107</span><br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220307184608281.png"></p><p>需要注意的是，SUM / AVG / COUNT均不考虑NULL值（过滤掉NULL值，当做不存在）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#正确写法<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(IFNULL(commission_pct,<span class="hljs-number">0</span>)), <span class="hljs-built_in">SUM</span>(IFNULL(commission_pct, <span class="hljs-number">0</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(IFNULL(commission_pct, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220307185315221.png"></p><h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981374920.png"></p><p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span>, group_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br>[<span class="hljs-keyword">WHERE</span><span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>group_by_expression]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><span class="hljs-keyword">column</span>];<br></code></pre></td></tr></table></figure><blockquote><p><strong>明确：WHERE一定放在FROM后面</strong></p></blockquote><p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</strong>，MySQL5.7不报错，MySQL8.0报错。MySQL有时候出错，也不报错（可能可以执行但是结果不对）</p><p><strong>需要注意的是，SQL92不允许不包含在group by子句中的列。但是SQL99及之后，MySQL5.7.5之后，启用ONLY_FULL_GROUP_BY SQL模式时，MySQL 5.7.5和更高版本还允许在GROUP BY子句中未命名的非聚合列，但前提是该列限于单个值。</strong>不过最好不要使用，可能会产生意想不到的情况，可以再套上一层子查询达到需要的效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   department_id, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981539408.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981544191.png" alt="1554981544191"></p><p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981574152.png"></p><h3 id="2-2-使用多个列分组"><a href="#2-2-使用多个列分组" class="headerlink" title="2.2 使用多个列分组"></a>2.2 使用多个列分组</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981607442.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   department_id dept_id, job_id, <span class="hljs-built_in">SUM</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_id ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981624864.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981629733.png"></p><h3 id="2-3-GROUP-BY中使用WITH-ROLLUP"><a href="#2-3-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2.3 GROUP BY中使用WITH ROLLUP"></a>2.3 GROUP BY中使用WITH ROLLUP</h3><p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的聚合函数，即统计记录数量。<strong>即将每组的聚合结果进行求和，方便查看统计结果。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT year, country, product, SUM(profit) AS profit<br>       FROM sales<br>       GROUP BY year, country, product;<br>+------+---------+------------+--------+<br>| year | country | product    | profit |<br>+------+---------+------------+--------+<br>| 2000 | Finland | Computer   |   1500 |<br>| 2000 | Finland | Phone      |    100 |<br>| 2000 | India   | Calculator |    150 |<br>| 2000 | India   | Computer   |   1200 |<br>| 2000 | USA     | Calculator |     75 |<br>| 2000 | USA     | Computer   |   1500 |<br>| 2001 | Finland | Phone      |     10 |<br>| 2001 | USA     | Calculator |     50 |<br>| 2001 | USA     | Computer   |   2700 |<br>| 2001 | USA     | TV         |    250 |<br>+------+---------+------------+--------+<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT year, country, product, SUM(profit) AS profit<br>       FROM sales<br>       GROUP BY year, country, product WITH ROLLUP;<br>+------+---------+------------+--------+<br>| year | country | product    | profit |<br>+------+---------+------------+--------+<br>| 2000 | Finland | Computer   |   1500 |<br>| 2000 | Finland | Phone      |    100 |<br>| 2000 | Finland | NULL       |   1600 |<br>| 2000 | India   | Calculator |    150 |<br>| 2000 | India   | Computer   |   1200 |<br>| 2000 | India   | NULL       |   1350 |<br>| 2000 | USA     | Calculator |     75 |<br>| 2000 | USA     | Computer   |   1500 |<br>| 2000 | USA     | NULL       |   1575 |<br>| 2000 | NULL    | NULL       |   4525 |<br>| 2001 | Finland | Phone      |     10 |<br>| 2001 | Finland | NULL       |     10 |<br>| 2001 | USA     | Calculator |     50 |<br>| 2001 | USA     | Computer   |   2700 |<br>| 2001 | USA     | TV         |    250 |<br>| 2001 | USA     | NULL       |   3000 |<br>| 2001 | NULL    | NULL       |   3010 |<br>| NULL | NULL    | NULL       |   7535 |<br>+------+---------+------------+--------+<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT department_id,AVG(salary)<br>FROM employees<br>WHERE department_id &gt; 80<br>GROUP BY department_id WITH ROLLUP;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>①当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。5.7报错，8.0之后不报错</p><p>②WITH ROLLUP只能对所有GROUP BY的列实行，不能只对某些列实行，所以WITH ROLLUP只能放在GROUP BY所有列的结尾。</p></blockquote><h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981656798.png"></p><p><strong>过滤分组：HAVING子句</strong></p><ol><li><p>行已经被分组。</p></li><li><p>使用了聚合函数。</p></li><li><p>满足HAVING 子句中条件的分组将被显示。</p></li><li><p>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。（语法层面非强制，不会报错。但是单独使用having没有意义）</p><p>如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE。否则，报错。<strong>需要注意的是，having是过滤显示的分组，是等group by还有rollup做完之后才开始过滤，不影响程序逻辑</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981808091.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   department_id, <span class="hljs-built_in">MAX</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span>   <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span> ;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981824564.png"></p><ul><li><strong>非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数。</strong>如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   department_id, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">WHERE</span>    <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">8000</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554981724375.png"></p><h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3.2 WHERE和HAVING的对比"></a>3.2 WHERE和HAVING的对比</h3><p><strong>区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong> </p><p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p><p><strong>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</strong> 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 </p><p>小结如下：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><p><strong>开发中的选择：</strong></p><p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4.1 查询的结构"></a>4.1 查询的结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：<br>SELECT ...,....,...<br>FROM ...,...,....<br>WHERE 多表的连接条件<br>AND 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br><br>#方式2：<br>SELECT ...,....,...<br>FROM ... (LEFT / RIGHT) JOIN ... <br>ON 多表的连接条件<br>(LEFT / RIGHT) JOIN ... # 在开发中一般把多的放左边，所以一般使用LEFT JOIN<br>ON ...<br>WHERE 不包含组函数的过滤条件<br>AND/OR 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br><br>#其中：<br>#（1）from：从哪些表中筛选<br>#（2）on：关联多表查询时，去除笛卡尔积<br>#（3）where：从表中筛选的条件<br>#（4）group by：分组依据<br>#（5）having：在统计结果中再次筛选<br>#（6）order by：排序<br>#（7）limit：分页<br></code></pre></td></tr></table></figure><h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4.2 SELECT执行顺序"></a>4.2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p><p><strong>1. 关键字的顺序是不能颠倒的：</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-params">...</span> FROM <span class="hljs-params">...</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-params">...</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-params">...</span> HAVING <span class="hljs-params">...</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-params">...</span> LIMIT<span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><strong>2.SELECT 语句的执行顺序</strong>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> 的字段 <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> LIMIT<br>   #行限制         #列限制                            #行限制<br>#<span class="hljs-keyword">from</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">on</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">join</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>（开始使用<span class="hljs-keyword">select</span>中的别名，后面的语句中都可以使用别名）<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>sum、count、max、avg<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">having</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">select</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">distinct</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>limit<br><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1566872301088.png"></p><p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5<br>FROM player JOIN team ON player.team_id = team.team_id # 顺序 1<br>WHERE height &gt; 1.80 # 顺序 2<br>GROUP BY player.team_id # 顺序 3<br>HAVING num &gt; 2 # 顺序 4<br>ORDER BY num DESC # 顺序 6<br>LIMIT 2 # 顺序 7<br></code></pre></td></tr></table></figure><p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p><h3 id="4-3-SQL-的执行原理"><a href="#4-3-SQL-的执行原理" class="headerlink" title="4.3 SQL 的执行原理"></a>4.3 SQL 的执行原理</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <code>vt1</code>，就可以在此基础上再进行 <code>WHERE 阶段</code>。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 <code>vt2</code>。</p><p>然后进入第三步和第四步，也就是 <code>GROUP 和 HAVING 阶段</code>。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 <code>vt3</code> 和 <code>vt4</code>。</p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <code>SELECT 和 DISTINCT 阶段</code>。</p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 <code>vt5-1</code> 和 <code>vt5-2</code>。</p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <code>ORDER BY 阶段</code>，得到虚拟表 <code>vt6</code>。</p><p>最后在 vt6 的基础上，取出指定行的记录，也就是 <code>LIMIT 阶段</code>，得到最终的结果，对应的是虚拟表 <code>vt7</code>。</p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">#另外一种更加详细的<br><span class="hljs-number">1</span>、<span class="hljs-keyword">FROM</span>：对<span class="hljs-keyword">FROM</span>左边的表和右边的表计算笛卡尔积，产生虚表VT1；<br><br><span class="hljs-number">2</span>、<span class="hljs-keyword">ON</span>：对虚拟表VT1进行<span class="hljs-keyword">ON</span>筛选，只有那些符合<span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span>条件的行才会被记录在虚拟表VT2中；<br><br><span class="hljs-number">3</span>、<span class="hljs-keyword">JOIN</span>：如果是<span class="hljs-keyword">OUT</span> <span class="hljs-keyword">JOIN</span>，那么将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表VT2中，从而产生虚拟表VT3；<br><br><span class="hljs-number">4</span>、<span class="hljs-keyword">WHERE</span>：对虚拟表VT3进行<span class="hljs-keyword">WHERE</span>条件过滤，只有符合<span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span>的记录才会被放入到虚拟表VT4；<br><br><span class="hljs-number">5</span>、<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>：根据<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>子句中的列，对虚拟表VT4进行分组操作，产生虚拟表VT5；<br><br><span class="hljs-number">6</span>、<span class="hljs-keyword">CUBE</span><span class="hljs-operator">|</span><span class="hljs-keyword">ROLLUP</span>：对虚拟表VT5进行<span class="hljs-keyword">CUBE</span>或者<span class="hljs-keyword">ROLLUP</span>操作，产生虚拟表VT6；<br><br><span class="hljs-number">7</span>、<span class="hljs-keyword">HAVING</span>：对虚拟表VT6进行<span class="hljs-keyword">HAVING</span>条件过滤，只有符合<span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span>的记录才会被插入到虚拟表VT7中；<br><br><span class="hljs-number">8</span>、<span class="hljs-keyword">SELECT</span>：执行<span class="hljs-keyword">SELECT</span>操作，选择指定的列，插入到虚拟表VT8中；<br><br><span class="hljs-number">9</span>、<span class="hljs-keyword">DISTINCT</span>：对虚拟表VT8中的记录进行去重，产生虚拟表VT9；<br><br><span class="hljs-number">10</span>、<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>：将虚拟表VT9中的记录按照<span class="hljs-operator">&lt;</span>order_by_list<span class="hljs-operator">&gt;</span>进行排序操作，产生虚拟表VT10；<br><br><span class="hljs-number">11</span>、LIMIT：取出指定行的记录，产生虚拟表VT11，并将结果返回。<br></code></pre></td></tr></table></figure><h3 id="4-4-课后练习"><a href="#4-4-课后练习" class="headerlink" title="4.4 课后练习"></a>4.4 课后练习</h3><p><strong>查询每个工种、每个部门的部门名、工种名和最低工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.department_name, e.job_id, <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d <br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.job_id, d.department_name<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> d.department_name, e.job_id, <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d <br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.job_id, d.department_name;<br></code></pre></td></tr></table></figure><p><strong>查询所有部门的名字，</strong>location_id<strong>，员工数量和平均工资，并按平均工 资降序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.department_name, d.location_id, <span class="hljs-built_in">COUNT</span>(IFNULL(salary, <span class="hljs-keyword">NULL</span>)), <span class="hljs-built_in">AVG</span>(salary) avg_salary<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d <br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> d.department_id<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_salary <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h1 id="第09章-子查询"><a href="#第09章-子查询" class="headerlink" title="第09章_子查询"></a>第09章_子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p><p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p><h2 id="1-需求分析与问题解决"><a href="#1-需求分析与问题解决" class="headerlink" title="1. 需求分析与问题解决"></a>1. 需求分析与问题解决</h2><h3 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1.1 实际问题"></a>1.1 实际问题</h3><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991034688.png" alt="" style="zoom:80%;" /><p>现有解决方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式一：<br>SELECT salary<br>FROM employees<br>WHERE last_name = &#x27;Abel&#x27;;<br><br>SELECT last_name,salary<br>FROM employees<br>WHERE salary &gt; 11000;<br><br>#方式二：自连接<br>SELECT e2.last_name,e2.salary<br>FROM employees e1,employees e2<br>WHERE e1.last_name = &#x27;Abel&#x27;<br>AND e1.`salary` &lt; e2.`salary`<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式三：子查询<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary &gt; (<br>SELECT salary<br>FROM employees<br>WHERE last_name = &#x27;Abel&#x27;<br>);<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991316599.png"></p><h3 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1.2 子查询的基本使用"></a>1.2 子查询的基本使用</h3><ul><li>子查询的基本语法结构：</li></ul><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991054388.png"></p><ul><li>子查询（内查询）在主查询之前一次执行完成。</li><li>子查询的结果被主查询（外查询）使用 。</li><li><strong>注意事项</strong><ul><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧（只是规范，可以放在左侧，但是为了可读性和美观角度思考，放在右侧）</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ul></li></ul><h3 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1.3 子查询的分类"></a>1.3 子查询的分类</h3><p><strong>分类方式1：</strong></p><p>我们按内查询的结果返回一条还是多条记录，将子查询分为<code>单行子查询</code>、<code>多行子查询</code>。</p><ul><li><p>单行子查询</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991538719.png"></p></li><li><p>多行子查询</p></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991555669.png"></p><p><strong>分类方式2：</strong></p><p>我们按内查询是否被执行多次，将子查询划分为<code>相关(或关联)子查询</code>和<code>不相关(或非关联)子查询</code>。</p><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p><p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p><h2 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a>2. 单行子查询</h2><h3 id="2-1-单行比较操作符"><a href="#2-1-单行比较操作符" class="headerlink" title="2.1 单行比较操作符"></a>2.1 单行比较操作符</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>equal to</td></tr><tr><td>&gt;</td><td>greater than</td></tr><tr><td>&gt;=</td><td>greater than or equal to</td></tr><tr><td>&lt;</td><td>less than</td></tr><tr><td>&lt;=</td><td>less than or equal to</td></tr><tr><td>&lt;&gt;</td><td>not equal to</td></tr></tbody></table><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><p><strong>题目：查询工资大于149号员工工资的员工的信息</strong></p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914232952626.png"></p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210914232935062.png"></p><p><strong>题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, job_id, salary<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  job_id <span class="hljs-operator">=</span>  <br>                (<span class="hljs-keyword">SELECT</span> job_id<br>                 <span class="hljs-keyword">FROM</span>   employees<br>                 <span class="hljs-keyword">WHERE</span>  employee_id <span class="hljs-operator">=</span> <span class="hljs-number">141</span>)<br><span class="hljs-keyword">AND</span>    salary <span class="hljs-operator">&gt;</span><br>                (<span class="hljs-keyword">SELECT</span> salary<br>                 <span class="hljs-keyword">FROM</span>   employees<br>                 <span class="hljs-keyword">WHERE</span>  employee_id <span class="hljs-operator">=</span> <span class="hljs-number">143</span>);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991892770.png"></p><p><strong>题目：返回公司工资最少的员工的last_name,job_id和salary</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, job_id, salary<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  salary <span class="hljs-operator">=</span> <br>                (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>                 <span class="hljs-keyword">FROM</span>   employees);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554991935186.png"></p><p><strong>题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</strong></p><p>实现方式1：不成对比较</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">SELECT</span>  employee_id, manager_id, department_id<br><span class="hljs-meta">FROM</span>    employees<br><span class="hljs-meta">WHERE</span>   manager_id <span class="hljs-meta">IN</span><br>  (<span class="hljs-meta">SELECT</span>  manager_id<br>                   <span class="hljs-meta">FROM</span>    employees<br>                   <span class="hljs-meta">WHERE</span>   employee_id <span class="hljs-meta">IN</span> (174,141))<br><span class="hljs-meta">AND</span>     department_id <span class="hljs-meta">IN</span> <br>  (<span class="hljs-meta">SELECT</span>  department_id<br>                   <span class="hljs-meta">FROM</span>    employees<br>                   <span class="hljs-meta">WHERE</span>   employee_id <span class="hljs-meta">IN</span> (174,141))<br><span class="hljs-meta">AND</span>employee_id <span class="hljs-meta">NOT</span> <span class="hljs-meta">IN(</span>174,141);<br></code></pre></td></tr></table></figure><p>实现方式2：成对比较</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span>employee_id, manager_id, department_id<br><span class="hljs-keyword">FROM</span>employees<br><span class="hljs-keyword">WHERE</span>  (manager_id, department_id) <span class="hljs-keyword">IN</span><br>                      (<span class="hljs-keyword">SELECT</span> manager_id, department_id<br>                       <span class="hljs-keyword">FROM</span>   employees<br>                       <span class="hljs-keyword">WHERE</span>  employee_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">141</span>,<span class="hljs-number">174</span>))<br><span class="hljs-keyword">AND</span>employee_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">141</span>,<span class="hljs-number">174</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">#实现方式<span class="hljs-number">1</span>写法，有可能会存在交叉相等，即manager_id 是<span class="hljs-number">141</span>的，而department_id是<span class="hljs-number">174</span>的。实现方式<span class="hljs-number">2</span>和下面这种写法不会出错。<br><span class="hljs-keyword">SELECT</span> e.employee_id, e.manager_id, e.department_id<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">WHERE</span> (e.manager_id <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> manager_id<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">141</span>)<br>                         <span class="hljs-keyword">AND</span><br> e.department_id <span class="hljs-operator">=</span> (<br>                         <span class="hljs-keyword">SELECT</span> department_id<br>                         <span class="hljs-keyword">FROM</span> employees<br>                         <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">141</span>)<br>                       <span class="hljs-keyword">OR</span><br>e.manager_id <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> manager_id<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">174</span>)<br>                <span class="hljs-keyword">AND</span><br> e.department_id <span class="hljs-operator">=</span> (<br>                         <span class="hljs-keyword">SELECT</span> department_id<br>                         <span class="hljs-keyword">FROM</span> employees<br>                         <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">174</span>)) <span class="hljs-keyword">AND</span> e.employee_id <span class="hljs-operator">!=</span> <span class="hljs-number">141</span> <span class="hljs-keyword">AND</span> e.employee_id <span class="hljs-operator">!=</span> <span class="hljs-number">174</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-HAVING-中的子查询"><a href="#2-3-HAVING-中的子查询" class="headerlink" title="2.3 HAVING 中的子查询"></a>2.3 HAVING 中的子查询</h3><ul><li>首先执行子查询。</li><li>向主查询中的HAVING 子句返回结果。</li></ul><p><strong>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   department_id, <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span>     employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span>   <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-operator">&gt;</span><br>                       (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>                        <span class="hljs-keyword">FROM</span>   employees<br>                        <span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-CASE中的子查询"><a href="#2-4-CASE中的子查询" class="headerlink" title="2.4 CASE中的子查询"></a>2.4 CASE中的子查询</h3><p>在CASE表达式中使用单列子查询：</p><p><strong>题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> employee_id, last_name,<br>       (<span class="hljs-keyword">CASE</span> department_id<br>        <span class="hljs-keyword">WHEN</span><br>             (<span class="hljs-keyword">SELECT</span> department_id <span class="hljs-keyword">FROM</span> departments<br>      <span class="hljs-keyword">WHERE</span> location_id = <span class="hljs-number">1800</span>)           <br>        <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Canada&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;USA&#x27;</span> <span class="hljs-keyword">END</span>) <span class="hljs-keyword">location</span><br><span class="hljs-keyword">FROM</span>   employees;<br></code></pre></td></tr></table></figure><h3 id="2-5-子查询中的空值问题"><a href="#2-5-子查询中的空值问题" class="headerlink" title="2.5 子查询中的空值问题"></a>2.5 子查询中的空值问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, job_id<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  job_id <span class="hljs-operator">=</span><br>                (<span class="hljs-keyword">SELECT</span> job_id<br>                 <span class="hljs-keyword">FROM</span>   employees<br>                 <span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Haas&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992067381.png"></p><blockquote><p><strong>子查询不返回任何行</strong></p></blockquote><h3 id="2-5-非法使用子查询"><a href="#2-5-非法使用子查询" class="headerlink" title="2.5 非法使用子查询"></a>2.5 非法使用子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  salary <span class="hljs-operator">=</span><br>                (<span class="hljs-keyword">SELECT</span>   <span class="hljs-built_in">MIN</span>(salary)<br>                 <span class="hljs-keyword">FROM</span>     employees<br>                 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992135819.png"></p><blockquote><p><strong>多行子查询使用单行比较符</strong></p></blockquote><h2 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a>3. 多行子查询</h2><ul><li>也称为集合比较子查询</li><li>内查询返回多行</li><li>使用多行比较操作符</li></ul><h3 id="3-1-多行比较操作符"><a href="#3-1-多行比较操作符" class="headerlink" title="3.1 多行比较操作符"></a>3.1 多行比较操作符</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td></tr><tr><td>SOME</td><td>实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><blockquote><p>体会 ANY 和 ALL 的区别</p></blockquote><h3 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a>3.2 代码示例</h3><p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992658876.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992664594.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992668429.png"></p><p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992753654.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992759467.png"></p><p><strong>题目：查询平均工资最低的部门id</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary) = (<br>SELECT MIN(avg_sal)<br>FROM (<br>SELECT AVG(salary) avg_sal<br>FROM employees<br>GROUP BY department_id<br>) dept_avg_sal #把子查询当做一个表，但是需要表有别名（必须要起个别名，因为子查询结果的表默认没有名字）<br>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式2：<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary) &lt;= ALL (<br>SELECT AVG(salary) avg_sal<br>FROM employees<br>GROUP BY department_id<br>)<br></code></pre></td></tr></table></figure><h3 id="3-3-空值问题"><a href="#3-3-空值问题" class="headerlink" title="3.3 空值问题"></a>3.3 空值问题</h3><p>当子查询使用<code>NOT IN</code>进行不相等比较时，子查询结果中含有NULL，返回空集，所以下列sql语句没有任何输出。</p><p>使用<code>IN</code>时，不会出现上面的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT last_name<br>FROM employees<br>WHERE employee_id NOT IN (<br>SELECT manager_id<br>FROM employees<br>);<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211027195906773.png"></p><h2 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a>4. 相关子查询</h2><h3 id="4-1-相关子查询执行流程"><a href="#4-1-相关子查询执行流程" class="headerlink" title="4.1 相关子查询执行流程"></a>4.1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。<strong>相关子查询只能两层相连，不能跨层相连</strong></p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992898234.png" alt="" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992925281.png" alt="" style="zoom:80%;" /><p>说明：<strong>子查询中使用主查询中的列</strong></p><h3 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a>4.2 代码示例</h3><p><strong>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</strong></p><p><strong>方式一：相关子查询</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554992986225.png"></p><p><strong>方式二：在 FROM 中使用子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,salary,e1.department_id<br><span class="hljs-keyword">FROM</span> employees e1,(<span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) dept_avg_sal <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) e2<br><span class="hljs-keyword">WHERE</span> e1.`department_id` <span class="hljs-operator">=</span> e2.department_id<br><span class="hljs-keyword">AND</span> e2.dept_avg_sal <span class="hljs-operator">&lt;</span> e1.`salary`;<br></code></pre></td></tr></table></figure><blockquote><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名，<br>把它当成一张“临时的虚拟的表”来使用。</p></blockquote><p>在ORDER BY 中使用子查询：</p><p><strong>题目：查询员工的id,salary,按照department_name 排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,salary<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (<br>  <span class="hljs-keyword">SELECT</span> department_name<br>  <span class="hljs-keyword">FROM</span> departments d<br>  <span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br>);<br></code></pre></td></tr></table></figure><p><strong>题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">e</span>.employee_id, last_name,<span class="hljs-built_in">e</span>.job_id<br><span class="hljs-keyword">FROM</span>   employees <span class="hljs-built_in">e</span> <br><span class="hljs-keyword">WHERE</span>  <span class="hljs-number">2</span> &lt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*)<br>             <span class="hljs-keyword">FROM</span>   job_history <br>             <span class="hljs-keyword">WHERE</span>  employee_id = <span class="hljs-built_in">e</span>.employee_id);<br></code></pre></td></tr></table></figure><p><strong>在SELECT哪些位置可以使用子查询呢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#在<span class="hljs-keyword">SELECT</span>查询语句中，除了<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>和LIMIT之外，其他位置都可以声明子查询！<br><span class="hljs-keyword">SELECT</span> ..., ..., ...<br><span class="hljs-keyword">FROM</span> ... (<span class="hljs-keyword">LEFT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">RIGHT</span>) <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> 多表的连接条件<br>(<span class="hljs-keyword">LEFT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">RIGHT</span>) <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ...<br><span class="hljs-keyword">WHERE</span> 不包含聚合函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ...<span class="hljs-operator">/</span> ...(<span class="hljs-keyword">ASC</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">DESC</span>)<br>LIMIT ..., ...<br></code></pre></td></tr></table></figure><h3 id="4-3-EXISTS-与-NOT-EXISTS关键字"><a href="#4-3-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="4.3 EXISTS 与 NOT EXISTS关键字"></a>4.3 EXISTS 与 NOT EXISTS关键字</h3><ul><li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li><li><strong>如果在子查询中不存在满足条件的行：</strong><ul><li>条件返回 FALSE</li><li>继续在子查询中查找</li></ul></li><li><strong>如果在子查询中存在满足条件的行：</strong><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li><li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li></ul><p><strong>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><p>方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, job_id, department_id<br><span class="hljs-keyword">FROM</span>   employees e1<br><span class="hljs-keyword">WHERE</span>  <span class="hljs-keyword">EXISTS</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>                 <span class="hljs-keyword">FROM</span>   employees e2<br>                 <span class="hljs-keyword">WHERE</span>  e2.manager_id <span class="hljs-operator">=</span> <br>                        e1.employee_id);<br></code></pre></td></tr></table></figure><p>方式二：自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.job_id, e1.department_id<br><span class="hljs-keyword">FROM</span>   employees e1 <span class="hljs-keyword">JOIN</span> employees e2<br><span class="hljs-keyword">WHERE</span> e1.employee_id <span class="hljs-operator">=</span> e2.manager_id;<br></code></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,job_id,department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> (<br>     <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id<br>     <span class="hljs-keyword">FROM</span> employees<br>     <br>     );<br></code></pre></td></tr></table></figure><p><strong>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</strong></p><p>方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, department_name<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;X&#x27;</span><br>                  <span class="hljs-keyword">FROM</span>   employees<br>                  <span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> d.department_id);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554993169269.png"></p><p>方式二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.department_id, d.department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d <br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id<br><span class="hljs-keyword">WHERE</span> e.employee_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="4-4-相关更新"><a href="#4-4-相关更新" class="headerlink" title="4.4 相关更新"></a>4.4 相关更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE table1 alias1<br><span class="hljs-keyword">SET</span>    <span class="hljs-keyword">column</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> expression<br>                 <span class="hljs-keyword">FROM</span>   table2 alias2<br>                 <span class="hljs-keyword">WHERE</span>  alias1.column <span class="hljs-operator">=</span> alias2.column);<br></code></pre></td></tr></table></figure><p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p><p><strong>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1）<br>ALTER TABLE employees<br>ADD(department_name VARCHAR2(14));<br><br># 2）<br>UPDATE employees e<br>SET department_name =  (SELECT department_name <br>                       FROM   departments d<br>                       WHERE  e.department_id = d.department_id);<br><br></code></pre></td></tr></table></figure><h3 id="4-4-相关删除"><a href="#4-4-相关删除" class="headerlink" title="4.4 相关删除"></a>4.4 相关删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table1 alias1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> operator (<span class="hljs-keyword">SELECT</span> expression<br>                       <span class="hljs-keyword">FROM</span>   table2 alias2<br>                       <span class="hljs-keyword">WHERE</span>  alias1.column <span class="hljs-operator">=</span> alias2.column);<br></code></pre></td></tr></table></figure><p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p><p><strong>题目：删除表employees中，其与emp_history表皆有的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">in</span>  <br>           (<span class="hljs-keyword">SELECT</span> employee_id<br>            <span class="hljs-keyword">FROM</span>   emp_history <br>            <span class="hljs-keyword">WHERE</span>  employee_id <span class="hljs-operator">=</span> e.employee_id);<br></code></pre></td></tr></table></figure><h2 id="5-抛一个思考题"><a href="#5-抛一个思考题" class="headerlink" title="5. 抛一个思考题"></a>5. 抛一个思考题</h2><p><strong>问题：</strong>谁的工资比Abel的高？</p><p><strong>解答：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：自连接<br>SELECT e2.last_name,e2.salary<br>FROM employees e1,employees e2<br>WHERE e1.last_name = &#x27;Abel&#x27;<br>AND e1.`salary` &lt; e2.`salary`<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式2：子查询<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary &gt; (<br>SELECT salary<br>FROM employees<br>WHERE last_name = &#x27;Abel&#x27;<br>);<br></code></pre></td></tr></table></figure><p><strong>问题：</strong>以上两种方式有好坏之分吗？</p><p><strong>解答：</strong>自连接方式好！</p><p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p><p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p><h2 id="6-课后练习"><a href="#6-课后练习" class="headerlink" title="6.课后练习"></a>6.课后练习</h2><p>子查询的编写技巧，从外往里写或者从里往外写？</p><p>①如果子查询较简单，建议从外往里写；如果子查询较困难，建议从里往外写。</p><p>②如果是相关子查询，建议从外往里写。</p><p>1.<strong>查询和</strong>Zlotkey<strong>相同部门的员工姓名和工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> department_id<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Zlotkey&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>2.<strong>查询工资比公司平均工资高的员工的员工号，姓名和工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>    <span class="hljs-keyword">FROM</span> employees<br>)<br></code></pre></td></tr></table></figure><p>3.<strong>选择工资大于所有</strong>JOB_ID = ‘SA_MAN’<strong>的员工的工资的员工的</strong>last_name, job_id, salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,job_id,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span> (<br>            <span class="hljs-keyword">SELECT</span> salary<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SA_MAN&#x27;</span><br>            );<br></code></pre></td></tr></table></figure><p>4.<strong>查询和姓名中包含字母</strong>u<strong>的员工在相同部门的员工的员工号和姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%u%&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>5.<strong>查询在部门的</strong>location_id<strong>为</strong>1700<strong>的部门工作的员工的员工号</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> department_id<br>    <span class="hljs-keyword">FROM</span> departments<br>    <span class="hljs-keyword">WHERE</span> location_id <span class="hljs-operator">=</span> <span class="hljs-number">1700</span><br>)<br></code></pre></td></tr></table></figure><p>6.<strong>查询管理者是</strong>King<strong>的员工姓名和工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> manager_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> employee_id<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;King&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>7.<strong>查询工资最低的员工信息</strong>: last_name, salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>        <span class="hljs-keyword">FROM</span> employees<br>);<br></code></pre></td></tr></table></figure><p>8.<strong>查询平均工资最低的部门信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> departments<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(dept_avgsal)<br>                        <span class="hljs-keyword">FROM</span> (<br>                            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) dept_avgsal<br>                            <span class="hljs-keyword">FROM</span> employees<br>                            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                            ) avg_sal<br>                                )<br>                    );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式二:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> departments<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">ALL</span>(<br>                            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                            <span class="hljs-keyword">FROM</span> employees<br>                            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式三:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> departments<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>                    <span class="hljs-keyword">SELECT</span> department_id<br>                    <span class="hljs-keyword">FROM</span> employees<br>                    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                         <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                         <span class="hljs-keyword">FROM</span> employees<br>                         <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                         <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal<br>                         LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span> <br>                    )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式四:<br><span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> departments d,(<br>    <span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal<br>    LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) dept_avg_sal<br><span class="hljs-keyword">WHERE</span> d.department_id <span class="hljs-operator">=</span> dept_avg_sal.department_id<br></code></pre></td></tr></table></figure><p>9.<strong>查询平均工资最低的部门信息和该部门的平均工资(相关子查询)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一：<br><span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> d.department_id) avg_sal<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(dept_avgsal)<br>                        <span class="hljs-keyword">FROM</span> (<br>                            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) dept_avgsal<br>                            <span class="hljs-keyword">FROM</span> employees<br>                            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                            ) avg_sal<br>                ) <br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式二:<br><span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> d.`department_id`) avg_sal<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">ALL</span>(<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                        )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式三:<br><span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> d.department_id) avg_sal<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                 <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                 <span class="hljs-keyword">FROM</span> employees<br>                 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal<br>                 LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span> <br>            )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式四:<br><span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,dept_avg_sal.avg_sal <span class="hljs-keyword">FROM</span> departments d,(<br>    <span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal<br>    LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) dept_avg_sal<br><span class="hljs-keyword">WHERE</span> d.department_id <span class="hljs-operator">=</span> dept_avg_sal.department_id<br></code></pre></td></tr></table></figure><p>10.<strong>查询平均工资最高的</strong> job <strong>信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> jobs<br><span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">SELECT</span> job_id<br>        <span class="hljs-keyword">FROM</span> employees<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>        <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(avg_sal)<br>                    <span class="hljs-keyword">FROM</span>(<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>                        ) job_avgsal       <br>) <br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式二:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> jobs<br><span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">SELECT</span> job_id<br>        <span class="hljs-keyword">FROM</span> employees<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>        <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">ALL</span>(<br>            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>            )<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式三:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> jobs<br><span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">SELECT</span> job_id<br>        <span class="hljs-keyword">FROM</span> employees<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>        <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>            <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal <span class="hljs-keyword">DESC</span><br>            LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>            )<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式四: <br><span class="hljs-keyword">SELECT</span> j.<span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> jobs j,(<br>        <span class="hljs-keyword">SELECT</span> job_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br>        <span class="hljs-keyword">FROM</span> employees<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal <span class="hljs-keyword">DESC</span><br>        LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span> ) job_avg_sal<br><span class="hljs-keyword">WHERE</span> j.job_id <span class="hljs-operator">=</span> job_avg_sal.job_id<br></code></pre></td></tr></table></figure><p>11.<strong>查询平均工资高于公司平均工资的部门有哪些</strong>?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> (<br>              <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>              <span class="hljs-keyword">FROM</span> employees<br>            );<br></code></pre></td></tr></table></figure><p>12.<strong>查询出公司中所有</strong> manager <strong>的详细信息</strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>:<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,salary <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> (<br>              <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id<br>              <span class="hljs-keyword">FROM</span> employees<br>            );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">2</span>:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.salary <br><span class="hljs-keyword">FROM</span> employees e1 <span class="hljs-keyword">JOIN</span> employees e2<br><span class="hljs-keyword">WHERE</span> e1.employee_id <span class="hljs-operator">=</span> e2.manager_id;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">3</span>:<br><span class="hljs-keyword">SELECT</span> employee_id, last_name, salary <span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>                 <span class="hljs-keyword">FROM</span>   employees e2<br>                 <span class="hljs-keyword">WHERE</span>  e2.manager_id <span class="hljs-operator">=</span> e1.employee_id);<br></code></pre></td></tr></table></figure><p>13.<strong>各个部门中 最高工资中最低的那个部门的 最低工资是多少</strong>?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(max_sal)<br>                        <span class="hljs-keyword">FROM</span> (<br>                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) max_sal<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) dept_max_sal<br>                        )<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">2</span>:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">ALL</span>(<br>                <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) max_sal<br>                <span class="hljs-keyword">FROM</span> employees<br>                <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                )<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">3</span>:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>            <span class="hljs-keyword">SELECT</span> department_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-operator">=</span> (<br>                <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) max_sal<br>                <span class="hljs-keyword">FROM</span> employees<br>                <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> max_sal<br>                LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span> <br>            )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">4</span>:<br><span class="hljs-keyword">SELECT</span> employee_id,<span class="hljs-built_in">MIN</span>(salary) <br><span class="hljs-keyword">FROM</span> employees e,<br>                (<span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">MAX</span>(salary) max_sal<br>                <span class="hljs-keyword">FROM</span> employees<br>                <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> max_sal<br>                LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) dept_max_sal<br><span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> dept_max_sal.department_id<br></code></pre></td></tr></table></figure><p>14.<strong>查询平均工资最高的部门的</strong> manager <strong>的详细信息</strong>: last_name,department_id, email, salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一:<br><span class="hljs-keyword">SELECT</span> employee_id,last_name, department_id, email, salary <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> (<br>            <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id<br>            <span class="hljs-keyword">FROM</span> employees<br>            <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> department_id<br>                        <span class="hljs-keyword">FROM</span> employees<br>                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                        <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>                                    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(avg_sal)<br>                                    <span class="hljs-keyword">FROM</span>(<br>                                        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                                        <span class="hljs-keyword">FROM</span> employees<br>                                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                                        ) dept_sal<br>                            )<br>                )<br>    );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式二:<br><span class="hljs-keyword">SELECT</span> employee_id,last_name, department_id, email, salary <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> (<br>                    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id<br>                    <span class="hljs-keyword">FROM</span> employees<br>                    <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<br>                        <span class="hljs-keyword">SELECT</span> department_id<br>                        <span class="hljs-keyword">FROM</span> employees e<br>                        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                        <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary)<span class="hljs-operator">&gt;=</span><span class="hljs-keyword">ALL</span>(<br>                                            <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>                                            <span class="hljs-keyword">FROM</span> employees<br>                                            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                        )<br>                    )                        <br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式三:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> (<br>            <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id<br>            <span class="hljs-keyword">FROM</span> employees e,(<br>                    <span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br>                    <span class="hljs-keyword">FROM</span> employees<br>                    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>                    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg_sal <span class="hljs-keyword">DESC</span><br>                    LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) dept_avg_sal<br>            <span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> dept_avg_sal.department_id<br>            )<br></code></pre></td></tr></table></figure><p>15.<strong>查询部门的部门号，其中不包括</strong>job_id<strong>是</strong>“ST_CLERK”<strong>的部门号</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方法一:<br><span class="hljs-keyword">SELECT</span> department_id<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id<br>        <span class="hljs-keyword">FROM</span> employees<br>        <span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ST_CLERK&#x27;</span><br>        );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方法二:<br><span class="hljs-keyword">SELECT</span> department_id <span class="hljs-keyword">FROM</span> departments d <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>        <span class="hljs-keyword">FROM</span> employees e<br>        <span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-operator">=</span> e.`department_id`<br>        <span class="hljs-keyword">AND</span> job_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ST_CLERK&#x27;</span><br>        );<br></code></pre></td></tr></table></figure><p>16.<strong>选择所有没有管理者的员工的</strong>last_name</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>        <span class="hljs-keyword">FROM</span> employees e2<br>        <span class="hljs-keyword">WHERE</span> e1.manager_id <span class="hljs-operator">=</span> e2.employee_id<br>        );<br></code></pre></td></tr></table></figure><p>17**.查询员工号、姓名、雇用时间、工资，其中员工的管理者为** ‘De Haan’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>:<br><span class="hljs-keyword">SELECT</span> employee_id, last_name, hire_date, salary <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> manager_id <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> employee_id<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;De Haan&#x27;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">2</span>:<br><span class="hljs-keyword">SELECT</span> employee_id, last_name, hire_date, salary <span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>        <span class="hljs-keyword">FROM</span> employees e2<br>        <span class="hljs-keyword">WHERE</span> e2.`employee_id` <span class="hljs-operator">=</span> e1.manager_id<br>        <span class="hljs-keyword">AND</span> e2.last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;De Haan&#x27;</span><br>        );<br></code></pre></td></tr></table></figure><p>18.<strong>查询各部门中工资比本部门平均工资高的员工的员工号</strong>, <strong>姓名和工资</strong>(<strong>难</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一:相关子查询<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,salary <span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<br>                # 查询某员工所在部门的平均<br>                <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>                <span class="hljs-keyword">FROM</span> employees e2<br>                <span class="hljs-keyword">WHERE</span> e2.department_id <span class="hljs-operator">=</span> e1.`department_id` <br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式二:<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,salary<br><span class="hljs-keyword">FROM</span> employees e1,<br>(<span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br><span class="hljs-keyword">FROM</span> employees e2 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>) dept_avg_sal<br><span class="hljs-keyword">WHERE</span> e1.`department_id` <span class="hljs-operator">=</span> dept_avg_sal.department_id <span class="hljs-keyword">AND</span> e1.`salary` <span class="hljs-operator">&gt;</span> dept_avg_sal.avg_sal;<br></code></pre></td></tr></table></figure><p>19.<strong>查询每个部门下的部门人数大于</strong> 5 <strong>的部门名称</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_name,department_id<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> <span class="hljs-number">5</span> <span class="hljs-operator">&lt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-keyword">FROM</span> employees e<br>    <span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-operator">=</span> e.`department_id`<br>    );<br></code></pre></td></tr></table></figure><p>20.<strong>查询每个国家下的部门个数大于</strong> 2 <strong>的国家编号</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> country_id<br><span class="hljs-keyword">FROM</span> locations l<br><span class="hljs-keyword">WHERE</span> <span class="hljs-number">2</span> <span class="hljs-operator">&lt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-keyword">FROM</span> departments d<br>    <span class="hljs-keyword">WHERE</span> l.`location_id` <span class="hljs-operator">=</span> d.`location_id`<br>    );<br></code></pre></td></tr></table></figure><h1 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章_创建和管理表"></a>第10章_创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-一条数据存储的过程"><a href="#1-1-一条数据存储的过程" class="headerlink" title="1.1 一条数据存储的过程"></a>1.1 一条数据存储的过程</h3><p><code>存储数据是处理数据的第一步</code>。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p><p>那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211007155810920.png"></p><p>我们要先创建一个数据库，而不是直接创建数据表呢？ </p><p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是<code>数据库服务器</code>、<code>数据库</code>、<code>数据表</code>、数据表的<code>行与列</code>。 </p><p>MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p><h3 id="1-2-标识符命名规则"><a href="#1-2-标识符命名规则" class="headerlink" title="1.2 标识符命名规则"></a>1.2 标识符命名规则</h3><ul><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h3 id="1-3-MySQL中的数据类型"><a href="#1-3-MySQL中的数据类型" class="headerlink" title="1.3 MySQL中的数据类型"></a>1.3 MySQL中的数据类型</h3><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、**INT(或INTEGER)**、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE   不靠谱</td></tr><tr><td>定点数类型</td><td>**DECIMAL ** 更准确</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、<strong>DATE</strong>、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>其中，常用的几类类型介绍如下：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>INT</td><td>从-2^31到2^31-1的整型数据。存储大小为 4个字节</td></tr><tr><td>CHAR(size)</td><td>定长字符数据。若未指定，默认为1个字符，最大长度255</td></tr><tr><td>VARCHAR(size)</td><td>可变长字符数据，根据字符串实际长度保存，<strong>必须指定长度</strong></td></tr><tr><td>FLOAT(M,D)</td><td>单精度，占用4个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</td></tr><tr><td>DOUBLE(M,D)</td><td>双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</td></tr><tr><td>DECIMAL(M,D)</td><td>高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</td></tr><tr><td>DATE</td><td>日期型数据，格式’YYYY-MM-DD’</td></tr><tr><td>BLOB</td><td>二进制形式的长文本数据，最大可达4G</td></tr><tr><td>TEXT</td><td>长文本数据，最大可达4G</td></tr></tbody></table><h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a>2.1 创建数据库</h3><ul><li>方式1：创建数据库(新数据库使用默认的字符集和比较规则)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名; <br></code></pre></td></tr></table></figure><ul><li>方式2：创建数据库并指定字符集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名 CHARACTER SET 字符集;<br></code></pre></td></tr></table></figure><ul><li>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS 数据库名; <br></code></pre></td></tr></table></figure><p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p></blockquote><h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2.2 使用数据库"></a>2.2 使用数据库</h3><ul><li>查看当前所有的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASES; #有一个S，代表多个数据库<br></code></pre></td></tr></table></figure><ul><li>查看当前正在使用的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATABASE();  #使用的一个 mysql 中的全局函数<br></code></pre></td></tr></table></figure><ul><li>查看指定库下所有的表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES FROM 数据库名; / SHOW TABLES #默认查询当前数据库<br></code></pre></td></tr></table></figure><ul><li>查看数据库的创建信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE DATABASE 数据库名;<br>或者：<br>SHOW CREATE DATABASE 数据库名\G<br></code></pre></td></tr></table></figure><ul><li>使用/切换数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE 数据库名;<br></code></pre></td></tr></table></figure><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p></blockquote><h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2.3 修改数据库"></a>2.3 修改数据库</h3><ul><li>更改数据库字符集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等<br></code></pre></td></tr></table></figure><h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2.4 删除数据库"></a>2.4 删除数据库</h3><ul><li>方式1：删除指定的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE 数据库名;<br></code></pre></td></tr></table></figure><ul><li>方式2：删除指定的数据库（<code>推荐</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE IF EXISTS 数据库名;<br></code></pre></td></tr></table></figure><h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="3-1-创建方式1"><a href="#3-1-创建方式1" class="headerlink" title="3.1 创建方式1"></a>3.1 创建方式1</h3><ul><li><strong>必须具备：</strong><ul><li>CREATE TABLE权限</li><li>存储空间</li></ul></li><li><strong>语法格式：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名(<br>字段1, 数据类型 [约束条件] [默认值],<br>字段2, 数据类型 [约束条件] [默认值],<br>字段3, 数据类型 [约束条件] [默认值],<br>……<br>[表约束条件]<br>);<br></code></pre></td></tr></table></figure><blockquote><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><ul><li><strong>必须指定：</strong><ul><li>表名</li><li>列名(或字段名)，数据类型，<strong>长度</strong></li></ul></li><li><strong>可选指定：</strong><ul><li>约束条件</li><li>默认值</li></ul></li><li>创建表举例1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建表<br>CREATE TABLE emp (<br>  -- int类型<br>  emp_id INT,<br>  -- 最多保存20个中英文字符<br>  emp_name VARCHAR(20),<br>  -- 总位数不超过15位<br>  salary DOUBLE,<br>  -- 日期类型<br>  birthday DATE<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC emp;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211016160557995.png"></p><p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</p><ul><li>创建表举例2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept(<br>    -- int类型，自增<br>deptno INT(2) AUTO_INCREMENT,<br>dname VARCHAR(14),<br>loc VARCHAR(13),<br>    -- 主键<br>    PRIMARY KEY (deptno)<br>) CHARACTER SET &#x27;utf8&#x27;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESCRIBE dept;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211016160643445.png"></p><blockquote><p>在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p></blockquote><h3 id="3-2-创建方式2"><a href="#3-2-创建方式2" class="headerlink" title="3.2 创建方式2"></a>3.2 创建方式2</h3><ul><li><p>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554997882872.png"></p></li><li><p>指定的列和子查询中的列要一一对应</p></li><li><p>通过列名和默认值定义列</p></li><li><p><strong>主要是复制数据，原表中除了非空约束，其他约束不会复制到新表中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE emp1 AS SELECT * FROM employees;<br><br>CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept80<br>AS <br>SELECT  employee_id, last_name, salary*12 ANNSAL, hire_date<br>FROM    employees<br>WHERE   department_id = 80;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESCRIBE dept80;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554997998148.png"></p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554998004494.png"></p><h3 id="3-3-查看数据表结构"><a href="#3-3-查看数据表结构" class="headerlink" title="3.3 查看数据表结构"></a>3.3 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC</code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE 表名\G<br></code></pre></td></tr></table></figure><p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p><h3 id="3-4-查看数据表属性"><a href="#3-4-查看数据表属性" class="headerlink" title="3.4 查看数据表属性"></a>3.4 查看数据表属性</h3><p>语法格式如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;表名&#x27;</span>;   #以表格形式显示<br>或者<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;表名&#x27;</span>\G  #以行形式显示<br></code></pre></td></tr></table></figure><h3 id="3-5-修改表的字符集"><a href="#3-5-修改表的字符集" class="headerlink" title="3.5 修改表的字符集"></a>3.5 修改表的字符集</h3><p>语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_emp <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;utf8&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p><p><strong>使用 ALTER TABLE 语句可以实现：</strong></p><ul><li><p>向已有的表中添加列</p></li><li><p>修改现有表中的列</p></li><li><p>删除现有表中的列</p></li><li><p>重命名现有表中的列</p></li></ul><h3 id="4-1-追加一个列"><a href="#4-1-追加一个列" class="headerlink" title="4.1 追加一个列"></a>4.1 追加一个列</h3><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】; #默认加在最后一列，FIRST加在第一列<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE dept80 <br>ADD job_id varchar(15);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1554998139815.png"></p><h3 id="4-2-修改一个列"><a href="#4-2-修改一个列" class="headerlink" title="4.2 修改一个列"></a>4.2 修改一个列</h3><ul><li><p>可以修改列的数据类型，长度、默认值和位置</p></li><li><p>修改字段数据类型、长度、默认值、位置的语法格式如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 MODIFY 【COLUMN】 字a段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;<br></code></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLEdept80<br>MODIFY last_name VARCHAR(30);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLEdept80<br>MODIFY salary double(9,2) default 1000;<br></code></pre></td></tr></table></figure><ul><li>对默认值的修改只影响今后对表的修改</li><li>此外，还可以通过此种方式修改列的约束。这里暂先不讲。</li></ul><h3 id="4-3-重命名一个列"><a href="#4-3-重命名一个列" class="headerlink" title="4.3 重命名一个列"></a>4.3 重命名一个列</h3><p>使用 CHANGE old_column  new_column  dataType子句重命名列。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; #可以再改名的同时修改列的数据类型<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE  dept80<br>CHANGE department_name dept_name varchar(15); <br></code></pre></td></tr></table></figure><h3 id="4-4-删除一个列"><a href="#4-4-删除一个列" class="headerlink" title="4.4 删除一个列"></a>4.4 删除一个列</h3><p>删除表中某个字段的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP 【COLUMN】字段名<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE  dept80<br>DROP COLUMN  jfrob_id; <br></code></pre></td></tr></table></figure><h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><ul><li>方式一：推荐使用RENAME</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RENAME TABLE emp<br>TO myemp;<br></code></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER table dept<br>RENAME [TO] detail_dept;  -- [TO]可以省略<br></code></pre></td></tr></table></figure><ul><li>必须是对象的拥有者</li></ul><h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><ul><li><p>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</p></li><li><p>数据和结构都被删除</p></li><li><p>所有正在运行的相关事务被提交</p></li><li><p>所有相关索引被删除</p></li><li><p>语法格式：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];<br></code></pre></td></tr></table></figure><p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE dept80;<br></code></pre></td></tr></table></figure><ul><li>DROP TABLE 语句不能回滚</li></ul><h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><ul><li><p>TRUNCATE TABLE语句：</p><ul><li>删除表中所有的数据</li><li>释放表的存储空间</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TRUNCATE TABLE detail_dept;<br></code></pre></td></tr></table></figure><ul><li>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚（在修改autocommit = FALSE操作的情况下）</li><li>COMMIT：提交数据。一旦执行COMMIT，则该数据就被永久的保存在了数据库中，意味着该数据不可以被回滚（不能覆盖该数据）。</li><li>ROLLBACK：一旦执行ROLLBACK，则可以实现数据的回滚（但不一定成功）。回滚到最近一次的COMMIT之后。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit = FALSE;<br>  <br>DELETE FROM emp2; <br>#TRUNCATE TABLE emp2; #数据被删除，且不能回滚<br>  <br>SELECT * FROM emp2; #数据被删除<br>  <br>ROLLBACK;<br>  <br>SELECT * FROM emp2; #数据仍然存在<br></code></pre></td></tr></table></figure><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER（触发器），有可能造成事故，故不建议在开发代码中使用此语句。 </p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><p><strong>DDL 和 DML 的说明</strong></p><p>① DDL的操作一旦执行，就不可以回滚。指令SET autocommit = FALSE对DDL操作失效。（因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit = FALSE的影响。</p><p>② DML的操作默认情况下，一旦执行，也是不可以回滚的。但是，如果在执行DML之前，执行了SET autocommit = FASLE， 则执行的DML操作就可以实现回滚。</p><h2 id="8-内容拓展"><a href="#8-内容拓展" class="headerlink" title="8. 内容拓展"></a>8. 内容拓展</h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h3><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name </li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。 </p><ul><li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。 </p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 </p><ul><li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211024012735469.png"></p></li></ul><h3 id="拓展2：如何理解清空表、删除表等操作需谨慎？！"><a href="#拓展2：如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="拓展2：如何理解清空表、删除表等操作需谨慎？！"></a>拓展2：如何理解清空表、删除表等操作需谨慎？！</h3><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="拓展3：MySQL8新特性—DDL的原子化"><a href="#拓展3：MySQL8新特性—DDL的原子化" class="headerlink" title="拓展3：MySQL8新特性—DDL的原子化"></a>拓展3：MySQL8新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE mytest;<br><br>USE mytest;<br><br>CREATE TABLE book1(<br>book_id INT ,<br>book_name VARCHAR(255)<br>);<br><br>SHOW TABLES;<br></code></pre></td></tr></table></figure><p>（1）在MySQL 5.7版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP TABLE book1,book2;<br>ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;<br></code></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES;<br>Empty set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p><p>（2）在MySQL 8.0版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP TABLE book1,book2;<br>ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;<br></code></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show tables;<br>+------------------+<br>| Tables_in_mytest |<br>+------------------+<br>| book1            |<br>+------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果可以看出，数据表book1并没有被删除。</p><h1 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章_数据处理之增删改"></a>第11章_数据处理之增删改</h1><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-实际问题-1"><a href="#1-1-实际问题-1" class="headerlink" title="1.1 实际问题"></a>1.1 实际问题</h3><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555425366064.png" alt="" style="zoom:80%;" /><p>解决方式：使用 INSERT 语句向表中插入数据。</p><h3 id="1-2-方式1：VALUES的方式添加"><a href="#1-2-方式1：VALUES的方式添加" class="headerlink" title="1.2 方式1：VALUES的方式添加"></a>1.2 方式1：VALUES的方式添加</h3><p>使用这种语法一次只能向表中插入<strong>一条</strong>数据。</p><p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名<br><span class="hljs-keyword">VALUES</span> (value1,value2,....);<br></code></pre></td></tr></table></figure><p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO departments<br>VALUES (70, &#x27;Pub&#x27;, 100, 1700);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTOdepartments<br>VALUES(100, &#x27;Finance&#x27;, NULL, NULL);<br></code></pre></td></tr></table></figure><p><strong>情况2：为表的指定字段插入数据</strong>（推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名(column1 [, column2, …, columnn]) <br>VALUES (value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO departments(department_id, department_name)<br>VALUES (80, &#x27;IT&#x27;);<br></code></pre></td></tr></table></figure><p> <strong>情况3：同时插入多条记录</strong></p><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO table_name <br>VALUES <br>(value1 [,value2, …, valuen]),<br>(value1 [,value2, …, valuen]),<br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO table_name(column1 [, column2, …, columnn]) <br>VALUES <br>(value1 [,value2, …, valuen]),<br>(value1 [,value2, …, valuen]),<br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO emp(emp_id,emp_name)<br>    -&gt; VALUES (1001,&#x27;shkstart&#x27;),<br>    -&gt; (1002,&#x27;atguigu&#x27;),<br>    -&gt; (1003,&#x27;Tom&#x27;);<br>Query OK, 3 rows affected (0.00 sec)<br>Records: 3  Duplicates: 0  Warnings: 0<br></code></pre></td></tr></table></figure><p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：<br>●　Records：表明插入的记录条数。<br>●　Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。<br>●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p><blockquote><p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p></blockquote><p><strong>小结：</strong></p><ul><li><code>VALUES</code>也可以写成<code>VALUE</code>，但是VALUES是标准写法。</li></ul><ul><li>字符和日期型数据应包含在单引号中。</li></ul><h3 id="1-3-方式2：将查询结果插入到表中"><a href="#1-3-方式2：将查询结果插入到表中" class="headerlink" title="1.3 方式2：将查询结果插入到表中"></a>1.3 方式2：将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p><p>基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 目标表名<br>(tar_column1 [, tar_column2, …, tar_columnn])<br>SELECT<br>(src_column1 [, src_column2, …, src_columnn])<br>FROM 源表名<br>[WHERE condition]<br></code></pre></td></tr></table></figure><ul><li>在 INSERT 语句中加入子查询。 </li><li><strong>不必书写</strong> <strong>VALUES</strong> <strong>子句。</strong> </li><li>子查询中的值列表应与 INSERT 子句中的列名对应。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp2 <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sales_reps(id, name, salary, commission_pct)<br><span class="hljs-keyword">SELECT</span> employee_id, last_name, salary, commission_pct<br><span class="hljs-keyword">FROM</span>   employees<br><span class="hljs-keyword">WHERE</span>  job_id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%REP%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，目标表中要添加数据的字段的长度不能低于来源表中查询的字段的长度。如果目标表中要添加数据的字段的长度低于来源表中查询的字段的长度的话，就会有添加不成功的风险。</strong></p><h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555425824246.png"></p><ul><li>使用 UPDATE 语句更新数据。语法如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE table_name<br><span class="hljs-keyword">SET</span> column1<span class="hljs-operator">=</span>value1, column2<span class="hljs-operator">=</span>value2, … , <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>valuen<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><ul><li><p>可以一次更新<strong>多条</strong>数据。</p></li><li><p>如果需要回滚数据，需要保证在DML前，进行设置：<strong>SET AUTOCOMMIT = FALSE;</strong></p></li></ul><hr><ul><li>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE employees<br><span class="hljs-keyword">SET</span>    department_id <span class="hljs-operator">=</span> <span class="hljs-number">70</span><br><span class="hljs-keyword">WHERE</span>  employee_id <span class="hljs-operator">=</span> <span class="hljs-number">113</span>;<br></code></pre></td></tr></table></figure><ul><li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE copy_emp<br><span class="hljs-keyword">SET</span>    department_id <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>更新中的数据完整性错误</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE employees<br><span class="hljs-keyword">SET</span>    department_id <span class="hljs-operator">=</span> <span class="hljs-number">55</span><br><span class="hljs-keyword">WHERE</span>  department_id <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555426069578.png"></p><blockquote><p>说明：不存在 55 号部门</p></blockquote><p><strong>修改数据时，时可能存在不成功的情况的。（可能是由于约束的影响造成的）。</strong></p><h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555426124751.png"></p><ul><li>使用 DELETE 语句从表中删除数据</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555426162264.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name [WHERE &lt;condition&gt;];<br></code></pre></td></tr></table></figure><p>table_name指定要执行删除操作的表；“[WHERE <condition>]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p><ul><li>使用 WHERE 子句删除指定的记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> departments<br><span class="hljs-keyword">WHERE</span>  department_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Finance&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>如果省略 WHERE 子句，则表中的全部数据将被删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span>  copy_emp;<br></code></pre></td></tr></table></figure><ul><li><strong>删除中的数据完整性错误</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> departments<br><span class="hljs-keyword">WHERE</span>       department_id <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555426258516.png"></p><blockquote><p>说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table.</p></blockquote><p><strong>需要注意的是，插入、更新、删除操作，都需要满足现有约束，否则执行不成功。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#特殊用法：将userid为Bbiri的<span class="hljs-keyword">user</span>表和my_employees表的记录全部删除 <br><span class="hljs-keyword">DELETE</span> u,e<br><span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">JOIN</span> my_employees e <span class="hljs-keyword">ON</span> u.`userid`<span class="hljs-operator">=</span>e.`Userid`<br><span class="hljs-keyword">WHERE</span> u.`userid`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Bbiri&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="4-MySQL8新特性：计算列"><a href="#4-MySQL8新特性：计算列" class="headerlink" title="4. MySQL8新特性：计算列"></a>4. MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p><p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。<br>首先创建测试表tb1，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb1(<br>id <span class="hljs-type">INT</span>,<br>a <span class="hljs-type">INT</span>,<br>b <span class="hljs-type">INT</span>,<br>c <span class="hljs-type">INT</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> (a <span class="hljs-operator">+</span> b) VIRTUAL<br>);<br><br>或者<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> test1 <br><span class="hljs-keyword">ADD</span> c <span class="hljs-type">INT</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> (a <span class="hljs-operator">+</span> b) VIRTUAL;<br></code></pre></td></tr></table></figure><p>插入演示数据，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO tb1(a,b) VALUES (100,200);<br></code></pre></td></tr></table></figure><p>查询数据表tb1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM tb1;<br>+------+------+------+------+<br>| id   | a    | b    | c    |<br>+------+------+------+------+<br>| NULL |  100 |  200 |  300 |<br>+------+------+------+------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>更新数据中的数据，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE tb1 SET a = 500;<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0<br></code></pre></td></tr></table></figure><h2 id="5-综合案例"><a href="#5-综合案例" class="headerlink" title="5. 综合案例"></a>5. 综合案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、创建数据库test01_library<br><br># 2、创建表 books，表结构如下：<br></code></pre></td></tr></table></figure><table><thead><tr><th>字段名</th><th>字段说明</th><th>数据类型</th></tr></thead><tbody><tr><td>id</td><td>书编号</td><td>INT</td></tr><tr><td>name</td><td>书名</td><td>VARCHAR(50)</td></tr><tr><td>authors</td><td>作者</td><td>VARCHAR(100)</td></tr><tr><td>price</td><td>价格</td><td>FLOAT</td></tr><tr><td>pubdate</td><td>出版日期</td><td>YEAR</td></tr><tr><td>note</td><td>说明</td><td>VARCHAR(100)</td></tr><tr><td>num</td><td>库存</td><td>INT</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 3、向books表中插入记录<br><br># 1）不指定字段名称，插入第一条记录<br># 2）指定所有字段名称，插入第二记录<br># 3）同时插入多条记录（剩下的所有记录）<br></code></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>authors</th><th>price</th><th>pubdate</th><th>note</th><th>num</th></tr></thead><tbody><tr><td>1</td><td>Tal of AAA</td><td>Dickes</td><td>23</td><td>1995</td><td>novel</td><td>11</td></tr><tr><td>2</td><td>EmmaT</td><td>Jane lura</td><td>35</td><td>1993</td><td>joke</td><td>22</td></tr><tr><td>3</td><td>Story of Jane</td><td>Jane Tim</td><td>40</td><td>2001</td><td>novel</td><td>0</td></tr><tr><td>4</td><td>Lovey Day</td><td>George Byron</td><td>20</td><td>2005</td><td>novel</td><td>30</td></tr><tr><td>5</td><td>Old land</td><td>Honore Blade</td><td>30</td><td>2010</td><td>law</td><td>0</td></tr><tr><td>6</td><td>The Battle</td><td>Upton Sara</td><td>30</td><td>1999</td><td>medicine</td><td>40</td></tr><tr><td>7</td><td>Rose Hood</td><td>Richard haggard</td><td>28</td><td>2008</td><td>cartoon</td><td>28</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 4、将小说类型(novel)的书的价格都增加5。<br><br># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。<br><br># 6、删除库存为0的记录。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 7、统计书名中包含a字母的书<br><br># 8、统计书名中包含a字母的书的数量和库存总量<br><br># 9、找出“novel”类型的书，按照价格降序排列<br><br># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列<br><br># 11、按照note分类统计书的数量<br><br># 12、按照note分类统计书的库存量，显示库存量超过30本的<br><br># 13、查询所有图书，每页显示5本，显示第二页<br><br># 14、按照note分类统计书的库存量，显示库存量最多的<br><br># 15、查询书名达到10个字符的书，不包括里面的空格<br><br># 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话<br><br># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货<br><br># 18、统计每一种note的库存量，并合计总量<br><br># 19、统计每一种note的数量，并合计总量<br><br># 20、统计库存量前三名的图书<br><br># 21、找出最早出版的一本书<br><br># 22、找出novel中价格最高的一本书<br><br># 23、找出书名中字数最多的一本书，不含空格<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1、创建数据库test01_library<br>CREATE DATABASE IF NOT EXISTS test01_library CHARACTER SET &#x27;utf8&#x27;;<br><br>#指定使用哪个数据库<br>USE test01_library;<br><br>#2、创建表 books<br>CREATE TABLE books(<br>id INT,<br>name VARCHAR(50),<br>`authors` VARCHAR(100) ,<br>price FLOAT,<br>pubdate YEAR ,<br>note VARCHAR(100),<br>num INT<br>);<br><br>#3、向books表中插入记录<br># 1）不指定字段名称，插入第一条记录<br>INSERT INTO books <br>VALUES(1,&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11);<br># 2）指定所有字段名称，插入第二记录<br>INSERT INTO books (id,name,`authors`,price,pubdate,note,num)<br>VALUES(2,&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;Joke&#x27;,22);<br># 3）同时插入多条记录（剩下的所有记录）<br>INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES<br>(3,&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0),<br>(4,&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30),<br>(5,&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;Law&#x27;,0),<br>(6,&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40),<br>(7,&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28);<br><br># 4、将小说类型(novel)的书的价格都增加5。<br>UPDATE books SET price=price+5 WHERE note = &#x27;novel&#x27;;<br><br># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。<br>UPDATE books SET price=40,note=&#x27;drama&#x27; WHERE name=&#x27;EmmaT&#x27;;<br><br># 6、删除库存为0的记录。<br>DELETE FROM books WHERE num=0;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 7、统计书名中包含a字母的书<br>SELECT * FROM books WHERE name LIKE &#x27;%a%&#x27;;<br><br># 8、统计书名中包含a字母的书的数量和库存总量<br>SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE &#x27;%a%&#x27;;<br><br># 9、找出“novel”类型的书，按照价格降序排列<br>SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC;<br><br># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列<br>SELECT * FROM books ORDER BY num DESC,note ASC;<br><br># 11、按照note分类统计书的数量<br>SELECT note,COUNT(*) FROM books GROUP BY note;<br><br># 12、按照note分类统计书的库存量，显示库存量超过30本的<br>SELECT note,SUM(num) FROM books GROUP BY note HAVING SUM(num)&gt;30;<br><br># 13、查询所有图书，每页显示5本，显示第二页<br>SELECT * FROM books LIMIT 5,5;<br><br># 14、按照note分类统计书的库存量，显示库存量最多的<br>SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;<br><br># 15、查询书名达到10个字符的书，不包括里面的空格<br>SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;))&gt;=10;<br><br>/*<br>16、查询书名和类型，<br> 其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话<br>*/<br>SELECT name AS &quot;书名&quot; ,note, CASE note <br> WHEN &#x27;novel&#x27; THEN &#x27;小说&#x27;<br> WHEN &#x27;law&#x27; THEN &#x27;法律&#x27;<br> WHEN &#x27;medicine&#x27; THEN &#x27;医药&#x27;<br> WHEN &#x27;cartoon&#x27; THEN &#x27;卡通&#x27;<br> WHEN &#x27;joke&#x27; THEN &#x27;笑话&#x27;<br> END AS &quot;类型&quot;<br>FROM books;<br><br><br># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货<br>SELECT name,num,CASE <br>  WHEN num&gt;30 THEN &#x27;滞销&#x27;<br>  WHEN num&gt;0 AND num&lt;10 THEN &#x27;畅销&#x27;<br>  WHEN num=0 THEN &#x27;无货&#x27;<br>  ELSE &#x27;正常&#x27;<br>  END AS &quot;库存状态&quot;<br>FROM books;<br><br># 18、统计每一种note的库存量，并合计总量<br>SELECT IFNULL(note,&#x27;合计总库存量&#x27;) AS note,SUM(num) FROM books GROUP BY note WITH ROLLUP;<br><br># 19、统计每一种note的数量，并合计总量<br>SELECT IFNULL(note,&#x27;合计总数&#x27;) AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;<br><br># 20、统计库存量前三名的图书<br>SELECT * FROM books ORDER BY num DESC LIMIT 0,3;<br><br># 21、找出最早出版的一本书<br>SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;<br><br># 22、找出novel中价格最高的一本书<br>SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC LIMIT 0,1;<br><br># 23、找出书名中字数最多的一本书，不含空格<br>SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;)) DESC LIMIT 0,1;<br></code></pre></td></tr></table></figure><h1 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章_MySQL数据类型精讲"></a>第12章_MySQL数据类型精讲</h1><h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性，如下：</p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建数据库时指明字符集<br><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> dbtest12 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;utf8&#x27;</span><br><br>#创建表时，指明表的字符集<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table1(<br>id <span class="hljs-type">INT</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;utf8&#x27;</span>;<br><br>#创建表时，指名表中字段的字符集<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table2(<br>id <span class="hljs-type">INT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;utf8&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h2><h3 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a>2.1 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><p>它们的区别如下表所示：</p><table><thead><tr><th><strong>整数类型</strong></th><th><strong>字节</strong></th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h3><p><strong>整数类型的可选属性有三个：</strong></p><h4 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a>2.2.1 M</h4><p><code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“0”填满宽度，否则指定显示宽度无效。当数据宽度大于5位时，显示原数据。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p><p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_int1 ( x TINYINT,　y SMALLINT,　z MEDIUMINT,　m INT,　n BIGINT );<br></code></pre></td></tr></table></figure><p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc test_int1;<br>+-------+--------------+------+-----+---------+-------+<br>| Field | Type         | Null | Key | Default | Extra |<br>+-------+--------------+------+-----+---------+-------+<br>|   x   | tinyint(4)   | YES  |     | NULL    |       |<br>| 　y   | smallint(6)  | YES  |     | NULL    |       |<br>| 　z   | mediumint(9) | YES  |     | NULL    |       |<br>| 　m   | int(11)      | YES  |     | NULL    |       |<br>| 　n   | bigint(20)   | YES  |     | NULL    |       |<br>+-------+--------------+------+-----+---------+-------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>TINYINT有符号数和无符号数的取值范围分别为-128<del>127和0</del>255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_int2(<br>f1 INT,<br>f2 INT(5),<br>f3 INT(5) ZEROFILL<br>)<br><br>DESC test_int2;<br><br>INSERT INTO test_int2(f1,f2,f3)<br>VALUES(1,123,123);<br><br>INSERT INTO test_int2(f1,f2)<br>VALUES(123456,123456);<br><br>INSERT INTO test_int2(f1,f2,f3)<br>VALUES(123456,123456,123456);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_int2;<br>+--------+--------+--------+<br>| f1     | f2     | f3     |<br>+--------+--------+--------+<br>|      1 |    123 |  00123 |<br>| 123456 | 123456 |   NULL |<br>| 123456 | 123456 | 123456 |<br>+--------+--------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a>2.2.2 UNSIGNED</h4><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_int3(<br>f1 INT UNSIGNED<br>);<br><br>mysql&gt; desc test_int3;<br>+-------+------------------+------+-----+---------+-------+<br>| Field | Type             | Null | Key | Default | Extra |<br>+-------+------------------+------+-----+---------+-------+<br>| f1    | int(10) unsigned | YES  |     | NULL    |       |<br>+-------+------------------+------+-----+---------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a>2.2.3 ZEROFILL</h4><p><code>ZEROFILL</code>: 0填充,（<strong>如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性</strong>），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。</strong>如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p><h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h3><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p><p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h3 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a>2.4 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。 </p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 </p><p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h2><h3 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a>3.1 类型介绍</h3><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li>FLOAT 表示单精度浮点数；</li><li>DOUBLE 表示双精度浮点数；</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211007173312237.png"></p><ul><li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET sql_mode = “REAL_AS_FLOAT”;<br></code></pre></td></tr></table></figure></li></ul><p><strong>问题1：</strong>FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题2：</strong>为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？ </p><p>MySQL 存储浮点数的格式为：<code>符号(S)</code>、<code>尾数(M)</code>和 <code>阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p><h3 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3.2 数据精度说明"></a>3.2 数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用<code>4</code>个字节，双精度值使用<code>8</code>个字节。</p><ul><li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。</p><p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p></li></ul><ul><li>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</li><li>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。只是加上<code>UNSINGED</code>插入负数会报错。</li></ul><ul><li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p><ul><li><p>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</p></li><li><p>如果存储时，小数点部分若超出范围，就分以下情况：</p><ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li><li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li></ul></li></ul></li><li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p></li><li><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_double1(<br>f1 FLOAT,<br>f2 FLOAT(5,2),<br>f3 DOUBLE,<br>f4 DOUBLE(5,2)<br>);<br><br>DESC test_double1;<br><br>INSERT INTO test_double1<br>VALUES(123.456,123.456,123.4567,123.45);<br><br>#Out of range value for column &#x27;f2&#x27; at row 1<br>INSERT INTO test_double1<br>VALUES(123.456,1234.456,123.4567,123.45); <br><br>SELECT * FROM test_double1;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-精度误差说明"><a href="#3-3-精度误差说明" class="headerlink" title="3.3 精度误差说明"></a>3.3 精度误差说明</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_double2(<br>f1 DOUBLE<br>);<br><br>INSERT INTO test_double2<br>VALUES(0.47),(0.44),(0.19);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUM(f1)<br>    -&gt; FROM test_double2;<br>+--------------------+<br>| SUM(f1)            |<br>+--------------------+<br>| 1.0999999999999999 |<br>+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUM(f1) = 1.1,1.1 = 1.1<br>    -&gt; FROM test_double2;<br>+---------------+-----------+<br>| SUM(f1) = 1.1 | 1.1 = 1.1 |<br>+---------------+-----------+<br>|             0 |         1 |<br>+---------------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p><p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。 </p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。 </p><p>在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。</strong>同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：<code>DECIMAL</code>。</p><h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><h3 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a>4.1 类型介绍</h3><ul><li><p>MySQL中的定点数类型只有 DECIMAL 一种类型。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC</td><td>M+2字节</td><td>有效范围由M和D决定</td></tr></tbody></table><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li><li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在MySQL内部是以<code>字符串</code>的形式进行存储，这就决定了它一定是精准的。</p></li><li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理（和FLOAT/DOUBLE一样的处理方式）。</p></li><li><p><strong>浮点数 vs 定点数</strong></p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li></ul></li><li><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_decimal1(<br>f1 DECIMAL,<br>f2 DECIMAL(5,2)<br>);<br><br>DESC test_decimal1;<br><br>INSERT INTO test_decimal1(f1,f2)<br>VALUES(123.123,123.456);<br><br>#Out of range value for column &#x27;f2&#x27; at row 1<br>INSERT INTO test_decimal1(f2)<br>VALUES(1234.34);<br><br>#Out of range value for column &#x27;f2&#x27; at row 1<br>INSERT INTO test_decimal1(f2)<br>VALUES(999.995);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_decimal1;<br>+------+--------+<br>| f1   | f2     |<br>+------+--------+<br>|  123 | 123.46 |<br>+------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure></li><li><p>举例</p><p>我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE test_double2<br>MODIFY f1 DECIMAL(5,2);<br></code></pre></td></tr></table></figure><p>然后，我们再一次运行求和语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUM(f1)<br>    -&gt; FROM test_double2;<br>+---------+<br>| SUM(f1) |<br>+---------+<br>|    1.10 |<br>+---------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUM(f1) = 1.1<br>    -&gt; FROM test_double2;<br>+---------------+<br>| SUM(f1) = 1.1 |<br>+---------------+<br>|             1 |<br>+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a>4.2 开发中经验</h3><blockquote><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p></blockquote><h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a>5. 位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似010110。</p><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;= M &lt;= 64</td><td>约为(M + 7)/8个字节</td></tr></tbody></table><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_bit1(<br>f1 BIT,<br>f2 BIT(5),<br>f3 BIT(64)<br>);<br><br>INSERT INTO test_bit1(f1)<br>VALUES(1);<br><br>#Data too long for column &#x27;f1&#x27; at row 1<br>INSERT INTO test_bit1(f1)<br>VALUES(2);<br><br>INSERT INTO test_bit1(f2)<br>VALUES(23);<br></code></pre></td></tr></table></figure><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><p>使用SELECT命令查询位字段时，可以用<code>BIN()</code>或<code>HEX()</code>函数进行读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_bit1;<br>+------------+------------+------------+<br>| f1         | f2         | f3         |<br>+------------+------------+------------+<br>| 0x01       | NULL       | NULL       |<br>| NULL       | 0x17       | NULL       |<br>+------------+------------+------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT BIN(f2),HEX(f2)<br>    -&gt; FROM test_bit1;<br>+---------+---------+<br>| BIN(f2) | HEX(f2) |<br>+---------+---------+<br>| NULL    | NULL    |<br>| 10111   | 17      |<br>+---------+---------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT f2 + 0<br>    -&gt; FROM test_bit1;<br>+--------+<br>| f2 + 0 |<br>+--------+<br>|   NULL |<br>|     23 |<br>+--------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p><h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a>6. 日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。 </p><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><ul><li><code>YEAR</code>类型通常用来表示年</li><li><code>DATE</code>类型通常用来表示年、月、日</li><li><code>TIME</code>类型通常用来表示时、分、秒</li><li><code>DATETIME</code>类型通常用来表示年、月、日、时、分、秒</li><li><code>TIMESTAMP</code>类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h3 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a>6.1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要<code>1个字节</code>的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li><li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul><li>当取值为01到69时，表示2001到2069；</li><li>当取值为70到99时，表示1970到1999；</li><li>当取值整数的0或00添加的话，那么是0000年；</li><li>当取值是日期/字符串的’0’添加的话，是2000年。</li></ul></li></ul><p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_year(<br>f1 YEAR,<br>f2 YEAR(4)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESC test_year;<br>+-------+---------+------+-----+---------+-------+<br>| Field | Type    | Null | Key | Default | Extra |<br>+-------+---------+------+-----+---------+-------+<br>| f1    | year(4) | YES  |     | NULL    |       |<br>| f2    | year(4) | YES  |     | NULL    |       |<br>+-------+---------+------+-----+---------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_year<br>VALUES(&#x27;2020&#x27;,2021);<br><br>mysql&gt; SELECT * FROM test_year;<br>+------+------+<br>| f1   | f2   |<br>+------+------+<br>| 2020 | 2021 |<br>+------+------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_year<br>VALUES(&#x27;45&#x27;,&#x27;71&#x27;);<br><br>INSERT INTO test_year<br>VALUES(0,&#x27;0&#x27;);<br><br>mysql&gt; SELECT * FROM test_year;<br>+------+------+<br>| f1   | f2   |<br>+------+------+<br>| 2020 | 2021 |<br>| 2045 | 1971 |<br>| 0000 | 2000 |<br>+------+------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a>6.2 DATE类型</h3><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要<code>3个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。<code>推荐写法</code></li><li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。<code>不推荐写法</code></li><li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li></ul><p><strong>举例：</strong></p><p>创建数据表，表中只包含一个DATE类型的字段f1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_date1(<br>f1 DATE<br>);<br>Query OK, 0 rows affected (0.13 sec)<br></code></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_date1<br>VALUES (&#x27;2020-10-01&#x27;), (&#x27;20201001&#x27;),(20201001);<br><br>INSERT INTO test_date1<br>VALUES (&#x27;00-01-01&#x27;), (&#x27;000101&#x27;), (&#x27;69-10-01&#x27;), (&#x27;691001&#x27;), (&#x27;70-01-01&#x27;), (&#x27;700101&#x27;), (&#x27;99-01-01&#x27;), (&#x27;990101&#x27;);<br><br>INSERT INTO test_date1<br>VALUES (000301), (690301), (700301), (990301); <br><br>INSERT INTO test_date1<br>VALUES (CURRENT_DATE()), (NOW());<br><br>SELECT *<br>FROM test_date1;<br></code></pre></td></tr></table></figure><h3 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a>6.3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要<code>3个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。<br>（1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS&#39;</code>、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。<br>（2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。<br>（3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIME类型的字段f1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_time1(<br>f1 TIME<br>);<br>Query OK, 0 rows affected (0.02 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_time1<br>VALUES(&#x27;2 12:30:29&#x27;), (&#x27;12:35:29&#x27;), (&#x27;12:40&#x27;), (&#x27;2 12:40&#x27;),(&#x27;1 05&#x27;), (&#x27;45&#x27;);<br><br>INSERT INTO test_time1<br>VALUES (&#x27;123520&#x27;), (124011),(1210);<br><br>INSERT INTO test_time1<br>VALUES (NOW()), (CURRENT_TIME());<br><br>SELECT * FROM test_time1;<br></code></pre></td></tr></table></figure><h3 id="6-4-DATETIME类型"><a href="#6-4-DATETIME类型" class="headerlink" title="6.4 DATETIME类型"></a>6.4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要<code>8</code>个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。<ul><li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li></ul></li><li>以<code>YY-MM-DD HH:MM:SS</code>格式或者<code>YYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li><li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li></ul><p><strong>举例：</strong></p><p>创建数据表，表中包含一个DATETIME类型的字段dt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_datetime1(<br>dt DATETIME<br>);<br>Query OK, 0 rows affected (0.02 sec)<br></code></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_datetime1<br>VALUES (&#x27;2021-01-01 06:50:30&#x27;), (&#x27;20210101065030&#x27;);<br><br>INSERT INTO test_datetime1<br>VALUES (&#x27;99-01-01 00:00:00&#x27;), (&#x27;990101000000&#x27;), (&#x27;20-01-01 00:00:00&#x27;), (&#x27;200101000000&#x27;);<br><br>INSERT INTO test_datetime1<br>VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);<br> <br>INSERT INTO test_datetime1<br>VALUES (CURRENT_TIMESTAMP()), (NOW());<br></code></pre></td></tr></table></figure><h3 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a>6.5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_timestamp1(<br>ts TIMESTAMP<br>);<br></code></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_timestamp1<br>VALUES (&#x27;1999-01-01 03:04:50&#x27;), (&#x27;19990101030405&#x27;), (&#x27;99-01-01 03:04:05&#x27;), (&#x27;990101030405&#x27;);<br><br>INSERT INTO test_timestamp1<br>VALUES (&#x27;2020@01@01@00@00@00&#x27;), (&#x27;20@01@01@00@00@00&#x27;);<br><br>INSERT INTO test_timestamp1<br>VALUES (CURRENT_TIMESTAMP()), (NOW());<br><br>#Incorrect datetime value<br>INSERT INTO test_timestamp1<br>VALUES (&#x27;2038-01-20 03:14:07&#x27;);<br></code></pre></td></tr></table></figure><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li><p>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</p></li><li><p>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离世界标准时间（英国时区）1970-1-1 0:0:0 0毫秒的毫秒值。</p></li><li><p>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</p></li><li><p>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE temp_time(<br>d1 DATETIME,<br>d2 TIMESTAMP<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO temp_time VALUES(&#x27;2021-9-2 14:45:52&#x27;,&#x27;2021-9-2 14:45:52&#x27;);<br><br>INSERT INTO temp_time VALUES(NOW(),NOW());<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM temp_time;<br>+---------------------+---------------------+<br>| d1                  | d2                  |<br>+---------------------+---------------------+<br>| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 |<br>| 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |<br>+---------------------+---------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改当前的时区<br>SET time_zone = &#x27;+9:00&#x27;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM temp_time;<br>+---------------------+---------------------+<br>| d1                  | d2                  |<br>+---------------------+---------------------+<br>| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 |<br>| 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |<br>+---------------------+---------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a>6.6 开发中经验</h3><p>用得最多的日期时间类型，就是 <code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。 </p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT UNIX_TIMESTAMP();<br>+------------------+<br>| UNIX_TIMESTAMP() |<br>+------------------+<br>|       1635932762 |<br>+------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a>7. 文本字符串类型</h2><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p><p>MySQL中，文本字符串总体上分为<code>CHAR</code>、<code>VARCHAR</code>、<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>ENUM</code>、<code>SET</code>等类型。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012003508730.png"></p><h3 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a>7.1 CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M * 3 个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 21845</td><td>(实际长度 + 1)  * 3 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。（无论是自己添加的尾部空格，还是自动填充的空格，都不显示）</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_char1(<br>c1 CHAR,<br>c2 CHAR(5)<br>);<br><br>DESC test_char1;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_char1<br>VALUES(&#x27;a&#x27;,&#x27;Tom&#x27;);<br><br>SELECT c1,CONCAT(c2,&#x27;***&#x27;) FROM test_char1;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_char1(c2)<br>VALUES(&#x27;a  &#x27;);<br><br>SELECT CHAR_LENGTH(c2)<br>FROM test_char1;<br></code></pre></td></tr></table></figure><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。（必须要指明最多可以存储多少个字符）</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_varchar1(<br>NAME VARCHAR  #错误<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#Column length too big for column &#x27;NAME&#x27; (max = 21845);<br>CREATE TABLE test_varchar2(<br>NAME VARCHAR(65535)  #错误<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_varchar3(<br>NAME VARCHAR(5)<br>);<br><br>INSERT INTO test_varchar3<br>VALUES(&#x27;尚硅谷&#x27;),(&#x27;尚硅谷教育&#x27;);<br><br>#Data too long for column &#x27;NAME&#x27; at row 1<br>INSERT INTO test_varchar3<br>VALUES(&#x27;尚硅谷IT教育&#x27;);<br></code></pre></td></tr></table></figure><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p><p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li><p><code>MyISAM</code> 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</p></li><li><p><code>MEMORY</code> 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</p></li><li><p><code>InnoDB</code>存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且<strong>主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</p></li></ul><h3 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a>7.2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p><table><thead><tr><th>文本字符串类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p><p><strong>举例：</strong></p><p>创建数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_text(<br>tx TEXT<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_text<br>VALUES(&#x27;atguigu   &#x27;);<br><br>SELECT CHAR_LENGTH(tx)<br>FROM test_text; #10      需要注意的是，TEXT不会忽略字符串结尾的空格，而CHAR会忽略字符串结尾的空格。<br></code></pre></td></tr></table></figure><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><p><strong>开发中经验：</strong></p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><p><strong>需要注意的是，TEXT不会忽略字符串结尾的空格，而CHAR会忽略字符串结尾的空格。</strong></p><h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a>8. ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值（MySQL忽略大小写），不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1或2个字节</td></tr></tbody></table><ul><li><p>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</p></li><li><p>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</p></li><li><p>ENUM类型的成员个数的上限为65535个。</p></li></ul><p>举例：</p><p>创建表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_enum(<br>season ENUM(&#x27;春&#x27;,&#x27;夏&#x27;,&#x27;秋&#x27;,&#x27;冬&#x27;,&#x27;unknow&#x27;) #下标从1开始，可以使用下标进行插入。<br>);<br></code></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_enum<br>VALUES(&#x27;春&#x27;),(&#x27;秋&#x27;);<br><br># 忽略大小写<br>INSERT INTO test_enum<br>VALUES(&#x27;UNKNOW&#x27;);<br><br># 允许按照角标的方式获取指定索引位置的枚举值<br>INSERT INTO test_enum<br>VALUES(&#x27;1&#x27;),(3);<br><br># Data truncated for column &#x27;season&#x27; at row 1<br>INSERT INTO test_enum<br>VALUES(&#x27;ab&#x27;);<br><br># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的<br>INSERT INTO test_enum<br>VALUES(NULL);<br></code></pre></td></tr></table></figure><h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为<code>64</code>。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。<strong>需要注意的是，一次选择多个成员时，不要多写空格；并且要写在一个字符串中以逗号分隔。</strong>可以使用下标插入元素，但是使用下标只能插入一个成员，不能插入多个成员。</p><p>举例：</p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_set(<br>s SET (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)<br>);<br></code></pre></td></tr></table></figure><p>向表中插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_set (s) VALUES (&#x27;A&#x27;), (&#x27;A,B&#x27;);<br><br>#插入重复的SET类型成员时，MySQL会自动删除重复的成员<br>INSERT INTO test_set (s) VALUES (&#x27;A,B,C,A&#x27;);<br><br>#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。<br>INSERT INTO test_set (s) VALUES (&#x27;A,B,C,D&#x27;);<br><br>SELECT *<br>FROM test_set;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE temp_mul(<br>gender ENUM(&#x27;男&#x27;,&#x27;女&#x27;),<br>hobby SET(&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;打豆豆&#x27;,&#x27;写代码&#x27;)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,打豆豆&#x27;); #成功<br><br># Data truncated for column &#x27;gender&#x27; at row 1<br>INSERT INTO temp_mul VALUES(&#x27;男,女&#x27;,&#x27;睡觉,写代码&#x27;); #失败<br><br># Data truncated for column &#x27;gender&#x27; at row 1<br>INSERT INTO temp_mul VALUES(&#x27;妖&#x27;,&#x27;睡觉,写代码&#x27;);#失败<br><br><br>INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,写代码,吃饭&#x27;); #成功<br></code></pre></td></tr></table></figure><h2 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a>10. 二进制字符串类型</h2><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p><h4 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a>BINARY与VARBINARY类型</h4><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table><p>举例：</p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_binary1(<br>f1 BINARY,<br>f2 BINARY(3),<br># f3 VARBINARY,<br>f4 VARBINARY(10)<br>);<br></code></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_binary1(f1,f2)<br>VALUES(&#x27;a&#x27;,&#x27;a&#x27;);<br><br>INSERT INTO test_binary1(f1,f2)<br>VALUES(&#x27;尚&#x27;,&#x27;尚&#x27;);#失败,这是汉字字符，需要占用大于一个字节的空间<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_binary1(f2,f4)<br>VALUES(&#x27;ab&#x27;,&#x27;ab&#x27;);<br><br>mysql&gt; SELECT LENGTH(f2),LENGTH(f4)<br>    -&gt; FROM test_binary1;<br>+------------+------------+<br>| LENGTH(f2) | LENGTH(f4) |<br>+------------+------------+<br>|          3 |       NULL |<br>|          3 |          2 |<br>+------------+------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h4><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如<code>图片</code>、<code>音频</code>和<code>视频</code>等。</p><p><strong>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</strong></p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_blob1(<br>id INT,<br>img MEDIUMBLOB<br>);<br></code></pre></td></tr></table></figure><p><strong>TEXT和BLOB的使用注意事项：</strong></p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。</p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p><h2 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h2><p>JSON（JavaScript Object Notation）是一种轻量级的<code>数据交换格式</code>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p><p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。<br>创建数据表，表中包含一个JSON类型的字段 js 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_json(<br>js json<br><br>);<br></code></pre></td></tr></table></figure><p>向表中插入JSON数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_json (js) <br>VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);<br></code></pre></td></tr></table></figure><p>查询t19表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT *<br>    -&gt; FROM test_json;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211104192516324.png"></p><p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT js -&gt; &#x27;$.name&#x27; AS NAME,js -&gt; &#x27;$.age&#x27; AS age ,js -&gt; &#x27;$.address.province&#x27; AS province, js -&gt; &#x27;$.address.city&#x27; AS city<br>    -&gt; FROM test_json;<br>+----------+------+-----------+-----------+<br>| NAME     | age  | province  | city      |<br>+----------+------+-----------+-----------+<br>| &quot;songhk&quot; | 18   | &quot;beijing&quot; | &quot;beijing&quot; |<br>+----------+------+-----------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p><h2 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a>12. 空间类型</h2><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用<code>Geometry（几何）</code>来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。</p><ul><li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。<ul><li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</li><li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。</li><li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</li></ul></li></ul><p>下面展示几种常见的几何图形元素：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211104192912988.png"></p><ul><li>MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个Point、LineString或Polygon组合而成。</li></ul><p>下面展示的是多个同类或异类几何图形元素的组合：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211104193330204.png"></p><h2 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a>13. 小结及选择建议</h2><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code> INT</code>； 如果是<code>小数</code>，一定用定点数类型 <code>DECIMAL(M,D)</code>； 如果是日期与时间，就用 <code>DATETIME</code>。 </p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错（不会插入数据时产生溢出）。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 <ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li></ul></li><li>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 </li><li>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul><h1 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章_约束"></a>第13章_约束</h1><h2 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束(constraint)概述"></a>1. 约束(constraint)概述</h2><h3 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1.1 为什么需要约束"></a>1.1 为什么需要约束</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男/女”</li><li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li><li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><h3 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1.2 什么是约束"></a>1.2 什么是约束</h3><p>约束是表级的强制规定。</p><p>可以在<strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong>，或者在<strong>表创建之后通过 ALTER TABLE 语句规定约束</strong>。</p><h3 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1.3 约束的分类"></a>1.3 约束的分类</h3><ul><li><strong>根据约束数据列的限制，</strong>约束可分为：<ul><li><strong>单列约束</strong>：每个约束只约束一列</li><li><strong>多列约束</strong>：每个约束可约束多列数据</li></ul></li><li><strong>根据约束的作用范围</strong>，约束可分为：<ul><li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面</li><li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">位置支持的约束类型是否可以起约束名<br>列级约束：列的后面语法都支持，但外键没有效果不可以<br>表级约束：所有列的下面   默认和非空不支持，其他支持   可以（主键没有效果）<br></code></pre></td></tr></table></figure><ul><li><strong>根据约束起的作用</strong>，约束可分为：<ul><li><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></li><li><strong>UNIQUE</strong>  <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></li><li><strong>PRIMARY KEY  主键(非空且唯一)约束</strong></li><li><strong>FOREIGN KEY</strong>  <strong>外键约束</strong></li><li><strong>CHECK</strong>  <strong>检查约束</strong></li><li><strong>DEFAULT</strong>  <strong>默认值约束</strong></li></ul></li></ul><blockquote><p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</p></blockquote><ul><li>查看某个表已有的约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#information_schema数据库名（系统库）<br>#table_constraints表名称（专门存储各个表的约束）<br>SELECT * FROM information_schema.table_constraints <br>WHERE table_name = &#x27;表名称&#x27;; #需要注意的是，这里是一个表，表名是作为一个字符串出现在表中的，所以需要单引号。<br></code></pre></td></tr></table></figure><h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p>限定某个字段/某列的值不允许为空</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555426972098.png"></p><h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h3><p>NOT NULL</p><h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h3><ul><li><p>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</p></li><li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空(只能使用列级约束，不能使用表级约束)</p></li><li><p>一个表可以有很多列都分别限定了非空</p></li><li><p>空字符串’’不等于NULL，0也不等于NULL</p></li></ul><h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2.4 添加非空约束"></a>2.4 添加非空约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名称(<br>字段名  数据类型,<br>    字段名  数据类型 NOT NULL,  <br>    字段名  数据类型 NOT NULL<br>);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE emp(<br>id INT(10) NOT NULL,<br>NAME VARCHAR(20) NOT NULL,<br>sex CHAR NULL<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>sid int,<br>    sname varchar(20) not null,<br>    tel char(11) ,<br>    cardid char(18) not null<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;110222198912032545&#x27;); #成功<br><br>insert into student values(2,&#x27;李四&#x27;,&#x27;13710011002&#x27;,null);#身份证号为空<br>ERROR 1048 (23000): Column &#x27;cardid&#x27; cannot be null<br><br>insert into student values(2,&#x27;李四&#x27;,null,&#x27;110222198912032546&#x27;);#成功，tel允许为空<br><br>insert into student values(3,null,null,&#x27;110222198912032547&#x27;);#失败<br>ERROR 1048 (23000): Column &#x27;sname&#x27; cannot be null<br><br>update student <br>set sname = NULL<br>where id = 1; #失败<br>Column &#x27;sname&#x27; cannot be null<br></code></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 not null;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp<br>MODIFY sex VARCHAR(30) NOT NULL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table student modify sname varchar(20) not null;<br></code></pre></td></tr></table></figure><h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a>2.5 删除非空约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空<br><br>或 <br><br>alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp<br>MODIFY sex VARCHAR(30) NULL;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp<br>MODIFY NAME VARCHAR(15) DEFAULT &#x27;abc&#x27; NULL;<br></code></pre></td></tr></table></figure><h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h3><p>用来限制某个字段/某列的值不能重复。</p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555427198811.png"></p><h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h3><p>UNIQUE</p><h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3.3 特点"></a>3.3 特点</h3><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空，而且允许出现多个NULL值。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3.4 添加唯一约束"></a>3.4 添加唯一约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型,<br>    字段名  数据类型  unique,  <br>    字段名  数据类型  unique key,<br>    字段名  数据类型<br>);<br>create table 表名称(<br>字段名  数据类型,<br>    字段名  数据类型,  <br>    字段名  数据类型,<br>    [constraint 约束名] unique key(字段名) #可以不起约束名<br>);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>sid int,<br>    sname varchar(20),<br>    tel char(11) unique,<br>    cardid char(18) unique key<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_course(<br>cid INT UNIQUE,<br>cname VARCHAR(100) UNIQUE,<br>description VARCHAR(200)<br>);<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE USER(<br> id INT NOT NULL,<br> NAME VARCHAR(25),<br> PASSWORD VARCHAR(16),<br> -- 使用表级约束语法<br> CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>表示用户名和密码组合不能重复</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);<br>insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student;<br>+-----+-------+-------------+--------------------+<br>| sid | sname | tel         | cardid             |<br>+-----+-------+-------------+--------------------+<br>|   1 | 张三  | 13710011002 | 101223199012015623 |<br>|   2 | 李四  | 13710011003 | 101223199012015624 |<br>+-----+-------+-------------+--------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student values(3,&#x27;王五&#x27;,&#x27;13710011004&#x27;,&#x27;101223199012015624&#x27;); #身份证号重复<br>ERROR 1062 (23000): Duplicate entry &#x27;101223199012015624&#x27; for key &#x27;cardid&#x27;<br><br>insert into student values(3,&#x27;王五&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015625&#x27;); <br>ERROR 1062 (23000): Duplicate entry &#x27;13710011003&#x27; for key &#x27;tel&#x27;<br></code></pre></td></tr></table></figure><p>（2）建表后指定唯一键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的<br>#方式1：<br>alter table 表名称 add [constraint 约束名称] unique [key] (字段列表); <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式2：<br>alter table 表名称 modify 字段名 字段类型 unique;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE USER <br>ADD UNIQUE(NAME,PASSWORD);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE USER <br>ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE USER <br>MODIFY NAME VARCHAR(20) UNIQUE;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>sid int primary key,<br>    sname varchar(20),<br>    tel char(11) ,<br>    cardid char(18) <br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table student add unique key(tel);<br>alter table student add unique key(cardid);<br></code></pre></td></tr></table></figure><h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3.5 关于复合唯一约束"></a>3.5 关于复合唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型,<br>    字段名  数据类型,  <br>    字段名  数据类型,<br>    unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#学生表<br>create table student(<br>sid int,#学号<br>    sname varchar(20),#姓名<br>    tel char(11) unique key,  #电话<br>    cardid char(18) unique key #身份证号<br>);<br><br>#课程表<br>create table course(<br>cid int,  #课程编号<br>    cname varchar(20)     #课程名称<br>);<br><br>#选课表<br>create table student_course(<br>    id int,<br>sid int,<br>    cid int,<br>    score int,<br>    unique key(sid,cid)  #复合唯一<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功<br>insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功<br>insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);#成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student;<br>+-----+-------+-------------+--------------------+<br>| sid | sname | tel         | cardid             |<br>+-----+-------+-------------+--------------------+<br>|   1 | 张三  | 13710011002 | 101223199012015623 |<br>|   2 | 李四  | 13710011003 | 101223199012015624 |<br>+-----+-------+-------------+--------------------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from course;<br>+------+-------+<br>| cid  | cname |<br>+------+-------+<br>| 1001 | Java  |<br>| 1002 | MySQL |<br>+------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student_course values<br>(1, 1, 1001, 89),<br>(2, 1, 1002, 90),<br>(3, 2, 1001, 88),<br>(4, 2, 1002, 56);#成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student_course;<br>+----+------+------+-------+<br>| id | sid  | cid  | score |<br>+----+------+------+-------+<br>|  1 |    1 | 1001 |    89 |<br>|  2 |    1 | 1002 |    90 |<br>|  3 |    2 | 1001 |    88 |<br>|  4 |    2 | 1002 |    56 |<br>+----+------+------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student_course values (5, 1, 1001, 88);#失败<br><br>#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27;   违反sid-cid的复合唯一<br></code></pre></td></tr></table></figure><h3 id="3-5-删除唯一约束"><a href="#3-5-删除唯一约束" class="headerlink" title="3.5 删除唯一约束"></a>3.5 删除唯一约束</h3><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名与对应唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表民 <br>DROP INDEX uk_name_pwd;<br></code></pre></td></tr></table></figure><blockquote><p>注意：可以通过 <code>show index from 表名称; </code>查看表的索引</p></blockquote><h2 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a>4. PRIMARY KEY 约束</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h3><p>用来唯一标识表中的一行记录。</p><h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4.2 关键字"></a>4.2 关键字</h3><p>primary key</p><h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a>4.3 特点</h3><ul><li>主键约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555427492244.png"></p><ul><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li></ul><ul><li><p>主键约束对应着表中的一列或者多列（复合主键）</p></li><li><p>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p></li><li><p><strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用。</p></li><li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p></li></ul><ul><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识（单纯UNIQUE不能保证唯一，因为可以多个NULL值），如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4.4 添加主键约束"></a>4.4 添加主键约束</h3><p>（1）建表时指定主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型  primary key, #列级模式<br>    字段名  数据类型,  <br>    字段名  数据类型  <br>);<br>create table 表名称(<br>字段名  数据类型,<br>    字段名  数据类型,  <br>    字段名  数据类型,<br>    [constraint 约束名] primary key(字段名) #表级模式<br>);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table temp(<br>id int primary key,<br>    name varchar(20)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc temp;<br>+-------+-------------+------+-----+---------+-------+<br>| Field | Type        | Null | Key | Default | Extra |<br>+-------+-------------+------+-----+---------+-------+<br>| id    | int(11)     | NO   | PRI | NULL    |       |<br>| name  | varchar(20) | YES  |     | NULL    |       |<br>+-------+-------------+------+-----+---------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into temp values(1,&#x27;张三&#x27;);#成功<br>insert into temp values(2,&#x27;李四&#x27;);#成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from temp;<br>+----+------+<br>| id | name |<br>+----+------+<br>|  1 | 张三 |<br>|  2 | 李四 |<br>+----+------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into temp values(1,&#x27;张三&#x27;);#失败<br>ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） &#x27;1&#x27; for key &#x27;PRIMARY&#x27;<br><br><br>insert into temp values(1,&#x27;王五&#x27;);#失败<br>ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;<br><br>insert into temp values(3,&#x27;张三&#x27;);#成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from temp;<br>+----+------+<br>| id | name |<br>+----+------+<br>|  1 | 张三 |<br>|  2 | 李四 |<br>|  3 | 张三 |<br>+----+------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into temp values(4,null);#成功<br><br><br>insert into temp values(null,&#x27;李琦&#x27;);#失败<br>ERROR 1048 (23000): Column &#x27;id&#x27; cannot be null<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from temp;<br>+----+------+<br>| id | name |<br>+----+------+<br>|  1 | 张三 |<br>|  2 | 李四 |<br>|  3 | 张三 |<br>|  4 | NULL |<br>+----+------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#演示一个表建立两个主键约束<br>create table temp(<br>id int primary key,<br>    name varchar(20) primary key<br>);<br>ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）<br></code></pre></td></tr></table></figure><p>再举例：</p><ul><li>列级约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE emp4(<br>id INT PRIMARY KEY AUTO_INCREMENT ,<br>NAME VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure><ul><li>表级约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE emp5(<br>id INT NOT NULL AUTO_INCREMENT,<br>NAME VARCHAR(20),<br>pwd VARCHAR(15),<br>CONSTRAINT emp5_id_pk PRIMARY KEY(id)<br>);<br></code></pre></td></tr></table></figure><p>（2）建表后增加主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称 ADD [CONSTRAINT 主键名] PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student ADD PRIMARY KEY (sid);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);<br></code></pre></td></tr></table></figure><h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4.5 关于复合主键"></a>4.5 关于复合主键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型,<br>    字段名  数据类型,  <br>    字段名  数据类型,<br>    primary key(字段名1,字段名2)  #表示字段1和字段2的组合是唯一的，也可以有更多个字段<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#学生表<br>create table student(<br>sid int primary key,  #学号<br>    sname varchar(20)     #学生姓名<br>);<br><br>#课程表<br>create table course(<br>cid int primary key,  #课程编号<br>    cname varchar(20)     #课程名称<br>);<br><br>#选课表<br>create table student_course(<br>sid int,<br>    cid int,<br>    score int,<br>    primary key(sid,cid)  #复合主键<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student values(1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;);<br>insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student;<br>+-----+-------+<br>| sid | sname |<br>+-----+-------+<br>|   1 | 张三  |<br>|   2 | 李四  |<br>+-----+-------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from course;<br>+------+-------+<br>| cid  | cname |<br>+------+-------+<br>| 1001 | Java  |<br>| 1002 | MySQL |<br>+------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student_course;<br>+-----+------+-------+<br>| sid | cid  | score |<br>+-----+------+-------+<br>|   1 | 1001 |    89 |<br>|   1 | 1002 |    90 |<br>|   2 | 1001 |    88 |<br>|   2 | 1002 |    56 |<br>+-----+------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student_course values(1, 1001, 100);<br>ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc student_course;<br>+-------+---------+------+-----+---------+-------+<br>| Field | Type    | Null | Key | Default | Extra |<br>+-------+---------+------+-----+---------+-------+<br>| sid   | int(11) | NO   | PRI | NULL    |       |<br>| cid   | int(11) | NO   | PRI | NULL    |       |<br>| score | int(11) | YES  |     | NULL    |       |<br>+-------+---------+------+-----+---------+-------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE emp6(<br>id INT NOT NULL,<br>NAME VARCHAR(20),<br>pwd VARCHAR(15),<br>CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd)<br>);<br></code></pre></td></tr></table></figure><h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4.6 删除主键约束"></a>4.6 删除主键约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 drop primary key;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp5 DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure><blockquote><p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p></blockquote><p>在实际开发中，不会去删除主键约束。（表是以主键来构建B+树的，如果没有主键会以唯一约束来构建B+树，如果再没有，那么Innodb内部会基于一个包含了ROW_ID值的列生成一个隐藏的聚集索引GEN_CLUST_INDEX ，ROW_ID是一个6个字节即48位单调递增的列。）</p><h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h3><p>某个字段的值自增</p><h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a>5.2 关键字</h3><p>auto_increment</p><h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5.3 特点和要求"></a>5.3 特点和要求</h3><p>（1）一个表最多只能有一个自增长列</p><p>（2）当需要产生唯一标识符或顺序值时，可设置自增长（每次会在当前最大值的基础上自增）</p><p>（3）自增长列约束的列必须是键列（主键列，唯一键列）</p><p>（4）自增约束的列的数据类型必须是整数类型</p><p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值（正整数或者负整数），直接赋值为具体值。</p><p>（6）在实际开发中，不要对自增长列赋值，让其自动自增长。（十分不建议手动赋值）</p><p>错误演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int auto_increment,<br>    ename varchar(20)<br>);<br># ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key   <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key,<br>    ename varchar(20) unique key auto_increment<br>);<br># ERROR 1063 (42000): Incorrect column specifier for column &#x27;ename&#x27;  因为ename不是整数类型<br></code></pre></td></tr></table></figure><h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5.4 如何指定自增约束"></a>5.4 如何指定自增约束</h3><p><strong>（1）建表时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型  primary key auto_increment,<br>    字段名  数据类型  unique key not null,  <br>    字段名  数据类型  unique key,<br>    字段名  数据类型  not null default 默认值, <br>);<br>create table 表名称(<br>字段名  数据类型 default 默认值 ,<br>    字段名  数据类型 unique key auto_increment,  <br>    字段名  数据类型 not null default 默认值,,<br>    primary key(字段名)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key auto_increment,<br>    ename varchar(20)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+-------+-------------+------+-----+---------+----------------+<br>| Field | Type        | Null | Key | Default | Extra          |<br>+-------+-------------+------+-----+---------+----------------+<br>| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |<br>| ename | varchar(20) | YES  |     | NULL    |                |<br>+-------+-------------+------+-----+---------+----------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>（2）建表后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 auto_increment; #此处字段必须已经是主键或者唯一键<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key ,<br>    ename varchar(20)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table employee modify eid int auto_increment;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+-------+-------------+------+-----+---------+----------------+<br>| Field | Type        | Null | Key | Default | Extra          |<br>+-------+-------------+------+-----+---------+----------------+<br>| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |<br>| ename | varchar(20) | YES  |     | NULL    |                |<br>+-------+-------------+------+-----+---------+----------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5.5 如何删除自增约束"></a>5.5 如何删除自增约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束<br><br>alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table employee modify eid int;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+-------+-------------+------+-----+---------+-------+<br>| Field | Type        | Null | Key | Default | Extra |<br>+-------+-------------+------+-----+---------+-------+<br>| eid   | int(11)     | NO   | PRI | NULL    |       |<br>| ename | varchar(20) | YES  |     | NULL    |       |<br>+-------+-------------+------+-----+---------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="5-6-MySQL-8-0新特性—自增变量的持久化"><a href="#5-6-MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="5.6 MySQL 8.0新特性—自增变量的持久化"></a>5.6 MySQL 8.0新特性—自增变量的持久化</h3><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>下面通过案例来对比不同的版本中自增变量是否持久化。<br>在MySQL 5.7版本中，测试步骤如下：<br>创建的数据表中包含自增主键的id字段，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test1(<br>id INT PRIMARY KEY AUTO_INCREMENT<br>);<br></code></pre></td></tr></table></figure><p>插入4个空值，执行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test1<br>VALUES(0),(0),(0),(0);<br></code></pre></td></tr></table></figure><p>查询数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test1;<br>+----+<br>| id |<br>+----+<br>|  1 |<br>|  2 |<br>|  3 |<br>|  4 |<br>+----+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>删除id为4的记录，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM test1 WHERE id = 4;<br></code></pre></td></tr></table></figure><p>再次插入一个空值，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test1 VALUES(0);<br></code></pre></td></tr></table></figure><p>查询此时数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test1;<br>+----+<br>| id |<br>+----+<br>|  1 |<br>|  2 |<br>|  3 |<br>|  5 |<br>+----+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。<br>删除id为5的记录，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM test1 where id=5;<br></code></pre></td></tr></table></figure><p><strong>重启数据库</strong>，重新插入一个空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test1 values(0);<br></code></pre></td></tr></table></figure><p>再次查询数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test1;<br>+----+<br>| id |<br>+----+<br>|  1 |<br>|  2 |<br>|  3 |<br>|  4 |<br>+----+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。<br>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test1;<br>+----+<br>| id |<br>+----+<br>|  1 |<br>|  2 |<br>|  3 |<br>|  6 |<br>+----+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果可以看出，自增变量已经持久化了。</p><p>MySQL 8.0将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a>6.1 作用</h3><p><strong>限定某个表的某个字段的引用完整性。</strong></p><p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555428214706.png"></p><h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a>6.2 关键字</h3><p>FOREIGN KEY</p><h3 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6.3 主表和从表/父表和子表"></a>6.3 主表和从表/父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p><p>从表（子表）：引用别人的表，参考别人的表</p><p>主表和从表是逻辑概念，主表和从表可以是一个表</p><p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p><p>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p><h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6.4 特点"></a>6.4 特点</h3><p>（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列</p><div class="code-wrapper"><pre><code class="hljs">      为什么？因为被依赖/被参考的值必须是唯一的</code></pre></div><p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如 student_ibfk_1;），建议指定外键约束名。</p><p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p><p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p><p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p><p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p><p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p><div class="code-wrapper"><pre><code class="hljs">      例如：都是表示部门编号，都是int类型。</code></pre></div><p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）</p><p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p><h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6.5 添加外键约束"></a>6.5 添加外键约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 主表名称(<br>字段1  数据类型  primary key,<br>    字段2  数据类型<br>);<br><br>create table 从表名称(<br>字段1  数据类型  primary key,<br>    字段2  数据类型,<br>    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)<br>);<br>#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样<br>#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样<br><br>-- FOREIGN KEY: 在表级指定子表中的列<br>-- REFERENCES: 标示在父表中的列<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept( #主表<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(#从表<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)   #在从表中指定外键约束<br>    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号<br>);<br><br>说明：<br>（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。<br>（2）删除表时，先删除从表emp，再删除主表dept<br></code></pre></td></tr></table></figure><p>（2）建表后</p><p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp1<br>ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int#员工所在的部门<br>);<br>#这两个表创建时，没有指定外键的话，那么创建顺序是随意<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table emp add foreign key (deptid) references dept(did);<br></code></pre></td></tr></table></figure><h3 id="6-6-演示问题"><a href="#6-6-演示问题" class="headerlink" title="6.6 演示问题"></a>6.6 演示问题</h3><p>（1）失败：不是键列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int ,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)<br>);<br>#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是dept的did不是键列<br></code></pre></td></tr></table></figure><p>（2）失败：数据类型不一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid char,#员工所在的部门<br>    foreign key (deptid) references dept(did)<br>);<br>#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致<br></code></pre></td></tr></table></figure><p>（3）成功，两个表字段名一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    did int,#员工所在的部门<br>    foreign key (did) references dept(did)  <br>    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号<br>    #是否重名没问题，因为两个did在不同的表中<br>);<br></code></pre></td></tr></table></figure><p>（4）添加、删除、修改问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)  <br>    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into dept values(1001,&#x27;教学部&#x27;);<br>insert into dept values(1003, &#x27;财务部&#x27;);<br><br>insert into emp values(1,&#x27;张三&#x27;,1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门<br><br>insert into emp values(2,&#x27;李四&#x27;,1005);#添加从表记录失败<br>ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部  |<br>| 1003 | 财务部  |<br>+------+--------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三   |   1001 |<br>+-----+-------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update emp set deptid = 1002 where eid = 1;#修改从表失败 <br>ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002<br><br>update dept set did = 1002 where did = 1001;#修改主表失败<br>ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。<br><br>update dept set did = 1002 where did = 1003;#修改主表成功  因为部门表的1003部门没有被emp表引用，所以可以修改<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from dept where did=1001; #删除主表失败<br>ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除<br></code></pre></td></tr></table></figure><p>总结：约束关系是针对双方的</p><ul><li><p>添加了外键约束后，主表的修改和删除数据受约束</p></li><li><p>添加了外键约束后，从表的添加和修改数据受约束</p></li><li><p>在从表上建立外键，要求主表必须存在</p></li><li><p>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</p></li></ul><h3 id="6-7-约束等级"><a href="#6-7-约束等级" class="headerlink" title="6.7 约束等级"></a>6.7 约束等级</h3><ul><li><p><code>Cascade方式</code>：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 </p></li><li><p><code>Set null方式</code>：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null  </p></li><li><p><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作  </p></li><li><p><code>Restrict方式</code>：同no action， 都是立即检查外键约束</p></li><li><p><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p></li></ul><p>如果没有指定等级，就相当于Restrict方式。</p><p>对于外键约束，最好是采用: <code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式。</p><p>（1）演示1：on update cascade on delete set null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)  on update cascade on delete set null<br>    #把修改操作设置为级联修改等级，把删除操作设置为set null等级<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into dept values(1001,&#x27;教学部&#x27;);<br>insert into dept values(1002, &#x27;财务部&#x27;);<br>insert into dept values(1003, &#x27;咨询部&#x27;);<br><br><br>insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门<br>insert into emp values(2,&#x27;李四&#x27;,1001);<br>insert into emp values(3,&#x27;王五&#x27;,1002);<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from dept;<br><br>mysql&gt; select * from emp;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了<br>mysql&gt; update dept set did = 1004 where did = 1002;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部 |<br>| 1003 | 咨询部 |<br>| 1004 | 财务部 | #原来是1002，修改为1004<br>+------+--------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   1001 |<br>|   2 | 李四  |   1001 |<br>|   3 | 王五  |   1004 | #原来是1002，跟着修改为1004<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除主表的记录成功，从表对应的字段的值被修改为null<br>mysql&gt; delete from dept where did = 1001;<br>Query OK, 1 row affected (0.01 sec)<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  | #记录1001部门被删除了<br>+------+--------+<br>| 1003 | 咨询部  |<br>| 1004 | 财务部  |<br>+------+--------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   NULL | #原来引用1001部门的员工，deptid字段变为null<br>|   2 | 李四  |   NULL |<br>|   3 | 王五  |   1004 |<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>（2）演示2：on update set null on delete cascade</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)  on update set null on delete cascade<br>    #把修改操作设置为set null等级，把删除操作设置为级联删除等级<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into dept values(1001,&#x27;教学部&#x27;);<br>insert into dept values(1002, &#x27;财务部&#x27;);<br>insert into dept values(1003, &#x27;咨询部&#x27;);<br><br>insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门<br>insert into emp values(2,&#x27;李四&#x27;,1001);<br>insert into emp values(3,&#x27;王五&#x27;,1002);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部 |<br>| 1002 | 财务部 |<br>| 1003 | 咨询部 |<br>+------+--------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   1001 |<br>|   2 | 李四  |   1001 |<br>|   3 | 王五  |   1002 |<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改主表，从表对应的字段设置为null<br>mysql&gt; update dept set did = 1004 where did = 1002;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部 |<br>| 1003 | 咨询部 |<br>| 1004 | 财务部 | #原来did是1002<br>+------+--------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   1001 |<br>|   2 | 李四  |   1001 |<br>|   3 | 王五  |   NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了<br>mysql&gt; delete from dept where did=1001;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  | #部门表中1001部门被删除<br>+------+--------+<br>| 1003 | 咨询部 |<br>| 1004 | 财务部 |<br>+------+--------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |#原来1001部门的员工也被删除了<br>+-----+-------+--------+<br>|   3 | 王五  |   NULL |<br>+-----+-------+--------+<br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><p>（3）演示：on update cascade on delete cascade</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>did int primary key,#部门编号<br>    dname varchar(50)#部门名称<br>);<br><br>create table emp(<br>eid int primary key,  #员工编号<br>    ename varchar(5),     #员工姓名<br>    deptid int,#员工所在的部门<br>    foreign key (deptid) references dept(did)  on update cascade on delete cascade<br>    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into dept values(1001,&#x27;教学部&#x27;);<br>insert into dept values(1002, &#x27;财务部&#x27;);<br>insert into dept values(1003, &#x27;咨询部&#x27;);<br><br>insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门<br>insert into emp values(2,&#x27;李四&#x27;,1001);<br>insert into emp values(3,&#x27;王五&#x27;,1002);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部 |<br>| 1002 | 财务部 |<br>| 1003 | 咨询部 |<br>+------+--------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   1001 |<br>|   2 | 李四  |   1001 |<br>|   3 | 王五  |   1002 |<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改主表，从表对应的字段自动修改<br>mysql&gt; update dept set did = 1004 where did = 1002;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  |<br>+------+--------+<br>| 1001 | 教学部 |<br>| 1003 | 咨询部 |<br>| 1004 | 财务部 | #部门1002修改为1004<br>+------+--------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |<br>+-----+-------+--------+<br>|   1 | 张三  |   1001 |<br>|   2 | 李四  |   1001 |<br>|   3 | 王五  |   1004 | #级联修改<br>+-----+-------+--------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了<br>mysql&gt; delete from dept where did=1001;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; select * from dept;<br>+------+--------+<br>| did  | dname  | #1001部门被删除了<br>+------+--------+<br>| 1003 | 咨询部 |<br>| 1004 | 财务部 | <br>+------+--------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from emp;<br>+-----+-------+--------+<br>| eid | ename | deptid |  #1001部门的员工也被删除了<br>+-----+-------+--------+<br>|   3 | 王五  |   1004 |<br>+-----+-------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="6-8-删除外键约束"><a href="#6-8-删除外键约束" class="headerlink" title="6.8 删除外键约束"></a>6.8 删除外键约束</h3><p>流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(1)第一步先查看约束名和删除外键约束<br>SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名<br><br>ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;<br><br>（2）第二步查看索引名和删除索引。（注意，只能手动删除）<br>SHOW INDEX FROM 表名称; #查看某个表的索引名<br><br>ALTER TABLE 从表名 DROP INDEX 索引名; #此处索引名就是外键名（二者同名）<br><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;emp&#x27;;<br><br>mysql&gt; alter table emp drop foreign key emp_ibfk_1;<br>Query OK, 0 rows affected (0.02 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show index from emp;<br><br>mysql&gt; alter table emp drop index deptid;<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt;  show index from emp;<br></code></pre></td></tr></table></figure><h3 id="6-9-开发场景"><a href="#6-9-开发场景" class="headerlink" title="6.9 开发场景"></a>6.9 开发场景</h3><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p><p>答：不是的</p><p><strong>问题2：建和不建外键约束有什么区别？</strong></p><p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p><p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p><p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p><p>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><h3 id="6-10-阿里开发规范"><a href="#6-10-阿里开发规范" class="headerlink" title="6.10 阿里开发规范"></a>6.10 阿里开发规范</h3><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p><h2 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h3><p>检查某个字段的值是否符合xx要求，一般指的是值的范围</p><h3 id="2、关键字"><a href="#2、关键字" class="headerlink" title="2、关键字"></a>2、关键字</h3><p>CHECK</p><h3 id="3、说明：MySQL-5-7-不支持"><a href="#3、说明：MySQL-5-7-不支持" class="headerlink" title="3、说明：MySQL 5.7 不支持"></a>3、说明：MySQL 5.7 不支持</h3><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p><p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key,<br>    ename varchar(5),<br>    gender char check (&#x27;男&#x27; or &#x27;女&#x27;)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into employee values(1,&#x27;张三&#x27;,&#x27;妖&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from employee;<br>+-----+-------+--------+<br>| eid | ename | gender |<br>+-----+-------+--------+<br>|   1 | 张三   | 妖     |<br>+-----+-------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE temp(<br>id INT AUTO_INCREMENT,<br>NAME VARCHAR(20),<br>age INT CHECK(age &gt; 20),<br>PRIMARY KEY(id)<br>);<br></code></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">age tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’))<br></code></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHECK(height&gt;=0 AND height&lt;3)<br></code></pre></td></tr></table></figure><h2 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a>8. DEFAULT约束</h2><h3 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a>8.1 作用</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h3 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a>8.2 关键字</h3><p>DEFAULT</p><h3 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8.3 如何给字段加默认值"></a>8.3 如何给字段加默认值</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名  数据类型  primary key,<br>    字段名  数据类型  unique key not null,  <br>    字段名  数据类型  unique key,<br>    字段名  数据类型  not null default 默认值, <br>);<br>create table 表名称(<br>字段名  数据类型 default 默认值 ,<br>    字段名  数据类型 not null default 默认值,  <br>    字段名  数据类型 not null default 默认值,<br>    primary key(字段名),<br>    unique key(字段名)<br>);<br><br>说明：默认值约束一般不在唯一键和主键列上加<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key,<br>    ename varchar(20) not null,<br>    gender char default &#x27;男&#x27;,<br>    tel char(11) not null default &#x27;&#x27; #默认是空字符串<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| eid    | int(11)     | NO   | PRI | NULL    |       |<br>| ename  | varchar(20) | NO   |     | NULL    |       |<br>| gender | char(1)     | YES  |     | 男      |       |<br>| tel    | char(11)    | NO   |     |         |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into employee values(1,&#x27;汪飞&#x27;,&#x27;男&#x27;,&#x27;13700102535&#x27;); #成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from employee;<br>+-----+-------+--------+-------------+<br>| eid | ename | gender | tel         |<br>+-----+-------+--------+-------------+<br>|   1 | 汪飞  | 男     | 13700102535 |<br>+-----+-------+--------+-------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into employee(eid,ename) values(2,&#x27;天琪&#x27;); #成功<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from employee;<br>+-----+-------+--------+-------------+<br>| eid | ename | gender | tel         |<br>+-----+-------+--------+-------------+<br>|   1 | 汪飞  | 男     | 13700102535 |<br>|   2 | 天琪  | 男     |             |<br>+-----+-------+--------+-------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into employee(eid,ename) values(3,&#x27;二虎&#x27;);<br>#ERROR 1062 (23000): Duplicate entry &#x27;&#x27; for key &#x27;tel&#x27;  <br>#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功<br></code></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE myemp(<br>id INT AUTO_INCREMENT PRIMARY KEY,<br>NAME VARCHAR(15),<br>salary DOUBLE(10,2) DEFAULT 2000<br>);<br></code></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 default 默认值;<br><br>#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了<br>#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了<br>alter table 表名称 modify 字段名 数据类型 default 默认值 not null;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key,<br>    ename varchar(20),<br>    gender char,<br>    tel char(11) not null<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| eid    | int(11)     | NO   | PRI | NULL    |       |<br>| ename  | varchar(20) | YES  |     | NULL    |       |<br>| gender | char(1)     | YES  |     | NULL    |       |<br>| tel    | char(11)    | NO   |     | NULL    |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table employee modify gender char default &#x27;男&#x27;;  #给gender字段增加默认值约束<br>alter table employee modify tel char(11) default &#x27;&#x27;; #给tel字段增加默认值约束<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| eid    | int(11)     | NO   | PRI | NULL    |       |<br>| ename  | varchar(20) | YES  |     | NULL    |       |<br>| gender | char(1)     | YES  |     | 男      |       |<br>| tel    | char(11)    | YES  |     |         |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table employee modify tel char(11) default &#x27;&#x27;  not null;#给tel字段增加默认值约束，并保留非空约束<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| eid    | int(11)     | NO   | PRI | NULL    |       |<br>| ename  | varchar(20) | YES  |     | NULL    |       |<br>| gender | char(1)     | YES  |     | 男      |       |<br>| tel    | char(11)    | NO   |     |         |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8.4 如何删除默认值约束"></a>8.4 如何删除默认值约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束<br><br>alter table 表名称 modify 字段名 数据类型  not null; #删除默认值约束，保留非空约束<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除<br>alter table employee modify tel char(11)  not null;#删除tel字段默认值约束，保留非空约束<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employee;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| eid    | int(11)     | NO   | PRI | NULL    |       |<br>| ename  | varchar(20) | YES  |     | NULL    |       |<br>| gender | char(1)     | YES  |     | NULL    |       |<br>| tel    | char(11)    | NO   |     | NULL    |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a>9. 面试</h2><p><strong>面试1、为什么建表时，加 not null default ‘’ （字符串类型）或 default 0（数字类型）</strong></p><p>答：不想让表中出现null值。</p><p><strong>面试2、为什么不想要 null 的值</strong></p><p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</p><div class="code-wrapper"><pre><code class="hljs"> （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default &#39;&#39; 或 default 0</code></pre></div><p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong><br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p><p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong><br>外键约束（FOREIGN KEY）不能跨引擎使用。</p><p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p><p>对每个表选择存储引擎格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#对于创建表时的定义，可以仿照下面指令返回的格式来写<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220314234125501.png"></p><h1 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章_视图"></a>第14章_视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证<strong>数据完整性</strong>的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table><h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555430281798.png"></p><h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2.1 为什么使用视图？"></a>2.1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p><p>刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p><h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2.2 视图的理解"></a>2.2 视图的理解</h3><ul><li><p>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p></li><li><p><strong>视图建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong>。（SELECT语句中涉及到的表）</p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211006211206990.png" alt="" style="zoom:67%;" /></li><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong> </p><ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。<strong>不过，视图中的字段可能在基表中存在一一对应的字段；也可能在基表中不存在一一对应的字段</strong>。</li></ul></li><li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p></li></ul><h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><ul><li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [OR REPLACE] <br>[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] <br>VIEW 视图名称 [(字段列表)]<br>AS 查询语句<br>[WITH [CASCADED|LOCAL] CHECK OPTION]<br></code></pre></td></tr></table></figure><ul><li>精简版</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW 视图名称 <br>AS 查询语句<br></code></pre></td></tr></table></figure><h3 id="3-1-创建单表视图"><a href="#3-1-创建单表视图" class="headerlink" title="3.1 创建单表视图"></a>3.1 创建单表视图</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW empvu80<br>AS <br>SELECT  employee_id, last_name, salary<br>FROM    employees<br>WHERE   department_id = 80;<br></code></pre></td></tr></table></figure><p>查询视图：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span>empvu80;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/1555430882363.png" alt="" style="zoom:80%;" /><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#确定视图中字段名的方式1：通过CREATE VIEW 起列别名<br>CREATE VIEW emp_year_salary (ename,year_salary)<br>AS <br>SELECT ename,salary*12*(1+IFNULL(commission_pct,0))<br>FROM t_employee;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#确定视图中字段名的方式2：通过select 语句起列别名<br>CREATE VIEW salvu50<br>AS <br>SELECT  employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY<br>FROM    employees<br>WHERE   department_id = 50;<br></code></pre></td></tr></table></figure><p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p><p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p><h3 id="3-2-创建多表联合视图"><a href="#3-2-创建多表联合视图" class="headerlink" title="3.2 创建多表联合视图"></a>3.2 创建多表联合视图</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW empview <br>AS <br>SELECT employee_id emp_id,last_name NAME,department_name<br>FROM employees e,departments d<br>WHERE e.department_id = d.department_id;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW emp_dept<br>AS <br>SELECT ename,dname<br>FROM t_employee LEFT JOIN t_department<br>ON t_employee.did = t_department.did;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEWdept_sum_vu<br>(name, minsal, maxsal, avgsal)<br>AS <br>SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)<br>FROM employees e, departments d<br>WHERE e.department_id = d.department_id <br>GROUP BY  d.department_name;<br></code></pre></td></tr></table></figure><ul><li><strong>利用视图对数据进行格式化</strong></li></ul><p>我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW emp_depart<br>AS<br>SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept<br>FROM employees e JOIN departments d<br>WHERE e.department_id = d.department_id<br></code></pre></td></tr></table></figure><h3 id="3-3-基于视图创建视图"><a href="#3-3-基于视图创建视图" class="headerlink" title="3.3 基于视图创建视图"></a>3.3 基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW emp_dept_ysalary<br>AS <br>SELECT emp_dept.ename,dname,year_salary<br>FROM emp_dept INNER JOIN emp_year_salary<br>ON emp_dept.ename = emp_year_salary.ename;<br></code></pre></td></tr></table></figure><h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法1：查看数据库的表对象、视图对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure><p>语法2：查看视图的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC / DESCRIBE 视图名称;<br></code></pre></td></tr></table></figure><p>语法3：查看视图的属性信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）<br>SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G<br></code></pre></td></tr></table></figure><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法4：查看视图的详细定义信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW 视图名称;<br></code></pre></td></tr></table></figure><h2 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a>5. 更新视图的数据</h2><h3 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5.1 一般情况"></a>5.1 一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句（跟对表的语法一致）对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><p>举例：UPDATE操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;<br>+---------+-------------+<br>| ename   | tel         |<br>+---------+-------------+<br>| 孙洪亮 | 13789098765 |<br>+---------+-------------+<br>1 row in set (0.01 sec)<br><br>mysql&gt; UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;<br>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;<br>+---------+-------------+<br>| ename  | tel         |<br>+---------+-------------+<br>| 孙洪亮 | 13789091234 |<br>+---------+-------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;<br>+---------+-------------+<br>| ename   | tel         |<br>+---------+-------------+<br>| 孙洪亮 | 13789091234 |<br>+---------+-------------+<br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><p>举例：DELETE操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;<br>+---------+-------------+<br>| ename  | tel           |<br>+---------+-------------+<br>| 孙洪亮 | 13789091234 |<br>+---------+-------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; DELETE FROM emp_tel  WHERE ename = &#x27;孙洪亮&#x27;;<br>Query OK, 1 row affected (0.01 sec)<br><br>mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;<br>Empty set (0.00 sec)<br><br>mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;<br>Empty set (0.00 sec)<br><br></code></pre></td></tr></table></figure><h3 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5.2 不可更新的视图"></a>5.2 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个<code>不可更新视图</code>；</li><li>常量视图。</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE OR REPLACE VIEW emp_dept<br>    -&gt; (ename,salary,birthday,tel,email,hiredate,dname)<br>    -&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname<br>    -&gt; FROM t_employee INNER JOIN t_department<br>    -&gt; ON t_employee.did = t_department.did ;<br>Query OK, 0 rows affected (0.01 sec)<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)<br>    -&gt; VALUES(&#x27;张三&#x27;,15000,&#x27;1995-01-08&#x27;,&#x27;18201587896&#x27;,<br>    -&gt; &#x27;zs@atguigu.com&#x27;,&#x27;2022-02-14&#x27;,&#x27;新部门&#x27;);<br>    <br>#ERROR 1393 (HY000): Can not modify more than one base table through a join view &#x27;atguigu_chapter9.emp_dept&#x27;<br><br></code></pre></td></tr></table></figure><p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p></blockquote><h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6.1 修改视图"></a>6.1 修改视图</h3><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW empvu80 #创建视图，如果已经存在则替换（相当于修改视图）<br>(id_number, name, sal, department_id)<br>AS <br>SELECT  employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id # || 在ORACLE中是字符串的连接，MySQL中是or<br>FROM employees<br>WHERE department_id = 80;<br></code></pre></td></tr></table></figure><blockquote><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p></blockquote><p>方式2：ALTER VIEW</p><p>修改视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER VIEW 视图名称 <br>AS<br>查询语句<br></code></pre></td></tr></table></figure><h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6.2 删除视图"></a>6.2 删除视图</h3><ul><li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p></li><li><p>删除视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS 视图名称;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;<br></code></pre></td></tr></table></figure></li><li><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW empvu80;<br></code></pre></td></tr></table></figure></li><li><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p></li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7.1 视图优点"></a>7.1 视图优点</h3><p><strong>1. 操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2. 减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3. 数据安全</strong></p><p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211010211744459.png"></p><p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4. 适应灵活多变的需求</strong><br>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5. 能够分解复杂的查询逻辑</strong><br>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7.2 视图不足"></a>7.2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，<code>可读性不好</code>，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h1 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章_存储过程与函数"></a>第15章_存储过程与函数</h1><p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p><h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h3><p><strong>含义</strong>：存储过程的英文是 <code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p><strong>好处</strong>：</p><p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力<br>2、减少操作过程中的失误，提高效率<br>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）<br>4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p><p><strong>和视图、函数的对比</strong>：</p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，通常不对底层数据表直接操作（通常对基表不做修改，只是做查询），而存储过程是程序化的 SQL，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p><p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<code>没有返回值</code>的。</p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p><p>1、没有参数（无参数无返回）<br>2、仅仅带 IN 类型（有参数无返回）<br>3、仅仅带 OUT 类型（无参数有返回）<br>4、既带 IN 又带 OUT（有参数有返回）<br>5、带 INOUT（有参数有返回）</p><p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p><h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2.1 语法分析"></a>2.1 语法分析</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)<br>[characteristics ...]<br>BEGIN<br>存储过程体<br><br>END<br></code></pre></td></tr></table></figure><p>类似于Java中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;<br><br>方法体;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1、参数前面的符号的意思</p><ul><li><p><code>IN</code>：当前参数为输入参数，也就是表示入参；</p><p>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</p></li><li><p><code>OUT</code>：当前参数为输出参数，也就是表示出参；</p><p>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</p></li><li><p><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</p></li></ul><p>2、形参类型可以是 MySQL数据库中的任意类型。</p><p>3、<code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LANGUAGE SQL<br>| [NOT] DETERMINISTIC<br>| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<br>| SQL SECURITY &#123; DEFINER | INVOKER &#125;<br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure><ul><li><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li><li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li><li><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。<ul><li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li><li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li><li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li><li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li><li>默认情况下，系统会指定为CONTAINS SQL。</li></ul></li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。<ul><li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li><li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li><li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</li></ul><p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p><p>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。<br>2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。<br>3. SET：赋值语句，用于对变量进行赋值。<br>4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。<br></code></pre></td></tr></table></figure><p>5、需要设置新的结束标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER 新的结束标记<br></code></pre></td></tr></table></figure><p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突（防止存储过程还没执行完，就被;识别终止），需要使用DELIMITER改变存储过程的结束符。<strong>当然在结束后，也需要将语句结束符号改回到;</strong></p><p>比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p><p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $<br><br>CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)<br>[characteristics ...]<br>BEGIN<br>sql语句1;<br>sql语句2;<br><br>END $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="2-2-代码举例"><a href="#2-2-代码举例" class="headerlink" title="2.2 代码举例"></a>2.2 代码举例</h3><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $<br><br>CREATE PROCEDURE select_all_data()<br>BEGIN<br>SELECT * FROM emps;<br><br>END $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE avg_employee_salary ()<br>BEGIN<br>SELECT AVG(salary) AS avg_salary FROM emps;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE show_max_salary()<br>LANGUAGE SQL<br>NOT DETERMINISTIC<br>CONTAINS SQL<br>SQL SECURITY DEFINER<br>COMMENT &#x27;查看最高薪资&#x27;<br>BEGIN<br>SELECT MAX(salary) FROM emps;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)<br>BEGIN<br>SELECT MIN(salary) INTO ms FROM emps;<br>END //<br><br>DELIMITER ;<br><br>#调用<br>CALL show_min_salary(@ms); #@代表用户定义的变量<br><br>SELECT @ms; #查看变量值<br></code></pre></td></tr></table></figure><p>举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))<br>BEGIN<br>SELECT salary FROM emps WHERE ename = empname;<br>END //<br><br>DELIMITER ;<br><br>#调用方式1<br>CALL show_someone_salary(&#x27;Abel&#x27;);<br>#调用方式2<br>SET @empname := &#x27;Able&#x27;; #或者 SET @empname = &#x27;Able&#x27;;<br>CALL show_someone_salary(@empname);<br></code></pre></td></tr></table></figure><p>举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)<br>BEGIN<br>SELECT salary INTO empsalary FROM emps WHERE ename = empname;<br>END //<br><br>DELIMITER ;<br><br>#调用<br>SET @empname = &#x27;Abel&#x27;;<br>CALL show_someone_salary2(@empname, @empsalary);<br>SELECT @empsalary;<br></code></pre></td></tr></table></figure><p>举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))<br>BEGIN<br>SELECT ename INTO empname FROM emps<br>WHERE eid = (SELECT MID FROM emps WHERE ename=empname);<br>END //<br><br>DELIMITER ;<br><br>#调用<br>SET @empname = &#x27;Abel&#x27;;<br>CALL show_mgr_name(@empname);<br>SELECT @empname;<br></code></pre></td></tr></table></figure><h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><h3 id="3-1-调用格式"><a href="#3-1-调用格式" class="headerlink" title="3.1 调用格式"></a>3.1 调用格式</h3><p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL 存储过程名(实参列表)<br></code></pre></td></tr></table></figure><p><strong>格式：</strong></p><p>1、调用in模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL sp1(&#x27;值&#x27;);<br></code></pre></td></tr></table></figure><p>2、调用out模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @name;<br>CALL sp1(@name);<br>SELECT @name;<br></code></pre></td></tr></table></figure><p>3、调用inout模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @name=值;<br>CALL sp1(@name);<br>SELECT @name;<br></code></pre></td></tr></table></figure><h3 id="3-2-代码举例"><a href="#3-2-代码举例" class="headerlink" title="3.2 代码举例"></a>3.2 代码举例</h3><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)<br>BEGIN<br>SELECT COUNT(*) INTO num FROM fruits <br>WHERE s_id = sid;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CALL CountProc (101, @num);<br>Query OK, 1 row affected (0.00 sec)<br></code></pre></td></tr></table></figure><p>查看返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT @num;<br></code></pre></td></tr></table></figure><p>该存储过程返回了指定 s_id=101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为3。</p><p><strong>举例2：</strong>创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE `add_num`(IN n INT)<br>BEGIN<br>       DECLARE i INT;<br>       DECLARE sum INT;<br>       <br>       SET i = 1;<br>       SET sum = 0;<br>       WHILE i &lt;= n DO<br>              SET sum = sum + i;<br>              SET i = i +1;<br>       END WHILE;<br>       SELECT sum;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</p><p>直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。</p><h3 id="3-3-如何调试"><a href="#3-3-如何调试" class="headerlink" title="3.3 如何调试"></a>3.3 如何调试</h3><p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境，难以Debug。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样<code>逐步推进</code>，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p><h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p><h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4.1 语法分析"></a>4.1 语法分析</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION 函数名(参数名 参数类型,...) <br>RETURNS 返回值类型<br>[characteristics ...]<br>BEGIN<br>函数体   #函数体中肯定有 RETURN 语句<br><br>END<br></code></pre></td></tr></table></figure><p>说明：</p><p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p><p>2、RETURNS type 语句表示函数返回数据的类型；</p><p>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p><p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p><p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p><h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4.2 调用存储函数"></a>4.2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是<code>用户自己定义</code>的，而内部函数是MySQL的<code>开发者定义</code>的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 函数名(实参列表)<br></code></pre></td></tr></table></figure><h3 id="4-3-代码举例"><a href="#4-3-代码举例" class="headerlink" title="4.3 代码举例"></a>4.3 代码举例</h3><p><strong>举例1：</strong></p><p>创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE FUNCTION email_by_name()<br>RETURNS VARCHAR(25)<br>DETERMINISTIC<br>CONTAINS SQL<br>BEGIN<br>RETURN (SELECT email FROM employees WHERE last_name = &#x27;Abel&#x27;);<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT email_by_name();<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE FUNCTION email_by_id(emp_id INT)<br>RETURNS VARCHAR(25)<br>DETERMINISTIC<br>CONTAINS SQL<br>BEGIN<br>RETURN (SELECT email FROM employees WHERE employee_id = emp_id);<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @emp_id = 102;<br>SELECT email_by_id(@emp_id);<br>#or<br>SELECT email_by_id(102);<br></code></pre></td></tr></table></figure><p><strong>举例3：</strong></p><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE FUNCTION count_by_id(dept_id INT)<br>RETURNS INT<br>LANGUAGE SQL<br>NOT DETERMINISTIC<br>READS SQL DATA<br>SQL SECURITY DEFINER<br>COMMENT &#x27;查询部门平均工资&#x27;<br>BEGIN<br>RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @dept_id = 50;<br>SELECT count_by_id(@dept_id);<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p><ul><li>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</li></ul><ul><li>方式2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;<br></code></pre></td></tr></table></figure><h3 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4.4 对比存储函数和存储过程"></a>4.4 对比存储函数和存储过程</h3><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有0个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p><h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5.1 查看"></a>5.1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p><p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p><p><strong>1. 使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p><p>基本语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE FUNCTION test_db.CountProc \G<br></code></pre></td></tr></table></figure><p><strong>2. 使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p><p>基本语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]<br></code></pre></td></tr></table></figure><p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p><p>[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。<br>举例：SHOW STATUS语句示例，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW PROCEDURE STATUS LIKE &#x27;SELECT%&#x27; \G <br>*************************** 1. row ***************************<br>                  Db: test_db<br>                Name: SelectAllData<br>                Type: PROCEDURE<br>             Definer: root@localhost<br>            Modified: 2021-10-16 15:55:07<br>             Created: 2021-10-16 15:55:07<br>       Security_type: DEFINER<br>             Comment: <br>character_set_client: utf8mb4<br>collation_connection: utf8mb4_general_ci<br>  Database Collation: utf8mb4_general_ci<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>3. 从information_schema.Routines表中查看存储过程和函数的信息</strong></p><p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.Routines<br>WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];<br></code></pre></td></tr></table></figure><p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p><p>举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.Routines<br>WHERE ROUTINE_NAME=&#x27;count_by_id&#x27;　AND　ROUTINE_TYPE = &#x27;FUNCTION&#x27; \G #此处ROUTINE_TYPE区分大小写，必须写FUNCTION<br></code></pre></td></tr></table></figure><h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5.2 修改"></a>5.2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名<br>[characteristic ...]<br></code></pre></td></tr></table></figure><p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<br>| SQL SECURITY &#123; DEFINER | INVOKER &#125;<br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure><ul><li><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</li><li><code>NO SQL</code>，表示子程序中不包含SQL语句。</li><li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li><li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>，指明谁有权限来执行。<ul><li><code>DEFINER</code>，表示只有定义者自己才能够执行。</li><li><code>INVOKER</code>，表示调用者可以执行。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>，表示注释信息。</li></ul><blockquote><p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p></blockquote><p><strong>举例1：</strong></p><p>修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER　PROCEDURE　CountProc<br>MODIFIES SQL DATA<br>SQL SECURITY INVOKER ;<br></code></pre></td></tr></table></figure><p>查询修改后的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT specific_name,sql_data_access,security_type<br>FROM information_schema.`ROUTINES`<br>WHERE routine_name = &#x27;CountProc&#x27; AND routine_type = &#x27;PROCEDURE&#x27;;<br></code></pre></td></tr></table></figure><p>结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ ACCESS）已经变成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。</p><p><strong>举例2：</strong></p><p>修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER　FUNCTION　CountProc<br>READS SQL DATA<br>COMMENT &#x27;FIND NAME&#x27; ;<br></code></pre></td></tr></table></figure><p>存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。</p><h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a>5.3 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名<br></code></pre></td></tr></table></figure><p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP PROCEDURE CountProc;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FUNCTION CountProc;<br></code></pre></td></tr></table></figure><h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><p>尽管存储过程有诸多优点，但是对于存储过程的使用，<strong>一直都存在着很多争议</strong>，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><p><strong>1、存储过程可以一次编译多次使用。</strong>存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p><p><strong>2、可以减少开发工作量。</strong>将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</p><p><strong>3、存储过程的安全性强。</strong>我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</p><p><strong>4、可以减少网络传输量。</strong>因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p><p><strong>5、良好的封装性。</strong>在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。</p><h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p><blockquote><h4 id="阿里开发规范"><a href="#阿里开发规范" class="headerlink" title="阿里开发规范"></a>阿里开发规范</h4><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p><p><strong>1、可移植性差。</strong>存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p><p><strong>2、调试困难。</strong>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p><p><strong>3、存储过程的版本管理很困难。</strong>比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p><p><strong>4、它不适合高并发的场景。</strong>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，<code>增加数据库的压力</code>，显然就不适用了。</p><p>小结：</p><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p><h1 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章_变量、流程控制与游标"></a>第16章_变量、流程控制与游标</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p><p>在 MySQL 数据库中，变量分为<code>系统变量</code>以及<code>用户自定义变量</code>。</p><h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1.1 系统变量"></a>1.1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1.1.1 系统变量分类"></a>1.1.1 系统变量分类</h4><p>变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址 <code>https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</code> 查看MySQL文档的系统变量。</p><p>系统变量分为全局系统变量（需要添加<code>global</code> 关键字）以及会话系统变量（需要添加 <code>session</code> 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。<strong>如果不写，默认会话级别。</strong>静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。<strong>一个变量可能既是全局系统变量也是会话系统变量(但是取值可能不同，底层有两个系统变量，一个是全局系统变量，一个是会话系统变量），也可能只是全局系统变量，也可能只是会话系统变量。</strong></p><p>当MySQL服务启动后，全局系统变量会被初始化，当客户端连接MySQL服务器之后，会产生对应的会话，这时会话系统变量会被初始化。</p><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211108114846634.png"></p><ul><li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code>。例如<code>SET GLOBAL log_bin_trust_function_creators = 1;</code></li><li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值；并且会话系统变量的修改针对当前会话是有效的，一旦结束会话，重新建立新的会话，该会话系统变量会重新进行初始化（修改失效）。</li><li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li></ul><p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1.1.2 查看系统变量"></a>1.1.2 查看系统变量</h4><ul><li><strong>查看所有或部分系统变量</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br><br>#查看所有会话变量<br>SHOW SESSION VARIABLES;<br>或<br>SHOW VARIABLES; #默认是会话变量<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看满足条件的部分系统变量。<br>SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;<br><br>#查看满足条件的部分会话变量<br>SHOW [SESSION] VARIABLES LIKE &#x27;%标识符%&#x27;; #默认是会话变量g<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GLOBAL VARIABLES LIKE &#x27;admin%&#x27;;<br></code></pre></td></tr></table></figure><ul><li><strong>查看指定系统变量</strong></li></ul><p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看指定的系统变量的值<br>SELECT @@global.变量名;<br><br>#查看指定的会话变量的值<br>SELECT @@session.变量名;<br>#或者<br>SELECT @@变量名;<br></code></pre></td></tr></table></figure><ul><li><strong>修改系统变量的值</strong></li></ul><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：</p><p>方式1：修改MySQL<code>配置文件</code>，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）<strong>重启不失效</strong></p><p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值。<strong>重启失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#为某个系统变量赋值<br>#方式1：<br>SET @@global.变量名=变量值;<br>#方式2：<br>SET GLOBAL 变量名=变量值;<br><br><br>#为某个会话变量赋值<br>#方式1：<br>SET @@session.变量名=变量值;<br>#方式2：<br>SET SESSION 变量名=变量值;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @@global.autocommit;<br>SET GLOBAL autocommit=0;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @@session.tx_isolation;<br>SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL max_connections = 1000;<br>SELECT @@global.max_connections;<br></code></pre></td></tr></table></figure><h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1.2 用户变量"></a>1.2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1.2.1 用户变量分类"></a>1.2.1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头（针对会话用户变量，局部变量不需要用@修饰）。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p><ul><li><p>会话用户变量：使用@开头，作用域和会话变量一样，只对<code>当前连接</code>会话有效。</p></li><li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</p></li></ul><h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1.2.2 会话用户变量"></a>1.2.2 会话用户变量</h4><ul><li>变量的定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：“=”或“:=”<br>SET @用户变量 = 值;<br>SET @用户变量 := 值;<br><br>#方式2：“:=” 或 INTO关键字<br>SELECT @用户变量 := 表达式 [FROM 等子句];<br>SELECT 表达式 INTO @用户变量  [FROM 等子句];<br>#INTO 可以同时赋多个值， 但是 := 不可以同时赋多个值。<br></code></pre></td></tr></table></figure><ul><li>查看用户变量的值 （查看、比较、运算等）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @用户变量<br></code></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @a = 1;<br><br>SELECT @a;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @num := COUNT(*) FROM employees;<br><br>SELECT @num;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(salary) INTO @avgsalary FROM employees;<br><br>SELECT @avgsalary;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @big;  #查看某个未声明的变量时，将得到NULL值<br></code></pre></td></tr></table></figure><h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1.2.3 局部变量"></a>1.2.3 局部变量</h4><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p><code>DECLARE</code>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN<br>#声明局部变量<br>DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];<br>DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];<br><br>#为局部变量赋值<br>SET 变量名1 = 值;<br>SELECT 值 INTO 变量名2 [FROM 子句];<br><br>#查看局部变量的值<br>SELECT 变量1,变量2,变量3;<br>END<br><br></code></pre></td></tr></table></figure><p><strong>1.声明变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE　myparam　INT　DEFAULT 100;<br></code></pre></td></tr></table></figure><p><strong>2.变量赋值</strong></p><p>方式1：一般用于赋简单的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 变量名=值;<br>SET 变量名:=值;<br></code></pre></td></tr></table></figure><p>方式2：一般用于赋表中的字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段名或表达式 INTO 变量名 FROM 表;<br></code></pre></td></tr></table></figure><p><strong>3.使用变量</strong>（查看、比较、运算等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 局部变量名;<br></code></pre></td></tr></table></figure><p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE set_value()<br>BEGIN<br>DECLARE emp_name VARCHAR(25);<br>DECLARE sal DOUBLE(10,2);<br><br>SELECT last_name,salary INTO emp_name,sal #INTO 可以同时赋多个值， 但是 := 不可以同时赋多个值。<br>FROM employees <br>WHERE employee_id = 102;<br><br>SELECT emp_name,sal;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：使用用户变量<br>SET @m=1;<br>SET @n=1;<br>SET @sum=@m+@n;<br><br>SELECT @sum;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式2：使用局部变量<br>DELIMITER //<br><br>CREATE PROCEDURE add_value()<br>BEGIN<br>#局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 3;<br>DECLARE SUM INT;<br><br>SET SUM = m+n;<br>SELECT SUM;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#声明<br>DELIMITER //<br><br>CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)<br>BEGIN<br>#声明局部变量<br>DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;<br>DECLARE mgr_id INT;<br><br>SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;<br>SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;<br>SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;<br>SET dif_salary = mgr_sal - emp_sal;<br><br>END //<br><br>DELIMITER ;<br><br>#调用<br>SET @emp_id = 102;<br>CALL different_salary(@emp_id,@diff_sal);<br><br><br>#查看<br>SELECT @diff_sal;<br></code></pre></td></tr></table></figure><h4 id="1-2-4-对比会话用户变量与局部变量"><a href="#1-2-4-对比会话用户变量与局部变量" class="headerlink" title="1.2.4 对比会话用户变量与局部变量"></a>1.2.4 对比会话用户变量与局部变量</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">  作用域声明位置  语法<br>会话用户变量  当前会话   会话的任何地方加@符号，不用指定类型<br>局部变量   定义它的<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">END</span>中 <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">END</span>的第一句话  一般不用加@,需要指定类型<br></code></pre></td></tr></table></figure><h2 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a>2. 定义条件与处理程序</h2><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><h3 id="2-1-案例分析"><a href="#2-1-案例分析" class="headerlink" title="2.1 案例分析"></a>2.1 案例分析</h3><p><strong>案例分析：</strong>创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE UpdateDataNoCondition()<br>BEGIN<br>SET @x = 1; #定义用户会话变量，主要是想检测程序执行到了哪里<br>UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 2;<br>UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 3;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CALL UpdateDataNoCondition();<br>ERROR 1048 (23000): Column &#x27;email&#x27; cannot be null<br><br>mysql&gt; SELECT @x;<br>+------+<br>| @x   |<br>+------+<br>|   1  |<br>+------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p><h3 id="2-2-定义条件"><a href="#2-2-定义条件" class="headerlink" title="2.2 定义条件"></a>2.2 定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中。</p><p>定义条件使用DECLARE语句，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 错误名称 CONDITION FOR 错误码;<br>#或者<br>DECLARE 错误名称 CONDITION FOR SQLSTATE &#x27;错误条件&#x27;; #错误条件是字符串，需要加上&#x27;&#x27;，防止被转换为其他数据类型<br></code></pre></td></tr></table></figure><p>错误码的说明：</p><ul><li><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。<ul><li>MySQL_error_code是数值类型错误代码。</li><li>sqlstate_value是长度为5的字符串类型错误代码。</li></ul></li><li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</li><li>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</li></ul><p><strong>举例1：</strong>定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#使用MySQL_error_code<br>DECLARE Field_Not_Be_NULL CONDITION FOR 1048;<br><br>#使用sqlstate_value<br>DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong>定义”ERROR 1148(42000)”错误，名称为command_not_allowed。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#使用MySQL_error_code<br>DECLARE command_not_allowed CONDITION FOR 1148;<br><br>#使用sqlstate_value<br>DECLARE command_not_allowed CONDITION FOR SQLSTATE &#x27;42000&#x27;;<br></code></pre></td></tr></table></figure><h3 id="2-3-定义处理程序"><a href="#2-3-定义处理程序" class="headerlink" title="2.3 定义处理程序"></a>2.3 定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句<br></code></pre></td></tr></table></figure><ul><li><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。<ul><li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li><li><code>EXIT</code>：表示遇到错误马上退出。</li><li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li></ul></li><li><strong>错误类型</strong>（即条件）可以有如下取值：<ul><li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为5的sqlstate_value类型的错误代码；</li><li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li><li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li><li><code>SQLWARNING</code>：匹配所有以01开头的sqlstate_value错误代码；</li><li><code>NOT FOUND</code>：匹配所有以02开头的sqlstate_value错误代码；</li><li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value错误代码；</li></ul></li><li><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li></ul><p>定义处理程序的几种方式，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方法1：捕获sqlstate_value<br>DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br><br>#方法2：捕获mysql_error_value<br>DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br><br>#方法3：先定义条件，再调用<br>DECLARE no_such_table CONDITION FOR 1146;<br>DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br><br>#方法4：使用SQLWARNING<br>DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;<br><br>#方法5：使用NOT FOUND<br>DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br><br>#方法6：使用SQLEXCEPTION<br>DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;<br></code></pre></td></tr></table></figure><h3 id="2-4-案例解决"><a href="#2-4-案例解决" class="headerlink" title="2.4 案例解决"></a>2.4 案例解决</h3><p>在存储过程中，定义处理程序，捕获MySQL_error_code值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE UpdateDataNoCondition()<br>BEGIN<br>#定义处理程序<br>DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;<br><br>SET @x = 1;<br>UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 2;<br>UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 3;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CALL UpdateDataWithCondition();<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SELECT @x,@proc_value;<br>+------+-------------+<br>| @x   | @proc_value |<br>+------+-------------+<br>|    3 |        -1  |<br>+------+-------------+<br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><p><strong>举例：</strong></p><p>创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#准备工作<br>CREATE TABLE departments<br>AS<br>SELECT * FROM atguigudb.`departments`;<br><br>ALTER TABLE departments<br>ADD CONSTRAINT uk_dept_name UNIQUE(department_id);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE InsertDataWithCondition()<br>BEGIN<br>DECLARE duplicate_entry CONDITION FOR SQLSTATE &#x27;23000&#x27; ;<br>DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;<br><br>SET @x = 1;<br>INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);<br>SET @x = 2;<br>INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);<br>SET @x = 3;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CALL InsertDataWithCondition();<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SELECT @x,@proc_value;<br>+------+-------------+<br>| @x   | @proc_value |<br>+------+-------------+<br>|    2 |        -1  |<br>+------+-------------+<br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><h2 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a>3. 流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p><ul><li><code>顺序结构</code>：程序从上往下依次执行</li><li><code>分支结构</code>：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li><li><code>循环结构</code>：程序满足一定条件下，重复执行一组语句</li></ul><p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p><ul><li><code>条件判断语句</code>：IF 语句和 CASE 语句</li><li><code>循环语句</code>：LOOP、WHILE 和 REPEAT 语句</li><li><code>跳转语句</code>：ITERATE 和 LEAVE 语句</li></ul><h3 id="3-1-分支结构之-IF"><a href="#3-1-分支结构之-IF" class="headerlink" title="3.1 分支结构之 IF"></a>3.1 分支结构之 IF</h3><ul><li>IF 语句的语法结构是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF 表达式1 THEN 操作1<br>[ELSEIF 表达式2 THEN 操作2]……<br>[ELSE 操作N] #注意最后一个ELSE没有表达式，因为没有表达式所以没有THEN<br>END IF<br></code></pre></td></tr></table></figure><p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p><ul><li><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p></li><li><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF val IS NULL <br>THEN SELECT &#x27;val is null&#x27;;<br>ELSE SELECT &#x27;val is not null&#x27;;<br><br>END IF;<br></code></pre></td></tr></table></figure></li><li><p><strong>举例2：</strong>声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)<br>BEGIN<br>DECLARE emp_salary DOUBLE;<br>DECLARE hire_year DOUBLE;<br><br>SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;<br><br>SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year<br>FROM employees WHERE employee_id = emp_id;<br><br>IF emp_salary &lt; 8000 AND hire_year &gt; 5<br>THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;<br>END IF;<br>END //<br><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure></li><li><p><strong>举例3：</strong>声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)<br>BEGIN<br>DECLARE emp_salary DOUBLE;<br>DECLARE hire_year DOUBLE;<br><br>SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;<br><br>SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year<br>FROM employees WHERE employee_id = emp_id;<br><br>IF emp_salary &lt; 8000 AND hire_year &gt; 5<br>THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;<br>ELSE <br>UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;<br>END IF;<br>END //<br><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure></li><li><p><strong>举例4：</strong>声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)<br>BEGIN<br>DECLARE emp_salary DOUBLE;<br>DECLARE bonus DECIMAL(3,2);<br><br>SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;<br>SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;<br><br>IF emp_salary &lt; 9000<br>THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;<br>ELSEIF emp_salary &lt; 10000 AND bonus IS NULL<br>THEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;<br>ELSE<br>UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;<br>END IF;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a>3.2 分支结构之 CASE</h3><p>CASE 语句的语法结构1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#情况一：类似于switch<br>CASE 表达式<br>WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) <br>WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)<br>...<br>[ELSE 结果n或语句n(如果是语句，需要加分号)]<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure><p>CASE 语句的语法结构2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#情况二：类似于多重if<br>CASE <br>WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) <br>WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)<br>...<br>[ELSE 结果n或语句n(如果是语句，需要加分号)]<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure><ul><li><strong>举例1：</strong></li></ul><p>使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE val<br>　　　WHEN 1 THEN SELECT &#x27;val is 1&#x27;;<br>　　　WHEN 2 THEN SELECT &#x27;val is 2&#x27;;<br>　　　ELSE SELECT &#x27;val is not 1 or 2&#x27;;<br>END CASE;<br></code></pre></td></tr></table></figure><ul><li><strong>举例2：</strong></li></ul><p>使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE<br>WHEN val IS NULL THEN SELECT &#x27;val is null&#x27;;<br>WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;<br>WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;;<br>ELSE SELECT &#x27;val is 0&#x27;;<br>END CASE;<br></code></pre></td></tr></table></figure><ul><li><strong>举例3：</strong>声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)<br>BEGIN<br>DECLARE emp_sal DOUBLE;<br>DECLARE bonus DECIMAL(3,2);<br><br>SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;<br>SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;<br><br>CASE<br>WHEN emp_sal&lt;9000<br>THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;<br>WHEN emp_sal&lt;10000 AND bonus IS NULL<br>THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;<br>ELSE<br>UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;<br>END CASE;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><ul><li>举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年，薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)<br>BEGIN<br>DECLARE emp_sal DOUBLE;<br>DECLARE hire_year DOUBLE;<br><br>SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;<br><br>SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365, 0) INTO hire_year FROM employees WHERE employee_id = emp_id;<br><br>CASE hire_year<br>WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;<br>WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;<br>WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;<br>WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;<br>WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;<br>ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;<br>END CASE;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="3-3-循环结构之LOOP"><a href="#3-3-循环结构之LOOP" class="headerlink" title="3.3 循环结构之LOOP"></a>3.3 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p><p>LOOP语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[loop_label:] LOOP<br>循环执行的语句<br>END LOOP [loop_label]<br></code></pre></td></tr></table></figure><p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p><p><strong>举例1：</strong></p><p>使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE id INT DEFAULT 0;<br>add_loop:LOOP<br>SET id = id +1;<br>IF id &gt;= 10 THEN LEAVE add_loop;<br>END IF;<br><br>END LOOP add_loop;<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong>当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_loop(OUT num INT)<br>BEGIN<br>DECLARE avg_salary DOUBLE;<br>DECLARE loop_count INT DEFAULT 0;<br><br>SELECT AVG(salary) INTO avg_salary FROM employees;<br><br>label_loop:LOOP<br>IF avg_salary &gt;= 12000 THEN LEAVE label_loop;<br>END IF;<br><br>UPDATE employees SET salary = salary * 1.1;<br>SET loop_count = loop_count + 1;<br>SELECT AVG(salary) INTO avg_salary FROM employees;<br>END LOOP label_loop;<br><br>SET num = loop_count;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="3-4-循环结构之WHILE"><a href="#3-4-循环结构之WHILE" class="headerlink" title="3.4 循环结构之WHILE"></a>3.4 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[while_label:] WHILE 循环条件  DO<br>循环体<br>END WHILE [while_label];<br></code></pre></td></tr></table></figure><p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。</p><p><strong>举例1：</strong></p><p>WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE test_while()<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br><br>WHILE i &lt; 10 DO<br>SET i = i + 1;<br>END WHILE;<br><br>SELECT i;<br>END //<br><br>DELIMITER ;<br>#调用<br>CALL test_while();<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong>市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_while(OUT num INT)<br>BEGIN<br>DECLARE avg_sal DOUBLE ;<br>DECLARE while_count INT DEFAULT 0;<br><br>SELECT AVG(salary) INTO avg_sal FROM employees;<br><br>WHILE avg_sal &gt; 5000 DO<br>UPDATE employees SET salary = salary * 0.9;<br><br>SET while_count = while_count + 1;<br><br>SELECT AVG(salary) INTO avg_sal FROM employees;<br>END WHILE;<br><br>SET num = while_count;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="3-5-循环结构之REPEAT"><a href="#3-5-循环结构之REPEAT" class="headerlink" title="3.5 循环结构之REPEAT"></a>3.5 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果<strong>满足条件就退出</strong>，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。<strong>这里的REPEAT和高级语言中的do while刚好相反，REPEAT满足条件退出，do while是满足条件才继续。</strong></p><p>REPEAT语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[repeat_label:] REPEAT<br>　　　　循环体的语句<br>UNTIL 结束循环的条件表达式 #注意UNTIL表达式的分号不要加，加上分号会报错<br>END REPEAT [repeat_label]<br></code></pre></td></tr></table></figure><p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE test_repeat()<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br><br>REPEAT <br>SET i = i + 1;<br>UNTIL i &gt;= 10<br>END REPEAT;<br><br>SELECT i;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong>当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE update_salary_repeat(OUT num INT)<br>BEGIN<br>DECLARE avg_sal DOUBLE ;<br>DECLARE repeat_count INT DEFAULT 0;<br><br>SELECT AVG(salary) INTO avg_sal FROM employees;<br><br>REPEAT<br>UPDATE employees SET salary = salary * 1.15;<br><br>SET repeat_count = repeat_count + 1;<br><br>SELECT AVG(salary) INTO avg_sal FROM employees;<br>UNTIL avg_sal &gt;= 13000<br>END REPEAT;<br><br>SET num = repeat_count;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p><strong>对比三种循环结构：</strong></p><p>1、这三种循环都可以省略标签，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加标签。<br>2、<br>LOOP：一般用于实现简单的”死”循环<br>WHILE：先判断后执行<br>REPEAT：先执行后判断，无条件至少执行一次</p><h3 id="3-6-跳转语句之LEAVE语句"><a href="#3-6-跳转语句之LEAVE语句" class="headerlink" title="3.6 跳转语句之LEAVE语句"></a>3.6 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p><p>基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LEAVE 标记名<br></code></pre></td></tr></table></figure><p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p><p><strong>举例1：</strong>创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。</p><ul><li>如果num&lt;=0，则使用LEAVE语句退出BEGIN…END；</li><li>如果num=1，则查询“employees”表的平均薪资；</li><li>如果num=2，则查询“employees”表的最低薪资；</li><li>如果num&gt;2，则查询“employees”表的最高薪资。</li></ul><p>IF语句结束后查询“employees”表的总人数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE leave_begin(IN num INT)<br><br>begin_label: BEGIN<br>IF num&lt;=0 <br>THEN LEAVE begin_label;<br>ELSEIF num=1 <br>THEN SELECT AVG(salary) FROM employees;<br>ELSEIF num=2 <br>THEN SELECT MIN(salary) FROM employees;<br>ELSE <br>SELECT MAX(salary) FROM employees;<br>END IF;<br><br>SELECT COUNT(*) FROM employees;<br>END //<br><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE leave_while(OUT num INT)<br><br>BEGIN <br>#<br>DECLARE avg_sal DOUBLE;#记录平均工资<br>DECLARE while_count INT DEFAULT 0; #记录循环次数<br><br>SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件<br><br>while_label:WHILE TRUE DO  #② 循环条件<br><br>#③ 循环体<br>IF avg_sal &lt;= 10000 THEN<br>LEAVE while_label;<br>END IF;<br><br>UPDATE employees SET salary  = salary * 0.9;<br>SET while_count = while_count + 1;<br><br>#④ 迭代条件<br>SELECT AVG(salary) INTO avg_sal FROM employees;<br><br>END WHILE;<br><br>#赋值<br>SET num = while_count;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="3-7-跳转语句之ITERATE语句"><a href="#3-7-跳转语句之ITERATE语句" class="headerlink" title="3.7 跳转语句之ITERATE语句"></a>3.7 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p><p>语句基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ITERATE label<br></code></pre></td></tr></table></figure><p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p><p><strong>举例：</strong>  定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p><ul><li>如果num &lt; 10，则继续执行循环；</li><li>如果num &gt; 15，则退出循环结构；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE test_iterate()<br><br>BEGIN<br>DECLARE num INT DEFAULT 0;<br><br>my_loop:LOOP<br>SET num = num + 1;<br><br>IF num &lt; 10 <br>THEN ITERATE my_loop;<br>ELSEIF num &gt; 15 <br>THEN LEAVE my_loop;<br>END IF;<br><br>SELECT &#x27;尚硅谷：让天下没有难学的技术&#x27;;<br><br>END LOOP my_loop;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h2 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a>4. 游标</h2><h3 id="4-1-什么是游标（或光标）"><a href="#4-1-什么是游标（或光标）" class="headerlink" title="4.1 什么是游标（或光标）"></a>4.1 什么是游标（或光标）</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是<code>随意定位到某一条记录</code>，并对记录的数据进行处理。</p><p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</strong></p><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标<code>充当了指针的作用</code>，我们可以通过操作游标来对数据行进行操作。</p><p>MySQL中游标可以在存储过程和函数中使用。</p><p>比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,salary FROM employees<br>WHERE salary &gt; 15000;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211111182656990.png"></p><p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p><h3 id="4-2-使用游标步骤"><a href="#4-2-使用游标步骤" class="headerlink" title="4.2 使用游标步骤"></a>4.2 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。<strong>（所以声明的顺序应该是：1.局部变量、2.条件（异常）、3.游标、4.处理程序）</strong></p><p>如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p><p><strong>第一步，声明游标</strong></p><p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE cursor_name CURSOR FOR select_statement; <br></code></pre></td></tr></table></figure><p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE cursor_name CURSOR IS select_statement;<br></code></pre></td></tr></table></figure><p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE cur_emp CURSOR FOR <br>SELECT employee_id,salary FROM employees;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE cursor_fruit CURSOR FOR <br>SELECT f_name, f_price FROM fruits ;<br></code></pre></td></tr></table></figure><p><strong>第二步，打开游标</strong></p><p>打开游标的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OPEN cursor_name<br></code></pre></td></tr></table></figure><p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的<code>逐条读取</code>结果集中的记录做准备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OPEN　cur_emp ;<br></code></pre></td></tr></table></figure><p><strong>第三步，使用游标（从游标中取得数据）</strong></p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FETCH cursor_name INTO var_name [, var_name] ...<br></code></pre></td></tr></table></figure><p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p><p>注意：var_name必须在声明游标之前就定义好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FETCH　cur_emp INTO emp_id, emp_sal ;<br></code></pre></td></tr></table></figure><p>注意：<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p><p><strong>第四步，关闭游标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CLOSE cursor_name<br></code></pre></td></tr></table></figure><p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会<code>占用系统资源</code>，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p><p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CLOSE　cur_emp;<br></code></pre></td></tr></table></figure><h3 id="4-3-举例"><a href="#4-3-举例" class="headerlink" title="4.3 举例"></a>4.3 举例</h3><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)<br><br>BEGIN<br>DECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资<br>DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值<br>DECLARE emp_count INT DEFAULT 0; #记录循环个数<br>#定义游标<br>DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;<br>#打开游标<br>OPEN emp_cursor;<br><br>REPEAT<br>#使用游标（从游标中获取数据）<br>FETCH emp_cursor INTO cursor_salary;<br><br>SET sum_salary = sum_salary + cursor_salary;<br>SET emp_count = emp_count + 1;<br><br>UNTIL sum_salary &gt;= limit_total_salary<br>END REPEAT;<br><br>SET total_count = emp_count;<br>#关闭游标<br>CLOSE emp_cursor;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h3><p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p><p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行**<code>加锁</code>**，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p><p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h2 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a>补充：MySQL 8.0的新特性—全局变量的持久化</h2><p>在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL MAX_EXECUTION_TIME=2000;<br></code></pre></td></tr></table></figure><p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。<br>MySQL 8.0版本新增了<code>SET PERSIST</code>命令。例如，设置服务器的最大连接数为1000：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PERSIST GLOBAL max_connections = 1000;<br>#或者<br>SET PERSIST max_connections = 1000;#PERSIST只能是全局变量，但是还是推荐写上GLOBAL<br></code></pre></td></tr></table></figure><p>MySQL会将该命令的配置保存到数据目录下的<code>mysqld-auto.cnf</code>文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><p>举例：</p><p>查看全局变量max_connections的值，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%max_connections%&#x27;;<br>+------------------------+-------+<br>| Variable_name          | Value |<br>+------------------------+-------+<br>| max_connections        | 151   |<br>| mysqlx_max_connections | 100   |<br>+------------------------+-------+<br>2 rows in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p>设置全局变量max_connections的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set persist max_connections=1000;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><code>重启MySQL服务器</code>，再次查询max_connections的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%max_connections%&#x27;;<br>+------------------------+-------+<br>| Variable_name          | Value |<br>+------------------------+-------+<br>| max_connections        | 1000  |<br>| mysqlx_max_connections | 100   |<br>+------------------------+-------+<br>2 rows in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h1 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章_触发器"></a>第17章_触发器</h1><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如<code>商品信息</code>和<code>库存信息</code>分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p><p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用<code>事务</code>包裹起来，确保这两个操作成为一个<code>原子操作</code>，要么全部执行，要么全部不执行。如果不使用原子操作，要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很<code>容易忘记其中的一步</code>，导致数据缺失。</p><p>这个时候，咱们可以使用触发器。<strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。</strong>这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><h3 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2.1 创建触发器语法"></a>2.1 创建触发器语法</h3><p>创建触发器的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER 触发器名称 <br>&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 <br>FOR EACH ROW <br>触发器执行的语句块;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>表名</code>：表示触发器监控的对象。</li><li><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li><li><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。<ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发。</li></ul></li></ul><ul><li><code>触发器执行的语句块</code>：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块**(当然使用BEGIN…END要使用DELIMITER //，防止复合语句块中的 ; 提前终止BEGIN语句块，使用END //来终止BEGIN语句块）**。</li></ul><h3 id="2-2-代码举例-1"><a href="#2-2-代码举例-1" class="headerlink" title="2.2 代码举例"></a>2.2 代码举例</h3><p><strong>举例1：</strong></p><p>1、创建数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_trigger (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>t_note VARCHAR(30)<br>);<br><br><br>CREATE TABLE test_trigger_log (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>t_log VARCHAR(30)<br>);<br></code></pre></td></tr></table></figure><p>2、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE TRIGGER before_insert<br>BEFORE INSERT ON test_trigger <br>FOR EACH ROW<br>BEGIN<br>INSERT INTO test_trigger_log (t_log)<br>VALUES(&#x27;before_insert&#x27;);<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>3、向test_trigger数据表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);<br></code></pre></td></tr></table></figure><p>4、查看test_trigger_log数据表中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_trigger_log;<br>+----+---------------+<br>| id | t_log         |<br>+----+---------------+<br>|  1 | before_insert |<br>+----+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>1、创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插入after_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE TRIGGER after_insert<br>AFTER INSERT ON test_trigger<br>FOR EACH ROW<br>BEGIN<br>INSERT INTO test_trigger_log (t_log)<br>VALUES(&#x27;after_insert&#x27;);<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>2、向test_trigger数据表中插入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 AFTER INSERT 触发器&#x27;);<br></code></pre></td></tr></table></figure><p>3、查看test_trigger_log数据表中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_trigger_log;<br>+----+---------------+<br>| id | t_log         |<br>+----+---------------+<br>|  1 | before_insert |<br>|  2 | before_insert |<br>|  3 | after_insert  |<br>+----+---------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>举例3：</strong>定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错误，从而使得添加失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br><br>CREATE TRIGGER salary_check_trigger<br>BEFORE INSERT ON employees <br>FOR EACH ROW<br>BEGIN<br>DECLARE mgrsalary DOUBLE;<br>SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id; #NEW代表INSERT语句添加语句的新纪录<br><br>IF NEW.salary &gt; mgrsalary THEN<br>SIGNAL SQLSTATE &#x27;HY000&#x27; SET MESSAGE_TEXT = &#x27;薪资高于领导薪资错误&#x27;; #人为抛异常<br>END IF;<br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p><strong>上面触发器声明过程中的NEW关键字代表INSERT / UPDATE  添加/更新 语句的新记录。OLD关键字代表DELETE / UPDATE 删除/更新语句的旧记录。由于触发器中FOR EACH ROW的存在，此处若有多条语句，会被循环执行NEW / OLD</strong></p><h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3.1 查看触发器"></a>3.1 查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p><p>方式1：查看当前数据库的所有触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS\G<br></code></pre></td></tr></table></figure><p>方式2：查看当前数据库中某个触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TRIGGER 触发器名<br></code></pre></td></tr></table></figure><p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.TRIGGERS;<br></code></pre></td></tr></table></figure><h3 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3.2 删除触发器"></a>3.2 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TRIGGER  IF EXISTS 触发器名称;<br></code></pre></td></tr></table></figure><h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p><strong>1、触发器可以确保数据的完整性</strong>。</p><p>假设我们用<code>进货单头表</code>（demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。</p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211010233336012.png"></p><p>用<code>进货单明细表</code>（demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。</p><p> <img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211010233344125.png"></p><p>每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p><p>为了解决这个问题，我们就可以使用触发器，<strong>规定每当进货单明细表有数据插入、修改和删除的操作时，自动触发 2 步操作：</strong></p><p>1）重新计算进货单明细表中的数量合计和金额合计；</p><p>2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</p><p>这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。</p><p><strong>2、触发器可以帮助我们记录操作日志。</strong></p><p>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p><p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p><p>比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏……这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。</p><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p><p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能<code>不受应用层的控制</code>。这对系统维护是非常有挑战的。</p><p>比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; update demo.membermaster set memberdeposit=20 where memberid = 2;<br>ERROR 1054 (42S22): Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;<br></code></pre></td></tr></table></figure><p>结果显示，系统提示错误，字段“aa”不存在。</p><p>这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p><p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p><p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p><h3 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h3><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器t1。</p><h1 id="第18章-MySQL8其它新特性"><a href="#第18章-MySQL8其它新特性" class="headerlink" title="第18章_MySQL8其它新特性"></a>第18章_MySQL8其它新特性</h1><h2 id="1-MySQL8新特性概述"><a href="#1-MySQL8新特性概述" class="headerlink" title="1. MySQL8新特性概述"></a>1. MySQL8新特性概述</h2><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="1-1-MySQL8-0-新增特性"><a href="#1-1-MySQL8-0-新增特性" class="headerlink" title="1.1 MySQL8.0 新增特性"></a>1.1 MySQL8.0 新增特性</h3><p><strong>1. 更简便的NoSQL支持</strong><br>NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。</p><p><strong>2. 更好的索引</strong><br>在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了<code>隐藏索引</code>和<code>降序索引</code>。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p><p><strong>3.更完善的JSON支持</strong><br>MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数<code>JSON_ARRAYAGG()</code>和<code>JSON_OBJECTAGG()</code>，将参数聚合为JSON数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。</p><p><strong>4.安全和账户管理</strong><br>MySQL 8中新增了<code>caching_sha2_password</code> 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p><p><strong>5.InnoDB的变化</strong><br><code>InnoDB是MySQL默认的存储引擎</code>，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的<code>改进和优化</code>，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p><p><strong>6.数据字典</strong><br>在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p><p><strong>7. 原子数据定义语句</strong><br>MySQL 8开始支持原子数据定义语句（Automic DDL），即<code>原子DDL</code>。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。<br>使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。<br>对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加<code>IF EXISTS</code>或<code>IF NOT EXISTS</code>语句来避免发生错误。</p><p><strong>8.资源管理</strong><br>MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。<br>目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。<br>资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。<br>在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</p><p><strong>9.字符集支持</strong><br>MySQL 8中默认的字符集由<code>latin1</code>更改为<code>utf8mb4</code>（最多四个字节表示一个字符，当然汉字还是占三个字节），并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</p><p><strong>10.优化器增强</strong><br>MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p><p><strong>11.公用表表达式</strong><br>公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前<code>使用WITH语句对临时结果集</code>进行命名。<strong>公用表的作用域是整个会话</strong></p><p>基础语法如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">WITH</span> cte_name (col_name1,col_name2 ...) <span class="hljs-keyword">AS</span> (Subquery)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> cte_name;<br></code></pre></td></tr></table></figure><p>Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。</p><p><strong>12.窗口函数</strong><br>MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分<code>聚合函数</code>在MySQL 8中也可以作为窗口函数来使用。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20210730165317542.png"></p><p><strong>13.正则表达式支持</strong><br>MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p><p><strong>14.内部临时表</strong><br><code>TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎</code>。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。</p><p><strong>15.日志记录</strong><br>在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入。</p><p><strong>16.备份锁</strong><br>新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p><p><strong>17.增强的MySQL复制</strong><br>MySQL 8复制支持对<code>JSON文档</code>进行部分更新的<code>二进制日志记录</code>，该记录<code>使用紧凑的二进制格式</code>，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。</p><h3 id="1-2-MySQL8-0移除的旧特性"><a href="#1-2-MySQL8-0移除的旧特性" class="headerlink" title="1.2 MySQL8.0移除的旧特性"></a>1.2 MySQL8.0移除的旧特性</h3><p>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p><p><strong>1. 查询缓存</strong><br><code>查询缓存已被移除</code>，删除的项有：<br><strong>（1）语句：</strong>FLUSH QUERY CACHE和RESET QUERY CACHE。<br><strong>（2）系统变量：</strong>query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。<br><strong>（3）状态变量：</strong>Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks。<br><strong>（4）线程状态：</strong>checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。</p><p><strong>2.加密相关</strong><br>删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。<br>对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代。</p><p><strong>3.空间函数相关</strong><br>在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被移除，只保留了对应的ST_和MBR函数。</p><p><strong>4.\N和NULL</strong><br>在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</p><p><strong>5. mysql_install_db</strong><br>在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着–initialize或者–initialize-insecure选项的mysqld来代替实现。另外，–bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。</p><p><strong>6.通用分区处理程序</strong><br>通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。<br>提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL 8中只支持InnoDB。</p><p><strong>7.系统和状态变量信息</strong><br>在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p><p><strong>8.mysql_plugin工具</strong><br>mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用–plugin-load或–plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。</p><h2 id="2-新特性1：窗口函数"><a href="#2-新特性1：窗口函数" class="headerlink" title="2. 新特性1：窗口函数"></a>2. 新特性1：窗口函数</h2><h3 id="2-1-使用窗口函数前后对比"><a href="#2-1-使用窗口函数前后对比" class="headerlink" title="2.1 使用窗口函数前后对比"></a>2.1 使用窗口函数前后对比</h3><p>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE sales(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>city VARCHAR(15),<br>county VARCHAR(15),<br>sales_value DECIMAL<br><br>);<br><br>INSERT INTO sales(city,county,sales_value)<br>VALUES<br>(&#x27;北京&#x27;,&#x27;海淀&#x27;,10.00),<br>(&#x27;北京&#x27;,&#x27;朝阳&#x27;,20.00),<br>(&#x27;上海&#x27;,&#x27;黄埔&#x27;,30.00),<br>(&#x27;上海&#x27;,&#x27;长宁&#x27;,10.00);<br></code></pre></td></tr></table></figure><p>查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM sales;<br>+----+------+--------+-------------+<br>| id | city | county | sales_value |<br>+----+------+--------+-------------+<br>|  1 | 北京 | 海淀    |          10 |<br>|  2 | 北京 | 朝阳    |          20 |<br>|  3 | 上海 | 黄埔    |          30 |<br>|  4 | 上海 | 长宁    |          10 |<br>+----+------+--------+-------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>需求：</strong>现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p><p>如果用分组和聚合函数，就需要分好几步来计算。</p><p>第一步，计算总销售金额，并存入临时表 a：</p><p><strong>此处涉及到了临时表的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TEMPORARY TABLE a       -- 创建临时表<br>SELECT SUM(sales_value) AS sales_value -- 计算总计金额<br>FROM sales;<br></code></pre></td></tr></table></figure><p>查看一下临时表 a ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM a;<br>+-------------+<br>| sales_value |<br>+-------------+<br>|          70 |<br>+-------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>第二步，计算每个城市的销售总额并存入临时表 b：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TEMPORARY TABLE b    -- 创建临时表<br>SELECT city,SUM(sales_value) AS sales_value  -- 计算城市销售合计<br>FROM sales<br>GROUP BY city;<br></code></pre></td></tr></table></figure><p>查看临时表 b ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM b;<br>+------+-------------+<br>| city | sales_value |<br>+------+-------------+<br>| 北京 |          30 |<br>| 上海 |          40 |<br>+------+-------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,<br>    -&gt; b.sales_value AS 市销售额,s.sales_value/b.sales_value AS 市比率,<br>    -&gt; a.sales_value AS 总销售额,s.sales_value/a.sales_value AS 总比率<br>    -&gt; FROM sales s<br>    -&gt; JOIN b ON (s.city=b.city) -- 连接市统计结果临时表<br>    -&gt; JOIN a                   -- 连接总计金额临时表<br>    -&gt; ORDER BY s.city,s.county;<br>+------+------+----------+----------+--------+----------+--------+<br>| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |<br>+------+------+----------+----------+--------+----------+--------+<br>| 上海  | 长宁 |       10 |       40 | 0.2500 |       70 | 0.1429 |<br>| 上海  | 黄埔 |       30 |       40 | 0.7500 |       70 | 0.4286 |<br>| 北京  | 朝阳 |       20 |       30 | 0.6667 |       70 | 0.2857 |<br>| 北京  | 海淀 |       10 |       30 | 0.3333 |       70 | 0.1429 |<br>+------+------+----------+----------+--------+----------+--------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p><p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT city AS 城市,county AS 区,sales_value AS 区销售额,<br>    -&gt; SUM(sales_value) OVER(PARTITION BY city) AS 市销售额,  -- 计算市销售额<br>    -&gt; sales_value/SUM(sales_value) OVER(PARTITION BY city) AS 市比率,<br>    -&gt; SUM(sales_value) OVER() AS 总销售额,   -- 计算总销售额<br>    -&gt; sales_value/SUM(sales_value) OVER() AS 总比率<br>    -&gt; FROM sales<br>    -&gt; ORDER BY city,county;<br>+------+------+----------+----------+--------+----------+--------+<br>| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |<br>+------+------+----------+----------+--------+----------+--------+<br>| 上海  | 长宁 |       10 |       40  | 0.2500 |       70 | 0.1429 |<br>| 上海  | 黄埔 |       30 |       40  | 0.7500 |       70 | 0.4286 |<br>| 北京  | 朝阳 |       20 |       30  | 0.6667 |       70 | 0.2857 |<br>| 北京  | 海淀 |       10 |       30  | 0.3333 |       70 | 0.1429 |<br>+------+------+----------+-----------+--------+----------+--------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>结果显示，我们得到了与上面那种查询同样的结果。</p><p>使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然，<strong>在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong>。</p><h3 id="2-2-窗口函数分类"><a href="#2-2-窗口函数分类" class="headerlink" title="2.2 窗口函数分类"></a>2.2 窗口函数分类</h3><p>MySQL从8.0版本开始支持窗口函数。<strong>窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</strong>窗口函数介于单行函数和聚合函数之间，既实现了分组又没有压缩数据行数。</p><p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p>MySQL官方网站窗口函数的网址为<a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number%E3%80%82">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number。</a></p><p>MySQL的窗口函数大致分类如下：</p><ul><li>专用窗口函数：rank()，dense_rank()，row_number()</li><li>聚合函数：max()，min()，count()，sum()，avg()等聚合函数</li></ul><p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20211012162944536.png"></p><h3 id="2-3-语法结构"><a href="#2-3-语法结构" class="headerlink" title="2.3 语法结构"></a>2.3 语法结构</h3><p>窗口函数的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">函数 OVER（[[PARTITION BY 字段名] [ORDER BY 字段名 ASC|DESC]]）<br></code></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">函数 OVER 窗口名 … WINDOW 窗口名 AS （[[PARTITION BY 字段名] [ORDER BY 字段名 ASC|DESC]]）<br></code></pre></td></tr></table></figure><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><h3 id="2-4-分类讲解"><a href="#2-4-分类讲解" class="headerlink" title="2.4 分类讲解"></a>2.4 分类讲解</h3><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE goods(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>category_id INT,<br>category VARCHAR(15),<br>NAME VARCHAR(30),<br>price DECIMAL(10,2),<br>stock INT,<br>upper_time DATETIME<br><br>);<br></code></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)<br>VALUES<br>(1, &#x27;女装/女士精品&#x27;, &#x27;T恤&#x27;, 39.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;连衣裙&#x27;, 79.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;卫衣&#x27;, 89.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;牛仔裤&#x27;, 89.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;百褶裙&#x27;, 29.90, 500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;呢绒外套&#x27;, 399.90, 1200, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;自行车&#x27;, 399.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;山地自行车&#x27;, 1399.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;登山杖&#x27;, 59.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;骑行装备&#x27;, 399.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;运动外套&#x27;, 799.90, 500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;滑板&#x27;, 499.90, 1200, &#x27;2020-11-10 00:00:00&#x27;);<br></code></pre></td></tr></table></figure><p>下面针对goods表中的数据来验证每个窗口函数的功能。</p><h4 id="1-序号函数"><a href="#1-序号函数" class="headerlink" title="1. 序号函数"></a>1. 序号函数</h4><p><strong>1．ROW_NUMBER()函数</strong></p><p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p><p>举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt; id, category_id, category, NAME, price, stock<br>    -&gt; FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id | category      | NAME       | price   | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |<br>|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |<br>|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |<br>|       4 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |<br>|       5 |  1 |           1 | 女装/女士精品   | T恤        |   39.90 |  1000 |<br>|       6 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |<br>|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |<br>|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |<br>|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |<br>|       4 |  7 |           2 | 户外运动       | 自行车      |  399.90 |  1000 |<br>|       5 | 10 |           2 | 户外运动       | 骑行装备    |  399.90 |  3500 |<br>|       6 |  9 |           2 | 户外运动       | 登山杖      |   59.90 |  1500 |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>举例：查询 goods 数据表中每个商品分类下价格最高的3种商品信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT *<br>    -&gt; FROM (<br>    -&gt;  SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt;  id, category_id, category, NAME, price, stock<br>    -&gt;  FROM goods) t<br>    -&gt; WHERE row_num &lt;= 3;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id | category      | NAME       | price   | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90  |  1200 |<br>|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |<br>|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90  |  3500 |<br>|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90  |  2500 |<br>|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90  |   500 |<br>|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90  |  1200 |<br>+---------+----+-------------+---------------+------------+----------+-------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>在名称为“女装/女士精品”的商品类别中，有两款商品的价格为89.90元，分别是卫衣和牛仔裤。两款商品的序号都应该为2，而不是一个为2，另一个为3。此时，可以使用RANK()函数和DENSE_RANK()函数解决。</p><p><strong>2．RANK()函数</strong></p><p><strong>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3（第一个和第二个相等，那么第一个和第二个并列第一）。</strong></p><p>举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt; id, category_id, category, NAME, price, stock<br>    -&gt; FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|<span class="hljs-string"> row_num </span>|<span class="hljs-string"> id </span>|<span class="hljs-string"> category_id </span>|<span class="hljs-string"> category      </span>|<span class="hljs-string"> NAME       </span>|<span class="hljs-string"> price   </span>|<span class="hljs-string"> stock </span>|<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|<span class="hljs-string">       1 </span>|<span class="hljs-string">  6 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 呢绒外套    </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  1200 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string">  3 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 卫衣        </span>|<span class="hljs-string">   89.90 </span>|<span class="hljs-string">  1500 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string">  4 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 牛仔裤      </span>|<span class="hljs-string">   89.90 </span>|<span class="hljs-string">  3500 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string">  2 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 连衣裙      </span>|<span class="hljs-string">   79.90 </span>|<span class="hljs-string">  2500 </span>|<br>|<span class="hljs-string">       5 </span>|<span class="hljs-string">  1 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> T恤         </span>|<span class="hljs-string">   39.90 </span>|<span class="hljs-string">  1000 </span>|<br>|<span class="hljs-string">       6 </span>|<span class="hljs-string">  5 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 百褶裙      </span>|<span class="hljs-string">   29.90 </span>|<span class="hljs-string">   500 </span>|<br>|<span class="hljs-string">       1 </span>|<span class="hljs-string">  8 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 山地自行车   </span>|<span class="hljs-string"> 1399.90 </span>|<span class="hljs-string">  2500 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 运动外套     </span>|<span class="hljs-string">  799.90 </span>|<span class="hljs-string">   500 </span>|<br>|<span class="hljs-string">       3 </span>|<span class="hljs-string"> 12 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 滑板        </span>|<span class="hljs-string">  499.90 </span>|<span class="hljs-string">  1200 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string">  7 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 自行车      </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  1000 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 骑行装备    </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  3500 </span>|<br>|<span class="hljs-string">       6 </span>|<span class="hljs-string">  9 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 登山杖      </span>|<span class="hljs-string">   59.90 </span>|<span class="hljs-string">  1500 </span>|<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>举例：使用RANK()函数获取 goods 数据表中类别为“女装/女士精品”的价格最高的4款商品信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT *<br>    -&gt; FROM(<br>    -&gt;  SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt;  id, category_id, category, NAME, price, stock<br>    -&gt;  FROM goods) t<br>    -&gt; WHERE category_id = 1 AND row_num &lt;= 4;<br>+---------+----+-------------+---------------+----------+--------+-------+<br>| row_num | id | category_id | category      | NAME     | price  | stock |<br>+---------+----+-------------+---------------+----------+--------+-------+<br>|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |<br>|       2 |  3 |           1 | 女装/女士精品   | 卫衣      |  89.90 |  1500 |<br>|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |<br>|       4 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |<br>+---------+----+-------------+---------------+----------+--------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到，使用RANK()函数得出的序号为1、2、2、4，相同价格的商品序号相同，后面的商品序号是不连续的，跳过了重复的序号。</p><p><strong>3．DENSE_RANK()函数</strong></p><p><strong>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。</strong></p><p>举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt; id, category_id, category, NAME, price, stock<br>    -&gt; FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|<span class="hljs-string"> row_num </span>|<span class="hljs-string"> id </span>|<span class="hljs-string"> category_id </span>|<span class="hljs-string"> category      </span>|<span class="hljs-string"> NAME       </span>|<span class="hljs-string"> price   </span>|<span class="hljs-string"> stock </span>|<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|<span class="hljs-string">       1 </span>|<span class="hljs-string">  6 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 呢绒外套    </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  1200 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string">  3 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 卫衣        </span>|<span class="hljs-string">   89.90 </span>|<span class="hljs-string">  1500 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string">  4 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 牛仔裤      </span>|<span class="hljs-string">   89.90 </span>|<span class="hljs-string">  3500 </span>|<br>|<span class="hljs-string">       3 </span>|<span class="hljs-string">  2 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 连衣裙      </span>|<span class="hljs-string">   79.90 </span>|<span class="hljs-string">  2500 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string">  1 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> T恤        </span>|<span class="hljs-string">   39.90 </span>|<span class="hljs-string">  1000 </span>|<br>|<span class="hljs-string">       5 </span>|<span class="hljs-string">  5 </span>|<span class="hljs-string">           1 </span>|<span class="hljs-string"> 女装/女士精品   </span>|<span class="hljs-string"> 百褶裙      </span>|<span class="hljs-string">   29.90 </span>|<span class="hljs-string">   500 </span>|<br>|<span class="hljs-string">       1 </span>|<span class="hljs-string">  8 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 山地自行车   </span>|<span class="hljs-string"> 1399.90 </span>|<span class="hljs-string">  2500 </span>|<br>|<span class="hljs-string">       2 </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 运动外套     </span>|<span class="hljs-string">  799.90 </span>|<span class="hljs-string">   500 </span>|<br>|<span class="hljs-string">       3 </span>|<span class="hljs-string"> 12 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 滑板        </span>|<span class="hljs-string">  499.90 </span>|<span class="hljs-string">  1200 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string">  7 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 自行车       </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  1000 </span>|<br>|<span class="hljs-string">       4 </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 骑行装备     </span>|<span class="hljs-string">  399.90 </span>|<span class="hljs-string">  3500 </span>|<br>|<span class="hljs-string">       5 </span>|<span class="hljs-string">  9 </span>|<span class="hljs-string">           2 </span>|<span class="hljs-string"> 户外运动       </span>|<span class="hljs-string"> 登山杖       </span>|<span class="hljs-string">   59.90 </span>|<span class="hljs-string">  1500 </span>|<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>举例：使用DENSE_RANK()函数获取 goods 数据表中类别为“女装/女士精品”的价格最高的4款商品信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT *<br>    -&gt; FROM(<br>    -&gt;  SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>    -&gt;  id, category_id, category, NAME, price, stock<br>    -&gt;  FROM goods) t<br>    -&gt; WHERE category_id = 1 AND row_num &lt;= 3;<br>+---------+----+-------------+---------------+----------+--------+-------+<br>| row_num | id | category_id | category      | NAME     | price  | stock |<br>+---------+----+-------------+---------------+----------+--------+-------+<br>|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |<br>|       2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90  |  1500 |<br>|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |<br>|       3 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |<br>+---------+----+-------------+---------------+----------+--------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到，使用DENSE_RANK()函数得出的行号为1、2、2、3，相同价格的商品序号相同，后面的商品序号是连续的，并且没有跳过重复的序号。</p><h4 id="2-分布函数"><a href="#2-分布函数" class="headerlink" title="2. 分布函数"></a>2. 分布函数</h4><p><strong>1．PERCENT_RANK()函数</strong></p><p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">注意：对于重复值，计算的时候，取重复值的第一行的位<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(rank - 1) / (rows - 1)<br></code></pre></td></tr></table></figure><p>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p><p>举例：计算 goods 数据表中名称为“女装/女士精品”的类别下的商品的PERCENT_RANK值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#写法一：<br>SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r,<br>PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr,<br>id, category_id, category, NAME, price, stock<br>FROM goods<br>WHERE category_id = 1;<br><br>#写法二：<br>mysql&gt; SELECT RANK() OVER w AS r,<br>    -&gt; PERCENT_RANK() OVER w AS pr,<br>    -&gt; id, category_id, category, NAME, price, stock<br>    -&gt; FROM goods<br>    -&gt; WHERE category_id = 1 WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>| r | pr  | id | category_id | category      | NAME     | price  | stock |<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>| 1 |   0 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |<br>| 2 | 0.2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90 |  1500 |<br>| 2 | 0.2 |  4 |           1 | 女装/女士精品   | 牛仔裤   |  89.90 |  3500  |<br>| 4 | 0.6 |  2 |           1 | 女装/女士精品   | 连衣裙   |  79.90 |  2500  |<br>| 5 | 0.8 |  1 |           1 | 女装/女士精品   | T恤      |  39.90 |  1000 |<br>| 6 |   1 |  5 |           1 | 女装/女士精品   | 百褶裙   |  29.90  |   500 |<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>2．CUME_DIST()函数</strong></p><p>CUME_DIST()函数主要用于查询小于或等于某个值的比例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">计算结果为相对位置/总行数,返回值为(0,1]<br>注意：对于重复值，计算的时候，取重复值的最后一行的位置<br></code></pre></td></tr></table></figure><p>举例：查询goods数据表中小于或等于当前价格的比例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CUME_DIST() OVER(PARTITION BY category_id ORDER BY price ASC) AS cd,<br>    -&gt; id, category, NAME, price<br>    -&gt; FROM goods;<br>+---------------------+----+---------------+------------+---------+<br>| cd                  | id | category      | NAME       | price   |<br>+---------------------+----+---------------+------------+---------+<br>| 0.16666666666666666 |  5 | 女装/女士精品   | 百褶裙      |   29.90 |<br>|  0.3333333333333333 |  1 | 女装/女士精品   | T恤        |   39.90 |<br>|                 0.5 |  2 | 女装/女士精品   | 连衣裙      |   79.90 |<br>|  0.8333333333333334 |  3 | 女装/女士精品   | 卫衣        |   89.90 |<br>|  0.8333333333333334 |  4 | 女装/女士精品   | 牛仔裤      |   89.90 |<br>|                   1 |  6 | 女装/女士精品   | 呢绒外套    |  399.90 |<br>| 0.16666666666666666 |  9 | 户外运动       | 登山杖      |   59.90 |<br>|                 0.5 |  7 | 户外运动       | 自行车      |  399.90 |<br>|                 0.5 | 10 | 户外运动       | 骑行装备     |  399.90 |<br>|  0.6666666666666666 | 12 | 户外运动       | 滑板        |  499.90 |<br>|  0.8333333333333334 | 11 | 户外运动       | 运动外套    |  799.90 |<br>|                   1 |  8 | 户外运动       | 山地自行车   | 1399.90 |<br>+---------------------+----+---------------+------------+---------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-前后函数"><a href="#3-前后函数" class="headerlink" title="3. 前后函数"></a>3. 前后函数</h4><p><strong>1．LAG(expr,n)函数</strong></p><p>LAG(expr,n)函数返回当前行的前n行的expr的值。</p><p>举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price<br>    -&gt; FROM (<br>    -&gt;  SELECT  id, category, NAME, price,LAG(price,1) OVER w AS pre_price<br>    -&gt;  FROM goods<br>    -&gt;  WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;<br>+----+---------------+------------+---------+-----------+------------+<br>| id | category      | NAME       | price   | pre_price | diff_price |<br>+----+---------------+------------+---------+-----------+------------+<br>|  5 | 女装/女士精品   | 百褶裙      |   29.90 |      NULL |       NULL |<br>|  1 | 女装/女士精品   | T恤        |   39.90 |     29.90 |      10.00 |<br>|  2 | 女装/女士精品   | 连衣裙      |   79.90 |     39.90 |      40.00 |<br>|  3 | 女装/女士精品   | 卫衣       |   89.90 |     79.90 |      10.00 |<br>|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |     89.90 |       0.00 |<br>|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |     89.90 |     310.00 |<br>|  9 | 户外运动       | 登山杖      |   59.90 |      NULL |       NULL |<br>|  7 | 户外运动       | 自行车      |  399.90 |     59.90 |     340.00 |<br>| 10 | 户外运动       | 骑行装备    |  399.90 |    399.90 |       0.00 |<br>| 12 | 户外运动       | 滑板       |  499.90 |    399.90 |     100.00 |<br>| 11 | 户外运动       | 运动外套    |  799.90 |    499.90 |     300.00 |<br>|  8 | 户外运动       | 山地自行车  | 1399.90 |    799.90 |     600.00 |<br>+----+---------------+------------+---------+-----------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>2．LEAD(expr,n)函数</strong></p><p>LEAD(expr,n)函数返回当前行的后n行的expr的值。</p><p>举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, behind_price, price,behind_price - price AS diff_price<br>    -&gt; FROM(<br>    -&gt;  SELECT id, category, NAME, price,LEAD(price, 1) OVER w AS behind_price<br>    -&gt;  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;<br>+----+---------------+------------+--------------+---------+------------+<br>| id | category      | NAME       | behind_price | price   | diff_price |<br>+----+---------------+------------+--------------+---------+------------+<br>|  5 | 女装/女士精品   | 百褶裙      |        39.90 |   29.90 |      10.00 |<br>|  1 | 女装/女士精品   | T恤        |        79.90 |   39.90 |      40.00 |<br>|  2 | 女装/女士精品   | 连衣裙      |        89.90 |   79.90 |      10.00 |<br>|  3 | 女装/女士精品   | 卫衣        |        89.90 |   89.90 |       0.00 |<br>|  4 | 女装/女士精品   | 牛仔裤      |       399.90 |   89.90 |     310.00 |<br>|  6 | 女装/女士精品   | 呢绒外套     |         NULL |  399.90 |       NULL |<br>|  9 | 户外运动       | 登山杖       |       399.90 |   59.90 |     340.00 |<br>|  7 | 户外运动       | 自行车       |       399.90 |  399.90 |       0.00 |<br>| 10 | 户外运动       | 骑行装备     |       499.90 |  399.90 |     100.00 |<br>| 12 | 户外运动       | 滑板        |       799.90 |  499.90 |     300.00 |<br>| 11 | 户外运动       | 运动外套     |      1399.90 |  799.90 |     600.00 |<br>|  8 | 户外运动       | 山地自行车   |         NULL | 1399.90 |       NULL |<br>+----+---------------+------------+--------------+---------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="4-首尾函数"><a href="#4-首尾函数" class="headerlink" title="4. 首尾函数"></a>4. 首尾函数</h4><p><strong>1．FIRST_VALUE(expr)函数</strong></p><p>FIRST_VALUE(expr)函数返回第一个expr的值。</p><p>举例：按照价格排序，查询第1个商品的价格信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS first_price<br>    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+-------+-------------+<br>| id | category      | NAME       | price   | stock | first_price |<br>+----+---------------+------------+---------+-------+-------------+<br>|  5 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |       29.90 |<br>|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |       29.90 |<br>|  2 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |       29.90 |<br>|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |       29.90 |<br>|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |       29.90 |<br>|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |       29.90 |<br>|  9 | 户外运动       | 登山杖      |   59.90 |  1500 |       59.90 |<br>|  7 | 户外运动       | 自行车      |  399.90 |  1000 |       59.90 |<br>| 10 | 户外运动       | 骑行装备    |  399.90 |  3500 |       59.90 |<br>| 12 | 户外运动       | 滑板       |  499.90 |  1200 |       59.90 |<br>| 11 | 户外运动       | 运动外套    |  799.90 |   500 |       59.90 |<br>|  8 | 户外运动       | 山地自行车  | 1399.90 |  2500 |       59.90 |<br>+----+---------------+------------+---------+-------+-------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>2．LAST_VALUE(expr)函数</strong></p><p>LAST_VALUE(expr)函数返回最后一个expr的值。</p><p>举例：按照价格排序，查询最后一个商品的价格信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price<br>    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+-------+------------+<br>| id | category      | NAME       | price   | stock | last_price |<br>+----+---------------+------------+---------+-------+------------+<br>|  5 | 女装/女士精品   | 百褶裙     |   29.90 |   500 |      29.90 |<br>|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |      39.90 |<br>|  2 | 女装/女士精品   | 连衣裙     |   79.90 |  2500 |      79.90 |<br>|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |      89.90 |<br>|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |  3500 |      89.90 |<br>|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |  1200 |     399.90 |<br>|  9 | 户外运动       | 登山杖     |   59.90 |  1500 |      59.90 |<br>|  7 | 户外运动       | 自行车     |  399.90 |  1000 |     399.90 |<br>| 10 | 户外运动       | 骑行装备   |  399.90 |  3500 |     399.90 |<br>| 12 | 户外运动       | 滑板       |  499.90 |  1200 |     499.90 |<br>| 11 | 户外运动       | 运动外套   |  799.90 |   500 |     799.90 |<br>|  8 | 户外运动       | 山地自行车 | 1399.90 |  2500 |    1399.90 |<br>+----+---------------+------------+---------+-------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5. 其他函数"></a>5. 其他函数</h4><p><strong>1．NTH_VALUE(expr,n)函数</strong></p><p>NTH_VALUE(expr,n)函数返回第n个expr的值。</p><p>举例：查询goods数据表中排名第2和第3的价格信息。</p><p><strong>需要注意的是，第n个expr的值未遍历到时，显示NULL值；当遍历到（过）第n个expr的值相等的值时，显示第n个expr的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price,NTH_VALUE(price,2) OVER w AS second_price,<br>    -&gt; NTH_VALUE(price,3) OVER w AS third_price<br>    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+--------------+-------------+<br>| id | category      | NAME       | price   | second_price | third_price |<br>+----+---------------+------------+---------+--------------+-------------+<br>|  5 | 女装/女士精品   | 百褶裙     |   29.90 |         NULL |        NULL |<br>|  1 | 女装/女士精品   | T恤        |   39.90 |        39.90 |        NULL |<br>|  2 | 女装/女士精品   | 连衣裙     |   79.90 |        39.90 |       79.90 |<br>|  3 | 女装/女士精品   | 卫衣       |   89.90 |        39.90 |       79.90 |<br>|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |        39.90 |       79.90 |<br>|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |        39.90 |       79.90 |<br>|  9 | 户外运动       | 登山杖     |   59.90 |         NULL |        NULL |<br>|  7 | 户外运动       | 自行车     |  399.90 |       399.90 |      399.90 |<br>| 10 | 户外运动       | 骑行装备   |  399.90 |       399.90 |      399.90 |<br>| 12 | 户外运动       | 滑板       |  499.90 |       399.90 |      399.90 |<br>| 11 | 户外运动       | 运动外套   |  799.90 |       399.90 |      399.90 |<br>|  8 | 户外运动       | 山地自行车 | 1399.90 |       399.90 |      399.90 |<br>+----+---------------+------------+---------+--------------+-------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>2．NTILE(n)函数</strong></p><p>NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号。（num / n上取整，其中num是行数，n是桶数）</p><p>举例：将goods表中的商品按照价格分为3组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NTILE(3) OVER w AS nt,id, category, NAME, price<br>    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+----+---------------+------------+---------+<br>| nt | id | category      | NAME       | price   |<br>+----+----+---------------+------------+---------+<br>|  1 |  5 | 女装/女士精品 | 百褶裙     |   29.90 |<br>|  1 |  1 | 女装/女士精品 | T恤        |   39.90 |<br>|  2 |  2 | 女装/女士精品 | 连衣裙     |   79.90 |<br>|  2 |  3 | 女装/女士精品 | 卫衣       |   89.90 |<br>|  3 |  4 | 女装/女士精品 | 牛仔裤     |   89.90 |<br>|  3 |  6 | 女装/女士精品 | 呢绒外套   |  399.90 |<br>|  1 |  9 | 户外运动      | 登山杖     |   59.90 |<br>|  1 |  7 | 户外运动      | 自行车     |  399.90 |<br>|  2 | 10 | 户外运动      | 骑行装备   |  399.90 |<br>|  2 | 12 | 户外运动      | 滑板       |  499.90 |<br>|  3 | 11 | 户外运动      | 运动外套   |  799.90 |<br>|  3 |  8 | 户外运动      | 山地自行车 | 1399.90 |<br>+----+----+---------------+------------+---------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="2-5-小-结"><a href="#2-5-小-结" class="headerlink" title="2.5 小 结"></a>2.5 小 结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h2 id="3-新特性2：公用表表达式"><a href="#3-新特性2：公用表表达式" class="headerlink" title="3. 新特性2：公用表表达式"></a>3. 新特性2：公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。<strong>CTE是一个命名的临时结果集，作用范围是当前语句。</strong>CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code> 2 种。</p><h3 id="3-1-普通公用表表达式"><a href="#3-1-普通公用表表达式" class="headerlink" title="3.1 普通公用表表达式"></a>3.1 普通公用表表达式</h3><p>普通公用表表达式的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH CTE名称 <br>AS （子查询）<br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure><p><strong>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</strong></p><p>举例：查询员工所在的部门的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM departments<br>    -&gt; WHERE department_id IN (<br>    -&gt;                  SELECT DISTINCT department_id<br>    -&gt;                  FROM employees<br>    -&gt;                  );<br>+---------------+------------------+------------+-------------+<br>| department_id | department_name  | manager_id | location_id |<br>+---------------+------------------+------------+-------------+<br>|            10 | Administration   |        200 |        1700 |<br>|            20 | Marketing        |        201 |        1800 |<br>|            30 | Purchasing       |        114 |        1700 |<br>|            40 | Human Resources  |        203 |        2400 |<br>|            50 | Shipping         |        121 |        1500 |<br>|            60 | IT               |        103 |        1400 |<br>|            70 | Public Relations |        204 |        2700 |<br>|            80 | Sales            |        145 |        2500 |<br>|            90 | Executive        |        100 |        1700 |<br>|           100 | Finance          |        108 |        1700 |<br>|           110 | Accounting       |        205 |        1700 |<br>+---------------+------------------+------------+-------------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>这个查询也可以用普通公用表表达式的方式完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; WITH emp_dept_id<br>    -&gt; AS (SELECT DISTINCT department_id FROM employees)<br>    -&gt; SELECT *<br>    -&gt; FROM departments d JOIN emp_dept_id e<br>    -&gt; ON d.department_id = e.department_id;<br>+---------------+------------------+------------+-------------+---------------+<br>| department_id | department_name  | manager_id | location_id | department_id |<br>+---------------+------------------+------------+-------------+---------------+<br>|            90 | Executive        |        100 |        1700 |            90 |<br>|            60 | IT               |        103 |        1400 |            60 |<br>|           100 | Finance          |        108 |        1700 |           100 |<br>|            30 | Purchasing       |        114 |        1700 |            30 |<br>|            50 | Shipping         |        121 |        1500 |            50 |<br>|            80 | Sales            |        145 |        2500 |            80 |<br>|            10 | Administration   |        200 |        1700 |            10 |<br>|            20 | Marketing        |        201 |        1800 |            20 |<br>|            40 | Human Resources  |        203 |        2400 |            40 |<br>|            70 | Public Relations |        204 |        2700 |            70 |<br>|           110 | Accounting       |        205 |        1700 |           110 |<br>+---------------+------------------+------------+-------------+---------------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</p><h3 id="3-2-递归公用表表达式"><a href="#3-2-递归公用表表达式" class="headerlink" title="3.2 递归公用表表达式"></a>3.2 递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是<strong>可以调用自己</strong>。它的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE CTE名称 <br>AS （子查询）<br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION  [ALL]进行连接。这里的<strong>种子查询，意思就是获得递归的初始值</strong>。<strong>这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">最后的结果集等于，初始数据集，加上每次的查询结果（其中每次的查询结果又会作为下一次查询的输入公用表，直到查询结果为空）<br></code></pre></td></tr></table></figure><p><strong>案例：</strong>针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p><p>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p><p>如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p><ul><li><p>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</p></li><li><p>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</p></li><li><p>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</p></li><li><p>第四步，找出所有以下下属为管理者的人，得到一个结果集。</p></li></ul><p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p><p>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p><ul><li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p></li><li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p></li><li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p></li></ul><p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE cte <br>AS <br>(<br>SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100 -- 种子查询，找到第一代领导<br>UNION ALL<br>SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte<br>ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人<br>)<br>SELECT employee_id,last_name FROM cte WHERE n &gt;= 3; <br></code></pre></td></tr></table></figure><p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p><h3 id="3-3-小-结"><a href="#3-3-小-结" class="headerlink" title="3.3 小 结"></a>3.3 小 结</h3><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="一、Linux基本简介"><a href="#一、Linux基本简介" class="headerlink" title="一、Linux基本简介"></a>一、Linux基本简介</h2><h3 id="1-1-Linux的应用领域"><a href="#1-1-Linux的应用领域" class="headerlink" title="1.1 Linux的应用领域"></a>1.1 Linux的应用领域</h3><h4 id="1-1-1-个人桌面应用领域"><a href="#1-1-1-个人桌面应用领域" class="headerlink" title="1.1.1 个人桌面应用领域"></a>1.1.1 个人桌面应用领域</h4><p>此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora[fɪˈdɔ:rə] 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高。</p><h4 id="1-1-2-服务器应用领域"><a href="#1-1-2-服务器应用领域" class="headerlink" title="1.1.2 服务器应用领域"></a>1.1.2 服务器应用领域</h4><p>linux在服务器领域的应用是最强的。<br>linux免费、稳定、高效等特点在这里得到了很好的体现，近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛。</p><h4 id="1-1-3-嵌入式应用领域"><a href="#1-1-3-嵌入式应用领域" class="headerlink" title="1.1.3 嵌入式应用领域"></a>1.1.3 嵌入式应用领域</h4><p>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高。</p><p>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后在<strong>物联网</strong>中应用会更加广泛。</p><h3 id="1-2-学习LINUX的阶段"><a href="#1-2-学习LINUX的阶段" class="headerlink" title="1.2 学习LINUX的阶段"></a>1.2 学习LINUX的阶段</h3><p>linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux,很多软件公司考虑到开发成本都首选linux,在中国软件公司得到广泛的使用。</p><p>我个人认为学习linux流程为:<br>第 1 阶段：linux环境下的基本操作命令，包括 文件操作命令(rmmkdirchmod,chown) 编辑工具使用（vivim）linux用户管理(useradduserdelusermod)等<br>第 2 阶段：linux的各种配置（环境变量配置，网络配置，服务配置）<br>第 3 阶段：linux下如何搭建对应语言的开发环境（大数据，JavaEE,Python等）<br>第 4 阶段：能编写shell脚本，对Linux服务器进行维护。<br>第 5 阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。<br>第 6 阶段：深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法。</p><h3 id="1-3-LINUX的学习方法和建议"><a href="#1-3-LINUX的学习方法和建议" class="headerlink" title="1.3 LINUX的学习方法和建议"></a>1.3 LINUX的学习方法和建议</h3><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) 高效而愉快的学习<br><span class="hljs-symbol">2 </span>) 先建立一个整体框架，然后细节<br><span class="hljs-symbol">3 </span>) 不需要掌握所有的Linux指令，要学会查询手册和百度<br><span class="hljs-symbol">4 </span>) 先knowhow,再knowwhy<br><span class="hljs-symbol">5 </span>) 计算机是一门”做中学” 的学科 ,不是会了再做，而是做了才会.<br><span class="hljs-symbol">6 </span>) 适当的囫囵吞枣<br><span class="hljs-symbol">7 </span>) Linux不是编程，重点是实际操作，各种常用指令要玩的溜<br></code></pre></td></tr></table></figure><h2 id="二、LINUX-入门"><a href="#二、LINUX-入门" class="headerlink" title="二、LINUX 入门"></a>二、LINUX 入门</h2><h3 id="2-1-LINUX介绍"><a href="#2-1-LINUX介绍" class="headerlink" title="2.1 LINUX介绍"></a>2.1 LINUX介绍</h3><p>1 ) Linux怎么读 【里纽克斯，利尼克斯，里纳克斯】<br>2 ) Linux是一款操作系统，免费，开源，安全，高效，稳定， 处理高并发非常强悍，现在很多的企业级的项目都部署到Linux/unix服务器运行。<br>3 ) Linux创始人 </p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221172406244.png" alt="linus"></p><p>4 ) Linux的吉祥物</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221172234551.png" alt="Tux"></p><p>5 ) Linux的主要的发行版:Ubuntu、RedHat、CentOS等，<a href="https://www.kernel.org/">Linux内核源码下载地址</a>，可以将源码下载下来查看。</p><h3 id="2-2Unix与Linux的关系"><a href="#2-2Unix与Linux的关系" class="headerlink" title="2.2Unix与Linux的关系"></a>2.2Unix与Linux的关系</h3><h4 id="2-2-1-Unix来源"><a href="#2-2-1-Unix来源" class="headerlink" title="2.2.1 Unix来源"></a>2.2.1 Unix来源</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/unix%E6%9D%A5%E6%BA%90.jpg" alt="Unix来源"></p><h4 id="2-2-2-Linux来源"><a href="#2-2-2-Linux来源" class="headerlink" title="2.2.2 Linux来源"></a>2.2.2 Linux来源</h4><p>Richard提出了伟大的GNU计划，大大促进了开源事业。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E6%9D%A5%E6%BA%90.jpg" alt="Linux来源"></p><h4 id="2-2-3-Linux与Unix关系"><a href="#2-2-3-Linux与Unix关系" class="headerlink" title="2.2.3 Linux与Unix关系"></a>2.2.3 Linux与Unix关系</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E4%B8%8EUnix%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Unix关系"></p><h4 id="2-2-4-Linux与Windows关系"><a href="#2-2-4-Linux与Windows关系" class="headerlink" title="2.2.4 Linux与Windows关系"></a>2.2.4 Linux与Windows关系</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E4%B8%8EWindows%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Windows关系"></p><h2 id="三、VM-和-LINUX-系统-CENTOS-安装"><a href="#三、VM-和-LINUX-系统-CENTOS-安装" class="headerlink" title="三、VM 和 LINUX 系统 (CENTOS) 安装"></a>三、VM 和 LINUX 系统 (CENTOS) 安装</h2><h3 id="3-1-安装VM和CENTOS"><a href="#3-1-安装VM和CENTOS" class="headerlink" title="3.1 安装VM和CENTOS"></a>3.1 安装VM和CENTOS</h3><p>学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。</p><p>1 )先安装virtual machine 15.5<br>2 )再安装Linux(CentOS 7.6 \ CentOS 8.1)<br>3 )原理示意图，这里我们画图说明一下 VM 和 CentOS的关系。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221184653303.png"></p><h3 id="3-2-安装步骤"><a href="#3-2-安装步骤" class="headerlink" title="3.2 安装步骤"></a>3.2 安装步骤</h3><p>1 ) 去BIOS里修改设置开启虚拟化设备支持<br>2 ) 安装虚拟机软件(VM 15.5)<br>3 ) 创建虚拟机(空间)<br>4 ) 安装系统(CentOS 6.8 )</p><h3 id="3-3-虚拟机网络连接三种方式"><a href="#3-3-虚拟机网络连接三种方式" class="headerlink" title="3.3 虚拟机网络连接三种方式"></a>3.3 虚拟机网络连接三种方式</h3><p>虚拟机网络连接有三种方式：桥接模式、NAT模式和主机模式。</p><p>1.桥接模式：虚拟机系统可以与外部系统互相通讯，但是由于桥接模式占用与物理机同一级的ip地址，所以如果当前局域网ip地址耗尽，容易造成ip冲突</p><p>2.NAT模式：网络地址转换模式，虚拟机系统可以向外部系统发消息，但是外部系统不可以向虚拟机系统发消息（如果没有内网穿透相关功能的话），NAT模式不会造成ip冲突。</p><p>3.主机模式：可以成为单机模式，不与外部系统连接网络，是一个独立的系统。</p><h3 id="3-4-虚拟机克隆"><a href="#3-4-虚拟机克隆" class="headerlink" title="3.4 虚拟机克隆"></a>3.4 虚拟机克隆</h3><p>如果已经安装了一台Linux操作系统，此时还需要更多，这时可以使用虚拟机克隆操作，有以下两种方式：</p><p>方式1：直接拷贝一份安装好的虚拟机文件</p><p>方式2：使用vmware的克隆操作(需要先关闭Linux系统)</p><h3 id="3-5-虚拟机快照"><a href="#3-5-虚拟机快照" class="headerlink" title="3.5 虚拟机快照"></a>3.5 虚拟机快照</h3><p>如果在使用虚拟机系统的时候（比如Linux），如果你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware特提供了这样的功能，叫快照管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">应用实例：<br>1.安装好系统以后，先做一个快照A<br>2.进入系统，创建一个文件夹，在保存一个快照B<br>3.回到系统刚刚安装好的状态，即快照A<br>4A试试看，是否还能再次回到快照B（答案是肯定的）<br></code></pre></td></tr></table></figure><p>需要注意的是，快照底层是使用指针实现的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221193015812.png"></p><h3 id="3-6-虚拟机迁移删除"><a href="#3-6-虚拟机迁移删除" class="headerlink" title="3.6 虚拟机迁移删除"></a>3.6 虚拟机迁移删除</h3><p>虚拟机系统的本质就是文件。因此虚拟机系统的迁移很方便，可以把安装好的虚拟机系统这个文件夹整体<strong>拷贝或者剪切</strong>到另外位置使用。同样地，虚拟机系统删除也很简单，用vmware进行移除（菜单 -&gt; 从磁盘删除），或者直接手动删除虚拟系统对应的文件夹即可。</p><h3 id="3-7-vmtools"><a href="#3-7-vmtools" class="headerlink" title="3.7 vmtools"></a>3.7 vmtools</h3><h4 id="3-7-1-vmtools作用"><a href="#3-7-1-vmtools作用" class="headerlink" title="3.7.1 vmtools作用"></a>3.7.1 vmtools作用</h4><ol><li>vmtools安装后，可以让我们在windows下跟好的管理vm虚拟机</li><li>可以设置windows和centos的共享文件夹</li></ol><h4 id="3-7-2-vmtools的安装步骤"><a href="#3-7-2-vmtools的安装步骤" class="headerlink" title="3.7.2 vmtools的安装步骤"></a>3.7.2 vmtools的安装步骤</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.进入centos<br><span class="hljs-number">2</span>.点击vm菜单的 -&gt; install vmwaretools<br><span class="hljs-number">3</span>.centos会出现一个vm的安装包，xx<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br><span class="hljs-number">4</span>.拷贝到/opt,使用解压命令tar -zxvf xx<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>, 得到一个安装文件<br><span class="hljs-number">5</span>.进入该vm解压的目录 ，该文件在/opt目录下<br><span class="hljs-number">6</span>.安装 ./vmware-install<span class="hljs-selector-class">.pl</span><br><span class="hljs-number">7</span>.全部使用默认设置即可<br><span class="hljs-number">8</span>.需要reboot重新启动即可生效<br><span class="hljs-number">9</span>.注意：安装vmtools，需要有gcc<br></code></pre></td></tr></table></figure><h4 id="3-7-3-使用vmtools来设置windows和linux的共享文件夹"><a href="#3-7-3-使用vmtools来设置windows和linux的共享文件夹" class="headerlink" title="3.7.3 使用vmtools来设置windows和linux的共享文件夹"></a>3.7.3 使用vmtools来设置windows和linux的共享文件夹</h4><p>1.在windows中新建一个文件夹</p><p>2.在vmware中设置共享文件夹</p><p>3.在Centos的/mnt/hgfs/下可以找到共享文件夹</p><h2 id="四、Linux-的目录结构"><a href="#四、Linux-的目录结构" class="headerlink" title="四、Linux 的目录结构"></a>四、Linux 的目录结构</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><p>linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p><p>深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下，记住一句经典的话：<strong>在Linux世界里，一切皆文件。</strong>硬件都当做文件来管理。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221203356156.png"></p><h3 id="4-2-目录结构的具体介绍"><a href="#4-2-目录结构的具体介绍" class="headerlink" title="4.2 目录结构的具体介绍"></a>4.2 目录结构的具体介绍</h3><ul><li><code>/bin：</code> 是Binary的缩写，这个目录存放着最经常使用的命令(命令其实就是一个个可执行文件)。</li><li><code>/sbin</code>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><code>/home：</code>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。(对应MacOS中的<code>/Users</code>目录)</li><li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><code>/lib</code>：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li><code>/lost+found</code>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><code>/etc</code>：所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库 my.conf。</li><li><code>/boot</code>:存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><code>/proc</code>：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。该目录不要动。</li><li><code>/srv</code>：service的缩写，该目录存放一些服务启动之后需要提供的数据。该目录不要动。</li><li><code>/sys</code>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。该目录不要动。</li><li><code>/tmp</code>：这个目录是用来存放一些临时文件的。</li><li><code>/dev</code>：类似windows的设备管理器，把所有的<strong>硬件</strong>用<strong>文件的形式存储</strong>。</li><li><code>/media</code>:linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下(Linux把这些设备映射成文件进行管理)。</li><li><code>/mnt</code>:系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</li><li><code>/opt</code>:这是给主机额外安装软件所<strong>摆放</strong>的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</li><li><code>/usr/local</code>：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li><li><code>/var</code>:这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li><li><code>/selinux</code>：SELinux是一种安全子系统，它能控制程序只能访问特定文件。</li></ul><h4 id="4-2-1-opt-amp-usr-local-amp-usr-区别"><a href="#4-2-1-opt-amp-usr-local-amp-usr-区别" class="headerlink" title="4.2.1 /opt &amp; /usr/local &amp; /usr 区别"></a>4.2.1 /opt &amp; /usr/local &amp; /usr 区别</h4><p><code>/opt</code>这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。<strong>相当于windows中的D:/Software。</strong></p><p><code>/usr/local</code>这里主要存放那些手动安装的软件，即不是通过apt-get等自动安装的软件，/usr/local目录下的一些子目录往往都是被加入到PATH环境变量中的。 <strong>相当于windows中的C:/Program Files</strong>。</p><p><code>/usr</code>：系统级的目录，可以理解为C:/Windows/，<code>/usr/lib</code>理解为C:/Windows/System32。</p><p><code>/usr/src</code>：系统级的源码目录。<code>/usr/local/src</code>：用户级的源码目录。</p><h3 id="4-3-Linux目录总结一下"><a href="#4-3-Linux目录总结一下" class="headerlink" title="4.3 Linux目录总结一下"></a>4.3 Linux目录总结一下</h3><ol><li>linux的目录中有且只要一个根目录 /</li><li>linux的各个目录存放的内容是规划好，不用乱放文件。</li><li>linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。</li></ol><p>linux的各个文件目录下存放什么内容，必须有一个认识，你脑海中应该有一颗linux目录树</p><h2 id="五、远程登录Linux系统"><a href="#五、远程登录Linux系统" class="headerlink" title="五、远程登录Linux系统"></a>五、远程登录Linux系统</h2><h3 id="5-1-SSH-三步解决免密登录"><a href="#5-1-SSH-三步解决免密登录" class="headerlink" title="5.1 SSH 三步解决免密登录"></a>5.1 SSH 三步解决免密登录</h3><h4 id="5-1-1-客户端生成公私钥"><a href="#5-1-1-客户端生成公私钥" class="headerlink" title="5.1.1 客户端生成公私钥"></a>5.1.1 客户端生成公私钥</h4><p>本地客户端生成公私钥：（一路回车默认即可）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>上面这个命令会在用户目录. ssh 文件夹下创建公私钥</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ls</span><br></code></pre></td></tr></table></figure><p>下创建两个密钥：</p><ol><li> id_rsa （私钥）</li><li> id_rsa.pub (公钥)</li></ol><h4 id="5-1-2-上传公钥到服务器"><a href="#5-1-2-上传公钥到服务器" class="headerlink" title="5.1.2 上传公钥到服务器"></a>5.1.2 上传公钥到服务器</h4><p>这里测试用的服务器地址为：192.168.235.22<br>用户为：root</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ssh-<span class="hljs-keyword">copy</span>-id -i ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub root@<span class="hljs-number">192.168</span>.<span class="hljs-number">235.22</span><br></code></pre></td></tr></table></figure><p>上面这条命令是写到服务器上的 ssh 目录下去了</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cat authorized_keys</span><br></code></pre></td></tr></table></figure><p>可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。</p><h4 id="5-1-3-测试免密登录"><a href="#5-1-3-测试免密登录" class="headerlink" title="5.1.3 测试免密登录"></a>5.1.3 测试免密登录</h4><p>客户端通过 ssh 连接远程服务器，就可以免密登录了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">192.168.235.22</span><br></code></pre></td></tr></table></figure><h3 id="5-2-管理多个私钥"><a href="#5-2-管理多个私钥" class="headerlink" title="5.2 管理多个私钥"></a>5.2 管理多个私钥</h3><p>在<code>~/.ssh/config</code>中进行配置，配置原则如下所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221210809219.png"></p><p><code>Host</code>是别名</p><p><code>HostName</code>是ip地址或者域名</p><p><code>User</code>是登录用户名</p><p><code>IdentityFile</code>是私钥地址</p><p><code>PerferredAuthentications</code>是首选身份验证方式</p><h2 id="六、Vi-和-Vim-编辑器"><a href="#六、Vi-和-Vim-编辑器" class="headerlink" title="六、Vi 和 Vim 编辑器"></a>六、Vi 和 Vim 编辑器</h2><h3 id="6-1-Vi和Vim的基本介绍"><a href="#6-1-Vi和Vim的基本介绍" class="headerlink" title="6.1 Vi和Vim的基本介绍"></a>6.1 Vi和Vim的基本介绍</h3><p>所有的 Linux 系统都会内建 vi 文本编辑器。</p><p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><h3 id="6-2-Vi和Vim的三种常见模式"><a href="#6-2-Vi和Vim的三种常见模式" class="headerlink" title="6.2 Vi和Vim的三种常见模式"></a>6.2 Vi和Vim的三种常见模式</h3><h4 id="6-2-1-正常模式"><a href="#6-2-1-正常模式" class="headerlink" title="6.2.1 正常模式"></a>6.2.1 正常模式</h4><p>在正常模式下，我们可以使用快捷键。<br>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。</p><h4 id="6-2-2-插入模式-编辑模式"><a href="#6-2-2-插入模式-编辑模式" class="headerlink" title="6.2.2 插入模式/编辑模式"></a>6.2.2 插入模式/编辑模式</h4><p>在模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式, 一般来说按i即可。</p><h4 id="6-2-3-命令行模式"><a href="#6-2-3-命令行模式" class="headerlink" title="6.2.3 命令行模式"></a>6.2.3 命令行模式</h4><p>在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！</p><h3 id="6-4-Vi和Vim三种模式的相互转化图"><a href="#6-4-Vi和Vim三种模式的相互转化图" class="headerlink" title="6.4 Vi和Vim三种模式的相互转化图"></a>6.4 Vi和Vim三种模式的相互转化图</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221212631089.png" alt="Vi和Vim三种模式的互相转换图"></p><h3 id="6-5-Vi和Vim的快捷键键盘一览图"><a href="#6-5-Vi和Vim的快捷键键盘一览图" class="headerlink" title="6.5 Vi和Vim的快捷键键盘一览图"></a>6.5 Vi和Vim的快捷键键盘一览图</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221213558671.png" alt="Vi和Vim的快捷键键盘一览图"></p><p>Vi和Vim的快键键包罗万象，遇到具体需求可以查看<a href="https://vim.rtorr.com/lang/zh_cn">Vim Cheat Sheet</a>或者在linux命令行输入<code>vimtutor</code>查看vim官方教程。</p><h2 id="七、关机、重启和用户登录注销"><a href="#七、关机、重启和用户登录注销" class="headerlink" title="七、关机、重启和用户登录注销"></a>七、关机、重启和用户登录注销</h2><h3 id="7-1-关机-amp-重启命令"><a href="#7-1-关机-amp-重启命令" class="headerlink" title="7.1 关机&amp;重启命令"></a>7.1 关机&amp;重启命令</h3><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">shutdown      </span>: 相当于 shutdown -h 1<br><span class="hljs-attribute">shutdown-h now</span>: 表示立即关机<br><span class="hljs-attribute">shutdown-h 1  </span>: 表示 1 分钟后关机<br><span class="hljs-attribute">shutdown-r now</span>: 立即重启<br><span class="hljs-attribute">halt          </span>: 效果等价于关机<br><span class="hljs-attribute">reboot        </span>: 就是重启系统。<br><span class="hljs-attribute">sync          :把内存的数据同步到磁盘</span><br></code></pre></td></tr></table></figure><p>注意细节：</p><p>1.当我们关机或者重启时，都应该先执行以下sync指令，把内存的数据写入磁盘，防止数据丢失。</p><p>2.目前的shutdown/reboot/halt等命令君已经在关机前进行了sync。</p><h3 id="7-2-用户登录和注销"><a href="#7-2-用户登录和注销" class="headerlink" title="7.2 用户登录和注销"></a>7.2 用户登录和注销</h3><p>1 ) 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用<code>su -s</code>命令来切换成系统管理员身份。</p><p>2 ) 在提示符下输入<code> logout</code> 即可注销用户。(在<code>root</code>用户下使用会退回到上次的普通用户上，在普通用户上使用会退出系统)</p><p>使用细节:<br>    1.logout 注销指令在图形运行级别无效，在 运行级别 3 下有效.<br>    2.运行级别这个概念，后面给大家介绍</p><h2 id="八、用户管理"><a href="#八、用户管理" class="headerlink" title="八、用户管理"></a>八、用户管理</h2><h3 id="8-1-基本介绍"><a href="#8-1-基本介绍" class="headerlink" title="8.1 基本介绍"></a>8.1 基本介绍</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。并且<strong>Linux的用户需要至少要属于一个组</strong>，每一个用户都对应一个自己的家目录。</p><h3 id="8-2-添加用户"><a href="#8-2-添加用户" class="headerlink" title="8.2 添加用户"></a>8.2 添加用户</h3><h4 id="8-2-1-基本语法"><a href="#8-2-1-基本语法" class="headerlink" title="8.2.1 基本语法"></a>8.2.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd [选项] 用户名<br></code></pre></td></tr></table></figure><h4 id="8-2-2-实际案例"><a href="#8-2-2-实际案例" class="headerlink" title="8.2.2 实际案例"></a>8.2.2 实际案例</h4><p>添加一个用户<code>jyg</code>,<code>useradd jyg</code>,并且默认该用户的家目录在<code>/home/jyg</code>。</p><h4 id="8-2-3-细节说明"><a href="#8-2-3-细节说明" class="headerlink" title="8.2.3 细节说明"></a>8.2.3 细节说明</h4><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>也可以通过 <code>useradd -d 指定目录 新的用户名</code>，给新创建的用户指定家目录</li><li>以什么用户身份登录，初始目录就在该用户的家目录下</li></ol><h3 id="8-3-给用户指定或者修改密码"><a href="#8-3-给用户指定或者修改密码" class="headerlink" title="8.3 给用户指定或者修改密码"></a>8.3 给用户指定或者修改密码</h3><h4 id="8-3-1-基本语法"><a href="#8-3-1-基本语法" class="headerlink" title="8.3.1 基本语法"></a>8.3.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd 用户名 #如果缺省用户名，则修改当前用户密码<br></code></pre></td></tr></table></figure><h4 id="8-2-2-实际案例-1"><a href="#8-2-2-实际案例-1" class="headerlink" title="8.2.2 实际案例"></a>8.2.2 实际案例</h4><p>给用户<code>jyg</code>更改密码，<code># passwd jyg</code></p><h3 id="8-4-删除用户"><a href="#8-4-删除用户" class="headerlink" title="8.4 删除用户"></a>8.4 删除用户</h3><h4 id="8-4-1-基本语法"><a href="#8-4-1-基本语法" class="headerlink" title="8.4.1 基本语法"></a>8.4.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel 用户名<br></code></pre></td></tr></table></figure><h4 id="8-4-2-应用案例"><a href="#8-4-2-应用案例" class="headerlink" title="8.4.2 应用案例"></a>8.4.2 应用案例</h4><ol><li><p>删除用户<code>jyg</code>，但是要保留家目录 <code>userdel jyg</code></p></li><li><p>删除用户<code>jyg</code>以及用户主目录 <code>userdel -r jyg</code></p></li></ol><p>主要注意的是，在删除用户时，我们一般不会将家目录删除。</p><h3 id="8-5-查询用户信息"><a href="#8-5-查询用户信息" class="headerlink" title="8.5 查询用户信息"></a>8.5 查询用户信息</h3><h4 id="8-5-1-基本语法"><a href="#8-5-1-基本语法" class="headerlink" title="8.5.1 基本语法"></a>8.5.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id 用户名<br></code></pre></td></tr></table></figure><h4 id="8-5-2-应用实例"><a href="#8-5-2-应用实例" class="headerlink" title="8.5.2 应用实例"></a>8.5.2 应用实例</h4><p>请查询root 信息 <code>id root</code></p><h4 id="8-5-3-细节说明"><a href="#8-5-3-细节说明" class="headerlink" title="8.5.3 细节说明"></a>8.5.3 细节说明</h4><p>当用户不存在时，返回<code>no such user</code></p><h3 id="8-6-切换用户"><a href="#8-6-切换用户" class="headerlink" title="8.6 切换用户"></a>8.6 切换用户</h3><h4 id="8-6-1-介绍"><a href="#8-6-1-介绍" class="headerlink" title="8.6.1 介绍"></a>8.6.1 介绍</h4><p>在操作Linux中，如果当前用户的权限不够，可以通过 <code>su - 用户名</code> 指令，切换到高权限用户，比如root</p><h4 id="8-6-2-基本语法"><a href="#8-6-2-基本语法" class="headerlink" title="8.6.2 基本语法"></a>8.6.2 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - 用户名<br></code></pre></td></tr></table></figure><h4 id="8-6-3-细节说明"><a href="#8-6-3-细节说明" class="headerlink" title="8.6.3 细节说明"></a>8.6.3 细节说明</h4><ol><li><p>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p></li><li><p>当需要返回到原来用户时，使用exit指令</p></li></ol><h3 id="8-7-查看当前用户-amp-登录信息"><a href="#8-7-查看当前用户-amp-登录信息" class="headerlink" title="8.7 查看当前用户 &amp; 登录信息"></a>8.7 查看当前用户 &amp; 登录信息</h3><h4 id="8-7-1-基本语法"><a href="#8-7-1-基本语法" class="headerlink" title="8.7.1 基本语法"></a>8.7.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whoami / who am i #两者不同，whoami是指当前用户，who am i是指登录信息（登录用户，登录信息，登录ip）<br></code></pre></td></tr></table></figure><h3 id="8-8-用户组"><a href="#8-8-用户组" class="headerlink" title="8.8 用户组"></a>8.8 用户组</h3><h4 id="8-8-1-介绍"><a href="#8-8-1-介绍" class="headerlink" title="8.8.1 介绍"></a>8.8.1 介绍</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><h4 id="8-8-2-增加组"><a href="#8-8-2-增加组" class="headerlink" title="8.8.2 增加组"></a>8.8.2 增加组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd 组名<br></code></pre></td></tr></table></figure><h4 id="8-8-3-删除组"><a href="#8-8-3-删除组" class="headerlink" title="8.8.3 删除组"></a>8.8.3 删除组</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupdel</span> 组名<br></code></pre></td></tr></table></figure><h3 id="8-9-增加用户时直接加上组"><a href="#8-9-增加用户时直接加上组" class="headerlink" title="8.9 增加用户时直接加上组"></a>8.9 增加用户时直接加上组</h3><h4 id="8-9-1-基本语法"><a href="#8-9-1-基本语法" class="headerlink" title="8.9.1 基本语法"></a>8.9.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -g 用户组 用户名<br></code></pre></td></tr></table></figure><p>需要注意的是，如果增加用户，但是没有指定用户组，那么系统会生成一个和该用户同名的用户组，并把该用户放入同名用户组中。</p><h4 id="8-9-2-案例演示"><a href="#8-9-2-案例演示" class="headerlink" title="8.9.2 案例演示"></a>8.9.2 案例演示</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">增加一个用户 zwj, 直接将他指定到 wudang<br>useradd -g wudang zwj<br></code></pre></td></tr></table></figure><h3 id="8-10-修改用户的组"><a href="#8-10-修改用户的组" class="headerlink" title="8.10 修改用户的组"></a>8.10 修改用户的组</h3><h4 id="8-10-1-基本语法"><a href="#8-10-1-基本语法" class="headerlink" title="8.10.1 基本语法"></a>8.10.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g 用户组 用户名<br></code></pre></td></tr></table></figure><h4 id="8-10-2-案例演示"><a href="#8-10-2-案例演示" class="headerlink" title="8.10.2 案例演示"></a>8.10.2 案例演示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">创建一个shaolin组，让将zwj 用户修改到shaolin<br>gourpadd shaolin<br>usermod -g shaolin zwj<br></code></pre></td></tr></table></figure><h3 id="8-11-用户和组相关文件"><a href="#8-11-用户和组相关文件" class="headerlink" title="8.11 用户和组相关文件"></a>8.11 用户和组相关文件</h3><h4 id="8-11-1-ETC-PASSWD-文件"><a href="#8-11-1-ETC-PASSWD-文件" class="headerlink" title="8.11.1 /ETC/PASSWD 文件"></a>8.11.1 /ETC/PASSWD 文件</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">用户（<span class="hljs-keyword">user</span>）的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令（被加密）:用户标识号:组标识号:注释性描述:主目录:登录<span class="hljs-keyword">Shell</span><br></code></pre></td></tr></table></figure><h4 id="8-11-2-ETC-SHADOW文件"><a href="#8-11-2-ETC-SHADOW文件" class="headerlink" title="8.11.2 /ETC/SHADOW文件"></a>8.11.2 /ETC/SHADOW文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">口令的配置文件<br><span class="hljs-section">每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></code></pre></td></tr></table></figure><h4 id="8-11-3-ETC-GROUP文件"><a href="#8-11-3-ETC-GROUP文件" class="headerlink" title="8.11.3 /ETC/GROUP文件"></a>8.11.3 /ETC/GROUP文件</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">组(<span class="hljs-keyword">group</span>)的配置文件，记录Linux包含的组的信息<br>每行含义：组名:口令:组标识号:组内用户列表<br></code></pre></td></tr></table></figure><p>组密码的作用：非本用户组的用户想切换到本用户组身份时，可以通过密码保证安全性。如果没有设置组密码，则只有属于本用户组的用户能够切换到本用户组的身份。</p><h2 id="九、实用指令"><a href="#九、实用指令" class="headerlink" title="九、实用指令"></a>九、实用指令</h2><h3 id="9-1-指定运行级别"><a href="#9-1-指定运行级别" class="headerlink" title="9.1 指定运行级别"></a>9.1 指定运行级别</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">运行级别说明：<br>0 ：关机<br>1 ：单用户【找回丢失密码】<br>2 ：多用户状态没有网络服务<br>3 ：多用户状态有网络服务<br>4 ：系统未使用保留给用户<br>5 ：图形界面<br>6 ：系统重启<br>常用运行级别是<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 5 </span><br></code></pre></td></tr></table></figure><p>要修改默认的运行级别:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">在centos7以前，可改文件/etc/inittab的id: 5 :initdefault:这一行中的数字<br><br>在Centos7以后，在/etc/inittab文件中，进行了简化，如下：<br>muti-user.target: analogous to runlevel 3<br>graphical.target: analogous to runlevel 5<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> To view current default target, run:</span><br>systemctl get-default<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> To <span class="hljs-built_in">set</span> a default target, run:</span><br>systemctl set-default [TARGET.target] # 例如：systemctl set-default graphical.target<br></code></pre></td></tr></table></figure><h3 id="9-2-切换到指定运行级别的指令"><a href="#9-2-切换到指定运行级别的指令" class="headerlink" title="9.2 切换到指定运行级别的指令"></a>9.2 切换到指定运行级别的指令</h3><h4 id="9-2-1-基本语法"><a href="#9-2-1-基本语法" class="headerlink" title="9.2.1 基本语法"></a>9.2.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">init [012356]<br></code></pre></td></tr></table></figure><h4 id="9-2-2-应用实例"><a href="#9-2-2-应用实例" class="headerlink" title="9.2.2 应用实例"></a>9.2.2 应用实例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">案例 <span class="hljs-number">1</span> ： 通过<span class="hljs-keyword">init</span> 来切换不同的运行级别，比如动 <span class="hljs-number">5</span> - &gt; <span class="hljs-number">3</span> ， 然后关机<br><span class="hljs-keyword">init</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="9-2-3-面试题"><a href="#9-2-3-面试题" class="headerlink" title="9.2.3 面试题"></a>9.2.3 面试题</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">如何找<span class="hljs-built_in">回root</span>密码，如果我们不小心，忘<span class="hljs-built_in">记root</span>密码，怎么找回。<br>思路： 进入到单用户模式，然后修<span class="hljs-built_in">改root</span>密码。因为进入单用户模式<span class="hljs-built_in">，root</span>不需要密码就可以登录，随后使用passwd指令修<span class="hljs-built_in">改root</span>密码。<br></code></pre></td></tr></table></figure><h3 id="9-3-帮助指令"><a href="#9-3-帮助指令" class="headerlink" title="9.3 帮助指令"></a>9.3 帮助指令</h3><h4 id="9-3-1-介绍"><a href="#9-3-1-介绍" class="headerlink" title="9.3.1 介绍"></a>9.3.1 介绍</h4><p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p><h4 id="9-3-2-man-命令"><a href="#9-3-2-man-命令" class="headerlink" title="9.3.2 man 命令"></a>9.3.2 man 命令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man [命令或配置文件]（功能描述：获得帮助信息）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例：查看ls命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man ls<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222125127245.png"></p><p><code>-a : 不忽略以 . 开头的文件</code></p><p>主要注意的是，[]是可选项的意思，而且可以组合使用且无顺序要求</p><h4 id="9-3-3-help指令"><a href="#9-3-3-help指令" class="headerlink" title="9.3.3 help指令"></a>9.3.3 help指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help 命令 （功能描述：获得shell内置命令的帮助信息,只能用于内部命令，不能用于外部命令）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例：查看cd命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help cd<br></code></pre></td></tr></table></figure><h3 id="9-3-4-info命令"><a href="#9-3-4-info命令" class="headerlink" title="9.3.4 info命令"></a>9.3.4 info命令</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">info 命令 # info 得到的信息比 man 还要多<br></code></pre></td></tr></table></figure><p>注意：由于help支持命令少，推荐使用man或者info命令。</p><h3 id="9-4-文件目录类"><a href="#9-4-文件目录类" class="headerlink" title="9.4 文件目录类"></a>9.4 文件目录类</h3><h4 id="9-4-1-pwd-指令"><a href="#9-4-1-pwd-指令" class="headerlink" title="9.4.1 pwd 指令"></a>9.4.1 pwd 指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd (功能描述：显示当前工作目录的绝对路径)<br></code></pre></td></tr></table></figure><h4 id="9-4-2-ls指令"><a href="#9-4-2-ls指令" class="headerlink" title="9.4.2 ls指令"></a>9.4.2 ls指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [选项] [目录或是文件]<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>a ：显示当前目录所有的文件和目录，包括隐藏的。</li><li>l ：以列表的方式显示信息</li></ul><h4 id="9-4-3-cd-指令"><a href="#9-4-3-cd-指令" class="headerlink" title="9.4.3 cd 指令"></a>9.4.3 cd 指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd [参数] (功能描述：切换到指定目录)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>~ / <span class="hljs-built_in">cd</span> :回到自己的家目录<br><span class="hljs-built_in">cd</span>..     :回到当前目录的上一级目录<br></code></pre></td></tr></table></figure><h4 id="9-4-4-mkdir指令"><a href="#9-4-4-mkdir指令" class="headerlink" title="9.4.4 mkdir指令"></a>9.4.4 mkdir指令</h4><p>基本语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [选项] 要创建的目录<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>p ：创建多级目录</li></ul><h4 id="9-4-5-rmdir指令"><a href="#9-4-5-rmdir指令" class="headerlink" title="9.4.5 rmdir指令"></a>9.4.5 rmdir指令</h4><p>rmdir指令删除空目录</p><p>基本语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir [选项] 要删除的空目录<br></code></pre></td></tr></table></figure><p>需要注意的是：rmdir指令只能删除空目录，只能使用<code>rm -rf</code></p><h4 id="9-4-6-touch指令"><a href="#9-4-6-touch指令" class="headerlink" title="9.4.6 touch指令"></a>9.4.6 touch指令</h4><p>touch指令创建空文件</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 文件名<br></code></pre></td></tr></table></figure><h4 id="9-4-7-cp指令"><a href="#9-4-7-cp指令" class="headerlink" title="9.4.7 cp指令"></a>9.4.7 cp指令</h4><p>cp 指令拷贝文件到指定目录</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp [选项] source dest # source、dest可以是文件也可以是文件夹<br>\cp [选项] source dest # 直接覆盖，不提示是否覆盖<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>r ：递归复制整个文件夹</li></ul><h4 id="9-4-8-rm指令"><a href="#9-4-8-rm指令" class="headerlink" title="9.4.8 rm指令"></a>9.4.8 rm指令</h4><p>rm 指令移除文件或目录</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [选项] 要删除的文件或目录<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>r ：递归删除整个文件夹</li><li>f ： 强制删除不提示</li></ul><h4 id="9-4-9-mv指令"><a href="#9-4-9-mv指令" class="headerlink" title="9.4.9 mv指令"></a>9.4.9 mv指令</h4><p>mv <strong>移动</strong>文件与目录或<strong>重命名</strong></p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv oldNameFile           newNameFile          (功能描述：重命名)<br>mv /oldFolder/movefile  /targetFolder         (功能描述：移动文件)<br></code></pre></td></tr></table></figure><p>案例移动整个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv oldFolder /targetFolder<br></code></pre></td></tr></table></figure><h4 id="9-4-10-cat指令"><a href="#9-4-10-cat指令" class="headerlink" title="9.4.10 cat指令"></a>9.4.10 cat指令</h4><p>cat 查看文件内容，是以只读的方式打开。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat [选项] 要查看的文件<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>n ：显示行号</li></ul><p>使用细节<br>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名 | more<br></code></pre></td></tr></table></figure><h4 id="9-4-11-more指令"><a href="#9-4-11-more指令" class="headerlink" title="9.4.11 more指令"></a>9.4.11 more指令</h4><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">more 要查看的文件<br></code></pre></td></tr></table></figure><p>操作说明</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>space</td><td>向下翻一页</td></tr><tr><td>return</td><td>向下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>b</td><td>向上翻一页</td></tr><tr><td>z</td><td>向下翻一页</td></tr><tr><td>=</td><td>输出当前行号</td></tr><tr><td>：f</td><td>输出文件名和当前行号</td></tr></tbody></table><h4 id="9-4-12-less指令"><a href="#9-4-12-less指令" class="headerlink" title="9.4.12 less指令"></a>9.4.12 less指令</h4><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less 文件<br></code></pre></td></tr></table></figure><p>操作说明</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>space</td><td>向下翻一页</td></tr><tr><td>return</td><td>向下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>b</td><td>向上翻一页</td></tr><tr><td>z</td><td>向下翻一页</td></tr><tr><td>=</td><td>显示当前页面行号范围</td></tr><tr><td>:f</td><td>显示当前页面行号范围</td></tr></tbody></table><p>推荐使用<code>less</code>而不是<code>more</code></p><h4 id="9-4-13-gt-指令-和-gt-gt-指令"><a href="#9-4-13-gt-指令-和-gt-gt-指令" class="headerlink" title="9.4.13 &gt;指令 和 &gt;&gt;指令"></a>9.4.13 &gt;指令 和 &gt;&gt;指令</h4><p><code>&gt;</code>命令是输出重定向：会将原来的文件内容覆盖</p><p><code>&gt;&gt;</code>命令是追加：不会覆盖原来文件的内容，而是追加到文件的尾部。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l &gt; 文件      （功能描述：列表的内容写入文件a.txt中（覆盖写））<br>  说明：ls-l&gt;a.txt, 将ls-l 的显示的内容覆盖写入到a.txt文件，如果该文件不存在，就创建该文件。<br>ls -al &gt;&gt; 文件   （功能描述：列表的内容追加到文件aa.txt的末尾）<br>cat 文件1 &gt; 文件2 （功能描述：将文件 1 的内容覆盖到文件 2 ）<br>echo &quot;内容&quot; &gt;&gt; 文件<br></code></pre></td></tr></table></figure><h4 id="9-4-14-echo指令"><a href="#9-4-14-echo指令" class="headerlink" title="9.4.14 echo指令"></a>9.4.14 echo指令</h4><p>echo输出内容到控制台。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [选项] [输出内容]<br></code></pre></td></tr></table></figure><p>应用实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH        #输出环境变量<br>echo $HOSTNAME    #输出主机名<br>echo hello world  #输出hello world<br></code></pre></td></tr></table></figure><h4 id="9-4-15-head指令"><a href="#9-4-15-head指令" class="headerlink" title="9.4.15 head指令"></a>9.4.15 head指令</h4><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前 10 行内容</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">head 文件 (功能描述：查看文件头 10 行内容)<br>head-n 5 文件 (功能描述：查看文件头 5 行内容， 5 可以是任意行数)<br></code></pre></td></tr></table></figure><h4 id="9-4-16-tail指令"><a href="#9-4-16-tail指令" class="headerlink" title="9.4.16 tail指令"></a>9.4.16 tail指令</h4><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后 10 行内容。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail 文件       (功能描述：查看文件后 10 行内容）<br>tail -n 5 文件 （功能描述：查看文件后 5 行内容， 5 可以是任意行数）<br>tail -f 文件   （功能描述：实时追踪该文档的所有更新，工作经常使用）<br></code></pre></td></tr></table></figure><h4 id="9-4-17-ln指令"><a href="#9-4-17-ln指令" class="headerlink" title="9.4.17 ln指令"></a>9.4.17 ln指令</h4><p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 : 在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /root ./linkToRoot<br></code></pre></td></tr></table></figure><p>案例 2 : 删除软连接 linkToRoot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm ./linkToRoot<br></code></pre></td></tr></table></figure><p>细节说明<br>当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。</p><h4 id="9-4-18-history指令"><a href="#9-4-18-history指令" class="headerlink" title="9.4.18 history指令"></a>9.4.18 history指令</h4><p>查看已经执行过历史命令,也可以执行历史指令</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history （功能描述：查看已经执行过历史命令）<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 : 显示所有的历史命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history<br></code></pre></td></tr></table></figure><p>案例 2 : 显示最近使用过的 10 个指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history 10<br></code></pre></td></tr></table></figure><p>案例 3 ：执行历史编号为 5 的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!5<br></code></pre></td></tr></table></figure><h3 id="9-5-时间日期类"><a href="#9-5-时间日期类" class="headerlink" title="9.5 时间日期类"></a>9.5 时间日期类</h3><h4 id="9-5-1-date指令-显示当前日期"><a href="#9-5-1-date指令-显示当前日期" class="headerlink" title="9.5.1 date指令-显示当前日期"></a>9.5.1 date指令-显示当前日期</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">date     （功能描述：显示当前时间）<br>date +%Y （功能描述：显示当前年份）<br>date +%m （功能描述：显示当前月份）<br>date +%d （功能描述：显示当前是哪一天）<br>date &quot;+%Y-%m-%d%H:%M:%S&quot;（功能描述：显示年月日时分秒）<br></code></pre></td></tr></table></figure><h4 id="9-5-2-date指令-设置日期"><a href="#9-5-2-date指令-设置日期" class="headerlink" title="9.5.2 date指令-设置日期"></a>9.5.2 date指令-设置日期</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">date -s 字符串时间     (字符串时间格式为：“2018-10-10 11:22:22”，此时日期和时间用双引号引起来)<br>date -s 14:31:00     (设置时间)<br>date -s 20100405    （设置日期）<br></code></pre></td></tr></table></figure><h4 id="9-5-3-cal指令"><a href="#9-5-3-cal指令" class="headerlink" title="9.5.3 cal指令"></a>9.5.3 cal指令</h4><p>查看日历指令</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cal [选项] （功能描述：不加选项，显示本月日历）<br>cal 2020   (功能描述：显示2020年日历)<br></code></pre></td></tr></table></figure><h3 id="9-6-搜索查找类"><a href="#9-6-搜索查找类" class="headerlink" title="9.6 搜索查找类"></a>9.6 搜索查找类</h3><h4 id="9-6-1-find指令"><a href="#9-6-1-find指令" class="headerlink" title="9.6.1 find指令"></a>9.6.1 find指令</h4><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [搜索范围] [选项]<br></code></pre></td></tr></table></figure><p>选项</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name &lt;文件名&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user &lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size &lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><p>应用实例<br>案例 1 : 按文件名：根据名称查找/home 目录下的hello.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name hello.txt<br></code></pre></td></tr></table></figure><p>案例 2 ：按拥有者：查找/opt目录下，属于nobody的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /opt -user nobody<br></code></pre></td></tr></table></figure><p>案例 3 ：查找整个linux系统下大于 20 m的文件（+n 大于 -n小于 n等于）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -size +200M<br></code></pre></td></tr></table></figure><p>案例 4：查询 / 目录下，所有 .txt的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name *.txt<br></code></pre></td></tr></table></figure><h4 id="9-6-2-locate指令"><a href="#9-6-2-locate指令" class="headerlink" title="9.6.2 locate指令"></a>9.6.2 locate指令</h4><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locate 搜索文件<br></code></pre></td></tr></table></figure><p>特别说明<br>由于locate指令基于数据库进行查询，所以第一次运行前，<strong>必须使用<code>updatedb</code>指令创建locate数据库</strong>。</p><p>应用实例<br>案例 1 : 请使用locate 指令快速定位 hello.txt 文件所在目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">updatedb<br>locate hello.txt<br></code></pre></td></tr></table></figure><h4 id="9-6-3-which指令"><a href="#9-6-3-which指令" class="headerlink" title="9.6.3 which指令"></a>9.6.3 which指令</h4><p>which指令可以查看某个指令在哪个目录下。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which 指令<br></code></pre></td></tr></table></figure><h4 id="9-6-4-grep指令-和-管道符号"><a href="#9-6-4-grep指令-和-管道符号" class="headerlink" title="9.6.4 grep指令 和 管道符号 |"></a>9.6.4 grep指令 和 管道符号 |</h4><p>grep 过滤查找 ， 管道符“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [选项] 查找内容 源文件<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>-n : 显示匹配行及行号</li><li>-i ：忽略字母大小写</li></ul><p>应用实例<br>案例 1 : 请在 hello.txt 文件中，查找 “yes” 所在行，并且显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /home/hello.txt | grep -n yes<br>grep -n yes hello.txt<br></code></pre></td></tr></table></figure><h3 id="9-7-压缩和解压类"><a href="#9-7-压缩和解压类" class="headerlink" title="9.7 压缩和解压类"></a>9.7 压缩和解压类</h3><h4 id="9-7-1-gzip-gunzip-指令"><a href="#9-7-1-gzip-gunzip-指令" class="headerlink" title="9.7.1 gzip/gunzip 指令"></a>9.7.1 gzip/gunzip 指令</h4><p>gzip 用于压缩文件， gunzip 用于解压的</p><p>基本语法</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gzip 文件      （功能描述：压缩文件，只能将文件压缩为*<span class="hljs-string">.gz</span>文件）<br>gunzip 文件<span class="hljs-string">.gz</span> （功能描述：解压缩文件命令）<br></code></pre></td></tr></table></figure><p>细节说明<br>当我们使用gzip 对文件进行压缩后，不会保留原来的文件。</p><h4 id="9-7-2-zip-unzip-指令"><a href="#9-7-2-zip-unzip-指令" class="headerlink" title="9.7.2 zip/unzip 指令"></a>9.7.2 zip/unzip 指令</h4><p>zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip   [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）<br>unzip [选项] XXX.zip（功能描述：解压缩文件）<br></code></pre></td></tr></table></figure><p>zip常用选项</p><ul><li>r：递归压缩，即压缩目录</li></ul><p>unzip的常用选项</p><ul><li>d&lt;目录&gt;：指定解压后文件的存放目录</li></ul><p>应用实例<br>案例 1 : 将 /home本身及下的所有文件进行压缩成 mypackage.zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r mypackage.zip /home<br></code></pre></td></tr></table></figure><p>案例 2 : 将 mypackage.zip 解压到 /opt/tmp 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip -d /opt/tmp mypackage.zip<br></code></pre></td></tr></table></figure><h4 id="9-7-3-tar-指令"><a href="#9-7-3-tar-指令" class="headerlink" title="9.7.3 tar 指令"></a>9.7.3 tar 指令</h4><p>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)<br></code></pre></td></tr></table></figure><p>选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩 (压缩成.gz文件需要加上，同时解压.gz文件也需要加上。如果文件是.tar结尾，不能加z选项)</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table><p>应用实例</p><p>案例 1 : 压缩多个文件，将 /home/pig.txt 和 /home/cat.txt 压缩成 pc.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt<br></code></pre></td></tr></table></figure><p>案例 2 : 将/home 的文件夹 压缩成 myhome.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf myhome.tar.gz /home<br></code></pre></td></tr></table></figure><p>案例 3 : 将 pc.tar.gz 解压到当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf pc.tar.gz<br></code></pre></td></tr></table></figure><p>案例 4 : 将myhome.tar.gz 解压到 /opt/ 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf myhome.tar.gz -C /opt # -C 选项代表解压到指定目录，指定解压到的那个目录，事先要存在才能成功，否则会报错。<br></code></pre></td></tr></table></figure><h2 id="十、组管理和权限管理"><a href="#十、组管理和权限管理" class="headerlink" title="十、组管理和权限管理"></a>十、组管理和权限管理</h2><h3 id="10-1-Linux组基本介绍"><a href="#10-1-Linux组基本介绍" class="headerlink" title="10.1 Linux组基本介绍"></a>10.1 Linux组基本介绍</h3><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</p><h3 id="10-2-文件-目录所有者"><a href="#10-2-文件-目录所有者" class="headerlink" title="10.2 文件/目录所有者"></a>10.2 文件/目录所有者</h3><p>一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者（当然随后可以更改文件的所有者）。</p><h4 id="10-2-1-查看文件的所有者"><a href="#10-2-1-查看文件的所有者" class="headerlink" title="10.2.1 查看文件的所有者"></a>10.2.1 查看文件的所有者</h4><p>基本语法</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -ahl  <span class="hljs-comment"># -a 显示所有文件</span><br> <span class="hljs-comment"># -l 显示文件详细信息，以行的形式显示</span><br> <span class="hljs-comment"># -h 以人类的习惯，显示文件大小</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222161844053.png"></p><h4 id="10-2-2-修改文件所有者"><a href="#10-2-2-修改文件所有者" class="headerlink" title="10.2.2 修改文件所有者"></a>10.2.2 修改文件所有者</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown 用户名 文件名<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例：使用root 创建一个文件apple.txt ，然后将其所有者修改成 tom</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown tom apple.txt<br></code></pre></td></tr></table></figure><h3 id="10-3-文件-目录-所在组"><a href="#10-3-文件-目录-所在组" class="headerlink" title="10.3 文件/目录 所在组"></a>10.3 文件/目录 所在组</h3><p>当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。</p><h4 id="10-3-1-查看文件-目录所在组"><a href="#10-3-1-查看文件-目录所在组" class="headerlink" title="10.3.1 查看文件/目录所在组"></a>10.3.1 查看文件/目录所在组</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lah<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222161945221.png"></p><h4 id="10-3-2-修改文件-目录所在的组"><a href="#10-3-2-修改文件-目录所在的组" class="headerlink" title="10.3.2 修改文件/目录所在的组"></a>10.3.2 修改文件/目录所在的组</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp 组名 文件名/目录<br></code></pre></td></tr></table></figure><p>应用实例<br>实例：使用root用户创建文件 orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到fruit组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp fruit orange.txt<br></code></pre></td></tr></table></figure><h3 id="10-4-其它组"><a href="#10-4-其它组" class="headerlink" title="10.4 其它组"></a>10.4 其它组</h3><p>除文件所在组外，系统其他组都是文件的其它组.</p><h3 id="10-5-改变用户所在组"><a href="#10-5-改变用户所在组" class="headerlink" title="10.5 改变用户所在组"></a>10.5 改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。</p><h4 id="10-5-1-改变用户所在组"><a href="#10-5-1-改变用户所在组" class="headerlink" title="10.5.1 改变用户所在组"></a>10.5.1 改变用户所在组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod –g 组名 用户名<br>usermod –d 目录名 用户名 # 改变该用户登陆的初始目录，当然该用户必须有进入该目录的权限<br></code></pre></td></tr></table></figure><p>应用实例</p><p>实例：创建一个土匪组（bandit）将 tom 这个用户从原来所在的police组，修改到 bandit(土匪) 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd bandit<br>usermod -g bandit tom<br></code></pre></td></tr></table></figure><h3 id="10-6-权限的基本介绍"><a href="#10-6-权限的基本介绍" class="headerlink" title="10.6 权限的基本介绍"></a>10.6 权限的基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l 中显示的内容如下：<br>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure><p>0 - 9 位说明</p><ul><li><p>第 0 位确定文件类型(d,-,l,c,b)</p><ul><li>l是连接，相当于windows的快捷方式</li><li>d是目录，相当于windows的文件夹</li><li>c是字符设备文件，比如鼠标、键盘等</li><li>b是块设备，比如硬盘 </li><li><code>-</code>是文件</li></ul></li><li><p>第 1 - 3 位确定所有者（该文件的所有者）拥有该文件的权限。—User</p></li><li><p>第 4 - 6 位确定所属组（同用户组的）拥有该文件的权限，—Group</p></li><li><p>第 7 - 9 位确定其他用户拥有该文件的权限 —Other</p></li></ul><h3 id="10-7-RWX权限详解"><a href="#10-7-RWX权限详解" class="headerlink" title="10.7 RWX权限详解"></a>10.7 RWX权限详解</h3><h4 id="10-7-1-rwx作用到文件"><a href="#10-7-1-rwx作用到文件" class="headerlink" title="10.7.1 rwx作用到文件"></a>10.7.1 rwx作用到文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[r]代表可读(read): 可以读取,查看<br>[w]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>[x]代表可执行(execute):可以被执行<br></code></pre></td></tr></table></figure><h4 id="10-7-2-rwx作用到目录"><a href="#10-7-2-rwx作用到目录" class="headerlink" title="10.7.2 rwx作用到目录"></a>10.7.2 rwx作用到目录</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[r]</span>代表可读(read): 可以读取，<span class="hljs-selector-tag">ls</span>查看目录内容<br><span class="hljs-selector-attr">[w]</span>代表可写(write): 可以修改,目录内创建+删除+重命名目录<br><span class="hljs-selector-attr">[x]</span>代表可执行(execute):可以进入该目录<br></code></pre></td></tr></table></figure><h3 id="10-8-文件及目录权限实际案例"><a href="#10-8-文件及目录权限实际案例" class="headerlink" title="10.8 文件及目录权限实际案例"></a>10.8 文件及目录权限实际案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l <br>-rwxrw-r-- 1 rootroot 1213 Feb 2 09 : 39 abc<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gcode">-rwxrw-r-- <span class="hljs-number">10</span>个字符确定不同用户能对文件干什么<br>第一个字符代表文件类型：文件 <span class="hljs-comment">(-)</span>,目录<span class="hljs-comment">(d)</span>,链接<span class="hljs-comment">(l)</span>,字符设备文件<span class="hljs-comment">(c)</span>,块设备<span class="hljs-comment">(b)</span><br>其余字符每 <span class="hljs-number">3</span> 个一组<span class="hljs-comment">(rwx)</span> 读<span class="hljs-comment">(r)</span> 写<span class="hljs-comment">(w)</span> 执行<span class="hljs-comment">(x)</span><br>第一组rwx: 文件拥有者的权限是读、写和执行<br>第二组rw-: 与文件拥有者同一组的用户的权限是读、写但不能执行<br>第三组r--: 不与文件拥有者同组的其他用户的权限是读不能写和执行<br>可用数字表示为:r= <span class="hljs-number">4</span> ,w= <span class="hljs-number">2</span> ,x= <span class="hljs-number">1</span> 因此rwx= <span class="hljs-number">4</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">7</span><br><br><span class="hljs-number">1</span>           文件：硬连接数或 目录：子目录数（该目录下一级的子目录数,注意空目录下也有 . 和 .. 代表当前目录和上一级目录）<br>root 所属用户<br>root        所属组<br><span class="hljs-number">1213</span> 文件大小<span class="hljs-comment">(字节)</span>，如果是文件夹，显示 <span class="hljs-number">4096</span> 字节<br>Feb <span class="hljs-number">2</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span> 最后修改日期<br>abc         文件名<br></code></pre></td></tr></table></figure><h3 id="10-9-修改权限"><a href="#10-9-修改权限" class="headerlink" title="10.9 修改权限"></a>10.9 修改权限</h3><p>基本说明：通过chmod指令，可以修改文件或者目录的权限</p><h4 id="10-9-1-第一种方式：-、-、-变更权限"><a href="#10-9-1-第一种方式：-、-、-变更权限" class="headerlink" title="10.9.1 第一种方式：+、-、=变更权限"></a>10.9.1 第一种方式：+、-、=变更权限</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)<br><span class="hljs-number">1</span> )<span class="hljs-keyword">chmod</span> u=rwx,g=rx,o=<span class="hljs-keyword">x</span> 文件目录名<br><span class="hljs-number">2</span> )<span class="hljs-keyword">chmod</span> o+w 文件目录名<br><span class="hljs-number">3</span> )<span class="hljs-keyword">chmod</span> a-<span class="hljs-keyword">x</span> 文件目录名<br></code></pre></td></tr></table></figure><p>案例演示<br>案例1： 给abc文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=rx abc<br></code></pre></td></tr></table></figure><p>案例2： 给abc文件的所有者除去执行的权限，增加组写的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u-x,g+w abc<br></code></pre></td></tr></table></figure><p>案例3： 给abc文件的所有用户添加读的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod a+r abc<br></code></pre></td></tr></table></figure><h4 id="10-9-2-第二种方式：通过数字变更权限"><a href="#10-9-2-第二种方式：通过数字变更权限" class="headerlink" title="10.9.2 第二种方式：通过数字变更权限"></a>10.9.2 第二种方式：通过数字变更权限</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">规则：r=<span class="hljs-number"> 4 </span>w=<span class="hljs-number"> 2 </span>x=<span class="hljs-number"> 1 </span>,rwx=<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 7<br>chmodu=rwx,g=rx,o=x 文件目录名<br>相当于 chmod<span class="hljs-number"> 751 </span>文件目录名<br></code></pre></td></tr></table></figure><p>案例演示</p><p>案例：将 /home/abc.txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现：<br>            rwx= 4 + 2 + 1 = 7<br>            r-x= 4 + 1 = 5<br>            r-x= 4 + 1 = 5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 /home/abc.txt<br></code></pre></td></tr></table></figure><h3 id="10-10-修改文件-目录所有者"><a href="#10-10-修改文件-目录所有者" class="headerlink" title="10.10 修改文件/目录所有者"></a>10.10 修改文件/目录所有者</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown newowner file           #改变文件/目录的所有者<br>chown newowner:newgroup file  #改变文件/目录的所有者和所有组<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>-R 如果是目录 则使其下所有子文件或目录递归生效</li></ul><p>案例演示：</p><p>案例1：请将 /home/abc.txt 文件的所有者修改成 tom</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod tom abc.txt<br></code></pre></td></tr></table></figure><p>案例2：请将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom，首选我们应该使用root操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R tom /home/kkk<br></code></pre></td></tr></table></figure><h3 id="10-11-修改文件-目录所在组"><a href="#10-11-修改文件-目录所在组" class="headerlink" title="10.11 修改文件/目录所在组"></a>10.11 修改文件/目录所在组</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp newgroup file 改变文件/目录的所在组<br></code></pre></td></tr></table></figure><p>案例演示：</p><p>案例1：请将 /home/abc.txt 文件的所在组修改成 bandit(土匪)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp bandit /home/abc.txt<br></code></pre></td></tr></table></figure><p>案例2：请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp -R bandit /home/kkk<br></code></pre></td></tr></table></figure><h3 id="10-12-最佳实践-警察和土匪游戏"><a href="#10-12-最佳实践-警察和土匪游戏" class="headerlink" title="10.12 最佳实践-警察和土匪游戏"></a>10.12 最佳实践-警察和土匪游戏</h3><p>police ,bandit<br>jack,jerry: 警察<br>xh,xq: 土匪<br>( 1 )创建组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd police<br>groupadd bandit<br></code></pre></td></tr></table></figure><p>( 2 )创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -g police jack<br>useradd -g police jerry<br>useradd -g bandit xh<br>useradd -g bandit xq<br></code></pre></td></tr></table></figure><p>( 3 ) jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - jack<br>touch jack.txt<br>chmod 640 jack.txt<br></code></pre></td></tr></table></figure><p>( 4 )jack 修改该文件，让其它组人可以读, 本组人可以读写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 664 jack.txt<br></code></pre></td></tr></table></figure><p>( 5 )xh 投靠警察，看看是否可以读写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g police xh<br></code></pre></td></tr></table></figure><h3 id="10-13-课后练习"><a href="#10-13-课后练习" class="headerlink" title="10.13 课后练习"></a>10.13 课后练习</h3><p>建立两个组（神仙,妖怪）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd shenxian <br>groupadd yaoguai<br></code></pre></td></tr></table></figure><p>建立四个用户(唐僧,悟空，八戒，沙僧)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd tang<br>useradd wu<br>useradd ba<br>useradd sha<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd tang<br>passwd wu<br>passwd ba<br>passwd sha<br></code></pre></td></tr></table></figure><p>把悟空，八戒放入妖怪 唐僧 沙僧 在神仙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g yaoguai wu<br>usermod -g yaoguai ba<br>usermod -g shenxian tang<br>usermod -g shenxian sha<br></code></pre></td></tr></table></figure><p>用悟空建立一个文件 （monkey.java 该文件要输出 iammonkey）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - wu<br>touch monkey.java<br>echo ianmonkey &gt; monkey.java<br></code></pre></td></tr></table></figure><p>给八戒一个可以rw 的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 760 monkey.java<br>chmod 777 /home/wu<br></code></pre></td></tr></table></figure><p>八戒修改monkey.java 加入一句话(iampig)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo iampig &gt;&gt; monkey.java<br></code></pre></td></tr></table></figure><p>唐僧 沙僧 对该文件没有权限,把 沙僧 放入妖怪组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g yaoguai sha<br>reboot #重新登录，刷新登录信息<br></code></pre></td></tr></table></figure><p>让沙僧 修改 该文件 monkey, 加入一句话 (“我是沙僧，我是妖怪!”);</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;我是沙僧，我是妖怪！&quot; &gt;&gt; monkey.java<br></code></pre></td></tr></table></figure><h2 id="十一、crond-任务调度"><a href="#十一、crond-任务调度" class="headerlink" title="十一、crond 任务调度"></a>十一、crond 任务调度</h2><h3 id="11-1-原理示意图"><a href="#11-1-原理示意图" class="headerlink" title="11.1 原理示意图"></a>11.1 原理示意图</h3><p>crontab 进行定时任务的设置。</p><p>任务调度：是指系统在某个时间执行的特定的命令或程序。<br>任务调度分类：</p><p>1 .系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>2 .个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p><p>基本语法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab [选项]<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>-e: 编辑crontab定时任务</li><li>-l: 查询crontab任务</li><li>-r: 删除当前用户所有的crontab任务</li></ul><h3 id="11-2-快速入门"><a href="#11-2-快速入门" class="headerlink" title="11.2 快速入门"></a>11.2 快速入门</h3><h4 id="11-2-1-任务的要求"><a href="#11-2-1-任务的要求" class="headerlink" title="11.2.1 任务的要求"></a>11.2.1 任务的要求</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">设置任务调度文件：<span class="hljs-regexp">/etc/</span>crontab<br>设置个人任务调度。执行crontab –e命令。<br>接着输入任务到调度文件<br>如：ls –l <span class="hljs-regexp">/etc/</span> &gt; <span class="hljs-regexp">/tmp/</span>to.txt<br>意思说每小时的每分钟执行ls –l<span class="hljs-regexp">/etc &gt; /</span>tmp/to.txt命令<br></code></pre></td></tr></table></figure><h4 id="11-2-2-步骤如下"><a href="#11-2-2-步骤如下" class="headerlink" title="11.2.2 步骤如下"></a>11.2.2 步骤如下</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) crontab -e<br><span class="hljs-symbol">2 </span>) */ <span class="hljs-number">1</span> * * * * ls -l /etc &gt; /tmp/<span class="hljs-keyword">to</span>.txt<br><span class="hljs-symbol">3 </span>) 当保存退出后就程序。<br><span class="hljs-symbol">4 </span>) 在每一分钟都会自动的调用 ls -l /etc &gt; /tmp/<span class="hljs-keyword">to</span>.txt<br></code></pre></td></tr></table></figure><h4 id="11-2-3-参数细节说明"><a href="#11-2-3-参数细节说明" class="headerlink" title="11.2.3 参数细节说明"></a>11.2.3 参数细节说明</h4><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个 “*”</td><td>一个小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个 ”*“</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个 ”*“</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个 ”*“</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个 ”*“</td><td>一周当中的星期几</td><td>0-7（0和7代表星期日）</td></tr></tbody></table><h4 id="11-2-4-特殊符号的说明"><a href="#11-2-4-特殊符号的说明" class="headerlink" title="11.2.4 特殊符号的说明"></a>11.2.4 特殊符号的说明</h4><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间。比如第一个”*“就代表一小时中每分钟都执行一次的意思</td></tr><tr><td>,</td><td>代表不连续的时间。比如<code>0 8,12,16 * * * </code>命令，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围。比如<code>0 5 * * 1-6</code>命令，代表在周一到周六的凌晨5点0分执行命令</td></tr><tr><td>*/n</td><td>代表每个多久执行一次。比如<code>*/10 * * * *</code>命令，代表每个10分钟就执行一遍命令</td></tr></tbody></table><h4 id="11-2-5-特定时间执行任务案例"><a href="#11-2-5-特定时间执行任务案例" class="headerlink" title="11.2.5 特定时间执行任务案例"></a>11.2.5 特定时间执行任务案例</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>45 22 * * * </code></td><td>每天22点45分执行任务</td></tr><tr><td><code>0 17 * * 1</code></td><td>每周星期一0点17分执行任务</td></tr><tr><td><code>0 5 1,15 * * </code></td><td>每月1号和15号的5点0分执行任务</td></tr><tr><td><code>40 4 * * 1-5</code></td><td>每周一到周五的4点40分执行任务</td></tr><tr><td><code>*/10 4 * * * </code></td><td>每天4点每隔10分钟执行任务</td></tr><tr><td><code>0 0 1,15 * 1</code></td><td>每月1号和5号，每周一的0点0分执行任务。（这里1号15号与周一取并集）</td></tr></tbody></table><p>注意：星期几和几号最好不要同时出现，因为他们定义的都是天，非常容易让管理员混乱。</p><p><a href="https://tool.lu/crontab/">crontab定时任务解析网站</a></p><h4 id="11-2-4-任务调度的几个应用实例"><a href="#11-2-4-任务调度的几个应用实例" class="headerlink" title="11.2.4 任务调度的几个应用实例"></a>11.2.4 任务调度的几个应用实例</h4><p>案例 1 ：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate文件中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">crontab -e<br>*<span class="hljs-regexp">/1 * * * * date &gt;&gt; /</span>tmp/mydate<br></code></pre></td></tr></table></figure><p>案例 2 ：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal文件中</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs qml">vim my.sh<br><span class="hljs-built_in">date</span> &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br>cal &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br><br>chmod <span class="hljs-number">777</span> home/my.sh<br><br>crontab -e<br>*<span class="hljs-regexp">/1 * * * * home/my</span>.sh<br></code></pre></td></tr></table></figure><p>案例 3 : 每天凌晨 2 : 00 将mysql数据库testdb ，备份到文件中 mydb.bak。提示：指令为<code>mysqldump -u root -p密码 数据库 &gt; /home/db.bak</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">crontab -e<br><span class="hljs-number">0</span> <span class="hljs-number">2</span> * * * mysqldump -u root -proot testdb &gt; <span class="hljs-regexp">/home/</span>db.bak<br></code></pre></td></tr></table></figure><h3 id="11-3-crond-相关指令"><a href="#11-3-crond-相关指令" class="headerlink" title="11.3 crond 相关指令"></a>11.3 crond 相关指令</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) conrtab –r：终止任务调度(就是删除任务）。<br><span class="hljs-symbol">2 </span>) crontab –l：列出当前有那些任务调度<br><span class="hljs-symbol">3 </span>) service crond restart   [重启任务调度]<br></code></pre></td></tr></table></figure><h3 id="11-4-at定时任务"><a href="#11-4-at定时任务" class="headerlink" title="11.4 at定时任务"></a>11.4 at定时任务</h3><p>基本介绍：</p><ol><li>at命令是一次性定时计划任务，at的守护进行atd会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，atd守护进行每60秒检查<strong>作业队列</strong>，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li><li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看。<code>ps -ef | grep atd</code>可以检测atd是否在运行。</li></ol><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at [选项] [时间]<br>Ctrl + D 结束at命令的输入(两次按Ctrl + D)<br></code></pre></td></tr></table></figure><p>选项说明：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td></tr><tr><td><code>-I</code></td><td>atq的别名（查询）</td></tr><tr><td>-d</td><td>atrm的别名（删除）</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-q &lt;队列&gt;</td><td>使用指定的队列</td></tr><tr><td>-f &lt;文件&gt;</td><td>从指定文件读入任务而不是从标准输入读入</td></tr><tr><td>-t &lt;时间参数&gt;</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table><p>at时间定义：</p><ol><li>接受在当天hh:mm（小时：分钟）式的时间指定。假如该时间已经过去，那么就放在第二天执行。例如：04:00</li><li>使用midnight（深夜)，noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间。</li><li>采用12小时计时制，即在时间后面加上AM（上午）或者PM（下午）来说明是上午还是下午。例如12PM</li><li>指定命令执行的具体日期，指定格式为month day （月 日）或者 mm/dd/yy（月/日/年） 或者 dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。例如：04:00 2021-03-01</li><li>使用相对计时法。指定格式为： now + count time-units，now就是当前时间，time-units是时间单位，几天，几小时。例如：now + 5 minutes</li><li>直接使用today（今天）、tomorrow（明天）来制定完成命令的时间。</li></ol><p>应用实例：</p><p>实例1:2天后的下午5点执行 /bin/ls /home</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at 5pm + 2 days<br><span class="hljs-meta">at&gt;</span><span class="bash"> /bin/ls /home</span><br></code></pre></td></tr></table></figure><p>案例2：atq命令来查看系统中没有执行的工作任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">atq<br></code></pre></td></tr></table></figure><p>案例3：明天17点钟，输出时间到指定文件内，比如/root/date100.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at 5pm tomorrow<br>date &gt;&gt; /root/date100.log<br></code></pre></td></tr></table></figure><p>案例4：2分钟后，输出时间到指定文件内，比如/root/date200.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at now + 2 minutes<br>date &gt;&gt; /root/date200.log<br></code></pre></td></tr></table></figure><p>案例5：删除已经设置的任务，artm编号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">atrm 1<br></code></pre></td></tr></table></figure><h2 id="十二、Linux-磁盘分区、挂载"><a href="#十二、Linux-磁盘分区、挂载" class="headerlink" title="十二、Linux 磁盘分区、挂载"></a>十二、Linux 磁盘分区、挂载</h2><h3 id="12-1-LINUX分区"><a href="#12-1-LINUX分区" class="headerlink" title="12.1 LINUX分区"></a>12.1 LINUX分区</h3><h4 id="12-1-1-原理介绍"><a href="#12-1-1-原理介绍" class="headerlink" title="12.1.1 原理介绍"></a>12.1.1 原理介绍</h4><ol><li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 ,Linux中每个分区都是用来组成整个文件系统的一部分。</p></li><li><p>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p></li><li><p>示意图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223162138373.png"></p></li></ol><h4 id="12-1-2-硬盘说明"><a href="#12-1-2-硬盘说明" class="headerlink" title="12.1.2 硬盘说明"></a>12.1.2 硬盘说明</h4><ol><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda 3 表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb 2 表示为第二个IDE硬盘上的第二个主分区或扩展分区。</li><li>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</li></ol><p>分区的方式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>)mbr分区:<br><span class="hljs-symbol">1 </span>.最多支持四个主分区<br><span class="hljs-symbol">2 </span>.系统只能安装在主分区<br><span class="hljs-symbol">3 </span>.扩展分区要占一个主分区<br><span class="hljs-symbol">4 </span>.MBR最大只支持 <span class="hljs-number">2</span> TB，但拥有最好的兼容性<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>)gtp分区:<br><span class="hljs-symbol">1 </span>.支持无限多个主分区（但操作系统可能限制，比如 windows下最多 <span class="hljs-number">128</span> 个分区）<br><span class="hljs-symbol">2 </span>.最大支持 <span class="hljs-number">18</span> EB的大容量（ <span class="hljs-number">1</span> EB= <span class="hljs-number">1024</span> PB， <span class="hljs-number">1</span> PB= <span class="hljs-number">1024</span> TB ）<br><span class="hljs-symbol">3 </span>.windows <span class="hljs-number">7</span> <span class="hljs-number">64</span> 位以后支持gtp<br></code></pre></td></tr></table></figure><h4 id="12-1-3-使用lsblk指令查看当前系统的分区情况"><a href="#12-1-3-使用lsblk指令查看当前系统的分区情况" class="headerlink" title="12.1.3 使用lsblk指令查看当前系统的分区情况"></a>12.1.3 使用lsblk指令查看当前系统的分区情况</h4><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsblk 或者 lsblk -f<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223163636480.png"></p><h3 id="12-2-挂载的经典案例"><a href="#12-2-挂载的经典案例" class="headerlink" title="12.2 挂载的经典案例"></a>12.2 挂载的经典案例</h3><p>需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> )虚拟机添加硬盘<br><span class="hljs-number">2</span> )分区 fdisk<span class="hljs-regexp">/dev/</span>sdb<br><span class="hljs-number">3</span> )格式化 mkfs -text <span class="hljs-number">4</span> <span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span><br><span class="hljs-number">4</span> )挂载 先创建一个 <span class="hljs-regexp">/home/</span>newdisk , 挂载 mount <span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span> <span class="hljs-regexp">/home/</span>newdisk<br><span class="hljs-number">5</span> )设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 <span class="hljs-regexp">/home/</span>newdisk) 。<br>vim <span class="hljs-regexp">/etc/</span>fstab<br><span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span> <span class="hljs-regexp">/home/</span>newdisk ext <span class="hljs-number">4</span> defaults <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h4 id="12-2-1-虚拟机增加硬盘步骤-1"><a href="#12-2-1-虚拟机增加硬盘步骤-1" class="headerlink" title="12.2.1 虚拟机增加硬盘步骤 1"></a>12.2.1 虚拟机增加硬盘步骤 1</h4><p>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！</p><h4 id="12-2-2-虚拟机增加硬盘步骤-2"><a href="#12-2-2-虚拟机增加硬盘步骤-2" class="headerlink" title="12.2.2 虚拟机增加硬盘步骤 2"></a>12.2.2 虚拟机增加硬盘步骤 2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">分区命令 fdisk <span class="hljs-regexp">/dev/</span>sdb<br>开始对/sdb分区<br></code></pre></td></tr></table></figure><ul><li>m 显示命令列表</li><li>p 显示磁盘分区 同 <code>fdisk –l</code></li><li>n 新增分区</li><li>d 删除分区</li><li>w 写入并退出<br>说明： 开始分区后输入n，新增分区，然后选择p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。</li></ul><h4 id="12-2-3-虚拟机增加硬盘步骤-3"><a href="#12-2-3-虚拟机增加硬盘步骤-3" class="headerlink" title="12.2.3 虚拟机增加硬盘步骤 3"></a>12.2.3 虚拟机增加硬盘步骤 3</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">格式化磁盘<br>分区命令:mkfs -t ext4 <span class="hljs-regexp">/dev/</span>sdb1<br>其中 ext4 是分区类型<br></code></pre></td></tr></table></figure><h4 id="12-2-4-虚拟机增加硬盘步骤-4"><a href="#12-2-4-虚拟机增加硬盘步骤-4" class="headerlink" title="12.2.4 虚拟机增加硬盘步骤 4"></a>12.2.4 虚拟机增加硬盘步骤 4</h4><p>挂载: 将一个分区与一个目录联系起来。</p><p>挂载基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount 设备名称 挂载目录<br>例如： mount /dev/sdb1 /newdisk<br></code></pre></td></tr></table></figure><p>卸载基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount 设备名称 或者 挂载目录<br>例如： umount /dev/sdb1 或者 umount /newdisk<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，使用命令行挂载，在重启后会失效。</strong></p><h4 id="12-2-5-虚拟机增加硬盘步骤-5"><a href="#12-2-5-虚拟机增加硬盘步骤-5" class="headerlink" title="12.2.5 虚拟机增加硬盘步骤 5"></a>12.2.5 虚拟机增加硬盘步骤 5</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">永久挂载: 通过修改 <span class="hljs-regexp">/etc/</span>fstab 实现挂载<br>添加完成后 执行 mount –a 即刻生效<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223170740749.png"></p><p>字段解释</p><p><strong>/etc/fstab文件主要包括6段，依次是：</strong></p><p><strong><file system>　　<dir>　　<type>　　<options>　　<dump>　　<pass></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;file system&gt; 要挂载的分区或存储设备<br>&lt;dir&gt;  挂载的目录位置<br>&lt;type&gt; 挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap<br>&lt;options&gt; 挂载使用的参数有哪些。举例如下：<br>auto - 在启动时或键入了 mount -a 命令时自动挂载。<br>noauto - 只在你的命令下被挂载。<br>exec - 允许执行此分区的二进制文件。<br>noexec - 不允许执行此文件系统上的二进制文件。<br>ro - 以只读模式挂载文件系统。<br>rw - 以读写模式挂载文件系统。<br>user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。<br>users - 允许所有 users 组中的用户挂载文件系统.<br>nouser - 只能被 root 挂载。<br>owner - 允许设备所有者挂载.<br>sync - I/O 同步进行。<br>async - I/O 异步进行。<br>dev - 解析文件系统上的块特殊设备。<br>nodev - 不解析文件系统上的块特殊设备。<br>suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。<br>nosuid - 禁止 suid 操作和设定 sgid 位。<br>noatime - 不更新文件系统上 inode 访问记录，可以提升性能。<br>nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。<br>relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。<br>flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。<br>defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.<br><br>&lt;dump&gt;  dump 工具通过它决定何时作备份. dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言 &lt;dump&gt; 应设为 0。<br><br>&lt;pass&gt; fsck 读取 &lt;pass&gt; 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2. 0 表示设备不会被 fsck 所检查。<br></code></pre></td></tr></table></figure><h3 id="12-3-磁盘情况查询"><a href="#12-3-磁盘情况查询" class="headerlink" title="12.3 磁盘情况查询"></a>12.3 磁盘情况查询</h3><h4 id="12-3-1-查询系统整体磁盘使用情况"><a href="#12-3-1-查询系统整体磁盘使用情况" class="headerlink" title="12.3.1 查询系统整体磁盘使用情况"></a>12.3.1 查询系统整体磁盘使用情况</h4><p>基本语法</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">df -h</span><br></code></pre></td></tr></table></figure><p>应用实例<br>实例1：查询系统整体磁盘使用情况</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223171558366.png"></p><h4 id="12-3-2-查询指定目录的磁盘占用情况"><a href="#12-3-2-查询指定目录的磁盘占用情况" class="headerlink" title="12.3.2 查询指定目录的磁盘占用情况"></a>12.3.2 查询指定目录的磁盘占用情况</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -h 目录   #查询指定目录的磁盘占用情况，默认为当前目录<br></code></pre></td></tr></table></figure><p>选项说明：</p><ul><li>-s 指定目录占用大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>–max-depth=1 子目录深度为1</li></ul><ul><li>-c 列出明细的同时，增加汇总值</li></ul><p>应用实例<br>案例1：查询 /opt 目录的磁盘占用情况，深度为 2</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223172209906.png"></p><h3 id="12-4-磁盘情况-工作实用指令"><a href="#12-4-磁盘情况-工作实用指令" class="headerlink" title="12.4 磁盘情况-工作实用指令"></a>12.4 磁盘情况-工作实用指令</h3><ol><li>统计/home文件夹下文件的个数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><ol start="2"><li>统计/home文件夹下目录的个数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /home | grep &quot;^d&quot; | wc -l<br></code></pre></td></tr></table></figure><p>3 统计/home文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lR /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><p>4 ) 统计文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lR /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><p>5 ) 以树状显示/home目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tree /home<br></code></pre></td></tr></table></figure><h2 id="十三、网络配置"><a href="#十三、网络配置" class="headerlink" title="十三、网络配置"></a>十三、网络配置</h2><h3 id="13-1-Linux网络配置原理图-含虚拟机"><a href="#13-1-Linux网络配置原理图-含虚拟机" class="headerlink" title="13.1 Linux网络配置原理图(含虚拟机)"></a>13.1 Linux网络配置原理图(含虚拟机)</h3><p>目前我们的网络配置采用的是NAT。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223193808182.png"></p><h3 id="13-2-查看网络IP和网关"><a href="#13-2-查看网络IP和网关" class="headerlink" title="13.2 查看网络IP和网关"></a>13.2 查看网络IP和网关</h3><p> 在windows环境下，查看ip配置，基本语法：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ipconfig</span><br></code></pre></td></tr></table></figure><p>在linux环境下，查看ip配置，基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h3 id="13-3-Ping测试主机之间网络连通"><a href="#13-3-Ping测试主机之间网络连通" class="headerlink" title="13.3 Ping测试主机之间网络连通"></a>13.3 Ping测试主机之间网络连通</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：测试当前服务器是否可以连接百度</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.baidu.com<br></code></pre></td></tr></table></figure><h3 id="13-4-Linux网络环境配置"><a href="#13-4-Linux网络环境配置" class="headerlink" title="13.4 Linux网络环境配置"></a>13.4 Linux网络环境配置</h3><h4 id="13-4-1-第一种方法-自动获取"><a href="#13-4-1-第一种方法-自动获取" class="headerlink" title="13.4.1 第一种方法(自动获取)"></a>13.4.1 第一种方法(自动获取)</h4><p>说明：登录以后，通过界面来设置自动获取ip，特点：linux启动后会自动获取ip。</p><p>缺点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip需要时固定的。</p><p>可以多了解一些<strong>DHCP</strong>（动态路由选择协议）。</p><h4 id="13-4-2-第二种方法-指定固定的ip"><a href="#13-4-2-第二种方法-指定固定的ip" class="headerlink" title="13.4.2 第二种方法(指定固定的ip)"></a>13.4.2 第二种方法(指定固定的ip)</h4><p>说明：直接修改配置文件来指定ip，并可以连接到外网(程序员推荐)，要求：将ip地址配置的静态的，ip地址为 192.168.184.130</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223200552506.png"></p><p>修改后，一定要重启服务/重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network restart<br>reboot <br></code></pre></td></tr></table></figure><h3 id="13-5-设置主机名和hosts映射"><a href="#13-5-设置主机名和hosts映射" class="headerlink" title="13.5 设置主机名和hosts映射"></a>13.5 设置主机名和hosts映射</h3><h4 id="13-5-1-设置主机名"><a href="#13-5-1-设置主机名" class="headerlink" title="13.5.1 设置主机名"></a>13.5.1 设置主机名</h4><ol><li>为了方便记忆，可以给linux系统设置<strong>主机名</strong>，也可以根据需要修改主机名</li><li>指令 <code>hostname</code>:查看主机名</li><li>修改文件在<code>/etc/hostname</code>指定</li><li>修改后，重启生效</li></ol><h4 id="13-5-2-设置hosts映射"><a href="#13-5-2-设置hosts映射" class="headerlink" title="13.5.2 设置hosts映射"></a>13.5.2 设置hosts映射</h4><p>通过 <strong>主机名</strong> 能够找到（比如ping）某个linux系统。</p><p>在windows系统下，修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件指定即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.200.130 jyg<br></code></pre></td></tr></table></figure><p>在linux系统下，修改<code>/etc/hosts</code>文件指定即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.200.1 jyg<br></code></pre></td></tr></table></figure><h3 id="13-6-主机名解析过程分析（Hosts、DNS）"><a href="#13-6-主机名解析过程分析（Hosts、DNS）" class="headerlink" title="13.6 主机名解析过程分析（Hosts、DNS）"></a>13.6 主机名解析过程分析（Hosts、DNS）</h3><h4 id="13-6-1-Hosts是什么"><a href="#13-6-1-Hosts是什么" class="headerlink" title="13.6.1 Hosts是什么"></a>13.6.1 Hosts是什么</h4><p>一个文本文件，用来记录ip和Hostname（主机名）的映射关系</p><h4 id="13-6-2-DNS"><a href="#13-6-2-DNS" class="headerlink" title="13.6.2 DNS"></a>13.6.2 DNS</h4><ol><li>DNS，就是Domain Name System的缩写，翻译过来就是域名系统</li><li>DNS是互联网上作为域名和ip地址相互映射的一个分布式数据库</li></ol><h4 id="13-6-3-当用户在浏览器输入www-baidu-com，系统如何解析的ip地址"><a href="#13-6-3-当用户在浏览器输入www-baidu-com，系统如何解析的ip地址" class="headerlink" title="13.6.3 当用户在浏览器输入www.baidu.com，系统如何解析的ip地址"></a>13.6.3 当用户在浏览器输入<a href="http://www.baidu.com,系统如何解析的ip地址/">www.baidu.com，系统如何解析的ip地址</a></h4><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址，如果有就先返回这个IP完成解析；如果没有，就检查操作系统DNS解析器缓存，如果有就直接返回这个IP完成解析。这两个缓存，可以理解为本地解析器缓存。</p><p>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存该域名的IP地址（DNS解析记录），例如在cmd窗口中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipconfig /displaydns   #DNS域名解析缓存<br>ipconfig /flushdns     #手动清理DNS缓存<br></code></pre></td></tr></table></figure></li><li><p>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中，有没有配置对应的域名IP映射，如果有，则完成解析病返回该IP</p><p><strong>所以，修改系统<code>hosts</code>文件，可以做到域名劫持。</strong></p></li><li><p>如果本地DNS解析器缓存和hosts文件中均没有找到哦啊对应的IP，则到域名服务器DNS进行解析域名。</p></li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223203658890.png"></p><h2 id="十四、进程管理"><a href="#十四、进程管理" class="headerlink" title="十四、进程管理"></a>十四、进程管理</h2><h3 id="14-1-进程的基本介绍"><a href="#14-1-进程的基本介绍" class="headerlink" title="14.1 进程的基本介绍"></a>14.1 进程的基本介绍</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-number">1</span>)在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号（<span class="hljs-keyword">pid</span>，进程号）。<br><span class="hljs-number">2</span>)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。<br><span class="hljs-number">3</span>)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。<br><span class="hljs-number">4</span>)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。<br></code></pre></td></tr></table></figure><h3 id="14-2-显示系统执行的进程"><a href="#14-2-显示系统执行的进程" class="headerlink" title="14.2 显示系统执行的进程"></a>14.2 显示系统执行的进程</h3><h4 id="14-2-1-ps命令基本介绍"><a href="#14-2-1-ps命令基本介绍" class="headerlink" title="14.2.1 ps命令基本介绍"></a>14.2.1 ps命令基本介绍</h4><p><code>ps</code>命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以加任何参数。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223211635045.png"></p><h4 id="14-2-2-ps现实的信息选项："><a href="#14-2-2-ps现实的信息选项：" class="headerlink" title="14.2.2 ps现实的信息选项："></a>14.2.2 ps现实的信息选项：</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程识别号</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程所消耗CPU时间</td></tr><tr><td>CMD</td><td>正在执行的命令或进程名</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a #显示当前终端的所有进程信息<br>ps -u #以用户格式显示进程信息<br>ps -x #显示后台进程运行的参数<br></code></pre></td></tr></table></figure><p>一般组合使用<code>ps -aux</code></p><h4 id="14-2-3-ps指令详解"><a href="#14-2-3-ps指令详解" class="headerlink" title="14.2.3 ps指令详解"></a>14.2.3 ps指令详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223212209393.png"></p><p>各字段解释：</p><ul><li><p>USER：    用户名称</p></li><li><p>PID：进程号</p></li><li><p>%CPU：进程占用CPU的百分比</p></li><li><p>%MEM：进程占用物理内存的百分比</p></li><li><p>VSZ：进程占用的虚拟内存大小（单位：KB）</p></li><li><p>RSS：进程占用的物理内存大小（单位：KB）</p></li><li><p>TTY：终端名称,太长就缩写为<code>?</code>.</p></li><li><p>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p></li><li><p>START：进程的启动时间</p></li><li><p>TIME：CPU时间，即进程使用CPU的总时间</p></li><li><p>COMMAND：进程名或者执行进程所用的命令和参数，如果过长会被截断显示</p></li></ul><p>应用实例：</p><p>实例1：查看有没有sshd服务进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux | grep sshd<br></code></pre></td></tr></table></figure><p>实例2：以全格式显示当前所有的进程，查看sshd进程的父进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #以全格式显示当前所有的进程<br></code></pre></td></tr></table></figure><p>选项解释：</p><ul><li>-e:显示所有进程</li><li>-f:全格式</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223213643683.png"></p><p>各字段解释：</p><ul><li><p>UID：用户ID</p></li><li><p>PID：进程ID</p></li><li><p>PPID：父进程ID</p></li><li><p>C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</p></li><li><p>STIME：进程启动的时间</p></li><li><p>TTY：完整的终端名称</p></li><li><p>TIME：CPU时间</p></li><li><p>CMD：启动进程所用的命令和参数<br>思考题，如果我们希望查看 sshd进程的父进程号是多少，应该怎样查询 ？</p></li></ul><h3 id="14-3-终止进程kill和killall"><a href="#14-3-终止进程kill和killall" class="headerlink" title="14.3 终止进程kill和killall"></a>14.3 终止进程kill和killall</h3><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><p>基本语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> [选项] 进程号 （功能描述：通过进程号杀死进程）<br>killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>-9 :表示强迫进程立即停止</li></ul><p>应用实践：</p><p>案例 1 ：踢掉某个非法登录用户<code>tom</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #查询tom登录的PID<br>kill [tom用户登录对应的进程号]<br></code></pre></td></tr></table></figure><p>案例 2 : 终止远程登录服务sshd, 在适当时候再次重启sshd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #查询sshd服务的PID<br>kill [sshd服务的PID]<br>/bin/systemctl start sshd.service #重启sshd服务<br></code></pre></td></tr></table></figure><p>案例 3 : 终止多个gedit 编辑器 【killall, 通过进程名称来终止进程】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall gedit<br></code></pre></td></tr></table></figure><p>案例 4 ：强制杀掉一个终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep bash<br>kill [bash的PID] #这种情况系统有保护，不能杀掉<br>kill -9 [bash的PID] #强制杀掉<br></code></pre></td></tr></table></figure><h3 id="14-4-查看进程树pstree"><a href="#14-4-查看进程树pstree" class="headerlink" title="14.4 查看进程树pstree"></a>14.4 查看进程树pstree</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pstree [选项] #可以更加直观的来看进程信息<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>-p:显示进程的PID</li><li>-u:显示进程的所属用户</li></ul><p>应用实例：</p><p>案例 1 ：请你树状的形式显示进程的pid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pstree -p<br></code></pre></td></tr></table></figure><p>案例 2 ：请你树状的形式进程的用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -u</span><br></code></pre></td></tr></table></figure><h3 id="14-5-服务-service-管理"><a href="#14-5-服务-service-管理" class="headerlink" title="14.5 服务(service)管理"></a>14.5 服务(service)管理</h3><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld,sshd,防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224193420932.png"></p><h4 id="14-5-1-service管理指令"><a href="#14-5-1-service管理指令" class="headerlink" title="14.5.1 service管理指令"></a>14.5.1 service管理指令</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">service 服务名 [start|<span class="hljs-type">stop</span>|<span class="hljs-type">restart</span>|<span class="hljs-type">reload</span>|<span class="hljs-type">status</span>]<br>在CentOS <span class="hljs-number">7.0</span> 后,不再使用service,而是 systemctl(ubuntu也是使用systemctl)<br></code></pre></td></tr></table></figure><p>在<code>/etc/init.d</code>下，可以查看service指令管理的服务。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224193758012.png"></p><p>使用实例：</p><p>实例1：使用<code>service</code>指令，查看、关闭、启动network。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network status<br>service network stop<br>service network start  <br></code></pre></td></tr></table></figure><h4 id="14-5-2-查看服务名"><a href="#14-5-2-查看服务名" class="headerlink" title="14.5.2 查看服务名"></a>14.5.2 查看服务名</h4><p>方式 1 ：使用setup-&gt; 系统服务 就可以看到（可以查看全部服务，许多发行版不支持了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setup<br></code></pre></td></tr></table></figure><p>方式 2 : /etc/init.d/服务名称（只能查看一部分）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /etc/init.d<br></code></pre></td></tr></table></figure><h4 id="14-5-3-服务的运行级别-runlevel"><a href="#14-5-3-服务的运行级别-runlevel" class="headerlink" title="14.5.3 服务的运行级别(runlevel)"></a>14.5.3 服务的运行级别(runlevel)</h4><p>Linux系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5</p><ul><li>运行级别 0 ：系统停机状态，系统默认运行级别不能设为 0 ，否则不能正常启动</li><li>运行级别 1 ：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别 2 ：多用户状态(没有NFS)，不支持网络</li><li>运行级别 3 ：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别 4 ：系统未使用，保留</li><li>运行级别 5 ：X 11 控制台，登陆后进入图形GUI模式</li><li>运行级别 6 ：系统正常关闭并重启，默认运行级别不能设为 6 ，否则不能正常启动</li></ul><h4 id="14-5-4-Linux开机的流程说明"><a href="#14-5-4-Linux开机的流程说明" class="headerlink" title="14.5.4 Linux开机的流程说明"></a>14.5.4 Linux开机的流程说明</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224194756970.png"></p><h4 id="14-5-5-chkconfig指令"><a href="#14-5-5-chkconfig指令" class="headerlink" title="14.5.5 chkconfig指令"></a>14.5.5 chkconfig指令</h4><p>介绍：</p><ol><li>通过chkconfig命令可以给服务的各个运行级别设置自 启动/关闭</li><li>chkconfig命令管理的服务在<code>/etc/init.d</code>查看</li><li>注意：centos7.0后，很多服务使用<code>systemctl</code>管理</li></ol><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chkconfig --list [| grep xxx] #查看chkconfig管理的服务以及各个运行级别下自启动情况<br>chkconfig --level 5 服务名 on/off   #将某个服务在运行级别5下，自启动on还是off<br></code></pre></td></tr></table></figure><p>使用细节：chkconfig重新设置服务后自动启动或关闭，需要重启机器生效。</p><h4 id="14-5-6-systemctl管理指令"><a href="#14-5-6-systemctl管理指令" class="headerlink" title="14.5.6 systemctl管理指令"></a>14.5.6 systemctl管理指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status] 服务名<br></code></pre></td></tr></table></figure><p>systemctl指令管理的服务在<code>/usr/lib/systemd/system</code>查看。</p><p>systemctl设置服务的自启动状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl list-unit-files [ | grep 服务名] #查看所有服务以及其自启动状态,grep可以进行过滤<br>systemctl enable 服务名 #设置服务开机启动<br>systemctl disable 服务名 #关闭服务开机启动<br>systemctl is-enable 服务名 #查询某个服务是否是自启动的<br>这里不指定运行级别，是因为Centos将运行级别简化为了3和5，这里都是针对3和5说的<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：查看防火墙当前状态，关闭防火墙和重启防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status firewalld<br>systemctl stop firewalld<br>systemtl restart firewalld<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224202132630.png"></p><p>细节讨论：</p><ol><li><p>关闭或者启动防火墙后，立即生效。使用telnet查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet ip:port<br></code></pre></td></tr></table></figure></li><li><p>这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。</p></li><li><p>如果希望设置某个服务自启动或关闭永久生效，要使用<code>systemctl [enable | disable] 服务名</code></p></li></ol><h4 id="14-5-7-telnet命令"><a href="#14-5-7-telnet命令" class="headerlink" title="14.5.7 telnet命令"></a>14.5.7 telnet命令</h4><p>Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet 主机名称|ip<br>或者<br>telnet 主机名称|ip:port<br></code></pre></td></tr></table></figure><h4 id="14-5-8-firewall命令"><a href="#14-5-8-firewall命令" class="headerlink" title="14.5.8 firewall命令"></a>14.5.8 firewall命令</h4><p>在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=端口号/协议   #打开端口<br>firewall-cmd --permanent --remove-port=端口号/协议 #关闭端口<br>firewall-cmd --reload#重新载入，才能生效<br>firewall-cmd --query-port=端口号/协议#查询端口是否开放<br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：开放111端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=111/tcp<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>案例2：关闭111端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --remove-port=111/tcp<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h3 id="14-6-动态监控进程"><a href="#14-6-动态监控进程" class="headerlink" title="14.6 动态监控进程"></a>14.6 动态监控进程</h3><p>介绍：</p><p>top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。</p><p>基本语法： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top [选项]<br></code></pre></td></tr></table></figure><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新，默认是3秒。</td></tr><tr><td>-i</td><td>是top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控进程id来仅仅金控某个进程的状态</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224205016495.png"></p><p>各项解释：</p><p>top：系统时间；up：登录用户数；load average：负载均衡</p><p>Tasks：进程数；running：运行进程数；sleeping：睡眠进程数；stopped：停止进程；zombie：僵死进程数(进程已死，内存未释放)</p><p>%Cpu（s）：us：用户占用Cpu比率；sy：系统占用Cpu比率；ni:用户进程空间内改变过优先级的进程占用Cpu比率；id：空闲Cpu比率；wa：等待输入输出的cpu时间占比；si：软终端占用百分比；st：虚拟机占用百分比</p><p>KiB Mem：total：物理内存总量；used：使用的物理内存总量；free：空闲内存总量；buffers：用作内核缓冲的内存量</p><p>KiB Swap：total：交换区总量；used：使用的交换区总量；free：空闲交换区总量；cached：缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过得交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小，相应的内存再次被换出是可不必再对交换区写入。</p><p>PR:优先级;NI:nice值。负值代表高优先级，正值代表低优先级;VIRT:进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES;RES:进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA;SHR:共享内存大小，单位kb;S:进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/通知，Z=僵尸进程）</p><p>交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><p>应用实例：</p><p>案例1：监视特定用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">top <br>u 用户名<br></code></pre></td></tr></table></figure><p>top：输入此命令，按回车键，查看执行的进程。<br>u：然后输入“u”回车，再输入用户名，即可。</p><p>案例 2 ：终止指定的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br>k PID<br></code></pre></td></tr></table></figure><p>top：输入此命令，按回车键，查看执行的进程。</p><p>k：然后输入“k”回车，再输入要结束的进程ID号</p><p>案例 3 :指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">top -d 10<br></code></pre></td></tr></table></figure><h3 id="14-7-查看系统网络情况netstat-重要"><a href="#14-7-查看系统网络情况netstat-重要" class="headerlink" title="14.7 查看系统网络情况netstat(重要)"></a>14.7 查看系统网络情况netstat(重要)</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat [选项]<br>netstat -anp<br></code></pre></td></tr></table></figure><p>选项说明</p><p>​    -a (all)显示所有选项，默认不显示LISTEN相关<br>​    -t (tcp)仅显示tcp相关选项<br>​    -u (udp)仅显示udp相关选项<br>​    -n 拒绝显示别名，能显示数字的全部转化成数字。<br>​    -l 仅列出有在 Listen (监听) 的服務状态</p><p>​    -p 显示建立相关链接的进程<br>​    -r 显示路由信息，路由表<br>​    -e 显示扩展信息，例如uid等<br>​    -s 按各个协议进行统计<br>​    -c 每隔一个固定时间，执行该netstat命令。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225131410928.png"></p><p>应用案例<br>案例1：查看系统所有的网络服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp<br></code></pre></td></tr></table></figure><p>案例2：请查看服务名为 sshd 的服务的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp | grep sshd<br></code></pre></td></tr></table></figure><h2 id="十五、RPM-和-YUM"><a href="#十五、RPM-和-YUM" class="headerlink" title="十五、RPM 和 YUM"></a>十五、RPM 和 YUM</h2><h3 id="15-1-RPM包的管理"><a href="#15-1-RPM包的管理" class="headerlink" title="15.1 RPM包的管理"></a>15.1 RPM包的管理</h3><h4 id="15-1-1介绍"><a href="#15-1-1介绍" class="headerlink" title="15.1.1介绍"></a>15.1.1介绍</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmp一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。<br>它生成具有.RPM扩展名的文件。RPM是RedHatPackageManager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。<br>Linux的分发版本都有采用（suse,redhat,centos等等），可以算是公认的行业标准了。<br></code></pre></td></tr></table></figure><h4 id="15-1-2-rpm包的简单查询指令"><a href="#15-1-2-rpm包的简单查询指令" class="headerlink" title="15.1.2 rpm包的简单查询指令"></a>15.1.2 rpm包的简单查询指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查询已安装的rpm列表</span> <br>rpm –qa | grep xx<br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：请查询看一下，当前的Linux有没有安装 firefox.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa | grep firefox<br></code></pre></td></tr></table></figure><h4 id="15-1-3-rpm包名基本格式"><a href="#15-1-3-rpm包名基本格式" class="headerlink" title="15.1.3 rpm包名基本格式"></a>15.1.3 rpm包名基本格式</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">一个rpm包名：firefox-<span class="hljs-number">45.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span><span class="hljs-selector-class">.el6</span><span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.x86_64</span><span class="hljs-selector-class">.rpm</span><br>名称:         firefox<br>版本号：        <span class="hljs-number">45.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span><br>适用操作系统:    el6<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.x86_64</span><br>表示centos <span class="hljs-number">6</span>.x的<span class="hljs-number">64</span>位系统<br>如果是i686 、i386 表示 <span class="hljs-number">32</span> 位系统，noarch表示通用。<br></code></pre></td></tr></table></figure><h4 id="15-1-4-rpm包的其它查询指令："><a href="#15-1-4-rpm包的其它查询指令：" class="headerlink" title="15.1.4 rpm包的其它查询指令："></a>15.1.4 rpm包的其它查询指令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa #查询所安装的所有rpm软件包<br>rpm -qa | more#[分页显示]<br>rpm -qa | grep X[rpm-qa|grepfirefox]<br>rpm -q 软件包名  #查询软件包是否安装，例如：rpm -q firefox<br>rpm -qi 软件包名  #查询软件包信息，例如：rpm -qi firefox<br>rpm -ql 软件报名 #查询软件包中的文件，例如rpm -ql firefox<br>rpm -qf 文件全路径名   #查询文件所属软件包,例如rpm -qf /etc/passwd;rpm -qf /root/install.log<br></code></pre></td></tr></table></figure><h4 id="15-1-5-卸载rpm包："><a href="#15-1-5-卸载rpm包：" class="headerlink" title="15.1.5 卸载rpm包："></a>15.1.5 卸载rpm包：</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e RPM包的名称  #e是erase删除的意思<br></code></pre></td></tr></table></figure><p>应用案例<br>案例1： 删除firefox 软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e firefox<br></code></pre></td></tr></table></figure><p>细节问题</p><ol><li><p>如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e foo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">error:<br>removing these packages would break dependencies: foo is needed by bar-1.0-1<br></code></pre></td></tr></table></figure></li><li><p>如果我们就是要删除 foo这个rpm 包，可以增加参数 –nodeps,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e --nodeps foo #带上 --nodeps 就是强制删除。<br></code></pre></td></tr></table></figure></li></ol><h4 id="15-1-6-安装rpm包："><a href="#15-1-6-安装rpm包：" class="headerlink" title="15.1.6 安装rpm包："></a>15.1.6 安装rpm包：</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh RPM包全路径名称<br></code></pre></td></tr></table></figure><p>参数说明<br>    i=install 安装<br>    v=verbose 提示<br>    h=hash 进度条</p><p>应用实例<br>实例1： 演示安装firefox浏览器<br>步骤先找到firefox的安装rpm 包,你需要挂载上我们安装centos的iso文件，然后到/media/下去找rpm 找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm<br></code></pre></td></tr></table></figure><h3 id="15-2-YUM"><a href="#15-2-YUM" class="headerlink" title="15.2 YUM"></a>15.2 YUM</h3><h4 id="15-2-1-介绍："><a href="#15-2-1-介绍：" class="headerlink" title="15.2.1 介绍："></a>15.2.1 介绍：</h4><p>Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系，并且一次安装所有依赖的软件包</strong>。使用yum的前提是可以联网。</p><h4 id="15-2-2-yum的基本指令"><a href="#15-2-2-yum的基本指令" class="headerlink" title="15.2.2 yum的基本指令"></a>15.2.2 yum的基本指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep xx #查询yum服务器是否有需要安装的软件<br>yum install xx     #安装指定的yum包<br></code></pre></td></tr></table></figure><h4 id="15-2-3-yum应用实例"><a href="#15-2-3-yum应用实例" class="headerlink" title="15.2.3 yum应用实例"></a>15.2.3 yum应用实例</h4><p>案例1：请使用yum的方式来安装firefox</p><ol><li><p>先查看一下 firefox rpm 在yum服务器有没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep firefox<br></code></pre></td></tr></table></figure></li><li><p>安装yuminstallfirefox会安装最新版本的软件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install firefox<br></code></pre></td></tr></table></figure></li></ol><h2 id="十六、搭建-JAVAEE-环境"><a href="#十六、搭建-JAVAEE-环境" class="headerlink" title="十六、搭建 JAVAEE 环境"></a>十六、搭建 JAVAEE 环境</h2><h3 id="16-1-概述"><a href="#16-1-概述" class="headerlink" title="16.1 概述"></a>16.1 概述</h3><p>如果需要在Linux下进行JavaEE的开发，我们需要安装如下软件：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225150900800.png"></p><h3 id="16-2-安装JDK"><a href="#16-2-安装JDK" class="headerlink" title="16.2 安装JDK"></a>16.2 安装JDK</h3><h4 id="16-2-1-安装步骤"><a href="#16-2-1-安装步骤" class="headerlink" title="16.2.1 安装步骤"></a>16.2.1 安装步骤</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/opt/</span>jdk<br>wget [下载链接]  <span class="hljs-comment">#下载JKD安装包</span><br>tar -zxvf 安装包<br>mkdir <span class="hljs-regexp">/usr/</span>local/java<br>mv 文件夹 <span class="hljs-regexp">/usr/</span>local/java<br><br>而配置环境变量,vim <span class="hljs-regexp">/etc/</span>profile<br>export JAVA_HOME=<span class="hljs-regexp">/opt/</span>jdk1.<span class="hljs-number">7.0</span>_79<br>export PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><br>需要注销用户，环境变量才能生效。<br>如果是在 <span class="hljs-number">3</span> 运行级别， logout<br>如果是在 <span class="hljs-number">5</span> 运行级别， source <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><h4 id="16-2-1-测试是否安装成功"><a href="#16-2-1-测试是否安装成功" class="headerlink" title="16.2.1 测试是否安装成功"></a>16.2.1 测试是否安装成功</h4><p>随意找一个目录，输入<code>javac --version &amp; java --version</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac --version<br>java --version<br></code></pre></td></tr></table></figure><h3 id="16-3-安装TOMCAT"><a href="#16-3-安装TOMCAT" class="headerlink" title="16.3 安装TOMCAT"></a>16.3 安装TOMCAT</h3><h4 id="16-3-1-步骤"><a href="#16-3-1-步骤" class="headerlink" title="16.3.1 步骤"></a>16.3.1 步骤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.上传安装文件，并解压缩到/opt/tomcat<br>2.进入解压目录/bin,启动tomcat（./startup.sh)<br>3.开放8080端口<br></code></pre></td></tr></table></figure><h4 id="16-3-2-测试是否安装成功"><a href="#16-3-2-测试是否安装成功" class="headerlink" title="16.3.2 测试是否安装成功"></a>16.3.2 测试是否安装成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">在windows、Linux下访问 http://ip:8080<br></code></pre></td></tr></table></figure><h3 id="16-4-安装IDEA"><a href="#16-4-安装IDEA" class="headerlink" title="16.4 安装IDEA"></a>16.4 安装IDEA</h3><h4 id="16-4-1-步骤"><a href="#16-4-1-步骤" class="headerlink" title="16.4.1 步骤"></a>16.4.1 步骤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. wget https://download.jetbrains.com/idea/ideaIU-2021.3.2.tar.gz?_gl=1*empi04*_ga*MTg0OTIyNTYuMTY0MzI1OTQ0Mw..*_ga_V0XZL7QHEB*MTY0NTc3NDI2OC40LjEuMTY0NTc3NDMwMy4w&amp;_ga=2.141732210.1541181338.1645774269-18492256.1643259443<br>2. tar -zxvf 安装包 #解压缩到/opt/idea<br>3. cd /opt/idea/bin<br>4. ./idea.sh<br>5. 配置jdk<br></code></pre></td></tr></table></figure><h3 id="16-5-MYSQL5-7的安装和配置"><a href="#16-5-MYSQL5-7的安装和配置" class="headerlink" title="16.5 MYSQL5.7的安装和配置"></a>16.5 MYSQL5.7的安装和配置</h3><h4 id="16-5-1-安装的步骤和文档"><a href="#16-5-1-安装的步骤和文档" class="headerlink" title="16.5.1 安装的步骤和文档"></a>16.5.1 安装的步骤和文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs linux">1. mkdir /opt/mysql<br>2. wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar<br>3. tar -zxvf mysql-5.7.26-1.el7.x86-64.rpm-bundle.tar<br>4. rpm -qa | grep mari<br>5. rpm -e --nodep mariadb-libs #Centos7.6自带mariadb数据库，会与mysql冲突，需要先删除<br>6. 按顺序执行：<br>rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm<br>7. systemctl start mysqld.service<br>8. grep &quot;password&quot; /var/log/mysqld.log #查看当前密码<br>9. mysql -u root -p#root用户登录<br>10. set global validate_password_policy=0; #提示密码设置策略<br>11. set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;mimamima&#x27;); #设置密码mimamima<br>12. flush privileges； #使密码设置生效<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225155613228.png"></p><h2 id="十七、Shell-编程"><a href="#十七、Shell-编程" class="headerlink" title="十七、Shell 编程"></a>十七、Shell 编程</h2><p>为什么要学习SHELL编程</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.Linux运维工程师在进行服务器集群管理时，需要编写<span class="hljs-keyword">Shell</span>程序来进行服务器管理。<br><span class="hljs-number">2</span>.对于JavaEE和Python程序员来说，工作的需要，你的老大会要求你编写一些<span class="hljs-keyword">Shell</span>脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。<br><span class="hljs-number">3</span>.对于大数据程序员来说，需要编写<span class="hljs-keyword">Shell</span>程序来管理集群。<br></code></pre></td></tr></table></figure><p>SHELL是什么?</p><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序.</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225202923215.png"></p><h3 id="17-1-SHELL脚本的执行方式"><a href="#17-1-SHELL脚本的执行方式" class="headerlink" title="17.1 SHELL脚本的执行方式"></a>17.1 SHELL脚本的执行方式</h3><h4 id="17-1-1-脚本格式要求"><a href="#17-1-1-脚本格式要求" class="headerlink" title="17.1.1 脚本格式要求"></a>17.1.1 脚本格式要求</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.脚本以#!/bin/bash开头 (或者不用指定解释器，直接使用bash xxx.sh执行)<br>2.脚本需要有可执行权限<br></code></pre></td></tr></table></figure><h4 id="17-1-2-编写第一个Shell脚本"><a href="#17-1-2-编写第一个Shell脚本" class="headerlink" title="17.1.2 编写第一个Shell脚本"></a>17.1.2 编写第一个Shell脚本</h4><p>需求说明：创建一个Shell脚本，输出helloworld!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim helloworld.sh #(也可以不以.sh为结尾，但是为了规范建议以.sh为结尾)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo helloworld<br><br>chmod u+x helloworld.sh<br>./helloworld.sh<br></code></pre></td></tr></table></figure><h4 id="17-1-3-脚本的常用执行方式"><a href="#17-1-3-脚本的常用执行方式" class="headerlink" title="17.1.3 脚本的常用执行方式"></a>17.1.3 脚本的常用执行方式</h4><p>方式 1 (输入脚本的绝对路径或相对路径)<br>1 )首先要赋予helloworld.sh 脚本的+x权限<br>2 )执行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chomd u+x helloworld.sh<br>./helloworld.sh #或者 ~/shcode/helloworld.sh<br></code></pre></td></tr></table></figure><p>方式 2 (sh+脚本的绝对路径或者相对路径)，不推荐<br>说明：不用赋予脚本+x权限，直接执行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash helloworld.sh<br></code></pre></td></tr></table></figure><h3 id="17-2-Shell的变量"><a href="#17-2-Shell的变量" class="headerlink" title="17.2 Shell的变量"></a>17.2 Shell的变量</h3><p>Shell的变量的介绍</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>）LinuxShell中的变量分为，系统变量和用户自定义变量。<br><span class="hljs-symbol">2 </span>）系统变量：$HOME、$PWD、$<span class="hljs-keyword">SHELL</span>、$USER等等。比如：echo$HOME 等等..<br><span class="hljs-symbol">3 </span>）显示当前<span class="hljs-keyword">shell</span>中所有变量：使用命令set来查看<br></code></pre></td></tr></table></figure><h4 id="17-2-1-shell变量的定义"><a href="#17-2-1-shell变量的定义" class="headerlink" title="17.2.1 shell变量的定义"></a>17.2.1 shell变量的定义</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 )定义变量：变量=值<br>2 )撤销变量：unset 变量<br>3 ) 声明静态变量：readonly变量，注意：不能unset<br></code></pre></td></tr></table></figure><p>应用案例：</p><p>案例 1 ：定义变量A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100<br>echo A = $A<br>echo &quot;A = %A&quot;<br></code></pre></td></tr></table></figure><p>案例 2 ：撤销变量A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100<br>unset A<br></code></pre></td></tr></table></figure><p>案例 3 ：声明静态的变量B= 2 ，不能unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>readonly B=200<br>echo &quot;B = $B&quot;<br></code></pre></td></tr></table></figure><p>案例 4 ：可把变量提升为全局环境变量，可供其他shell程序使用【一会举例。】</p><h4 id="17-2-2定义变量的规则"><a href="#17-2-2定义变量的规则" class="headerlink" title="17.2.2定义变量的规则"></a>17.2.2定义变量的规则</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。<br><span class="hljs-bullet">2.</span> 等号两侧不能有空格<br><span class="hljs-bullet">3.</span> 变量名称一般习惯为大写,当然小写不出错，但是大写是规范<br></code></pre></td></tr></table></figure><h4 id="17-2-3-将命令的返回值赋给变量（重点）"><a href="#17-2-3-将命令的返回值赋给变量（重点）" class="headerlink" title="17.2.3 将命令的返回值赋给变量（重点）"></a>17.2.3 将命令的返回值赋给变量（重点）</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1. <span class="hljs-attribute">A</span>=`ls-la` 反引号，运行里面的命令，并把结果返回给变量A<br>2. <span class="hljs-attribute">A</span>=$(ls-la) 等价于反引号<br>否则，就是将字符串赋值给变量<br></code></pre></td></tr></table></figure><h3 id="17-3-设置环境变量"><a href="#17-3-设置环境变量" class="headerlink" title="17.3 设置环境变量"></a>17.3 设置环境变量</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. <span class="hljs-built_in">export</span> 变量名=变量值 （功能描述：将shell变量输出为环境变量/全局变量）<br>2. <span class="hljs-built_in">source</span> 配置文件 （功能描述：让修改后的配置信息立即生效）<br>3. <span class="hljs-built_in">echo</span> $变量名 （功能描述：查询环境变量的值）<br></code></pre></td></tr></table></figure><p>应用案例：</p><p>案例1：在/etc/profile文件中定义TOMCAT_HOME环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br><br>export TOMCAT_HOME=/opt/tomcat<br></code></pre></td></tr></table></figure><p>案例2：查看环境变量TOMCAT_HOME的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $TOMCAT_HOME<br></code></pre></td></tr></table></figure><p>案例3：在另外一个shell程序中使用TOMCAT_HOME。注意：在输出TOMCAT_HOME 环境变量前，需要让其生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h3 id="17-4-Shell的注释"><a href="#17-4-Shell的注释" class="headerlink" title="17.4 Shell的注释"></a>17.4 Shell的注释</h3><p>单行注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;[字符]  #这里的字符可以是数字或者是字符都可以<br>语句1<br>语句2<br>[字符]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">比如</span><br>:&lt;&lt;!<br>语句1<br>语句2<br>!<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">或者</span><br>:&lt;&lt;0<br>语句1<br>语句2<br>0<br></code></pre></td></tr></table></figure><h3 id="17-5-位置参数变量"><a href="#17-5-位置参数变量" class="headerlink" title="17.5 位置参数变量"></a>17.5 位置参数变量</h3><p>介绍：</p><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量，比如 ：<code>./myshell.sh 100 200</code> , 这个就是一个执行shell的命令行，可以在myshell 脚本中获取到</p><p>基本语法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$n</span> （功能描述：n为数字，<span class="hljs-variable">$0</span> 代表命令本身，<span class="hljs-variable">$1</span>-<span class="hljs-variable">$9</span> 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<span class="hljs-variable">$</span>&#123;<span class="hljs-number">10</span>&#125;）<br><span class="hljs-variable">$</span>* （功能描述：这个变量代表命令行中所有的参数，<span class="hljs-variable">$</span>*把所有的参数看成一个整体）<br><span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span> （功能描述：这个变量也代表命令行中所有的参数，不过<span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>把每个参数区分对待）<br><span class="hljs-variable">$</span><span class="hljs-comment"># （功能描述：这个变量代表命令行中所有参数的个数）</span><br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：编写一个shell脚本 positionPara.sh ， 在脚本中获取到命令行的各个参数信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim myshell.sh<br><br>echo 第一个参数 = $1 第二个参数 = $2<br></code></pre></td></tr></table></figure><h3 id="17-6-预定义变量"><a href="#17-6-预定义变量" class="headerlink" title="17.6 预定义变量"></a>17.6 预定义变量</h3><p>基本介绍</p><p>预定义变量就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用。</p><p>基本语法</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> （功能描述：当前进程的进程号（PID））<br><span class="hljs-symbol">$</span>! （功能描述：后台运行的最后一个进程的进程号（PID））<br><span class="hljs-symbol">$</span>？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 <span class="hljs-number">0</span> ，证明上一个命令正确执行；如果这个变量的值为非 <span class="hljs-number">0</span> （具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：在一个shell脚本中简单使用一下预定义变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo 当前进程的进程号$$<br>bash ~/shcode/myshell.sh &amp; #次数加上&amp;，说明让该命令后台运行<br>echo 最后一个后台运行的进程ID$!<br>echo 最后一次执行的命令的返回状态$?<br></code></pre></td></tr></table></figure><h3 id="17-7-运算符"><a href="#17-7-运算符" class="headerlink" title="17.7 运算符"></a>17.7 运算符</h3><p>基本介绍</p><p>学习如何在shell中进行各种运算操作。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">“$((运算式))” 或者 “$[运算式]”  #*不需要转义，运算符间也不需要空格<br>expr m + n #注意expr运算符间要有空格，如果希望将expr结果赋值给某个变量，需要使用‘’引起来，例如`expr m + n`<br>expr \*,/,% 乘，除，取余 #需要注意的是*，需要转义<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例 1 ：计算（ 2 + 3 ）X 4 的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=$(((2 + 3) * 4)) #注意只有expr运算符才需要将*转义<br>A=$[(2 + 3) * 4]<br>A=`expr (2 + 3) \* 4` #这种做法是错误的，应该分步走<br>A=`expr 2 + 3`<br>A=`expr 4 \* $A`<br></code></pre></td></tr></table></figure><p>案例 2 ：请求出命令行的两个参数[整数]的和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=$[$1 + $2]<br>echo 和为 $A<br></code></pre></td></tr></table></figure><h3 id="17-8-条件判断"><a href="#17-8-条件判断" class="headerlink" title="17.8 条件判断"></a>17.8 条件判断</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ condition ]   #注意condition前后要有空格<br>  #非空返回true，可使用$?验证（ 0 为true，&gt; 1 为false）<br></code></pre></td></tr></table></figure><p>应用实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ atguigu ] 返回true<br>[ ] 返回false<br>[ condition ] &amp;&amp; echo OK || echo notok #条件满足，执行后面的语句，相当于三目运算<br></code></pre></td></tr></table></figure><p>常用判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">= 字符串比较<br><span class="hljs-meta">#</span><span class="bash">两个整数的比较</span><br>- lt 小于<br>- le 小于等于<br>- eq 等于<br>- gt 大于<br>- ge 大于等于<br>- ne 不等于<br><span class="hljs-meta">#</span><span class="bash">按照文件权限进行判断</span><br>- r 有读的权限 [-r 文件 ]<br>- w 有写的权限<br>- x 有执行的权限<br><span class="hljs-meta">#</span><span class="bash">按照文件类型进行判断</span><br>- f 文件存在并且是一个常规的文件<br>- e 文件存在<br>- d 文件存在并是一个目录<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：”ok”是否等于”ok”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ok = ok<br></code></pre></td></tr></table></figure><p>案例2： 23 是否大于等于 22</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">23 -ge 22<br></code></pre></td></tr></table></figure><p>案例 3 ：/root/install.log目录中的文件是否存在</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-f <span class="hljs-regexp">/root/i</span>nstall.log<br></code></pre></td></tr></table></figure><h3 id="17-9-流程控制"><a href="#17-9-流程控制" class="headerlink" title="17.9 流程控制"></a>17.9 流程控制</h3><h4 id="17-9-1-if-判断"><a href="#17-9-1-if-判断" class="headerlink" title="17.9.1 if 判断"></a>17.9.1 if 判断</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sehll">if [ 条件判断式 ]<br>then<br>  程序<br>fi<br><br>或者<br><br>if [ 条件判断式 ]<br>then<br>     程序<br>elif [ 条件判断式 ]<br>then<br>程序<br>fi<br><br>或者<br><br>if [ 条件判断式 ]<br>then<br>程序<br>else<br>程序<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">注意事项：<span class="hljs-selector-attr">[ 条件判断式 ]</span>中括号和条件判断式之间必须有空格<br></code></pre></td></tr></table></figure><p>应用实例<br>案例1：请编写一个shell程序，如果输入的参数，大于等于 60 ，则输出 “及格了”，如果小于 60 ,则输出 “不及格”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 -ge 60 ]<br>then<br>        echo 及格了<br>elif [ $1 -lt 60 ]<br>then<br>        echo 不及格<br>fi<br></code></pre></td></tr></table></figure><h4 id="17-9-2-case语句"><a href="#17-9-2-case语句" class="headerlink" title="17.9.2 case语句"></a>17.9.2 case语句</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;值 1 &quot;）<br>如果变量的值等于值 1 ，则执行程序 1<br>;;<br>&quot;值 2 &quot;）<br>如果变量的值等于值 2 ，则执行程序 2<br>;;<br>*）<br>如果变量的值都不是以上的值，则执行此程序<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：当命令行参数是 1 时，输出 “周一”, 是 2 时，就输出”周二”，其它情况输出 “other”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>case $1 in<br>&quot;1&quot;)<br>echo 周一<br>;;<br>&quot;2&quot;)<br>echo 周二<br>;;<br>*)<br>echo other...<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="17-9-3-for循环"><a href="#17-9-3-for循环" class="headerlink" title="17.9.3 for循环"></a>17.9.3 for循环</h3><p>基本语法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3 ...<br>do<br>程序/代码<br>done<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：打印命令行输入的参数 【会使用到$*  $@，体会$* 与 $@的区别】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>for i in &quot;$*&quot;<br>do<br>        echo num is $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash for.sh 1 2 3 4 5<br>输出：<br>num is 1 2 3 4 5<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>for i in &quot;$@&quot;<br>do<br>        echo num is $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash for.sh 1 2 3 4 5<br>输出：<br>num is 1<br>num is 2<br>num is 3<br>num is 4<br>num is 5<br></code></pre></td></tr></table></figure><p>基本语法 </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for<span class="hljs-comment">(( 初始值 ; 循环控制条件 ; 变量变化 )</span>)<br><span class="hljs-keyword">do</span><br>程序<br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例 1 ：从 1 加到 100 的值输出显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>SUM=0<br>for (( i=1; i&lt;=100; i++))<br>do<br>        SUM=$[$SUM+$i]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><h4 id="17-9-4-while循环"><a href="#17-9-4-while循环" class="headerlink" title="17.9.4 while循环"></a>17.9.4 while循环</h4><p>基本语法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">while[ 条件判断式 ]<br>do<br>      程序<br>done<br><span class="hljs-meta">#</span><span class="bash">注意：<span class="hljs-keyword">while</span>和[有空格，条件判断式和[也有空格</span><br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：从命令行输入一个数n，统计从 1 +..+n 的值是多少？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>SUM=0<br>i=0<br>while [ $i -le $1 ]<br>do<br>        SUM=$[$SUM+$i]<br>        i=$[$i+1]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><h3 id="17-10-READ读取控制台输入"><a href="#17-10-READ读取控制台输入" class="headerlink" title="17.10 READ读取控制台输入"></a>17.10 READ读取控制台输入</h3><p>基本语法</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">read</span> <span class="hljs-params">(选项)</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></table></figure><p>选项：</p><ul><li>-p：指定读取值时的提示符；</li><li>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。。<br>参数<br>变量：指定读取值的变量名</li></ul><p>应用实例</p><p>案例 1 ：读取控制台输入一个num值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>read -p 请输入一个数 NUM<br>echo $NUM<br></code></pre></td></tr></table></figure><p>案例 2 ：读取控制台输入一个num值，在 10 秒内输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>read -t 10 -p 输入一个数 NUM<br>echo $NUM<br></code></pre></td></tr></table></figure><h3 id="17-11-函数"><a href="#17-11-函数" class="headerlink" title="17.11 函数"></a>17.11 函数</h3><p>函数介绍：</p><p>shell编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。</p><h4 id="17-11-1-系统函数"><a href="#17-11-1-系统函数" class="headerlink" title="17.11.1 系统函数"></a>17.11.1 系统函数</h4><p>basename基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">basename [pathname] [suffix] #功能：返回完整路径最后 / 的部分，常用于获取文件名<br></code></pre></td></tr></table></figure><p>选项：</p><p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>案例 1 ：请返回 /home/aaa/test.txt 的 “test.txt” 部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">basename /home/aaa/test.txt<br>basename /home/aaa/test.txt .txt<br></code></pre></td></tr></table></figure><p>dirname基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dirname 文件绝对路径 #（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））<br></code></pre></td></tr></table></figure><p>案例 2 ：请返回 /home/aaa/test.txt 的 /home/aaa</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dirname /home/aaa/test.txt<br></code></pre></td></tr></table></figure><h4 id="17-11-2-自定义函数"><a href="#17-11-2-自定义函数" class="headerlink" title="17.11.2 自定义函数"></a>17.11.2 自定义函数</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[function]funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br><span class="hljs-meta">#</span><span class="bash">在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <span class="hljs-variable">$n</span> 的形式来获取参数的值，例如，<span class="hljs-variable">$1</span>表示第一个参数，<span class="hljs-variable">$2</span>表示第二个参数...</span><br></code></pre></td></tr></table></figure><p>调用直接写函数名：funname [值]</p><p>应用实例<br>案例 1 ：计算输入两个参数的和（read）， getSum</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">function getSum() &#123;<br>        SUM=$[$n1+$n2]<br>        echo 和是$SUM<br>&#125;<br>read -p 输入两个值 n1 n2<br>getSum <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Shell 变量的作用域可以分为三种：<br>有的变量只能在函数内部使用，这叫做局部变量（local variable）；除非定义时使用local限定，否则都是全局变量<br>有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；正常定义都是全局变量<br>而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。需要使用export导出环境变量。<br><br></code></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/773.html">Shell作用域细节</a></p><h3 id="17-12-SHELL编程综合案例"><a href="#17-12-SHELL编程综合案例" class="headerlink" title="17.12 SHELL编程综合案例"></a>17.12 SHELL编程综合案例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">需求分析<br><span class="hljs-number">1</span> )每天凌晨 <span class="hljs-number">2</span> : <span class="hljs-number">10</span> 备份 数据库 atguiguDB 到 /data/backup/db<br><span class="hljs-number">2</span> )备份开始和备份结束能够给出相应的提示信息<br><span class="hljs-number">3</span> )备份后的文件要求以备份时间为文件名，并打包成 <span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 的形式，比如：<span class="hljs-number">2018</span>-<span class="hljs-number">03</span>-<span class="hljs-number">12</span>_230201<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br><span class="hljs-number">4</span> ) 在备份的同时，检查是否有 <span class="hljs-number">10</span> 天前备份的数据库文件，如果有就将其删除。<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. cd/usr/sbin #root用户的系统管理程序<br>vim mysqlbd_backup.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">备份目录</span><br>BACKUP=/data/backup/bd<br><span class="hljs-meta">#</span><span class="bash">当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br>echo $DATETIME<br><span class="hljs-meta">#</span><span class="bash">数据库地址</span><br>HOST=localhost<br><span class="hljs-meta">#</span><span class="bash">数据库用户名</span><br>DB_USER=root<br><span class="hljs-meta">#</span><span class="bash">数据库密码</span><br>DB_PW=hspedu100<br><span class="hljs-meta">#</span><span class="bash">备份的数据库名</span><br>DATABASE=hspedu<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">备份数据库</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$&#123;DATETIME&#125;.sql.gz<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">将文件处理成.tar.gz</span><br>cd $&#123;BACKUP&#125;<br>tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta">#</span><span class="bash">删除对应的备份目录</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除十天前备份文件</span><br>find $&#123;BACKUP&#125; -atime + 10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br>echo &quot;备份数据库$&#123;DATABASE&#125;&quot;<br><br><br>crond -e<br>30 2 * * * /usr/sbin/mysqlbd_backup.sh<br></code></pre></td></tr></table></figure><h2 id="十八、Ubuntu"><a href="#十八、Ubuntu" class="headerlink" title="十八、Ubuntu"></a>十八、Ubuntu</h2><p>Ubuntu介绍</p><p>Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu是基于GNU/Linux，支持x 86 、amd 64 （即x 64 ）和ppc架构，由全球化的专业开发团队（CanonicalLtd）打造的。</p><p>专业的Python开发者一般会选择 Ubuntu 这款Linux系统作为生产平台.<br>温馨提示：<br>Ubuntu 和 Centos 都是基于 GNU/Linux 内核的，因此基本使用和Centos是几乎一样的，它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在前面学习CentOS都使用过。只是界面和预安装的软件有所差别。</p><p>Ubuntu下载地址：<a href="http://cn.ubuntu.com/download/">http://cn.ubuntu.com/download/</a></p><h3 id="18-1-设置Ubuntu支持中文"><a href="#18-1-设置Ubuntu支持中文" class="headerlink" title="18.1 设置Ubuntu支持中文"></a>18.1 设置Ubuntu支持中文</h3><p>默认安装的ubuntu 中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。</p><p>安装中文支持步骤：</p><p>1 .单击左侧图标栏打开 SystemSettings（系统设置）菜单，点击打开 LanguageSupport（语言支持）选项卡。</p><p>2 .点击 Install/RemoveLanguages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击ApplyChanges 提交，系统会自动联网下载中文语言包。（保证ubuntu 是联网的）。</p><p>3 .这时“汉语（中国）”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语（中国）”设置为第一位。设置方法是拖动，鼠标单击“汉语（中国）”，当底色变化（表示选中了）后，按住鼠标左键不松手，向上拖动放置到第一位。</p><p>4 .设置后不会即刻生效，需要下一次登录时才会生效。</p><h3 id="18-2-Ubuntu的root用户"><a href="#18-2-Ubuntu的root用户" class="headerlink" title="18.2 Ubuntu的root用户"></a>18.2 Ubuntu的root用户</h3><p>安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上 sudo 。有的时候感觉很麻烦。</p><p>我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码，就会抛出 su:Authenticationfailure 这样的问题。所以，我们只要给root用户设置一个初始密码就好了。</p><h4 id="18-2-1-给root用户设置密码并使用"><a href="#18-2-1-给root用户设置密码并使用" class="headerlink" title="18.2.1 给root用户设置密码并使用"></a>18.2.1 给root用户设置密码并使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 ) 输入 sudo passwd 命令，输入一般用户密码并设定root用户密码。<br>2 ) 设定root密码成功后，输入 su 命令，并输入刚才设定的root密码，就可以切换成root了。# 提示符$代表一般用户，提示符#代表root用户。<br>3 ) 输入 exit 命令，退出root并返回一般用户<br>4 ) 以后就可以使用root用户了 <br></code></pre></td></tr></table></figure><p>需要注意的是，<code>sudo</code>是允许当前用户以root身份执行命令，但是本身还是普通用户；而<code>su root</code>是切换到root用户，家目录变成<code>/root</code>。</p><h2 id="十九、Ubuntu-软件管理和远程登录"><a href="#十九、Ubuntu-软件管理和远程登录" class="headerlink" title="十九、Ubuntu 软件管理和远程登录"></a>十九、Ubuntu 软件管理和远程登录</h2><p>APT介绍</p><p>apt是AdvancedPackagingTool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令可用于软件包的安装、删除、清理等，类似于Windows中的软件管理工具。</p><p>ubuntu 软件管理的原理示意图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227150334400.png"></p><h3 id="19-1-Ubuntu软件操作的相关命令"><a href="#19-1-Ubuntu软件操作的相关命令" class="headerlink" title="19.1 Ubuntu软件操作的相关命令"></a>19.1 Ubuntu软件操作的相关命令</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> update 更新源<br>sudo apt-<span class="hljs-builtin-name">get</span> install package 安装包<br>sudo apt-<span class="hljs-builtin-name">get</span> <span class="hljs-builtin-name">remove</span> package 删除包<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo apt-cache search <span class="hljs-keyword">package</span> <span class="hljs-title">搜索软件包</span><br>sudo apt-cache show <span class="hljs-keyword">package</span> <span class="hljs-title">获取包的相关信息，如说明、大小、版本等</span><br>sudo apt-get install <span class="hljs-keyword">package</span> <span class="hljs-title">--reinstall 重新安装包</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> -f install 修复安装<br>sudo apt-<span class="hljs-builtin-name">get</span> <span class="hljs-builtin-name">remove</span> package --purge 删除包，包括配置文件等<br>sudo apt-<span class="hljs-builtin-name">get</span> build-dep package 安装相关的编译环境<br></code></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">sudo apt-<span class="hljs-built_in">get</span> upgrade 更新已安装的包<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">dist</span>-upgrade 升级系统<br>sudo apt-cache depends <span class="hljs-keyword">package</span> 了解使用该包依赖那些包<br>sudo apt-cache rdepends <span class="hljs-keyword">package</span> 查看该包被哪些包依赖<br>sudo apt-<span class="hljs-built_in">get</span> source <span class="hljs-keyword">package</span> 下载该包的源代码<br></code></pre></td></tr></table></figure><h3 id="19-2-更新UBUNTU软件下载地址"><a href="#19-2-更新UBUNTU软件下载地址" class="headerlink" title="19.2 更新UBUNTU软件下载地址"></a>19.2 更新UBUNTU软件下载地址</h3><h4 id="19-2-1-寻找国内镜像源"><a href="#19-2-1-寻找国内镜像源" class="headerlink" title="19.2.1 寻找国内镜像源"></a>19.2.1 寻找国内镜像源</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore</p><h4 id="19-2-2-备份Ubuntu默认的源地址"><a href="#19-2-2-备份Ubuntu默认的源地址" class="headerlink" title="19.2.2 备份Ubuntu默认的源地址"></a>19.2.2 备份Ubuntu默认的源地址</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br></code></pre></td></tr></table></figure><h4 id="19-2-3-更新源服务器列表"><a href="#19-2-3-更新源服务器列表" class="headerlink" title="19.2.3 更新源服务器列表"></a>19.2.3 更新源服务器列表</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227151112006.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/apt/souces.list #更新镜像源地址文件<br>sudo apt-get update #更新源地址<br></code></pre></td></tr></table></figure><h3 id="19-3-Ubuntu软件安装与卸载"><a href="#19-3-Ubuntu软件安装与卸载" class="headerlink" title="19.3 Ubuntu软件安装与卸载"></a>19.3 Ubuntu软件安装与卸载</h3><p>使用apt完成安装和卸载vim 软件，并查询 vim软件的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove vim<br>sudo apt-get install vim<br>sudo apt-cache show vim<br></code></pre></td></tr></table></figure><p>需要注意的是，现在官方主推apt命令，apt相当于apt-get + apt-cache + apt-config</p><h3 id="19-4-使用SSH远程登录Ubuntu"><a href="#19-4-使用SSH远程登录Ubuntu" class="headerlink" title="19.4 使用SSH远程登录Ubuntu"></a>19.4 使用SSH远程登录Ubuntu</h3><p>ssh介绍</p><p>SSH为SecureShell的缩写，由 IETF 的网络工作小组（NetworkWorkingGroup）所制定；SSH为建立在应用层和传输层基础上的安全协议。</p><p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。</p><p>使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。和CentOS不一样，Ubuntu默认没有安装SSHD服务(netstat -anp 查看是否有进程监听22号端口，如果连netstat命令都没有安装，可以使用apt install net-tools先安装netstat命令)，因此，我们不能进行远程登录。</p><h4 id="19-4-1-原理示意图"><a href="#19-4-1-原理示意图" class="headerlink" title="19.4.1 原理示意图"></a>19.4.1 原理示意图</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227152239100.png"></p><h3 id="19-5-使用SSH远程登录Ubuntu"><a href="#19-5-使用SSH远程登录Ubuntu" class="headerlink" title="19.5 使用SSH远程登录Ubuntu"></a>19.5 使用SSH远程登录Ubuntu</h3><h4 id="19-5-1-安装SSH和启用"><a href="#19-5-1-安装SSH和启用" class="headerlink" title="19.5.1 安装SSH和启用"></a>19.5.1 安装SSH和启用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install openssh-server #执行上面指令后，在当前这台Linux上就安装了SSH服务端和客户端。<br>service sshd restart #执行上面的指令，就启动了 sshd 服务。会监听端口 22<br></code></pre></td></tr></table></figure><h4 id="19-5-2-从linux系统客户机远程登陆linux系统服务机"><a href="#19-5-2-从linux系统客户机远程登陆linux系统服务机" class="headerlink" title="19.5.2 从linux系统客户机远程登陆linux系统服务机"></a>19.5.2 从linux系统客户机远程登陆linux系统服务机</h4><p>首先，我们需要在linux的系统客户机也要安装<code>openssh-server</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227152741432.png"></p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 用户名@IP<br><span class="hljs-meta">#</span><span class="bash">例如：sshatguigu@192.168.188.131</span><br><span class="hljs-meta">#</span><span class="bash">使用ssh访问，如访问出现错误。可查看是否有该文件 ～/.ssh/known_ssh 尝试删除该文件解决。</span><br></code></pre></td></tr></table></figure><p>登出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br><span class="hljs-meta">#</span><span class="bash">或者</span><br>logout<br></code></pre></td></tr></table></figure><h2 id="二十、CentOS8-0-Vs-CentOS7-0"><a href="#二十、CentOS8-0-Vs-CentOS7-0" class="headerlink" title="二十、CentOS8.0 Vs CentOS7.0"></a>二十、CentOS8.0 Vs CentOS7.0</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227180614734.png"></p><p>可惜，由于红帽的政策，Centos会逐渐变成上游不稳定版本，而且Centos7和Centos8也会很快不被维护。</p><h2 id="二十一、日志管理"><a href="#二十一、日志管理" class="headerlink" title="二十一、日志管理"></a>二十一、日志管理</h2><p>基本介绍</p><ol><li>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。</li><li>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。</li><li>可以这样理解日志是用来记录重大事件的工具</li></ol><h3 id="21-1-系统常用日志"><a href="#21-1-系统常用日志" class="headerlink" title="21.1 系统常用日志"></a>21.1 系统常用日志</h3><p><code>/var/log</code>目录就是系统日志文件的保存位置：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227181515157.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227182650989.png"></p><p>应用案例</p><p>案例1：使用root用户通过xshell6登陆,第一次使用错误的密码，第二次使用正确的密码登录成功看看在日志文件/var/log/secure里有没有记录相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/secure<br></code></pre></td></tr></table></figure><h3 id="21-2-日志管理服务rsyslogd"><a href="#21-2-日志管理服务rsyslogd" class="headerlink" title="21.2 日志管理服务rsyslogd"></a>21.2 日志管理服务rsyslogd</h3><p>​        CentOS7.6日志服务是rsyslogd，CentOS6.x日志服务是syslogd。rsyslogd功能更强大。rsyslogd的使用、日志文件的格式，和syslogd服务兼容的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227183859819.png"></p><p><code>/etc/rsyslog.conf</code>中记录了，各种服务应该写入日志的目录。</p><p>应用案例</p><p>案例1：查询Linux中的rsyslogd服务是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux | grep rsyslogd | grep -v grep  # grep -v 是指选择不含匹配串的行<br></code></pre></td></tr></table></figure><p>案例2：查询rsyslogd服务的自启动状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl list-unit-files | grep rsyslogd<br></code></pre></td></tr></table></figure><h4 id="21-2-1-配置文件-etc-rsyslog-conf"><a href="#21-2-1-配置文件-etc-rsyslog-conf" class="headerlink" title="21.2.1 配置文件 /etc/rsyslog.conf"></a>21.2.1 配置文件 /etc/rsyslog.conf</h4><p>编辑文件时的格式为：*.*, 存放日志文件</p><p>其中第一个*代表日志类型，第二个*代表日志级别</p><ol><li><p>日志类型分为：</p><p>auth：pam产生的日志</p><p>authpriv：ssh、ftp等登录信息的验证信息</p><p>corn：时间任务相关</p><p>kern：内核</p><p>lpr：打印</p><p>mail：邮件</p><p>mark(syslog)-rsyslog:服务内部的信息，时间标识</p><p>news：新闻组</p><p>user：用户程序产生的相关信息</p><p>uucp：unix to unix copy主机之间相关的通信</p><p>local 1-7：自定义的日志设备</p></li><li><p>日志级别：</p><p>debug：有调试信息的，日志通信最多</p><p>info：一般信息日志，最常用</p><p>notice：最具有重要性的普通条件的信息</p><p>warning：警告级别</p><p>err：错误级别，阻止某个功能或者模块不能正常工作的信息</p><p>crit：严重级别，阻止整个系统或者整个软件不能正常工作的信息</p><p>alert：需要立刻修改的信息</p><p>emerg：内核崩溃等重要信息</p><p>none：什么都不记录</p><p>注意：从上到下，级别从低到高，记录信息越来越少</p></li></ol><p>由日志服务rsyslogd记录的日志文件，日志文件的格式包含以下4列：</p><ol><li><p>事件产生的时间</p></li><li><p>产生事件的服务器的主机名</p></li><li><p>产生事件的服务名或程序名</p></li><li><p>事件的具体信息</p></li></ol><p>应用案例</p><p>案例1：查看一下/var/log/secure日志，这个日志中记录的是用户验证和授权方面的信息，来分析如何查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/secure<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227185605784.png"></p><p>案例2：在/etc/rsyslog.conf中添加一个日志文件/var/log/hsp.log,当有事件发送时(比如sshd服务相关事件)，该文件会接收到信息并保存.给小伙伴演示重启，登录的情况，看看是否有日志保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/rsyslog.conf<br><br>*.*/var/log/hsp.log<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/hsp.log #就可以看到相关服务时间的日志<br></code></pre></td></tr></table></figure><h3 id="21-3-日志轮替"><a href="#21-3-日志轮替" class="headerlink" title="21.3 日志轮替"></a>21.3 日志轮替</h3><p>基本介绍</p><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。</p><h4 id="21-3-1-日志轮替文件命名"><a href="#21-3-1-日志轮替文件命名" class="headerlink" title="21.3.1 日志轮替文件命名"></a>21.3.1 日志轮替文件命名</h4><ol><li>centos7使用logrotate进行日志轮替管理，要想改变日志轮替文件名字，通过/etc/logrotate.conf配置文件中“dateext”参数</li><li>如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。</li><li> 如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。</li></ol><h4 id="21-3-2-logrotate配置文件"><a href="#21-3-2-logrotate配置文件" class="headerlink" title="21.3.2 logrotate配置文件"></a>21.3.2 logrotate配置文件</h4><p><code>/etc/logrotate.conf</code>为logrotate的全局配置文件</p><p>#rotate log files weekly,每周对日志文件进行一次轮替</p><p>weekly</p><p>#keep 4 weeks worth of backlogs,共保存4份日志文件，当建立新的日志文件时，旧的将会被删除</p><p>rotate4</p><p>#create new (empty) log files after rotating old ones,创建新的空的日志文件，在日志轮替后</p><p>create</p><p>#use date as a suffix of the rotated file,使用日期作为日志轮替文件的后缀</p><p>dateext</p><p>#uncomment this if you want your log files compressed,日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩#compress</p><p>#RPM packages drop log rotation information into this directory </p><p>include /etc/logrotate.d/</p><p>#包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，</p><p>#下面是单独设置，优先级更高。</p><p>#no packages own wtmp and btmp – we’ll rotate them here</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/log/wtmp &#123;<br><span class="hljs-meta">monthly#</span><span class="bash">每月对日志文件进行一次轮替</span><br>create 0664 root utmp #建立的新日志文件，权限是0664，所有者是root，所属组是utmp组<br>minsize 1M #日志文件最小轮替大小是1MB，也就是日志一定要超过1MB才会被轮替，否则就算时间达到一个月，也不进行日志转储<br>rotate 1 #仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/log/btmp &#123;<br>missingok #如果日志不存在，则忽略该日志的警告信息<br>monthly<br>create 0600 root utmp<br>rotate 1<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="21-3-3-logroate配置文件的参数说明"><a href="#21-3-3-logroate配置文件的参数说明" class="headerlink" title="21.3.3 logroate配置文件的参数说明"></a>21.3.3 logroate配置文件的参数说明</h4><table><thead><tr><th>daily</th><th>日志的轮替周期是每天</th></tr></thead><tbody><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日后在的轮替周期是每月</td></tr><tr><td>rotate 数字</td><td>保留的日志文件个数。0指每月备份</td></tr><tr><td>compress</td><td>日志轮替是，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组</td></tr><tr><td>mail address</td><td>当日志轮替是，输出内容通过邮件发送到指定的邮件地址</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值，也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀</td></tr><tr><td>sharedscripts</td><td>再次关键字之后的监本只执行一次</td></tr><tr><td>prerotate/endscript</td><td>在日志轮替前执行脚本命令</td></tr><tr><td>postroate/endscript</td><td>在日志轮替后执行脚本命令</td></tr></tbody></table><p>应用案例</p><p>案例1：把自己的日志加入日志轮替</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">可以写入到/etc/logrotate.d/下，vim hsp<br><br>/var/log/hsp.log &#123;<br>missingok<br>daily<br>copytruncate<br>rotate 7<br>notifempty<br>&#125;<br><span class="hljs-meta">#</span><span class="bash">同样也可以直接写入到主配置文件中，/etc/logrotate.conf中</span><br></code></pre></td></tr></table></figure><h4 id="21-3-4-日志轮替机制原理"><a href="#21-3-4-日志轮替机制原理" class="headerlink" title="21.3.4 日志轮替机制原理"></a>21.3.4 日志轮替机制原理</h4><p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在/etc/cron.daily/目录，就会发现这个目录中是有logrotate文件(可执行)，logrotate通过这个文件依赖定时任务执行的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227183859819.png"></p><h3 id="21-4-查看内存日志"><a href="#21-4-查看内存日志" class="headerlink" title="21.4 查看内存日志"></a>21.4 查看内存日志</h3><p>journalctl可以查看内存日志，这里我们看看常用的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">journalctl #查看全部<br>journalctl -n 3 #查看最新3条<br>journalctl --since 19:00 --until 19:10:10 #查看起始时间到结束时间的日志可加日期<br>journalctl -p err #报错日志<br>journalctl -o varbose #日志详细内容<br>journalctl _PID=1245 _COMM=sshd #查看包含这些参数的日志<br>或者 journalctl | grep sshd<br></code></pre></td></tr></table></figure><p>注意：journalctl查看的事内存日志，重启清空</p><p>应用案例：</p><p>案例1：使用 journalctl | grep sshd来看看用户登录清空,重启系统，再次查询，看看日志有什么变化没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">journalctl | grep sshd<br></code></pre></td></tr></table></figure><h2 id="二十二、定制自己的Linux系统"><a href="#二十二、定制自己的Linux系统" class="headerlink" title="二十二、定制自己的Linux系统"></a>二十二、定制自己的Linux系统</h2><h3 id="22-1-基本介绍"><a href="#22-1-基本介绍" class="headerlink" title="22.1 基本介绍"></a>22.1 基本介绍</h3><p>通过裁剪现有Linux系统(CentOS7.6)，创建属于自己的minLinux小系统，可以加深我们对linux的理解。</p><h3 id="22-2-启动流程介绍"><a href="#22-2-启动流程介绍" class="headerlink" title="22.2 启动流程介绍"></a>22.2 启动流程介绍</h3><p>制作Linux小系统之前，再了解一下Linux的启动流程：</p><p>1、首先Linux要通过自检，检查硬件设备有没有故障</p><p>2、如果有多块启动盘的话，需要在BIOS中选择启动磁盘</p><p>3、启动MBR中的bootloader引导程序</p><p>4、加载内核文件</p><p>5、执行所有进程的父进程、老祖宗systemd</p><p>6、欢迎界面</p><p>在Linux的启动流程中，加载内核文件时关键文件：</p><p>1）kernel文件:vmlinuz-3.10.0-957.el7.x86_64</p><p>2）initrd文件:initramfs-3.10.0-957.el7.x86_64.img</p><h3 id="22-3-制作minlinux思路分析"><a href="#22-3-制作minlinux思路分析" class="headerlink" title="22.3 制作minlinux思路分析"></a>22.3 制作minlinux思路分析</h3><p>1)在现有的Linux系统(centos7.6)上加一块硬盘/dev/sdb，在硬盘上分两个分区，一个是/boot，一个是/，并将其格式化。需要明确的是，现在加的这个硬盘在现有的Linux系统中是/dev/sdb，但是，当我们把东西全部设置好时，要把这个硬盘拔除，放在新系统上，此时，就是/dev/sda</p><p>2)在/dev/sdb硬盘上，将其打造成独立的Linux系统，里面的所有文件是需要拷贝进去的</p><p>3)作为能独立运行的Linux系统，内核是一定不能少，要把内核文件和initramfs文件也一起拷到/dev/sdb上</p><p>4)以上步骤完成，我们的自制Linux就完成,创建一个新的linux虚拟机，将其硬盘指向我们创建的硬盘，启动即可</p><h2 id="二十三、Linux内核源码介绍-amp-内核升级"><a href="#二十三、Linux内核源码介绍-amp-内核升级" class="headerlink" title="二十三、Linux内核源码介绍&amp;内核升级"></a>二十三、Linux内核源码介绍&amp;内核升级</h2><p>为什么要阅读linux内核?</p><p>1)爱好，就是喜欢linux(黑客精神)</p><p>2)想深入理解linux底层运行机制，对操作系统有深入理解</p><p>3)阅读Linux内核，你会对整个计算机体系有一个更深刻的认识。作为开发者，不管你从事的是驱动开发，应用开发还是后台开发，你都需要了解操作系统内核的运行机制，这样才能写出更好的代码。</p><p>4)作为开发人员不应该只局限在自己的领域，你设计的模块看起来小，但是你不了解进程的调用机制，你不知道进程为什么会阻塞、就绪、执行几个状态。那么很难写出优质的代码。</p><p>5)作为有追求的程序员，还是应该深入的了解一个操作系统的底层机制,(比如linux/unix)最好是源码级别的，这样你写多线程高并发程序，包括架构，优化，算法等，高度不一样的，当然老韩也不是要求小伙伴儿把一个非常庞大的Linux内核每一行都读懂。我觉得。你至少能看几个核心的模块。</p><h4 id="23-1-linux0-01内核源码"><a href="#23-1-linux0-01内核源码" class="headerlink" title="23.1 linux0.01内核源码"></a>23.1 linux0.01内核源码</h4><p>Linux的内核源代码可以从网上下载,解压缩后文件一般也都位于linux目录下。内核源代码有很多版本，可以从linux0.01内核入手，总共的代码1w行左右，最新版本5.9.8总共代码超过700w行，非常庞大.<a href="https://www.kernel.org/">Linux内核下载地址</a></p><h4 id="23-1-1-内核源码阅读技巧"><a href="#23-1-1-内核源码阅读技巧" class="headerlink" title="23.1.1 内核源码阅读技巧"></a>23.1.1 内核源码阅读技巧</h4><p>1)linux0.01的阅读需要懂c语言</p><p>2)阅读源码前，应知道Linux内核源码的整体分布情况。现代的操作系统一般由进程管理、内存管理、文件系统、驱动程序和网络等组成。Linux内核源码的各个目录大致与此相对应.</p><p>3)在阅读方法或顺序上，有纵向与横向之分。所谓纵向就是顺着程序的执行顺序逐步进行；所谓横向，就是按模块进行。它们经常结合在一起进行</p><p>4)对于Linux启动的代码可顺着Linux的启动顺序一步步来阅读；对于像内存管理部分，可以单独拿出来进行阅读分析。实际上这是一个反复的过程，不可能读一遍就理解</p><h4 id="23-1-2-linux目录说明"><a href="#23-1-2-linux目录说明" class="headerlink" title="23.1.2 linux目录说明"></a>23.1.2 linux目录说明</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227214906739.png"></p><h4 id="23-1-3-main-c初探"><a href="#23-1-3-main-c初探" class="headerlink" title="23.1.3 main.c初探"></a>23.1.3 main.c初探</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227215620318.png"></p><h3 id="23-2-内核升级"><a href="#23-2-内核升级" class="headerlink" title="23.2 内核升级"></a>23.2 内核升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -a #查看当前的内核版本<br>yum info kernel -q #检测内核版本，显示可以升级的内核<br>yum update kernel #升级内核<br>yum list kernel -q #查看已经安装的内核<br></code></pre></td></tr></table></figure><h3 id="二十四、备份与恢复"><a href="#二十四、备份与恢复" class="headerlink" title="二十四、备份与恢复"></a>二十四、备份与恢复</h3><p>基本介绍：</p><p>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，还会造成数据丢失。所以我们可以使用备份和恢复技术linux的备份和恢复很简单，有两种方式：</p><p>1)把需要的文件(或者分区)用<code>tar</code>打包就行，下次需要恢复的时候，再解压开覆盖即可</p><p>2)使用dump和restore命令</p><h4 id="24-1-安装dump和restore"><a href="#24-1-安装dump和restore" class="headerlink" title="24.1 安装dump和restore"></a>24.1 安装dump和restore</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install dump<br>yum -y install restore<br></code></pre></td></tr></table></figure><h3 id="24-2-使用dump完成备份"><a href="#24-2-使用dump完成备份" class="headerlink" title="24.2 使用dump完成备份"></a>24.2 使用dump完成备份</h3><p>基本介绍</p><p>dump支持分卷和增量备份（所谓增量备份是指备份上次备份后修改/增加过的文件，也称差异备份）。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump [-cu] [-f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [目录或文件系统]<br>dump [-wW]<br></code></pre></td></tr></table></figure><p>选项解释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-c :创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头（c就是下面0-9的数字)<br>-0123456789： 备份的层级。0为最完整备份，会被分所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替<br>-f &lt;备份后文件名&gt;: 指定备份后文件名<br>-j: 调用bzlib库压缩备份文件，也就是将备份后的文件压缩成bz2格式，让文件更小<br>-T &lt;日期&gt;: 指定开始备份的时间与日期<br>-u: 备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期与时间等。<br>-t: 指定文件若改文件已存在备份文件中，则列出名称<br>-W: 显示需要备份的文件及其最后一次备份的层级，时间，日期<br>-w：与-W类似，但仅显示需要备份的文件。<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：将/boot分区所有内容备份到/opt/boot.bak0.bz2文件中，备份层级为“0”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -0uj -f /opt/book.bak0.bz2 /boot<br></code></pre></td></tr></table></figure><p>案例2：在/boot目录下增加新文件，备份层级为“1”(只备份上次使用层次“0”备份后发生过改变的数据),注意比较看看这次生成的备份文件boot1.bak有多大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -1uj -f /opt/boot.bak1.bz2 /boot<br></code></pre></td></tr></table></figure><p>通过dump命令在配合crontab可以实现无人值守备份</p><p>案例3：显示需要备份的文件及其最后一次备份的层级，时间，日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -W<br></code></pre></td></tr></table></figure><p>案例4：查看备份时间文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/dumpdates<br></code></pre></td></tr></table></figure><p><strong>dump备份文件或者目录前面我们在备份分区时，是可以支持增量备份的，如果备份文件或者目录，不再支持增量备份,即只能使用0级别备份案例</strong>,也不支持-u选项。</p><p>使用dump备份/etc整个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -0j -f /opt/etc.bak.bz2 /etc/#下面这条语句会报错，提示DUMP:Only level 0 dumps are allowed on a subdirectory dump -1j -f /opt/etc.bak.bz2 /etc/<br></code></pre></td></tr></table></figure><h3 id="24-3-使用restore完成恢复"><a href="#24-3-使用restore完成恢复" class="headerlink" title="24.3 使用restore完成恢复"></a>24.3 使用restore完成恢复</h3><p>基本介绍</p><p>restore命令用来恢复已备份的文件，可以从dump生成的备份文件中恢复原文件，一般是恢复到当前目录</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore [模式选项] [选项]<br></code></pre></td></tr></table></figure><p>说明下面四个模式，不能混用，再一次命令中，只能指定一种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-C: 使用对比模式，将备份的文件与已存在的文件相互对比。<br>-i: 使用交互模式，在进行还原操作时，restore指令将依序询问用户<br>-r: 进行还原模式<br>-t: 查看模式，看备份文件有哪些文件<br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-f &lt;备份设备&gt;: 从指定的文件中读取备份数据，进行还原操作<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：restore命令比较模式，比较备份文件和原文件的区别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /boot/hello.java /boot/hello100.java<br>restore -C -f boot.bak1.bz2 #注意和最新的文件比较<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228164134772.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /boot/hello100.java /boot/hello.java<br>restore -C -f boot.bak1.bz2<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228164214084.png"></p><p>案例2：restore命令查看模式，看备份文件有哪些数据/文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -t -f boot.bak0.bz2<br></code></pre></td></tr></table></figure><p>案例3：restore命令还原模式,注意细节：如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件，就要恢复几个，按顺序来恢复即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -r -f /opt/boot.bak0.bz2 #恢复到第一次完全备份状态<br>restore -r -f /opt/boot.bak1.bz2 #恢复到第二次完全备份状态<br></code></pre></td></tr></table></figure><p>案例4：restore命令恢复备份的文件，或者整个目录的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -r -f 备份好的文件<br></code></pre></td></tr></table></figure><h2 id="二十五、Linux可视化管理"><a href="#二十五、Linux可视化管理" class="headerlink" title="二十五、Linux可视化管理"></a>二十五、Linux可视化管理</h2><h3 id="25-1-webmin"><a href="#25-1-webmin" class="headerlink" title="25.1 webmin"></a>25.1 webmin</h3><h4 id="25-1-1-基本介绍"><a href="#25-1-1-基本介绍" class="headerlink" title="25.1.1 基本介绍"></a>25.1.1 基本介绍</h4><p>Webmin是功能强大的基于Web的Unix/linux系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理操作。除了各版本的linux以外还可用于：AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等系统</p><h4 id="25-1-2-安装webmin-amp-配置"><a href="#25-1-2-安装webmin-amp-配置" class="headerlink" title="25.1.2 安装webmin&amp;配置"></a>25.1.2 安装webmin&amp;配置</h4><p>1)下载地址:<a href="http://download.webmin.com/download/yum/,%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF">http://download.webmin.com/download/yum/,用下载工具下载即可</a></p><p>或者<code>wgethttp://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm</code></p><p>2)安装：<code>rpm -ivh webmin-1.700-1.noarch.rpm</code></p><p>3)重置密码:<code>/usr/libexec/webmin/changepass.pl /etc/webminroot test root</code>是webmin的用户名，不是OS的,这里就是把webmin的root用户密码改成了test</p><p>4)修改webmin服务的端口号（默认是10000出于安全目的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/webmin/miniserv.conf#修改端口<br><br>将port=10000修改为其他端口号，如port=6666<br>将listen=10000修改为listen=6666<br></code></pre></td></tr></table></figure><p>5)重启webmin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">/etc/webmin/restart#</span><span class="bash">重启</span><br><span class="hljs-meta">/etc/webmin/start#</span><span class="bash">启动</span><br><span class="hljs-meta">/etc/webmin/stop#</span><span class="bash">停止</span><br></code></pre></td></tr></table></figure><p>6)防火墙放开6666端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall -cmd--zone=public --add-port=6666/tcp --permanent#配置防火墙开放6666端口<br>firewall -cmd--reload#更新防火墙配置<br>firewall -cmd--zone=public --list-ports#查看已经开放的端口号<br></code></pre></td></tr></table></figure><p>7)登录webmin</p><p><a href="http://ip:6666可以访问了">http://ip:6666可以访问了</a></p><p>用root账号和重置的新密码test</p><h3 id="25-2-bt-宝塔"><a href="#25-2-bt-宝塔" class="headerlink" title="25.2 bt(宝塔)"></a>25.2 bt(宝塔)</h3><h4 id="25-2-1基本介绍"><a href="#25-2-1基本介绍" class="headerlink" title="25.2.1基本介绍"></a>25.2.1基本介绍</h4><p>bt宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等多项服务器管理功能。</p><h4 id="25-2-2-安装使用"><a href="#25-2-2-安装使用" class="headerlink" title="25.2.2 安装使用"></a>25.2.2 安装使用</h4><p>1)安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></td></tr></table></figure><p>&amp;&amp;代表先执行前面的命令，在执行后面的命令。</p><p>2)安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录，</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228180112466.png"></p><h4 id="25-2-3-如果bt的用户名，密码忘记了，使用btdefault可以查看"><a href="#25-2-3-如果bt的用户名，密码忘记了，使用btdefault可以查看" class="headerlink" title="25.2.3 如果bt的用户名，密码忘记了，使用btdefault可以查看"></a>25.2.3 如果bt的用户名，密码忘记了，使用btdefault可以查看</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">by default<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228180222987.png"></p><h2 id="二十六、Linux应用实例"><a href="#二十六、Linux应用实例" class="headerlink" title="二十六、Linux应用实例"></a>二十六、Linux应用实例</h2><p>案例1：分析日志t.log(访问量)，将各个ip地址截取，并统计出现次数,并按从大到小排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">t.txt<br>http://192.168.200.10/index1.html<br>http://192.168.200.10/index2.html<br>http://192.168.200.20/index1.html<br>http://192.168.200.30/index1.html<br>http://192.168.200.40/index1.html<br>http://192.168.200.30/order.html<br>http://192.168.200.10/order.html<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat t.txt | cut -d &#x27;/&#x27; -f 3 | sort | uniq -c | sort -nr<br></code></pre></td></tr></table></figure><p><strong>cut是split命令，-d是指定分割符号(不可以是空格），-f是取出第几列</strong>,<strong>uniq -c 统计命令是统计相邻行相同的数量</strong></p><p>案例2：统计连接到服务器的各个ip情况，并按连接数从大到小排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -an | grep ESTABLISHED | awk -F &quot; &quot; &#x27;&#123;print $5&#125;&#x27; | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr<br></code></pre></td></tr></table></figure><p>案例3：如忘记了mysql5.7数据库的ROOT用户的密码，如何找回?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/my.cnf<br><br>skip-grant-tables #加上一行，跳过密码<br><br>service mysqld.service #重启mysqld服务<br>mysql -u root -p #登录<br>show databases;<br>use mysql;<br>show tables;<br>desc users;<br>update user set authentication_string=password(&quot;xinmima&quot;) where user=&#x27;root&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>案例4：统计ip访问情况，要求分析nginx访问日志(access.log)，找出访问页面数量在前2位的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat access.log | awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr | head -2<br></code></pre></td></tr></table></figure><p>案例5：使用tcpdump监听本机,将来自ip192.168.200.1，tcp端口为22的数据，保存输出到tcpdump.log,用做将来数据分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcpdump -i ens33 host 192.168.200.1 and port 22 &gt;&gt; /opt/tcpdump.log<br></code></pre></td></tr></table></figure><p>监听网络设备ens33</p><p>案例6：常用的Nginx模块，用来做什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">rewrite模块，实现重写功能<br>access模块：来源控制<br>ssl模块：安全加密<br>ngx_http_gzip_module：网络传输压缩模块<br>ngx_http_proxy_module:模块实现代理<br>ngx_http_upstream_module:模块实现定义后端服务器列表<br>ngx_cache_purge:实现缓存清除功能<br></code></pre></td></tr></table></figure><p>案例7：如果你是系统管理员，在进行Linux系统权限划分时,应考虑哪些因素?</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228193525894.png"></p><ol><li><p>注意权限分离，比如:工作中，Linux系统权限和数据库权限不要在同一个部门</p></li><li><p>权限最小原则(即:在满足使用的情况下最少优先)</p></li><li><p>减少使用root用户，尽量用普通用户+sudo提权进行日常操作。</p></li><li><p>重要的系统文件，比如/etc/passwd,/etc/shadowetc/fstab，/etc/sudoers等,日常建议使用chattr(change attribute)锁定,需要操作时再打开。【演示比如:锁定/etc/passwd让任何用户都不能随意useradd,除非解除锁定】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chattr +i /etc/passwd #锁定文件<br></code></pre></td></tr></table></figure></li><li><p>使用SUID,SGID,Sticky设置特殊权限。</p></li><li><p>可以利用工具，比如chkrootkit或者rootkit hunter检测rootkit脚本（rootkit是入侵者使用工具,在不察觉的建立了入侵系统途径）[演示使用wget <a href="ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz]">ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz]</a></p></li><li><p>利用工具Tripwire检测文件系统完整性</p></li></ol><p>案例8：权限操作思考题</p><p>（1）用户tom对目录/home/test有执行x和读r写w权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗?(ok)</p><p>（2）用户tom对目录/home/test只有读写权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(no)?能修改吗(no)？能删除吗(no)?</p><p>（3）用户tom对目录/home/test只有执行权限x，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗(no)?</p><p>（4）用户tom对目录/home/test只有执行x和写w权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗(ok)?</p><p>案例9：列举Linux高级命令，至少6个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat #网络状态监控<br>top #系统运行状态<br>lsblk #查看硬盘分区<br>find<br>ps -aux #查看运行进程<br>chkconfig #查看服务启动状态<br>systemctl #管理系统服务器<br></code></pre></td></tr></table></figure><p>案例10：Linux查看内存、io读写、磁盘存储、端口占用、进程查看命令是什么?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top,iotop,df -lh,netstat -tunlp,ps -aux | grep 关心的进程<br></code></pre></td></tr></table></figure><p>案例11：使用Linux命令计算t2.txt第二列的和并输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat t2.txt | awk -F &quot; &quot; &#x27;&#123;sum+=$2&#125; END &#123;print sum&#125;&#x27;<br></code></pre></td></tr></table></figure><p>案例12：Shell脚本里如何检查一个文件是否存在？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ -f 文件名 ] then echo &quot;存在&quot; else echo &quot;不存在&quot; fi<br></code></pre></td></tr></table></figure><p>案例13：用shell写一个脚本，对文本t3.txt中无序的一列数字排序,并将总和输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort -nr t3.txt | awk &#x27;&#123;sum+=$0; print $0&#125; END &#123;print &quot;和=&quot;sum&#125;&#x27;<br></code></pre></td></tr></table></figure><p>案例14：请用指令写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符“cat”的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1<br></code></pre></td></tr></table></figure><p>案例15：请写出统计/home目录下所有文件个数和所有文件总行数的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name &quot;*.*&quot; | wc -l<br>find /home -name &quot;*.*&quot; | xargs wc -l<br></code></pre></td></tr></table></figure><p>案例16：每天晚上10点30分，打包站点目录/var/spool/mail备份到/home目录下（每次备份按时间生成不同的备份包比如按照年月日时分秒）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e<br><br>30 22 * * * test.sh<br><br>vim test.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>cd /var/spool/ &amp;&amp; /bin/tar zcf /home/mail-`date +%Y-%m-%d_%H%M%S`.tar.gz mail<br><br>chomd 777 test.sh<br></code></pre></td></tr></table></figure><p>案例17：如何优化Linux系统，说出你的方法</p><p>(1)不用root,使用sudo提示权限</p><p>(2)定时的自动更新服务时间,使用nptdate npt1.aliyun.com,让croud定时更新</p><p>(3)配置yum源，指向国内镜像(清华，163)</p><p>(4)配置合理的防火墙策略,打开必要的端口，关闭不必要的端口</p><p>(5)打开最大文件数(调整文件的描述的数量)vim /etc/profile ulimit -SHn 65535</p><p>(6)配置合理的监控策略</p><p>(7)配置合理的系统重要文件的备份策略</p><p>(8)对安装的软件进行优化，比如nginx,apache</p><p>(9)内核参数进行优化/etc/sysctl.conf</p><p>(10)锁定一些重要的系统文件chattr/etc/passwd /ect/shadow /etc/inittab</p><p>(11)禁用不必要的服务setup,ntsysv</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="一、Git基础学习"><a href="#一、Git基础学习" class="headerlink" title="一、Git基础学习"></a>一、Git基础学习</h2><h3 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1. Git常用命令"></a>1. Git常用命令</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a628594255e4d238d24b4a1276dbbf8tplv-k3u1fbpfcp-watermark.awebp"></p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>安装与配置</strong></td><td align="left"></td></tr><tr><td align="left">sudo apt-get install git</td><td align="left">Ubuntu 上安装 Git 命令</td></tr><tr><td align="left">git config --global user.name 用户名</td><td align="left">设置用户签名<br>（安装 Git 后务必设置）</td></tr><tr><td align="left">git config --global user.email email 地址</td><td align="left">设置用户 email 地址<br>（安装 Git 后务必设置）</td></tr><tr><td align="left"><strong>获取与创建项目</strong></td><td align="left"></td></tr><tr><td align="left">git init</td><td align="left">初始化本地库</td></tr><tr><td align="left">git clone 远程库地址</td><td align="left">从远程库克隆到本地</td></tr><tr><td align="left"><strong>基本快照</strong></td><td align="left"></td></tr><tr><td align="left">git status</td><td align="left">查看本地库状态</td></tr><tr><td align="left">git add 文件名</td><td align="left">添加变动文件到暂存区</td></tr><tr><td align="left">git add .</td><td align="left">添加当前目录下所有变动文件到暂存区</td></tr><tr><td align="left">git restore --staged 文件名</td><td align="left">复位在暂存区的文件（add 反悔药）</td></tr><tr><td align="left">git rm --cached 文件名</td><td align="left">移除在暂存区的文件（add 反悔药）（同上一条）</td></tr><tr><td align="left">git commit -m “备注文本” 文件名</td><td align="left">提交暂存区文件到本地库<br>（文件名缺省时，将暂存区所有文件提交）</td></tr><tr><td align="left">git commit --amend</td><td align="left">修改上次提交的备注文本</td></tr><tr><td align="left">git revert 版本号 (7 位)</td><td align="left">撤销指定的提交（commit 反悔药）(慎用)</td></tr><tr><td align="left">git reset --hard 版本号 (7 位)</td><td align="left">版本间穿梭（配合 git reflog 使用）</td></tr><tr><td align="left">git reset --hard HEAD^</td><td align="left">穿梭到上一个版本</td></tr><tr><td align="left"><strong>分支与合并</strong></td><td align="left"></td></tr><tr><td align="left">git branch</td><td align="left">列出所有分支</td></tr><tr><td align="left">git branch 分支名</td><td align="left">创建分支</td></tr><tr><td align="left">git checkout 分支名</td><td align="left">切换分支</td></tr><tr><td align="left">git merge 分支名 B</td><td align="left">分支 B 合并到 A<br>（A 为当前工作目录所处分支）</td></tr><tr><td align="left">git branch -d 分支名</td><td align="left">删除分支</td></tr><tr><td align="left">git tag</td><td align="left">列出所有本地标签</td></tr><tr><td align="left">git tag -l 通配模式文本 (*)</td><td align="left">根据符合通配模式文本，列出所有本地标签</td></tr><tr><td align="left">git tag 标签名</td><td align="left">为最新提交创建<strong>轻量</strong>标签</td></tr><tr><td align="left">git tag 标签名 版本号 (7 位)</td><td align="left">为对应版本号提交创建<strong>轻量</strong>标签（在后期打标签）</td></tr><tr><td align="left">git tag -a 标签名 -m 备注文本</td><td align="left">为最新提交创建<strong>附注</strong>标签</td></tr><tr><td align="left">git tag -d 标签名</td><td align="left">删除指定标签</td></tr><tr><td align="left"><strong>共享与更新项目</strong></td><td align="left"></td></tr><tr><td align="left">git remote add 别名 远程仓库地址</td><td align="left">添加远程库</td></tr><tr><td align="left">git remote -v</td><td align="left">查看添加过的远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 分支名</td><td align="left">推送到远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 --tags</td><td align="left">推送所有标签到远程库</td></tr><tr><td align="left">git fetch</td><td align="left">将远程库的最新内容拉到本地</td></tr><tr><td align="left">git pull 远程库地址或其别名 分支名</td><td align="left">将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并，<br>相当于 git fetch + git merge，这样可能会产生冲突，需要手动解决</td></tr><tr><td align="left"><strong>检查与比较</strong></td><td align="left"></td></tr><tr><td align="left">git show 标签名</td><td align="left">显示标签信息和与之对应的提交信息</td></tr><tr><td align="left">git show 版本号 (7 位)</td><td align="left">显示对应版本对应的提交信息</td></tr><tr><td align="left">git log</td><td align="left">显示当前分支所有提交过的版本信息</td></tr><tr><td align="left">git log --follow 文件名</td><td align="left">显示当前分支所有提交过的关于指定文件版本信息</td></tr><tr><td align="left">git log --pretty=oneline</td><td align="left">显示当前分支所有提交过的版本信息（精简）</td></tr><tr><td align="left">git log --graph</td><td align="left">显示当前分支所有提交过的版本信息（附有分支合并图）</td></tr><tr><td align="left">git diff 分支一 分支二</td><td align="left">显示两分支差异</td></tr><tr><td align="left">git diff 版本号一 (7 位) 版本号二 (7 位)</td><td align="left">显示同一分支两版本差异</td></tr><tr><td align="left"><strong>管理</strong></td><td align="left"></td></tr><tr><td align="left">git reflog</td><td align="left">可以查看所有分支的所有操作记录<br>（包括已被删除的 commit 记录和 reset 的操作，git log 所不能）</td></tr></tbody></table><h3 id="2-官网介绍"><a href="#2-官网介绍" class="headerlink" title="2. 官网介绍"></a>2. 官网介绍</h3><p><a href="https://git-scm.com/">Git 官网</a></p><p><a href="http://git-scm.com/docs">Git 官方文档</a></p><p><a href="https://git-scm.com/book/zh/v2">Git 官方书</a></p><p><a href="https://git-scm.com/downloads">Git 下载页面</a></p><p><a href="https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/">Github Git Cheat Sheets - 中文版</a></p><p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</p><h3 id="3-版本控制介绍"><a href="#3-版本控制介绍" class="headerlink" title="3. 版本控制介绍"></a>3. 版本控制介绍</h3><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2abc5f18d46afc2d50cee7db484a460f.png"></p><p>为什么需要版本控制？因为要从个人开发过渡到团队协作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2bcf55bc8f1e6cda16fc048ed30e12fc.png"></p><h3 id="4-分布式版本控制-VS-集中式版本控制"><a href="#4-分布式版本控制-VS-集中式版本控制" class="headerlink" title="4. 分布式版本控制 VS 集中式版本控制"></a>4. 分布式版本控制 VS 集中式版本控制</h3><h4 id="4-1-集中式版本控制工具"><a href="#4-1-集中式版本控制工具" class="headerlink" title="4.1  集中式版本控制工具"></a>4.1  集中式版本控制工具</h4><p>集中化的版本控制系统诸如 CVS、 SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统， 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做显而易见的<strong>缺点</strong>是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f0cc7f6f1eb57316f7f8fce8e2f03f45.png"></p><h4 id="4-2-分布式版本控制工具"><a href="#4-2-分布式版本控制工具" class="headerlink" title="4.2 分布式版本控制工具"></a>4.2 分布式版本控制工具</h4><p>Git、 Mercurial、 Bazaar、 Darcs……</p><p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后, 解决了集中式版本控制系统的缺陷：</p><ol><li> 服务器断网的情况下也可以进行开发（因为版本控制是在<strong>本地</strong>进行的）</li><li> 每个客户端保存的也都是整个<strong>完整的项目</strong>（包含历史记录， 更加安全）</li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/340e9b3bc50013b61f0e83e96b99f86a.png"></p><h3 id="5-Git发展历史"><a href="#5-Git发展历史" class="headerlink" title="5. Git发展历史"></a>5. Git发展历史</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f25cba01665ab8dcb63fcc79d05f04f.png"></p><h3 id="6-工作机制和代码托管中心"><a href="#6-工作机制和代码托管中心" class="headerlink" title="6. 工作机制和代码托管中心"></a>6. 工作机制和代码托管中心</h3><h4 id="6-1-Git-工作机制"><a href="#6-1-Git-工作机制" class="headerlink" title="6.1 Git 工作机制"></a>6.1 Git 工作机制</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1706b3553447ac9f8d95377d965d4fd2.png"></p><h4 id="6-2-Git-代码托管中心"><a href="#6-2-Git-代码托管中心" class="headerlink" title="6.2 Git 代码托管中心"></a>6.2 Git 代码托管中心</h4><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li>局域网<ul><li>  GitLab</li></ul></li><li>互联网<ul><li>  GitHub（外网）</li><li>  Gitee 码云（国内网站）</li></ul></li></ul><h3 id="7-Git安装和客户端的使用"><a href="#7-Git安装和客户端的使用" class="headerlink" title="7. Git安装和客户端的使用"></a>7. Git安装和客户端的使用</h3><p>在 <a href="https://git-scm.com/downloads">Git 下载页面</a>，选择下载 Windows 64 位版的 Git 安装软件。</p><p>安装步骤按照安装软件的安装向导安装即可，无需过多配置。</p><p>安装成功后，通常在文件浏览器空白处单击击鼠标右键，弹出菜单栏有 Git 的选项。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/72adc78acc2344ab51285dae2c4776ad.png"></p><h2 id="二、Git-基本使用"><a href="#二、Git-基本使用" class="headerlink" title="二、Git 基本使用"></a>二、Git 基本使用</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config --global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config --global user.email 邮箱</td><td>设置用户 email 地址</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset --hard 版本号</td><td>版本穿梭</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1352126739_7909.jpg"></p><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当执行 <strong>git rm –cached &lt;file&gt;</strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（<strong>git commit</strong>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。<strong>版本库 -&gt; 暂存区</strong></li><li>当执行<strong>git reset HEAD –hard</strong>，暂存区和工作区都会被版本库重写，相当于HEAD指针移动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – &lt;file&gt;</strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。<strong>暂存区 -&gt; 工作区</strong></li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD &lt;file&gt;</strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li></ul><h3 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1. 设置用户签名"></a>1. 设置用户签名</h3><h4 id="1-1-设置系统级用户签名"><a href="#1-1-设置系统级用户签名" class="headerlink" title="1.1  设置系统级用户签名"></a>1.1  设置系统级用户签名</h4><figure class="highlight autoit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name abc <span class="hljs-meta">#用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email abc<span class="hljs-symbol">@123</span>.com<br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>在用户目录下的<code>./gitconfig</code>中查看设置过用户签名</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">abc@</span>DESKTOP-R85C9HV MINGW64 ~/Desktop<br>$ cat ~/.gitconfig<br><span class="hljs-string">[user]</span><br>        name = abc<br>        email = <span class="hljs-symbol">abc@</span><span class="hljs-number">123.</span>com<br><span class="hljs-string">[core]</span><br>        quotepath = <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="1-2-设置仓库级用户签名"><a href="#1-2-设置仓库级用户签名" class="headerlink" title="1.2 设置仓库级用户签名"></a>1.2 设置仓库级用户签名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config user.name abc</span><br><span class="hljs-meta">$</span><span class="bash"> git config user.email abc@163.com</span><br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身份，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>创建成功，用户签名信息会保存在本地工作区 <code>./.git/config</code> 文件中，你可以使用 <code>cat</code> 命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/笔记 (master)<br><span class="hljs-meta">$</span><span class="bash"> cat .git/config</span><br>[core]<br>        repositoryformatversion = 0<br>        filemode = false<br>        bare = false<br>        logallrefupdates = true<br>        symlinks = false<br>        ignorecase = true<br>[remote &quot;origin&quot;]<br>        url = git@github.com:JYGQAQ/Notebook.git<br>        fetch = +refs/heads/*:refs/remotes/origin/*<br>[user]<br>        name = JYGQAQ<br>        email = 604713431@qq.com<br></code></pre></td></tr></table></figure><p>需要注意的是，签名的作用是区分不同的不同的操作者身份，所以一般只用设置系统级的用户签名。如果两个级别同时存在，那么依照就近原则，仓库级别要大于系统级别。如果两个级别都不存在，则无法完成 Git 一些命令，会提示验证身份。</p><h3 id="2-初始化本地库"><a href="#2-初始化本地库" class="headerlink" title="2. 初始化本地库"></a>2. 初始化本地库</h3><p>基本语法：<code>git init</code></p><p>案例实操：</p><ul><li>创建项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir gitLearn<br></code></pre></td></tr></table></figure><ul><li>进入项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd gitLearn/<br></code></pre></td></tr></table></figure><ul><li>初始化本地库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in E:/gitLearn/.git/<br></code></pre></td></tr></table></figure><p>Git自动创建了一个名为. git 非空隐藏文件夹。</p><h3 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3. 查看本地库状态"></a>3. 查看本地库状态</h3><p>基本语法：<code>git status</code></p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master <br><br>No commits yet<br><br>nothing to commit (create/copy files and use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>第一行：目前处于哪个本地分支</p><p>第二行：从来没有<code>commit</code>过，本地库没有版本信息。</p><p>第三行：没有更改需要<code>commit</code></p><ul><li>新建文件后，查看本地库状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        newfile.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/image-20220121000221864.png"></p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标红</strong>），意思是需要<code>git add</code>来提交到暂存区追踪。</p><p>有被<strong>标红</strong>的文件，说明该文件<strong>新创建或者和相对于暂存区有更改</strong>需要被<code>git add</code>提交到暂存区追踪。</p><h3 id="4-添加到暂存区"><a href="#4-添加到暂存区" class="headerlink" title="4.添加到暂存区"></a>4.添加到暂存区</h3><p>基本语法：<code>git add 文件名</code> 或者 <code>git add .</code>代表添加所有有更改的文件到暂存区</p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add newfile.txt<br>或者<br>git add .<br></code></pre></td></tr></table></figure><p>接下来使用<code>git status</code>查看本地库状态</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e666e7de96c9def5042f595dd04805e.png"></p><p>注意上面的提示：</p><p>可以使用<code>git rm --cached newfile.txt</code>来从索引中删除文件。但是本地文件还存在， 只是不希望这个文件被版本控制，意思是从暂存区中删除<code>newfile.txt</code>。</p><p>若使用<code>git rm newfile.txt</code>同时从工作区和索引中删除文件。即本地的文件也被删除了。</p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标绿</strong>），意思是需要<code>git commit</code>来提交到本地库，来进行版本控制。</p><p>有被<strong>标绿</strong>的文件，说明该文件<strong>未被提交到本地库或者本文件相对于本地库有更改</strong>需要被<code>git commit</code>来提交到本地库，来进行版本控制。</p><p> <code> git commit -a -m “massage“</code></p><p>​      其他功能如-m参数，加的-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。建议一般不要使用-a参数，正常的提交还是使用git add先将要改动的文件添加到暂存区，再用git commit 提交到本地版本库。</p><p>  <code>git commit --amend</code></p><p>​      如果我们不小心提交了一版我们不满意的代码，并且给它推送到服务器了，在代码没被merge之前我们希望再修改一版满意的，而如果我们不想在服务器上abondon，那么我们怎么做呢？git commit –amend //也叫追加提交，它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中，使得版本库更加清爽。</p><h3 id="5-提交本地库"><a href="#5-提交本地库" class="headerlink" title="5. 提交本地库"></a>5. 提交本地库</h3><p>基本语法：<code>git commit -m &quot;日志信息&quot; 文件名</code> 或者 <code>git commit -m &quot;message&quot;</code>提交所有暂存区内容到本地库。</p><p>git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫<strong>commit-id</strong>，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里。</p><p>案例实操：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bbc4110ceb47c9dba34e612aef1167f.png"></p><p>查看本地库状态：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/139f25276d55d99e9197b2570a65bff.png"></p><p>发现没有<strong>绿名</strong>和<strong>红名</strong>文件被标注，说明没有文件需要被<strong>commit</strong>和<strong>add</strong>。</p><h4 id="5-1-查看本地库版本信息"><a href="#5-1-查看本地库版本信息" class="headerlink" title="5.1 查看本地库版本信息"></a>5.1 查看本地库版本信息</h4><p>查看本地库版本信息，使用<code>git reflog</code>查看引用日志信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p>说明：开头是的哈希值是<strong>commit-id</strong>，最后是<strong>commit</strong>的message信息。<code>HEAD</code>是指针，指向了<code>master</code>分支。</p><p>查看本地库版本的详细信息，使用<code>git log</code>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p>说明：第一行是<strong>commit-id</strong>的准确值，第二行是提交者的用户签名，第三行是提交时间，第四行是<code>commit</code>的<code>message</code>。</p><h4 id="5-2-Commit-Message-规范"><a href="#5-2-Commit-Message-规范" class="headerlink" title="5.2 Commit Message 规范"></a>5.2 Commit Message 规范</h4><p><code>git commit</code>命令要求编写<code>commit message</code>，不然无法提交，关于<code>commit message</code>的编写，我们往往容易忽略规范，整体来讲，<code>commit message</code>应该清晰简洁，能够提现本次提交目的。</p><p>关于<code>commit message</code>的编写规范，社区有很多种，<code>Angular规范</code>是目前使用最广的写法，本文就简单介绍一下。</p><p><code>commit message</code>的构成包括三部分： <code>Header, Body 和 Footer</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;type&gt;</span> (<span class="hljs-params">&lt;scope&gt;</span>): <span class="hljs-params">&lt;subject&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;body&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;footer&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>其中，<code>Header</code>是必需的，<code>Body</code>和<code>Footer</code>可以省略。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">注意：任何一布行都不得超过 <span class="hljs-number">72</span><span class="hljs-comment">(或100)</span> 个字符，避免自动换行影响美观<br>复制代码<br><br></code></pre></td></tr></table></figure><h5 id="5-2-1Header"><a href="#5-2-1Header" class="headerlink" title="5.2.1Header"></a>5.2.1Header</h5><p><code>Header</code>占一行，包括三个字段：<code>type, scope, subject</code></p><p><strong>(1) type</strong></p><p><code>type</code> 用于说明 <code>commit</code>类别，只允许以下 7 个标识：</p><ul><li>  feat: 新功能 (feature)</li><li>  fix: 修补 bug</li><li>  docs: 文档 (documentation)</li><li>  style: 格式 (比如去除空行)</li><li>  refactor: 重构 (不是新增功能，也不是修补 bug)</li><li>  test: 增加测试</li><li>  chore: 构建过程或辅助工具的变动</li></ul><p><strong>(2) scope</strong></p><p><code>scope</code> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等 (很少用到)</p><p><strong>(3) subject</strong></p><p>描述本次提交的目的，不超过 50 个字符</p><ul><li>  以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li><li>  第一个字母小写</li><li>  结尾不加句号</li></ul><h5 id="5-2-2-Body"><a href="#5-2-2-Body" class="headerlink" title="5.2.2 Body"></a>5.2.2 Body</h5><p><code>Body</code>部分是对本次 <code>commit</code> 的详细描述，可以分为多行描述，要求使用第一人称现在时，说明代码变动原因以及前后行为对比。</p><h5 id="5-2-3-Footer"><a href="#5-2-3-Footer" class="headerlink" title="5.2.3 Footer"></a>5.2.3 Footer</h5><p><code>Footer</code> 只适用于两种情况：</p><ul><li>  (1) 不兼容变动</li></ul><p>当前代码与上一个版本不兼容，则 <code>Footer</code> 部分以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、变动理由和迁移方法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">BREAKING CHANGE:</span> <span class="hljs-string">isolate</span> <span class="hljs-string">scope</span> <span class="hljs-string">bindings</span> <span class="hljs-string">definition</span> <span class="hljs-string">has</span> <span class="hljs-string">changed.</span><br><br>    <span class="hljs-attr">To migrate the code follow the example below:</span><br><br>    <span class="hljs-attr">Before:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;attribute&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-attr">After:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;@&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-string">The</span> <span class="hljs-string">removed</span> <span class="hljs-string">`inject`</span> <span class="hljs-string">wasn&#x27;t</span> <span class="hljs-string">generaly</span> <span class="hljs-string">useful</span> <span class="hljs-string">for</span> <span class="hljs-string">directives</span> <span class="hljs-string">so</span> <span class="hljs-string">there</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-literal">no</span> <span class="hljs-string">code</span> <span class="hljs-string">using</span> <span class="hljs-string">it.</span><br></code></pre></td></tr></table></figure><ul><li>  (2) 关闭 <code>Issue</code></li></ul><p>如果当前 <code>commit</code> 针对某个 <code>issue</code>，那么可以在 <code>Footer</code> 部分关闭这个 <code>issue</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Closes</span> #<span class="hljs-number">123</span>, #<span class="hljs-number">234</span>, #<span class="hljs-number">345</span><br></code></pre></td></tr></table></figure><h3 id="6-修改文件"><a href="#6-修改文件" class="headerlink" title="6. 修改文件"></a>6. 修改文件</h3><p>修改 <code>newfile.txt</code> 内容，<code>git status</code>会提示该文件修改过（会被<strong>标红</strong>，跟暂存区相比有更改），如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bf87fdbd981c5d3e8d12843be4647e.png"></p><p><code>git checkout -- file</code>是指根据暂存区的<code>file</code>文件来覆盖工作区的<code>file</code>文件，也就是放弃更改。</p><p>需要注意的是，Git是以<strong>行</strong>来管理文件的，最小单位是行。</p><h3 id="7-查看版本之间的不同"><a href="#7-查看版本之间的不同" class="headerlink" title="7. 查看版本之间的不同"></a>7. 查看版本之间的不同</h3><h4 id="7-1-比较工作区与暂存区"><a href="#7-1-比较工作区与暂存区" class="headerlink" title="7.1 比较工作区与暂存区"></a>7.1 比较工作区与暂存区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff<br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区</p><h4 id="7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"><a href="#7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）" class="headerlink" title="7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"></a>7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;path&gt;...] <br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区2.7.1比较工作区与暂存区</p><h4 id="7-3-比较工作区与最新本地版本库"><a href="#7-3-比较工作区与最新本地版本库" class="headerlink" title="7.3 比较工作区与最新本地版本库"></a>7.3 比较工作区与最新本地版本库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff HEAD [&lt;path&gt;...] #如果HEAD指向的是master分支，那么HEAD还可以换成master<br></code></pre></td></tr></table></figure><h4 id="7-4-比较工作区域指定commit-id的差异"><a href="#7-4-比较工作区域指定commit-id的差异" class="headerlink" title="7.4 比较工作区域指定commit-id的差异"></a>7.4 比较工作区域指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff commit-id [&lt;path&gt; ...]<br></code></pre></td></tr></table></figure><h4 id="7-5-比较暂存区与指定commit-id的差异"><a href="#7-5-比较暂存区与指定commit-id的差异" class="headerlink" title="7.5 比较暂存区与指定commit-id的差异"></a>7.5 比较暂存区与指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;commit-id&gt;][&lt;path&gt;...]<br></code></pre></td></tr></table></figure><h4 id="7-6-比较两个commit-id之间的差异"><a href="#7-6-比较两个commit-id之间的差异" class="headerlink" title="7.6 比较两个commit-id之间的差异"></a>7.6 比较两个commit-id之间的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;]<br></code></pre></td></tr></table></figure><h3 id="8-版本穿梭"><a href="#8-版本穿梭" class="headerlink" title="8. 版本穿梭"></a>8. 版本穿梭</h3><h4 id="8-1-查看历史版本"><a href="#8-1-查看历史版本" class="headerlink" title="8.1 查看历史版本"></a>8.1 查看历史版本</h4><p>基本语法：</p><ul><li>  <code>git reflog</code> 查看版本信息</li><li>  <code>git log</code> 查看版本详细信息         加上<code>--graph</code>有图形表示。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p><strong>git log 与 git reflog 区别</strong></p><p><code>git log</code> 命令可以显示所有提交过的版本信息，如果感觉太繁琐，可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p><p><code>git reflog</code> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行 <code>git reset --hard HEAD~1</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的 commitid，用<code>git reflog</code>则可以看到被删除的 commitid，我们就可以买后悔药，恢复到被删除的那个版本。<a href="https://blog.csdn.net/u013252047/article/details/80230781">link</a></p><h4 id="8-2-版本穿梭"><a href="#8-2-版本穿梭" class="headerlink" title="8.2 版本穿梭"></a>8.2 版本穿梭</h4><p>基本语法：</p><p><code>git reset --hard 版本号</code>，**–hard** 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。</p><p><code>git reset HEAD</code> 、<code>git reset</code> 、<code>git reset --soft HEAD</code>或者<code>git reset --mixed</code><strong>–mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><p><strong>需要注意的是，上面两种用法，都可以填<code>版本号</code>和<code>HEAD ... HEAD^^</code>，唯一不同的是，–hard重写工作区和暂存区，其他只重写暂存区。</strong></p><p><strong>Git 切换版本， 底层其实是移动的 HEAD 指针，不会产生新的版本。</strong></p><h2 id="三、Git分支用法"><a href="#三、Git分支用法" class="headerlink" title="三、Git分支用法"></a>三、Git分支用法</h2><h3 id="1-分支概述和优点"><a href="#1-分支概述和优点" class="headerlink" title="1. 分支概述和优点"></a>1. 分支概述和优点</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bcad650a512a72097b3391e00ecb8bbe.png"></p><h4 id="1-1-什么是分支"><a href="#1-1-什么是分支" class="headerlink" title="1.1 什么是分支"></a>1.1 什么是分支</h4><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来， 开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f1d0659ed000e9dfa295fc696a58cf74.png"></p><h4 id="1-2分支的好处"><a href="#1-2分支的好处" class="headerlink" title="1.2分支的好处"></a>1.2分支的好处</h4><p>同时<strong>并行</strong>推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="2-分支基本操作"><a href="#2-分支基本操作" class="headerlink" title="2. 分支基本操作"></a>2. 分支基本操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h4 id="2-1-查看分支"><a href="#2-1-查看分支" class="headerlink" title="2.1 查看分支"></a>2.1 查看分支</h4><p>基本语法：<code>git branch -v</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fab3df037a60224caf0f127e53de4b1.png"></p><p><code>*</code>代表当前所在的分支</p><h4 id="2-2-创建分支"><a href="#2-2-创建分支" class="headerlink" title="2.2 创建分支"></a>2.2 创建分支</h4><p>基本语法：<code>git branch 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/47e47992b7ff1da878bbbfe9b87559c.png"></p><p><strong>刚创建的新的分支，并将主分支 master 的内容复制了一份</strong>。</p><h4 id="2-3-切换分支"><a href="#2-3-切换分支" class="headerlink" title="2.3 切换分支"></a>2.3 切换分支</h4><p>基本语法：<code>git checkout 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f6a55ec01908aa4b7a06b59b51bc26f.png"></p><h3 id="3-合并分支-正常合并"><a href="#3-合并分支-正常合并" class="headerlink" title="3. 合并分支 (正常合并)"></a>3. 合并分支 (正常合并)</h3><p>基本语法：<code>git merge 分支名</code></p><p>将<code>分支名</code>合并到当前分支。</p><p>在 master 分支上合并 hot-fix 分支（将 hot-fix 的合并到 master）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1e50945d4aa000d22dfca989fc7b0d2.png"></p><h3 id="4-合并分支-冲突合并"><a href="#4-合并分支-冲突合并" class="headerlink" title="4. 合并分支 (冲突合并)"></a>4. 合并分支 (冲突合并)</h3><h4 id="4-1-冲突产生的原因"><a href="#4-1-冲突产生的原因" class="headerlink" title="4.1 冲突产生的原因"></a>4.1 冲突产生的原因</h4><p>并分支时，<strong>多个分支修改了同一个文件(任何地方)或者多个分支修改了同一个文件的名称</strong>（从该文件第一行开始，最先开始不同的行到最后不同的行会括起来）。 Git 无法替我们决定使用哪一个，因此，必须<strong>人为决定</strong>新代码内容。</p><p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可。</p><h4 id="4-2-产生冲突"><a href="#4-2-产生冲突" class="headerlink" title="4.2 产生冲突"></a>4.2 产生冲突</h4><p>修改两个分支，中同一文件同一行，合并两个分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eda203702114339268b657212811c5f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/61073b71dfe7abee793f6b335747116.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9218cbf54fd3120e70da480441c654.png"></p><h4 id="4-3-解决冲突"><a href="#4-3-解决冲突" class="headerlink" title="4.3 解决冲突"></a>4.3 解决冲突</h4><p>编辑有冲突的文件，<strong>删除特殊符号</strong>，决定要使用的内容。随后<code>git add .</code> &amp; <code>git commit -m &quot;message&quot;</code>正式合并分支。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/73ccf068132905eee5e42c7ab2e0514.png"></p><h4 id="4-4-创建分支和切换分支"><a href="#4-4-创建分支和切换分支" class="headerlink" title="4.4 创建分支和切换分支"></a>4.4 创建分支和切换分支</h4><p>master、 hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。</p><ul><li>  HEAD 如果指向 master，那么我们现在就在 master 分支上。</li><li>  HEAD 如果执行 hot-fix，那么我们现在就在 hot-fix 分支上。</li></ul><p>所以切换分支的本质就是移动 HEAD 指针。</p><h3 id="5-远程分支"><a href="#5-远程分支" class="headerlink" title="5. 远程分支"></a>5. 远程分支</h3><h4 id="5-1-创建远程分支"><a href="#5-1-创建远程分支" class="headerlink" title="5.1 创建远程分支"></a>5.1 创建远程分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支<br>git push origin my-test:my-test  //将my-test分支推送到远程<br>或<br>git push origin my-test //本地分支和远程分支重名<br></code></pre></td></tr></table></figure><p><code>git push origin my-test:my-test</code>其中第一个<code>my-test</code>是本地分支名，第二个<code>my-test</code>是远程分支名</p><h4 id="5-2-建立本地分支与远程分支的联系"><a href="#5-2-建立本地分支与远程分支的联系" class="headerlink" title="5.2 建立本地分支与远程分支的联系"></a>5.2 建立本地分支与远程分支的联系</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch --set-upstream-to=origin/develop develop<br></code></pre></td></tr></table></figure><p>其中，<code>origin</code>是远程仓库的别名，第一个<code>develop</code>是远程分支名，第二个是<code>debelop</code>本地分支名</p><h4 id="5-3-查看所有分支"><a href="#5-3-查看所有分支" class="headerlink" title="5.3 查看所有分支"></a>5.3 查看所有分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -vv<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/98446cf13d8282318d8127c5e566a82.png"></p><blockquote><p>黄色框是本地分支名，绿色框是远程分支名。需要注意的是有些本地分支没有关联远程分支。</p></blockquote><h2 id="四、使用Github"><a href="#四、使用Github" class="headerlink" title="四、使用Github"></a>四、使用Github</h2><p>团队内协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c397bde00d728c4e41eca79f578d25c3.png"></p><p>跨团队协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p><a href="https://github.com/">GitHub 网址</a></p><h3 id="1-创建远程库"><a href="#1-创建远程库" class="headerlink" title="1. 创建远程库"></a>1. 创建远程库</h3><p>登陆后，点击在网页右上角的 “+” –&gt; “New repository”，创建远程库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3dfd6ad9419bfcef2635e08a5c02e86c.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3ddd9d9b5ec3b0ab8c238ef66a183d1.png"></p><h4 id="1-1-远程仓库操作"><a href="#1-1-远程仓库操作" class="headerlink" title="1.1 远程仓库操作"></a>1.1 远程仓库操作</h4><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td></tr></tbody></table><h3 id="2-关联远程库"><a href="#2-关联远程库" class="headerlink" title="2. 关联远程库"></a>2. 关联远程库</h3><p><strong>基本语法</strong>：</p><ul><li>  <code>git remote -v</code> 查看当前所有远程地址别名</li><li>  <code>git remote add 别名 远程地址</code></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/682725a20f0d99a4467e2a6cda04ad2.png"></p><p>这个地址在创建完远程仓库后生成的连接 ，如图所示</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/94534c6c6ba1d748bbfcc87338e38d7.png"></p><h3 id="3-推送本地库到远程库"><a href="#3-推送本地库到远程库" class="headerlink" title="3. 推送本地库到远程库"></a>3. 推送本地库到远程库</h3><p>基本语法：<code>git push 别名 分支</code>  将该分支推送上去</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7bec3b7357867896ea8f87838591b41.png"></p><h4 id="3-1-git-push详解"><a href="#3-1-git-push详解" class="headerlink" title="3.1 git push详解"></a>3.1 git push详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p>如果当前本地分支关联过远程分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br></code></pre></td></tr></table></figure><h3 id="4-拉取远程库到本地库"><a href="#4-拉取远程库到本地库" class="headerlink" title="4. 拉取远程库到本地库"></a>4. 拉取远程库到本地库</h3><p>需要注意的是，当远程库与本地库不相同时，需要先拉取远程库（如果直接push，会出错）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5eca728584bde973a8c9c109f26314c.png"></p><h4 id="4-1-git-pull详解"><a href="#4-1-git-pull详解" class="headerlink" title="4.1 git pull详解"></a>4.1 git pull详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f4b96f8b373b6e9ff02775e89050c9f.png"></p><p>主要注意的是，<code>git pull</code>之后查看本地库状态，发现本地库是干净的，说明<code>git pull</code>会自动<code>git add .</code>和<code>git commit</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/110ae677e2075dabba3ba280b680768.png"></p><h4 id="4-2-日常提交代码到远程库的流程"><a href="#4-2-日常提交代码到远程库的流程" class="headerlink" title="4.2 日常提交代码到远程库的流程"></a>4.2 日常提交代码到远程库的流程</h4><p>日常提交代码到远程库的流程如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add -A           #需要添加到版本库中的文件 -A 就代表着所有文件(除开了 .gitignore忽略掉的文件)<br>git commit -m &#x27;本次提交的备注&#x27;<br>git pull            #将远程的库和本地的库版本同步一下,因为远程库可能发生了修改(多人合作开发时)<br>git push  <br></code></pre></td></tr></table></figure><p>这样操作的前提是本地远程都是同一个分支上</p><h4 id="4-3-为什么在git-push前需要先git-pull呢？"><a href="#4-3-为什么在git-push前需要先git-pull呢？" class="headerlink" title="4.3 为什么在git push前需要先git pull呢？"></a>4.3 为什么在git push前需要先git pull呢？</h4><ol><li>本地和远程的关系相当于两个分支,你感觉一样是因为你<code>git pull</code> 的时候已经自动给绑定好对应关系了, set-upstream..balbala</li><li>你远程新建了一个分支拉到本地的道理是一样的,属于复制了一份,但是本地分支和远程分支已经是两个东西了</li><li>本地分支属于本地仓库里,是包含关系,一个仓库里可以有很多分支, 如果是 tag 的话可以分离出独立的仓库</li><li>肯定不会全量推送到远程的,是通过对比 commit 的记录,如果本地高于远程就直接把多出来的<code>commit</code> 给怼上去,如果本地的这几个 <code>commit</code> 和远程的 <code>commit</code> 有冲突的部分就<code>merge</code>,然后根据提交时间排序再新建一个merge 的 commit 记录再怼上去</li><li>这个先 commit 再 pull 再 push 的情况就是为了应对多人合并开发的情况,<ol><li><code>commit</code> 是为了告诉 git 我这次提交改了哪些东西,不然你只是改了但是 git 不知道你改了,也就无从判断比较;</li><li><code>pull</code>是为了本地 commit 和远程commit 的对比记录,git 是按照文件的行数操作进行对比的,如果同时操作了某文件的同一行那么就会产生冲突,git 也会把这个冲突给标记出来,这个时候就需要先把和你冲突的那个人拉过来问问保留谁的代码,然后在 <code>git add &amp;&amp; git commit &amp;&amp; git pull</code> 这三连,再次 pull 一次是为了防止再你们协商的时候另一个人给又提交了一版东西,如果真发生了那流程重复一遍,通常没有冲突的时候就直接给你合并了,不会把你的代码给覆盖掉</li><li>出现代码覆盖或者丢失的情况:比如A B两人的代码pull 时候的版本都是1,A在本地提交了2,3并且推送到远程了,B 进行修改的时候没有<code>commit</code> 操作,他先自己写了东西,然后 <code>git pull</code> 这个时候 B 本地版本已经到3了,B 在本地版本3的时候改了 A 写过的代码,再进行了<code>git commit &amp;&amp; git push</code> 那么在远程版本中就是4,而且 A 的代码被覆盖了,所以说所有人都要先 commit 再 pull,不然真的会覆盖代码的<strong>经过本人亲自实验，这种情况不会发生代码覆盖问题</strong></li></ol></li><li>两个互相合并的唯一区别就是 A-&gt;B 的时候 B 分支上会产生一个 merge_commit 的信息,这个时候 B 是合并状态而 A 未合并状态,如果现在<strong>没有发生任何改动</strong>执行 B-&gt;A 就直接切换过去了,连 merge_commit 都不会生成了</li></ol><p><strong>这合并的时候发生了什么?</strong></p><p>比如你从一个git log为<code>1,2,3,4,5,6</code>的远程库拉取到了本地, 另一个同事也拉取了同样的代码,而且你的同事先于你提交到远程了, 此时<strong>远程</strong>的版本是<code>1,2,3,4,5,6,7_new,8_new</code>, 而你当前只是<strong>本地</strong>的版本<code>1,2,3,4,5,6,7_local,8_local,9_local</code> 从这里你就能看出你前一部分和<strong>远程</strong>的一样,后一部分和<strong>远程</strong>的不一样, 这个时候你不能正常推送上去的,如果你采取<code>git push origin master --force</code> 那么<strong>远程</strong>的版本就变成了<code>1,2,3,4,5,6,7_local,8_local,9_local</code> 之前你同事推送的<code>7_new,8_new</code>这两次推送被覆盖了,这不是大家想要的情况 因此需要<code>git pull</code>来将<strong>本地</strong>的版本合并成样 <code>1,2,3,4,5,6,7_new,7_local,8_local,8_new,9_local,10_commit_merge</code> 远程和<strong>本地</strong>的排序是按当时 <code>commit</code> 的时间来排的,最后一个<code>10_commit_merge</code>就是你<strong>本地</strong>和<strong>远程</strong>合并的标志,最后你推送到远程仓库的应该也是这个, 因为你们操作的是同一个库始终要保持代码的同步,所以一旦版本库发生改动同一分支下的所有人都要跟着去同步他,因为各开发各的直接往上推 git 还没智能到帮你处理冲突的地步 </p><h3 id="5-克隆远程库到本地"><a href="#5-克隆远程库到本地" class="headerlink" title="5. 克隆远程库到本地"></a>5. 克隆远程库到本地</h3><p>基本语法：<code>git clone 远程地址</code>在远程库获取地址 URL</p><p>需要注意的是：远程地址如果是https格式的，任何人都可以克隆。远程地址如果是ssh形式的，只有项目的参与者才可以克隆。在git中clone项目有两种方式：HTTPS和SSH，它们的区别如下： HTTPS：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码； SSH：clone的项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bed545d3938cde21c57c8f86ffcfffd.png"></p><p>克隆完成后，查看远程仓库别名，和分支对应情况：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d75f5d9b4a0889a1f2aca32b259d3c3.png"></p><p>clone 会做如下操作：</p><ol><li> 拉取代码。</li><li> 初始化本地仓库。</li><li> 创建别名。</li><li> 创建对应分支</li></ol><h3 id="6-团队内协作"><a href="#6-团队内协作" class="headerlink" title="6. 团队内协作"></a>6. 团队内协作</h3><p>一、选择邀请合作者。（在仓库设置里操作）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/945f1ba6e29fb725ee0d852ff59c3851.png"></p><p>二、填入目标合作者。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ee1b6a6656efe2adbb740b38954529b9.png"></p><p>三、复制网址发送给你目标合作者 ， 复制内容如下：<a href="https://github.com/atguiguyueyue/git-shTest/invitations%E3%80%82">https://github.com/atguiguyueyue/git-shTest/invitations。</a></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0f5ec0155e64421d315594aa537fd187.png"></p><p>四、目标合作者接收到网址，用浏览器打开它，点击接受邀请。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/295a2398e0a3150d50530d5db21103aa.png"></p><p>五、接受邀请成功之后，可以在目标合作者 Github 账号上看到将来共同开发远程仓库。</p><p>六、目标合作者可以修改内容并 push 到远程仓库。</p><p>七、回到发送合作邀请者的 GitHub 远程仓库中可以看到，最后一次是目标合作者提交的。</p><h3 id="7-跨团队协作"><a href="#7-跨团队协作" class="headerlink" title="7. 跨团队协作"></a>7. 跨团队协作</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p>一、将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。</p><p>二、在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 网页右上方的 Fork 按钮，将项目叉到自己的本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4856e4845a7f0dbb54c79bd804892f5e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c641d9ba65f20ba58d3f98ec792ae0e5.png"></p><p>fork成功后可以看到当前仓库信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3078d75badb2fd393dbe172327dc094c.png"></p><p>三、东方不败就可以在线编辑fork过来的文件。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/40aa522895eb04a6c203a9bcbca25005.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb19249416069d158e2b4280a679063f.png"></p><p>四、编辑完毕后，填写描述信息并点击左下角绿色按钮提交。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c87379a8a91eb65e2961475129362da4.png"></p><p>五、接下来点击上方的 Pull 请求，并创建一个新的请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bdb52dc24df07d8d846a4fe19985908.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c2f07c7ba5586e3923ba870a37c856d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/996007e8e9fee91ef37af6818e164139.png"></p><p>六、回到岳岳 GitHub 账号可以看到有一个 Pull request 请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c634b139396001cb2fcb64b8e2a078e1.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d666e1f3544c07821e85b602d0beffc5.png"></p><p>进入到聊天室，可以讨论代码相关内容。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3d97452ea50fffca42ec29308c842692.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c477d95ea98448b966264bdae235b64.png"></p><p>七、如果代码没有问题，可以点击 Merge pull reque 合并代码。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/894bdb75678d7793e92f1099e5c1d080.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2964db9c2239859ee59c4bfb9fb25513.png"></p><h3 id="8-SSH-免密登录"><a href="#8-SSH-免密登录" class="headerlink" title="8. SSH 免密登录"></a>8. SSH 免密登录</h3><p><strong>ssh配置只是省去了输入github账号密码的这一步操作，所以跟github仓库关系不大，跟github账号关系大</strong></p><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/197d6964ccfb06f1eaf22f795061826d.png"></p><p>先到用户的主页目录，运行命令 ssh-keygen 生成. ssh 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;604713431@qq.com&quot;<br></code></pre></td></tr></table></figure><p><code>-t rsa</code>是使用非对称加密协议<code>rsa</code>，<code>-C &quot;****&quot;</code>是注释。</p><p>在家目录下生成了<code>id_rsa</code>是私钥，放在本地；<code>id_rsa.pub</code>是公钥，放在服务器。</p><p>然后，将生成的公钥添加至 Github 账号 SSH 设置</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2d213036d44d57f07ad75b23d20871ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0a6a75ce73adad73a535947dce7fa525.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0c2f4dd9ef30bdc8c47ae59e50b8851b.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f54c4dccd3d8a17e909042c28181fb6.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0ad893fd8447ac90ed0ee7ceafdf582e.png"></p><p>添加公钥后，使用ssh方法可不用输入 Github 账号密码便可<code>push</code>或者<code>pull</code>。</p><h2 id="五、IDEA集成Git"><a href="#五、IDEA集成Git" class="headerlink" title="五、IDEA集成Git"></a>五、IDEA集成Git</h2><p>在IDEA中，红色表示文件新创建并未被<code>add</code>提交到暂存区，绿色代表文件未被<code>commit</code>提交到本地版本库，蓝色代表文件被修改了，需要重新<code>add &amp; commit</code>(此处也可以直接<code>commit</code>)（但是之前被<code>add &amp; commit</code>过）。</p><p><code>git log</code>中绿色标签代表分支，黄色标签代表<code>HEAD</code>头指针。</p><h3 id="1-配置-Git-忽略文件"><a href="#1-配置-Git-忽略文件" class="headerlink" title="1. 配置 Git 忽略文件"></a>1. 配置 Git 忽略文件</h3><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。例如，Maven 工程根据 src 生成的 target。</p><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore），这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，<strong>建议</strong>也放在用户家目录下。</p><p>git.ignore 文件模版内容如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># Compiled class file</span><br>*<span class="hljs-string">.class</span><br><br><span class="hljs-comment"># Log file</span><br>*<span class="hljs-string">.log</span><br><br><span class="hljs-comment"># BlueJ files</span><br>*<span class="hljs-string">.ctxt</span><br><br><span class="hljs-comment"># Mobile Tools for Java (J2ME)</span><br><span class="hljs-string">.mtj.tmp/</span><br><br><span class="hljs-comment"># Package Files #</span><br>*<span class="hljs-string">.jar</span><br>*<span class="hljs-string">.war</span><br>*<span class="hljs-string">.nar</span><br>*<span class="hljs-string">.ear</span><br>*<span class="hljs-string">.zip</span><br>*<span class="hljs-string">.tar.gz</span><br>*<span class="hljs-string">.rar</span><br><br><span class="hljs-comment"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br>hs_err_pid*<br><span class="hljs-string">.classpath</span><br><span class="hljs-string">.project</span><br><span class="hljs-string">.settings</span><br>target<br><span class="hljs-string">.idea</span><br>*<span class="hljs-string">.iml</span><br><br></code></pre></td></tr></table></figure><p>在. gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[user]</span><br>    <span class="hljs-attr">name</span> = Layne<br>    <span class="hljs-attr">email</span> = Layne@atguigu.com<br><span class="hljs-section">[core]</span><br><span class="hljs-attr">excludesfile</span> = C:/Users/asus/git.ignore<br><br></code></pre></td></tr></table></figure><p>注意：这里要使用 “正斜线（/）”，不要使用 “反斜线（\）”</p><h3 id="2-在-IDEA-配置-Git-程序"><a href="#2-在-IDEA-配置-Git-程序" class="headerlink" title="2. 在 IDEA 配置 Git 程序"></a>2. 在 IDEA 配置 Git 程序</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 Git，配置 Git 的安装路径。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d86ae18c01b9a08bc73f02aa6c1b3708.png"></p><h3 id="3-IDEA初始化-Git"><a href="#3-IDEA初始化-Git" class="headerlink" title="3. IDEA初始化 Git"></a>3. IDEA初始化 Git</h3><p>先创建一个名叫 HelloGit 的 Maven 工程。</p><p>在菜单栏 VCS -&gt; Import into Version Control -&gt; Create Git Repository</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4bbfb1e76fb25655b3fe6900bb29ea47.png"></p><p>选择要创建 Git 本地仓库的工程，也就是 HelloGit 工程，然后添加 OK。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5dc609978787f3e5a83dbdf954a3e039.png"></p><h3 id="4-添加到暂存区-1"><a href="#4-添加到暂存区-1" class="headerlink" title="4. 添加到暂存区"></a>4. 添加到暂存区</h3><p>创建一个 HelloGit 类，将其添加 Git 暂存区。</p><p>右键点击 HelloGit 类，选择 Git-&gt;Add。可以右键点击 HelloGit项目根目录，更大范围地添加文件到暂存区。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9ec5087e543611c5ac99b171277f590.png"></p><p>添加成功后，文件名会从红色变成绿色。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ec95c2b0b99d1f3a0ac8ad3291fdde50.png"></p><h3 id="5-提交至本地库"><a href="#5-提交至本地库" class="headerlink" title="5. 提交至本地库"></a>5. 提交至本地库</h3><p>右键点击 HelloGit，选择 Git-&gt;Commit Directory。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a73d7bbac024bfe61951662f5bf6ded.png"></p><p>添加注释后提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/281c7f26319b59e7584103c2a3ee88dd.png"></p><p>添加成功后，后台打印相关信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3bdf7a9135d3ae80b9aad4d678626491.png"></p><h3 id="6-切换版本"><a href="#6-切换版本" class="headerlink" title="6. 切换版本"></a>6. 切换版本</h3><p>在 IDEA 的左下角，点击 Git，然后点击 Log 查看版本</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/69e6670ea5681781c173f1c86864ae1e.png"></p><p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5530ac3d829954cebd23ed15a681769f.png"></p><h3 id="7-创建分支"><a href="#7-创建分支" class="headerlink" title="7. 创建分支"></a>7. 创建分支</h3><p>右键点击 HelloGit，Git -&gt; Repository -&gt; Branches，或者点击 IDEA 的右下角，如图红圈所示部位：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3e31e84cd2f7b5b95bb2639abcb1804f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c7544c1bade118b3177907ad903a8082.png"></p><p>选择点击 New Branch：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9c18ec9924788adfa432b7b924308ce.png"></p><p>创建新分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8a4a5e7cf7511d086ddac0be704e850f.png"></p><h3 id="8-切换分支"><a href="#8-切换分支" class="headerlink" title="8. 切换分支"></a>8. 切换分支</h3><p>跟<strong>创建分支</strong>步骤相似，如点击 IDEA 的右下角（它显示项目正处在那条分支），如图红圈所示部位，选择你想要切换的分支，然后 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/6678ecf9283ace1783e83e184847a29.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/afbbe9a835629f522d0b02024fe2c11b.png"></p><p>或者在 log 窗口，右键点击分支，选择 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7ab6ab48e9b5a42009757b8b17b901f0.png"></p><h3 id="9-合并分支-正常合并"><a href="#9-合并分支-正常合并" class="headerlink" title="9. 合并分支 (正常合并)"></a>9. 合并分支 (正常合并)</h3><p>先在 hot-fix 分支修改 HelloGit 类，并将其提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/41667203b7e067b59d1310cce4d92b15.png"></p><p>然后切换到 master 分支，右下角的 hot-fix 会变为 master：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f183b86164b0e00e9d6e8c8c9a4a17da.png"></p><p>然后，点击 IDEA 窗口的右下角的 master，将 hot-fix 分支合并到当前 master 分支。选择 hot-fix-&gt;Merge into Current</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fff1d4e014223aa2cc70f0fdc237f350.png"></p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/271421c28750e86e69accd6ac687490c.png"></p><h3 id="10-合并分支-冲突合并"><a href="#10-合并分支-冲突合并" class="headerlink" title="10. 合并分支 (冲突合并)"></a>10. 合并分支 (冲突合并)</h3><p>分别在 master，hot-fix 分支修改 HelloGit 类同一行，并提交，故意制作冲突：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/53daad680bc796069dc1ce61682d4abc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f8fcf275169cdec742d31ce85ce20d7f.png"></p><p>切换到 master 分支，将 hot-fix 的合并到 master 分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1573ef3ec85b85c4215189d74065012.png"></p><p>冲突产生，需要人工解决：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb3804e00dccfa2658aa33c972d8996e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/511c531d359729b40f0850a4c9e0398.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eafebea94008b4f1f0ae15f8b2092919.png"></p><p>代码冲突解决，将代码提交本地库后，如图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/15a9058f7f35112b8605cd69aaf42e35.png"></p><h2 id="六、IDEA集成GitHub"><a href="#六、IDEA集成GitHub" class="headerlink" title="六、IDEA集成GitHub"></a>六、IDEA集成GitHub</h2><h3 id="1-设置-GitHub-账号"><a href="#1-设置-GitHub-账号" class="headerlink" title="1. 设置 GitHub 账号"></a>1. 设置 GitHub 账号</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 GitHub，添加 GitHub 账号：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/00572764f1ed257dbc2d0f668434e6a0.png"></p><p>由于网络问题，会时常登陆不了：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3084475acd640b1adf621688462a1504.png"></p><p>解决方法：可通过 Token 登陆。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/75ed9ef7614c18c244456c4089dfde6.png"></p><p>登陆 Github 网站，<strong>获取 Token</strong>，操作步骤看下图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1d162ac7e37a01549448032011f2a62.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9b2489e068b004bee03a227760248edb.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/200c556f6f0b6d44c442b58d6e8bb7ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/81a82fb47421c0a802cd1cfad7297e43.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f596f2f68d50d277eefe1a4e6035d2d.png"></p><p>将生成的 token 用来 IDEA 登录。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/704eafd9157658a0be35b081c3530ced.png"></p><h3 id="2-分享项目到-GitHub"><a href="#2-分享项目到-GitHub" class="headerlink" title="2. 分享项目到 GitHub"></a>2. 分享项目到 GitHub</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e057d2e660c2033ef9eae0c638aee2bc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a5ba3e09a890113b94420c3939dac239.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/44b2419dd2eebc2c053fb642188e8909.png"></p><h3 id="3-推送代码到GitHub远程库"><a href="#3-推送代码到GitHub远程库" class="headerlink" title="3. 推送代码到GitHub远程库"></a>3. 推送代码到GitHub远程库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/84baeaa175c6faa3ff538e0313187eff.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1ee51e1ed781404a93655f1ad10bd9ca.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bb9689e1fc2e1167e68ef39f73f28af7.png"></p><p>注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ <strong>因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！</strong></p><h3 id="4-拉取GitHub远程库代码合并本地库"><a href="#4-拉取GitHub远程库代码合并本地库" class="headerlink" title="4. 拉取GitHub远程库代码合并本地库"></a>4. 拉取GitHub远程库代码合并本地库</h3><p>右键点击项目，可以将远程仓库的内容 pull 到本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/193d00830bc1636e2ae2640b749b9899.png"></p><p>注意： pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p><h3 id="5-克隆代码到本地"><a href="#5-克隆代码到本地" class="headerlink" title="5. 克隆代码到本地"></a>5. 克隆代码到本地</h3><p>在菜单栏的 File-&gt;Close Project-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f436b8f9156e5e5ce8c0e2b3b5fe3639.png"></p><p>或者在菜单栏 VCS-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/63f9691dd0a7627bd44a125942be7f31.png"></p><h2 id="七、Gitee使用"><a href="#七、Gitee使用" class="headerlink" title="七、Gitee使用"></a>七、Gitee使用</h2><h3 id="1-Gitee简介-amp-创建远程库"><a href="#1-Gitee简介-amp-创建远程库" class="headerlink" title="1. Gitee简介 &amp; 创建远程库"></a>1. Gitee简介 &amp; 创建远程库</h3><h4 id="1-1-码云简介"><a href="#1-1-码云简介" class="headerlink" title="1.1 码云简介"></a>1.1 码云简介</h4><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况， 大家也可以使用国内的项目托管网站 - 码云。</p><p>码云是开源中国推出的基于 Git 的代码托管服务中心， 网址是 <a href="https://gitee.com/">https://gitee.com/</a> ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好，它是最好的选择。</p><p>而且，Gitee的操作和GitHub基本一样。</p><h4 id="1-2-创建远程库"><a href="#1-2-创建远程库" class="headerlink" title="1.2 创建远程库"></a>1.2 创建远程库</h4><p>跟 Github 的类似。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c8c01b7813e8578423ee2d790a580ee4.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/16341a72fa521e904f7b5a5489d4c693.png"></p><p>另外，可以从 GitHub 与 GitLab 中导入仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c5daf945afdd2f2836c1e9e20e8e389b.png"></p><p>点击刷新按钮，从GitHub获取更新</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3441eab01ee412c90cb4f2be908833f.png" alt="3441eab01ee412c90cb4f2be908833f"></p><h3 id="2-IDEA-集成-Gitee-码云"><a href="#2-IDEA-集成-Gitee-码云" class="headerlink" title="2. IDEA 集成 Gitee 码云"></a>2. IDEA 集成 Gitee 码云</h3><p>首先，要在 IDEA 安装 Gitee 插件。</p><p>在菜单栏选 File-&gt;Settings-&gt;Plugins，搜 Gitee。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0241b8536ebed6fb08dcf04804c62cb0.png"></p><p>安装插件成功后，重启 IDEA。</p><p>功能跟在 IDEA 的 Github 插件，功能类似，如添加 Gitee 账号等，可参考前文 IDEA 的 Github 插件，触类旁通。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/87e35b8ee0fd1fd4136f2b2727cbf02a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/89e7174170b4ecc1c4ba896e3f1c9ad9.png"></p><h2 id="八、GitLab"><a href="#八、GitLab" class="headerlink" title="八、GitLab"></a>八、GitLab</h2><h3 id="1-GitLab简介-amp-安装环境准备"><a href="#1-GitLab简介-amp-安装环境准备" class="headerlink" title="1. GitLab简介 &amp; 安装环境准备"></a>1. GitLab简介 &amp; 安装环境准备</h3><h4 id="1-1-GitLab-简介"><a href="#1-1-GitLab-简介" class="headerlink" title="1.1 GitLab 简介"></a>1.1 GitLab 简介</h4><p>GitLab 是由 GitLab Inc. 开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有 wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。（可搭建局域网 Git 仓库）。</p><p>GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM， Sony， JülichResearchCenter， NASA， Alibaba，Invincea， O’ReillyMedia， Leibniz-Rechenzentrum(LRZ)， CERN， SpaceX 等组织使用。</p><h4 id="1-2-GitLab-官网地址"><a href="#1-2-GitLab-官网地址" class="headerlink" title="1.2 GitLab 官网地址"></a>1.2 GitLab 官网地址</h4><p><a href="https://about.gitlab.com/">官网地址</a></p><p><a href="https://about.gitlab.com/installation/">安装说明</a></p><h4 id="1-3-GitLab-安装准备"><a href="#1-3-GitLab-安装准备" class="headerlink" title="1.3 GitLab 安装准备"></a>1.3 GitLab 安装准备</h4><ol><li> 准备一个系统为 CentOS7 以上版本的服务器， 要求内存 4G，磁盘 50G。</li><li> 关闭防火墙， 并且配置好主机名和 IP，保证服务器可以上网。</li><li> 此教程使用虚拟机：主机名： gitlab-server <code>修改/etc/hostname文件为gitlab-server</code>IP 地址： 192.168.6.200(修改相对应文件)</li><li> Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。<a href="https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm">下载地址</a>。注：资料里提供了此 rpm 包，直接将此包上传到服务器 / opt/module 目录下即可。</li></ol><h3 id="2-GitLab-安装-amp-初始化服务-amp-启动服务"><a href="#2-GitLab-安装-amp-初始化服务-amp-启动服务" class="headerlink" title="2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务"></a>2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务</h3><h4 id="2-1-编写安装脚本"><a href="#2-1-编写安装脚本" class="headerlink" title="2.1 编写安装脚本"></a>2.1 编写安装脚本</h4><p>安装 gitlab 步骤比较繁琐，因此我们可以参考<a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh">官网编写 gitlab 的安装脚本</a>。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@gitlab-server module]# <span class="hljs-keyword">vim</span> gitlab-install.<span class="hljs-keyword">sh</span><br>sudo rpm -ivh /<span class="hljs-keyword">opt</span>/module/gitlab-<span class="hljs-keyword">ce</span>-<span class="hljs-number">13.10</span>.<span class="hljs-number">2</span>-<span class="hljs-keyword">ce</span>.<span class="hljs-number">0</span>.el7.x86_64.rpm<br><br>sudo yum install -<span class="hljs-keyword">y</span> curl policycoreutils-<span class="hljs-keyword">python</span> openssh-server cronie<br><br>sudo lokkit -s http -s ssh<br><br>sudo yum install -<span class="hljs-keyword">y</span> postfix<br><br>sudo service postfix start<br><br>sudo chkconfig postfix <span class="hljs-keyword">on</span><br><br>curl http<span class="hljs-variable">s:</span>//packages.gitlab.<span class="hljs-keyword">com</span>/install/repositories/gitlab/gitlabce/script.rpm.<span class="hljs-keyword">sh</span> | sudo bash<br><br>sudo EXTERNAL_URL=<span class="hljs-string">&quot;http://gitlab.example.com&quot;</span> yum -<span class="hljs-keyword">y</span> install gitlabce<br><br></code></pre></td></tr></table></figure><p>给脚本增加执行权限</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@gitlab-server module]<span class="hljs-comment"># chmod +x gitlab-install.sh</span><br>[root@gitlab-server module]<span class="hljs-comment"># ll</span><br>总用量 403104<br>-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 412774002 </span>4 月<span class="hljs-number"> 7 </span>15:47 gitlab-ce-13.10.2-<br>ce.0.el7.x86_64.rpm<br>-rwxr-xr-x.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 416 </span>4 月<span class="hljs-number"> 7 </span>15:49 gitlab-install.sh<br><br></code></pre></td></tr></table></figure><p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@gitlab-server <span class="hljs-keyword">module</span>]# ./gitlab-install.sh<br>警告： /opt/<span class="hljs-keyword">module</span>/gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7.x86_64.rpm: 头 V4<br>RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY<br>准备中... #################################<br>[<span class="hljs-number">100</span>%]<br>正在升级/安装...<br><span class="hljs-number">1</span>:gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7<br>################################# [<span class="hljs-number">100</span>%]<br>。 。 。 。 。 。<br><br></code></pre></td></tr></table></figure><h4 id="2-2-初始化-GitLab-服务"><a href="#2-2-初始化-GitLab-服务" class="headerlink" title="2.2 初始化 GitLab 服务"></a>2.2 初始化 GitLab 服务</h4><p>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">[root<span class="hljs-variable">@gitlab</span><span class="hljs-operator">-</span>server <span class="hljs-keyword">module</span>]# gitlab<span class="hljs-operator">-</span>ctl reconfigure<br>。 。 。 。 。 。<br><span class="hljs-keyword">Running</span> handlers:<br><span class="hljs-keyword">Running</span> handlers complete<br>Chef Client finished, <span class="hljs-number">425</span><span class="hljs-operator">/</span><span class="hljs-number">608</span> resources updated <span class="hljs-keyword">in</span> <span class="hljs-number">03</span> minutes <span class="hljs-number">08</span><br>seconds<br>gitlab Reconfigured<span class="hljs-operator">!</span><br><br></code></pre></td></tr></table></figure><h4 id="2-3-启动-GitLab-服务"><a href="#2-3-启动-GitLab-服务" class="headerlink" title="2.3 启动 GitLab 服务"></a>2.3 启动 GitLab 服务</h4><p>执行以下命令启动 GitLab 服务，如需停止，执行 <code>gitlab-ctl stop</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@gitlab-server</span> <span class="hljs-string">module</span>]<span class="hljs-comment"># gitlab-ctl start</span><br><span class="hljs-attr">ok: run: alertmanager:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6812</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: gitaly:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6740</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-monitor:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6765</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-workhorse:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6722</span><span class="hljs-string">)</span> <span class="hljs-string">136s</span><br><span class="hljs-attr">ok: run: logrotate:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5994</span><span class="hljs-string">)</span> <span class="hljs-string">197s</span><br><span class="hljs-attr">ok: run: nginx:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5930</span><span class="hljs-string">)</span> <span class="hljs-string">203s</span><br><span class="hljs-attr">ok: run: node-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6234</span><span class="hljs-string">)</span> <span class="hljs-string">185s</span><br><span class="hljs-attr">ok: run: postgres-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6834</span><span class="hljs-string">)</span> <span class="hljs-string">133s</span><br><span class="hljs-attr">ok: run: postgresql:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5456</span><span class="hljs-string">)</span> <span class="hljs-string">257s</span><br><span class="hljs-attr">ok: run: prometheus:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6777</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: redis:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5327</span><span class="hljs-string">)</span> <span class="hljs-string">263s</span><br><span class="hljs-attr">ok: run: redis-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6391</span><span class="hljs-string">)</span> <span class="hljs-string">173s</span><br><span class="hljs-attr">ok: run: sidekiq:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5797</span><span class="hljs-string">)</span> <span class="hljs-string">215s</span><br><span class="hljs-attr">ok: run: unicorn:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5728</span><span class="hljs-string">)</span> <span class="hljs-string">221s</span><br><br></code></pre></td></tr></table></figure><h3 id="3-GitLab-登录-amp-创建远程库"><a href="#3-GitLab-登录-amp-创建远程库" class="headerlink" title="3. GitLab 登录 &amp; 创建远程库"></a>3. GitLab 登录 &amp; 创建远程库</h3><h4 id="3-1-登录-GitLab"><a href="#3-1-登录-GitLab" class="headerlink" title="3.1 登录 GitLab"></a>3.1 登录 GitLab</h4><p>使用主机名或者 IP 地址即可访问 GitLab 服务。可配一下 windows 的 hosts 文件（C:\Windows\System32\drivers\etc）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/048956890f1e644fb77e8d58092a8b6d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1870c658dcabcf08fbc3b5b9fa6b2243.png"></p><p>首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。</p><p>然后使用修改后的密码登录 GitLab。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5608650ec5e913d5ab549f30fbb477d3.png"></p><p>GitLab 登录成功。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3231f6dd1a07f90326ec0506eaae747f.png"></p><h4 id="3-2-创建远程库"><a href="#3-2-创建远程库" class="headerlink" title="3.2 创建远程库"></a>3.2 创建远程库</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2ab639dfaa57cd499133c2c4cde1222a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f135a7b76c745c3aeef9034a82c8afaf.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5ff82d173fe047244945c8cd255a4b33.png"></p><h3 id="4-IDEA-集成-GitLab"><a href="#4-IDEA-集成-GitLab" class="headerlink" title="4. IDEA 集成 GitLab"></a>4. IDEA 集成 GitLab</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f34175126922c56c158f466dd4d665c.png"></p><p>接下来插件配置，Git 操作等与 Github、Gitee 的 IDEA 插件大同小异，不再赘述，自己触类旁通吧！</p><h2 id="九、Git报错处理"><a href="#九、Git报错处理" class="headerlink" title="九、Git报错处理"></a>九、Git报错处理</h2><h3 id="1-SSL报错"><a href="#1-SSL报错" class="headerlink" title="1.SSL报错"></a>1.SSL报错</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatal: unable to access &#x27;https://github.com/.......&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。参考网上解决办法：解除ssl验证后，再次git即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用方法</title>
    <link href="/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用方法"><a href="#Hexo使用方法" class="headerlink" title="Hexo使用方法"></a>Hexo使用方法</h1><h2 id="一、搭建Hexo博客"><a href="#一、搭建Hexo博客" class="headerlink" title="一、搭建Hexo博客"></a>一、搭建Hexo博客</h2><h3 id="1-下载Node-js"><a href="#1-下载Node-js" class="headerlink" title="1. 下载Node.js"></a>1. 下载Node.js</h3><p>去<a href="https://nodejs.org/en/">Node.js官网</a>下载Node.js稳定版本</p><h3 id="2-更换下载cnpm并更换淘宝源"><a href="#2-更换下载cnpm并更换淘宝源" class="headerlink" title="2. 更换下载cnpm并更换淘宝源"></a>2. 更换下载cnpm并更换淘宝源</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="3-Windows特殊操作"><a href="#3-Windows特殊操作" class="headerlink" title="3. Windows特殊操作"></a>3. Windows特殊操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set-ExecutionPolicy RemoteSigned<br></code></pre></td></tr></table></figure><p>更改策略，放行cnpm</p><h3 id="4-安装Hexo博客框架"><a href="#4-安装Hexo博客框架" class="headerlink" title="4. 安装Hexo博客框架"></a>4. 安装Hexo博客框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="5-建立博客文件夹"><a href="#5-建立博客文件夹" class="headerlink" title="5. 建立博客文件夹"></a>5. 建立博客文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir blog<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，从这里往下，所有步骤都是在<code>blog</code>文件夹下的。</strong></p><h3 id="6-生成Hexo博客"><a href="#6-生成Hexo博客" class="headerlink" title="6. 生成Hexo博客"></a>6. 生成Hexo博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hexo init<br></code></pre></td></tr></table></figure><h2 id="二、使用Hexo"><a href="#二、使用Hexo" class="headerlink" title="二、使用Hexo"></a>二、使用Hexo</h2><h3 id="1-本地启动博客"><a href="#1-本地启动博客" class="headerlink" title="1. 本地启动博客"></a>1. 本地启动博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>hexo start</p><h3 id="2-新建一篇文章"><a href="#2-新建一篇文章" class="headerlink" title="2. 新建一篇文章"></a>2. 新建一篇文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &quot;文章名&quot;<br></code></pre></td></tr></table></figure><p>然后就可以在<code>blog\source\_posts</code>路径下看见生成的文章。</p><h3 id="3-Hexo-清理"><a href="#3-Hexo-清理" class="headerlink" title="3. Hexo 清理"></a>3. Hexo 清理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo-生成"><a href="#4-Hexo-生成" class="headerlink" title="4. Hexo 生成"></a>4. Hexo 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>hexo generate</p><h3 id="5-一篇文章配置多个分类"><a href="#5-一篇文章配置多个分类" class="headerlink" title="5. 一篇文章配置多个分类"></a>5. 一篇文章配置多个分类</h3><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> Java<br><span class="hljs-bullet">  -</span> Servlet<br></code></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">categories</span>:<span class="hljs-meta"> [Java, Servlet]</span><br></code></pre></td></tr></table></figure><p>上面两种方法最终效果一样，都是将文章放在了一个子分类的目录下，效果如图。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/12972816-cc5be43b9b70f040.png"> </p><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> [Java]<br><span class="hljs-bullet">  -</span> [Servlet]<br></code></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。<strong>此处需要特别注意的是，- 与 [ 之间有空格。</strong></p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> [Java, Servlet]<br><span class="hljs-bullet">  -</span> [Programming]<br></code></pre></td></tr></table></figure><h3 id="6-一篇文章配置多个标签"><a href="#6-一篇文章配置多个标签" class="headerlink" title="6. 一篇文章配置多个标签"></a>6. 一篇文章配置多个标签</h3><p>配置格式如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">tag:<br><span class="hljs-bullet">    -</span> 前端<br><span class="hljs-bullet">    -</span> Hexo<br><span class="hljs-bullet">    -</span> HTML<br><span class="hljs-bullet">    -</span> JavaScript<br></code></pre></td></tr></table></figure><h2 id="三、将博客部署到Github上"><a href="#三、将博客部署到Github上" class="headerlink" title="三、将博客部署到Github上"></a>三、将博客部署到Github上</h2><p>将博客部署到Github上，这样不用备案也不用云服务器，比较方便。</p><h3 id="1-Github上新建仓库"><a href="#1-Github上新建仓库" class="headerlink" title="1. Github上新建仓库"></a>1. Github上新建仓库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b39cf6827134af18affb5fbc934318e.png"></p><p>需要注意的是，这里仓库名<strong>必须</strong>是<code>用户名.github.io</code>。</p><h3 id="2-安装Git部署插件"><a href="#2-安装Git部署插件" class="headerlink" title="2. 安装Git部署插件"></a>2. 安装Git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="3-在-config-yml更改配置"><a href="#3-在-config-yml更改配置" class="headerlink" title="3. 在_config.yml更改配置"></a>3. 在_config.yml更改配置</h3><p>在<code>_config.yml</code>的<code>deploy:</code>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">type: git<br>repo: https://github.com/JYGQAQ/JYGQAQ.github.io<br>branch: master<br></code></pre></td></tr></table></figure><h3 id="4-Hexo部署到远端"><a href="#4-Hexo部署到远端" class="headerlink" title="4. Hexo部署到远端"></a>4. Hexo部署到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>deploy : 部署</p><p><strong>若此处出现<code>Error： Spawn failed</code></strong></p><h4 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a>解决方法一：</h4><p><strong>可以尝试将<code>_config.yml</code>中的<code>repo</code>改为<code>ssh</code>方式</strong></p><p>原因如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git不再支持用户名密码验证了，其实改一下仓库地址就可以了。<br>原来用的https的仓库，改成ssh的仓库地址就行了。<br></code></pre></td></tr></table></figure><h4 id="解决方法二："><a href="#解决方法二：" class="headerlink" title="解决方法二："></a>解决方法二：</h4><ol><li><p>打开GitHub主页，点击头像找到Settings</p></li><li><p>在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请</p></li><li><p>Scopes那里可以全选</p></li><li><p>在mac上打开keychain access，搜索GitHub，输入刚刚的Token(需要注意的是token生成后一定要复制，刷新github就再也看不到了，需要重新生成)</p></li><li><p>执行以下命令<br> <code>$ git remote add origin https://“刚刚得到的Token“@github.com/“User名”/“仓库名（XXX.github.io）”.git</code></p></li><li><p>修改Hexo的 config.yml配置文件</p></li></ol>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">deploy:<br>  type: git<br>  repo: https:<span class="hljs-regexp">//</span><span class="hljs-string">&quot;Token&quot;</span>@github.com<span class="hljs-regexp">/“用户名”/</span>“仓库名（XXX.github.io）”.git<br>  branch: master<br></code></pre></td></tr></table></figure><h3 id="5-访问博客"><a href="#5-访问博客" class="headerlink" title="5. 访问博客"></a>5. 访问博客</h3><p>博客的网址就是仓库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jygqaq.github.io<br></code></pre></td></tr></table></figure><p>由于域名没有大小写，所以是小写。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><h3 id="1-克隆主题仓库"><a href="#1-克隆主题仓库" class="headerlink" title="1. 克隆主题仓库"></a>1. 克隆主题仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:jerryc127/hexo-theme-butterfly.git themes/butterfly<br></code></pre></td></tr></table></figure><p>把项目clone到themes目录下的butterfly文件夹</p><p>使用butterfly还需要安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-pug hexo-renderer-stylus --save<br></code></pre></td></tr></table></figure><h3 id="2-更改Hexo配置文件"><a href="#2-更改Hexo配置文件" class="headerlink" title="2. 更改Hexo配置文件"></a>2. 更改Hexo配置文件</h3><p>更改<code>_config.yml</code>配置文件中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: butterfly<br></code></pre></td></tr></table></figure><h3 id="3-清理Hexo"><a href="#3-清理Hexo" class="headerlink" title="3. 清理Hexo"></a>3. 清理Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo生成"><a href="#4-Hexo生成" class="headerlink" title="4. Hexo生成"></a>4. Hexo生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="5-Hexo-Start"><a href="#5-Hexo-Start" class="headerlink" title="5. Hexo Start"></a>5. Hexo Start</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>需要注意的是，如果使用<code>fluid</code>主题，那么<code>themes/fluid/_config.yml</code>比<code>themes/fluid/_config.fluid.yml</code>优先级要高。</p><h2 id="五、迁移博客"><a href="#五、迁移博客" class="headerlink" title="五、迁移博客"></a>五、迁移博客</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h3><p>根据本博客重新配置环境</p><h3 id="2-更换文件"><a href="#2-更换文件" class="headerlink" title="2. 更换文件"></a>2. 更换文件</h3><p>需要跟换以下文件：</p><ul><li><code>_config.yml</code></li><li><code>package.json</code></li><li><code>scaffolds</code></li><li><code>source</code></li><li><code>theme</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
