<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="一、Git基础学习"><a href="#一、Git基础学习" class="headerlink" title="一、Git基础学习"></a>一、Git基础学习</h2><h3 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1. Git常用命令"></a>1. Git常用命令</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a628594255e4d238d24b4a1276dbbf8tplv-k3u1fbpfcp-watermark.awebp"></p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>安装与配置</strong></td><td align="left"></td></tr><tr><td align="left">sudo apt-get install git</td><td align="left">Ubuntu 上安装 Git 命令</td></tr><tr><td align="left">git config --global user.name 用户名</td><td align="left">设置用户签名<br>（安装 Git 后务必设置）</td></tr><tr><td align="left">git config --global user.email email 地址</td><td align="left">设置用户 email 地址<br>（安装 Git 后务必设置）</td></tr><tr><td align="left"><strong>获取与创建项目</strong></td><td align="left"></td></tr><tr><td align="left">git init</td><td align="left">初始化本地库</td></tr><tr><td align="left">git clone 远程库地址</td><td align="left">从远程库克隆到本地</td></tr><tr><td align="left"><strong>基本快照</strong></td><td align="left"></td></tr><tr><td align="left">git status</td><td align="left">查看本地库状态</td></tr><tr><td align="left">git add 文件名</td><td align="left">添加变动文件到暂存区</td></tr><tr><td align="left">git add .</td><td align="left">添加当前目录下所有变动文件到暂存区</td></tr><tr><td align="left">git restore --staged 文件名</td><td align="left">复位在暂存区的文件（add 反悔药）</td></tr><tr><td align="left">git rm --cached 文件名</td><td align="left">移除在暂存区的文件（add 反悔药）（同上一条）</td></tr><tr><td align="left">git commit -m “备注文本” 文件名</td><td align="left">提交暂存区文件到本地库<br>（文件名缺省时，将暂存区所有文件提交）</td></tr><tr><td align="left">git commit --amend</td><td align="left">修改上次提交的备注文本</td></tr><tr><td align="left">git revert 版本号 (7 位)</td><td align="left">撤销指定的提交（commit 反悔药）(慎用)</td></tr><tr><td align="left">git reset --hard 版本号 (7 位)</td><td align="left">版本间穿梭（配合 git reflog 使用）</td></tr><tr><td align="left">git reset --hard HEAD^</td><td align="left">穿梭到上一个版本</td></tr><tr><td align="left"><strong>分支与合并</strong></td><td align="left"></td></tr><tr><td align="left">git branch</td><td align="left">列出所有分支</td></tr><tr><td align="left">git branch 分支名</td><td align="left">创建分支</td></tr><tr><td align="left">git checkout 分支名</td><td align="left">切换分支</td></tr><tr><td align="left">git merge 分支名 B</td><td align="left">分支 B 合并到 A<br>（A 为当前工作目录所处分支）</td></tr><tr><td align="left">git branch -d 分支名</td><td align="left">删除分支</td></tr><tr><td align="left">git tag</td><td align="left">列出所有本地标签</td></tr><tr><td align="left">git tag -l 通配模式文本 (*)</td><td align="left">根据符合通配模式文本，列出所有本地标签</td></tr><tr><td align="left">git tag 标签名</td><td align="left">为最新提交创建<strong>轻量</strong>标签</td></tr><tr><td align="left">git tag 标签名 版本号 (7 位)</td><td align="left">为对应版本号提交创建<strong>轻量</strong>标签（在后期打标签）</td></tr><tr><td align="left">git tag -a 标签名 -m 备注文本</td><td align="left">为最新提交创建<strong>附注</strong>标签</td></tr><tr><td align="left">git tag -d 标签名</td><td align="left">删除指定标签</td></tr><tr><td align="left"><strong>共享与更新项目</strong></td><td align="left"></td></tr><tr><td align="left">git remote add 别名 远程仓库地址</td><td align="left">添加远程库</td></tr><tr><td align="left">git remote -v</td><td align="left">查看添加过的远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 分支名</td><td align="left">推送到远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 --tags</td><td align="left">推送所有标签到远程库</td></tr><tr><td align="left">git fetch</td><td align="left">将远程库的最新内容拉到本地</td></tr><tr><td align="left">git pull 远程库地址或其别名 分支名</td><td align="left">将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并，<br>相当于 git fetch + git merge，这样可能会产生冲突，需要手动解决</td></tr><tr><td align="left"><strong>检查与比较</strong></td><td align="left"></td></tr><tr><td align="left">git show 标签名</td><td align="left">显示标签信息和与之对应的提交信息</td></tr><tr><td align="left">git show 版本号 (7 位)</td><td align="left">显示对应版本对应的提交信息</td></tr><tr><td align="left">git log</td><td align="left">显示当前分支所有提交过的版本信息</td></tr><tr><td align="left">git log --follow 文件名</td><td align="left">显示当前分支所有提交过的关于指定文件版本信息</td></tr><tr><td align="left">git log --pretty=oneline</td><td align="left">显示当前分支所有提交过的版本信息（精简）</td></tr><tr><td align="left">git log --graph</td><td align="left">显示当前分支所有提交过的版本信息（附有分支合并图）</td></tr><tr><td align="left">git diff 分支一 分支二</td><td align="left">显示两分支差异</td></tr><tr><td align="left">git diff 版本号一 (7 位) 版本号二 (7 位)</td><td align="left">显示同一分支两版本差异</td></tr><tr><td align="left"><strong>管理</strong></td><td align="left"></td></tr><tr><td align="left">git reflog</td><td align="left">可以查看所有分支的所有操作记录<br>（包括已被删除的 commit 记录和 reset 的操作，git log 所不能）</td></tr></tbody></table><h3 id="2-官网介绍"><a href="#2-官网介绍" class="headerlink" title="2. 官网介绍"></a>2. 官网介绍</h3><p><a href="https://git-scm.com/">Git 官网</a></p><p><a href="http://git-scm.com/docs">Git 官方文档</a></p><p><a href="https://git-scm.com/book/zh/v2">Git 官方书</a></p><p><a href="https://git-scm.com/downloads">Git 下载页面</a></p><p><a href="https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/">Github Git Cheat Sheets - 中文版</a></p><p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</p><h3 id="3-版本控制介绍"><a href="#3-版本控制介绍" class="headerlink" title="3. 版本控制介绍"></a>3. 版本控制介绍</h3><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2abc5f18d46afc2d50cee7db484a460f.png"></p><p>为什么需要版本控制？因为要从个人开发过渡到团队协作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2bcf55bc8f1e6cda16fc048ed30e12fc.png"></p><h3 id="4-分布式版本控制-VS-集中式版本控制"><a href="#4-分布式版本控制-VS-集中式版本控制" class="headerlink" title="4. 分布式版本控制 VS 集中式版本控制"></a>4. 分布式版本控制 VS 集中式版本控制</h3><h4 id="4-1-集中式版本控制工具"><a href="#4-1-集中式版本控制工具" class="headerlink" title="4.1  集中式版本控制工具"></a>4.1  集中式版本控制工具</h4><p>集中化的版本控制系统诸如 CVS、 SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统， 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做显而易见的<strong>缺点</strong>是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f0cc7f6f1eb57316f7f8fce8e2f03f45.png"></p><h4 id="4-2-分布式版本控制工具"><a href="#4-2-分布式版本控制工具" class="headerlink" title="4.2 分布式版本控制工具"></a>4.2 分布式版本控制工具</h4><p>Git、 Mercurial、 Bazaar、 Darcs……</p><p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后, 解决了集中式版本控制系统的缺陷：</p><ol><li> 服务器断网的情况下也可以进行开发（因为版本控制是在<strong>本地</strong>进行的）</li><li> 每个客户端保存的也都是整个<strong>完整的项目</strong>（包含历史记录， 更加安全）</li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/340e9b3bc50013b61f0e83e96b99f86a.png"></p><h3 id="5-Git发展历史"><a href="#5-Git发展历史" class="headerlink" title="5. Git发展历史"></a>5. Git发展历史</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f25cba01665ab8dcb63fcc79d05f04f.png"></p><h3 id="6-工作机制和代码托管中心"><a href="#6-工作机制和代码托管中心" class="headerlink" title="6. 工作机制和代码托管中心"></a>6. 工作机制和代码托管中心</h3><h4 id="6-1-Git-工作机制"><a href="#6-1-Git-工作机制" class="headerlink" title="6.1 Git 工作机制"></a>6.1 Git 工作机制</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1706b3553447ac9f8d95377d965d4fd2.png"></p><h4 id="6-2-Git-代码托管中心"><a href="#6-2-Git-代码托管中心" class="headerlink" title="6.2 Git 代码托管中心"></a>6.2 Git 代码托管中心</h4><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li>局域网<ul><li>  GitLab</li></ul></li><li>互联网<ul><li>  GitHub（外网）</li><li>  Gitee 码云（国内网站）</li></ul></li></ul><h3 id="7-Git安装和客户端的使用"><a href="#7-Git安装和客户端的使用" class="headerlink" title="7. Git安装和客户端的使用"></a>7. Git安装和客户端的使用</h3><p>在 <a href="https://git-scm.com/downloads">Git 下载页面</a>，选择下载 Windows 64 位版的 Git 安装软件。</p><p>安装步骤按照安装软件的安装向导安装即可，无需过多配置。</p><p>安装成功后，通常在文件浏览器空白处单击击鼠标右键，弹出菜单栏有 Git 的选项。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/72adc78acc2344ab51285dae2c4776ad.png"></p><h2 id="二、Git-基本使用"><a href="#二、Git-基本使用" class="headerlink" title="二、Git 基本使用"></a>二、Git 基本使用</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config --global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config --global user.email 邮箱</td><td>设置用户 email 地址</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset --hard 版本号</td><td>版本穿梭</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1352126739_7909.jpg"></p><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当执行 <strong>git rm –cached &lt;file&gt;</strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（<strong>git commit</strong>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。<strong>版本库 -&gt; 暂存区</strong></li><li>当执行<strong>git reset HEAD –hard</strong>，暂存区和工作区都会被版本库重写，相当于HEAD指针移动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – &lt;file&gt;</strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。<strong>暂存区 -&gt; 工作区</strong></li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD &lt;file&gt;</strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li></ul><h3 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1. 设置用户签名"></a>1. 设置用户签名</h3><h4 id="1-1-设置系统级用户签名"><a href="#1-1-设置系统级用户签名" class="headerlink" title="1.1  设置系统级用户签名"></a>1.1  设置系统级用户签名</h4><figure class="highlight autoit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name abc <span class="hljs-meta">#用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email abc<span class="hljs-symbol">@123</span>.com<br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>在用户目录下的<code>./gitconfig</code>中查看设置过用户签名</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">abc@</span>DESKTOP-R85C9HV MINGW64 ~/Desktop<br>$ cat ~/.gitconfig<br><span class="hljs-string">[user]</span><br>        name = abc<br>        email = <span class="hljs-symbol">abc@</span><span class="hljs-number">123.</span>com<br><span class="hljs-string">[core]</span><br>        quotepath = <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="1-2-设置仓库级用户签名"><a href="#1-2-设置仓库级用户签名" class="headerlink" title="1.2 设置仓库级用户签名"></a>1.2 设置仓库级用户签名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config user.name abc</span><br><span class="hljs-meta">$</span><span class="bash"> git config user.email abc@163.com</span><br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身份，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>创建成功，用户签名信息会保存在本地工作区 <code>./.git/config</code> 文件中，你可以使用 <code>cat</code> 命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/笔记 (master)<br><span class="hljs-meta">$</span><span class="bash"> cat .git/config</span><br>[core]<br>        repositoryformatversion = 0<br>        filemode = false<br>        bare = false<br>        logallrefupdates = true<br>        symlinks = false<br>        ignorecase = true<br>[remote &quot;origin&quot;]<br>        url = git@github.com:JYGQAQ/Notebook.git<br>        fetch = +refs/heads/*:refs/remotes/origin/*<br>[user]<br>        name = JYGQAQ<br>        email = 604713431@qq.com<br></code></pre></td></tr></table></figure><p>需要注意的是，签名的作用是区分不同的不同的操作者身份，所以一般只用设置系统级的用户签名。如果两个级别同时存在，那么依照就近原则，仓库级别要大于系统级别。如果两个级别都不存在，则无法完成 Git 一些命令，会提示验证身份。</p><h3 id="2-初始化本地库"><a href="#2-初始化本地库" class="headerlink" title="2. 初始化本地库"></a>2. 初始化本地库</h3><p>基本语法：<code>git init</code></p><p>案例实操：</p><ul><li>创建项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir gitLearn<br></code></pre></td></tr></table></figure><ul><li>进入项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd gitLearn/<br></code></pre></td></tr></table></figure><ul><li>初始化本地库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in E:/gitLearn/.git/<br></code></pre></td></tr></table></figure><p>Git自动创建了一个名为. git 非空隐藏文件夹。</p><h3 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3. 查看本地库状态"></a>3. 查看本地库状态</h3><p>基本语法：<code>git status</code></p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master <br><br>No commits yet<br><br>nothing to commit (create/copy files and use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>第一行：目前处于哪个本地分支</p><p>第二行：从来没有<code>commit</code>过，本地库没有版本信息。</p><p>第三行：没有更改需要<code>commit</code></p><ul><li>新建文件后，查看本地库状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        newfile.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/image-20220121000221864.png"></p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标红</strong>），意思是需要<code>git add</code>来提交到暂存区追踪。</p><p>有被<strong>标红</strong>的文件，说明该文件<strong>新创建或者和相对于暂存区有更改</strong>需要被<code>git add</code>提交到暂存区追踪。</p><h3 id="4-添加到暂存区"><a href="#4-添加到暂存区" class="headerlink" title="4.添加到暂存区"></a>4.添加到暂存区</h3><p>基本语法：<code>git add 文件名</code> 或者 <code>git add .</code>代表添加所有有更改的文件到暂存区</p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add newfile.txt<br>或者<br>git add .<br></code></pre></td></tr></table></figure><p>接下来使用<code>git status</code>查看本地库状态</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e666e7de96c9def5042f595dd04805e.png"></p><p>注意上面的提示：</p><p>可以使用<code>git rm --cached newfile.txt</code>来从索引中删除文件。但是本地文件还存在， 只是不希望这个文件被版本控制，意思是从暂存区中删除<code>newfile.txt</code>。</p><p>若使用<code>git rm newfile.txt</code>同时从工作区和索引中删除文件。即本地的文件也被删除了。</p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标绿</strong>），意思是需要<code>git commit</code>来提交到本地库，来进行版本控制。</p><p>有被<strong>标绿</strong>的文件，说明该文件<strong>未被提交到本地库或者本文件相对于本地库有更改</strong>需要被<code>git commit</code>来提交到本地库，来进行版本控制。</p><p> <code> git commit -a -m “massage“</code></p><p>​      其他功能如-m参数，加的-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。建议一般不要使用-a参数，正常的提交还是使用git add先将要改动的文件添加到暂存区，再用git commit 提交到本地版本库。</p><p>  <code>git commit --amend</code></p><p>​      如果我们不小心提交了一版我们不满意的代码，并且给它推送到服务器了，在代码没被merge之前我们希望再修改一版满意的，而如果我们不想在服务器上abondon，那么我们怎么做呢？git commit –amend //也叫追加提交，它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中，使得版本库更加清爽。</p><h3 id="5-提交本地库"><a href="#5-提交本地库" class="headerlink" title="5. 提交本地库"></a>5. 提交本地库</h3><p>基本语法：<code>git commit -m &quot;日志信息&quot; 文件名</code> 或者 <code>git commit -m &quot;message&quot;</code>提交所有暂存区内容到本地库。</p><p>git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫<strong>commit-id</strong>，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里。</p><p>案例实操：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bbc4110ceb47c9dba34e612aef1167f.png"></p><p>查看本地库状态：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/139f25276d55d99e9197b2570a65bff.png"></p><p>发现没有<strong>绿名</strong>和<strong>红名</strong>文件被标注，说明没有文件需要被<strong>commit</strong>和<strong>add</strong>。</p><h4 id="5-1-查看本地库版本信息"><a href="#5-1-查看本地库版本信息" class="headerlink" title="5.1 查看本地库版本信息"></a>5.1 查看本地库版本信息</h4><p>查看本地库版本信息，使用<code>git reflog</code>查看引用日志信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p>说明：开头是的哈希值是<strong>commit-id</strong>，最后是<strong>commit</strong>的message信息。<code>HEAD</code>是指针，指向了<code>master</code>分支。</p><p>查看本地库版本的详细信息，使用<code>git log</code>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p>说明：第一行是<strong>commit-id</strong>的准确值，第二行是提交者的用户签名，第三行是提交时间，第四行是<code>commit</code>的<code>message</code>。</p><h4 id="5-2-Commit-Message-规范"><a href="#5-2-Commit-Message-规范" class="headerlink" title="5.2 Commit Message 规范"></a>5.2 Commit Message 规范</h4><p><code>git commit</code>命令要求编写<code>commit message</code>，不然无法提交，关于<code>commit message</code>的编写，我们往往容易忽略规范，整体来讲，<code>commit message</code>应该清晰简洁，能够提现本次提交目的。</p><p>关于<code>commit message</code>的编写规范，社区有很多种，<code>Angular规范</code>是目前使用最广的写法，本文就简单介绍一下。</p><p><code>commit message</code>的构成包括三部分： <code>Header, Body 和 Footer</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;type&gt;</span> (<span class="hljs-params">&lt;scope&gt;</span>): <span class="hljs-params">&lt;subject&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;body&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;footer&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>其中，<code>Header</code>是必需的，<code>Body</code>和<code>Footer</code>可以省略。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">注意：任何一布行都不得超过 <span class="hljs-number">72</span><span class="hljs-comment">(或100)</span> 个字符，避免自动换行影响美观<br>复制代码<br><br></code></pre></td></tr></table></figure><h5 id="5-2-1Header"><a href="#5-2-1Header" class="headerlink" title="5.2.1Header"></a>5.2.1Header</h5><p><code>Header</code>占一行，包括三个字段：<code>type, scope, subject</code></p><p><strong>(1) type</strong></p><p><code>type</code> 用于说明 <code>commit</code>类别，只允许以下 7 个标识：</p><ul><li>  feat: 新功能 (feature)</li><li>  fix: 修补 bug</li><li>  docs: 文档 (documentation)</li><li>  style: 格式 (比如去除空行)</li><li>  refactor: 重构 (不是新增功能，也不是修补 bug)</li><li>  test: 增加测试</li><li>  chore: 构建过程或辅助工具的变动</li></ul><p><strong>(2) scope</strong></p><p><code>scope</code> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等 (很少用到)</p><p><strong>(3) subject</strong></p><p>描述本次提交的目的，不超过 50 个字符</p><ul><li>  以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li><li>  第一个字母小写</li><li>  结尾不加句号</li></ul><h5 id="5-2-2-Body"><a href="#5-2-2-Body" class="headerlink" title="5.2.2 Body"></a>5.2.2 Body</h5><p><code>Body</code>部分是对本次 <code>commit</code> 的详细描述，可以分为多行描述，要求使用第一人称现在时，说明代码变动原因以及前后行为对比。</p><h5 id="5-2-3-Footer"><a href="#5-2-3-Footer" class="headerlink" title="5.2.3 Footer"></a>5.2.3 Footer</h5><p><code>Footer</code> 只适用于两种情况：</p><ul><li>  (1) 不兼容变动</li></ul><p>当前代码与上一个版本不兼容，则 <code>Footer</code> 部分以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、变动理由和迁移方法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">BREAKING CHANGE:</span> <span class="hljs-string">isolate</span> <span class="hljs-string">scope</span> <span class="hljs-string">bindings</span> <span class="hljs-string">definition</span> <span class="hljs-string">has</span> <span class="hljs-string">changed.</span><br><br>    <span class="hljs-attr">To migrate the code follow the example below:</span><br><br>    <span class="hljs-attr">Before:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;attribute&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-attr">After:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;@&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-string">The</span> <span class="hljs-string">removed</span> <span class="hljs-string">`inject`</span> <span class="hljs-string">wasn&#x27;t</span> <span class="hljs-string">generaly</span> <span class="hljs-string">useful</span> <span class="hljs-string">for</span> <span class="hljs-string">directives</span> <span class="hljs-string">so</span> <span class="hljs-string">there</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-literal">no</span> <span class="hljs-string">code</span> <span class="hljs-string">using</span> <span class="hljs-string">it.</span><br></code></pre></td></tr></table></figure><ul><li>  (2) 关闭 <code>Issue</code></li></ul><p>如果当前 <code>commit</code> 针对某个 <code>issue</code>，那么可以在 <code>Footer</code> 部分关闭这个 <code>issue</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Closes</span> #<span class="hljs-number">123</span>, #<span class="hljs-number">234</span>, #<span class="hljs-number">345</span><br></code></pre></td></tr></table></figure><h3 id="6-修改文件"><a href="#6-修改文件" class="headerlink" title="6. 修改文件"></a>6. 修改文件</h3><p>修改 <code>newfile.txt</code> 内容，<code>git status</code>会提示该文件修改过（会被<strong>标红</strong>，跟暂存区相比有更改），如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bf87fdbd981c5d3e8d12843be4647e.png"></p><p><code>git checkout -- file</code>是指根据暂存区的<code>file</code>文件来覆盖工作区的<code>file</code>文件，也就是放弃更改。</p><p>需要注意的是，Git是以<strong>行</strong>来管理文件的，最小单位是行。</p><h3 id="7-查看版本之间的不同"><a href="#7-查看版本之间的不同" class="headerlink" title="7. 查看版本之间的不同"></a>7. 查看版本之间的不同</h3><h4 id="7-1-比较工作区与暂存区"><a href="#7-1-比较工作区与暂存区" class="headerlink" title="7.1 比较工作区与暂存区"></a>7.1 比较工作区与暂存区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff<br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区</p><h4 id="7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"><a href="#7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）" class="headerlink" title="7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"></a>7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;path&gt;...] <br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区2.7.1比较工作区与暂存区</p><h4 id="7-3-比较工作区与最新本地版本库"><a href="#7-3-比较工作区与最新本地版本库" class="headerlink" title="7.3 比较工作区与最新本地版本库"></a>7.3 比较工作区与最新本地版本库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff HEAD [&lt;path&gt;...] #如果HEAD指向的是master分支，那么HEAD还可以换成master<br></code></pre></td></tr></table></figure><h4 id="7-4-比较工作区域指定commit-id的差异"><a href="#7-4-比较工作区域指定commit-id的差异" class="headerlink" title="7.4 比较工作区域指定commit-id的差异"></a>7.4 比较工作区域指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff commit-id [&lt;path&gt; ...]<br></code></pre></td></tr></table></figure><h4 id="7-5-比较暂存区与指定commit-id的差异"><a href="#7-5-比较暂存区与指定commit-id的差异" class="headerlink" title="7.5 比较暂存区与指定commit-id的差异"></a>7.5 比较暂存区与指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;commit-id&gt;][&lt;path&gt;...]<br></code></pre></td></tr></table></figure><h4 id="7-6-比较两个commit-id之间的差异"><a href="#7-6-比较两个commit-id之间的差异" class="headerlink" title="7.6 比较两个commit-id之间的差异"></a>7.6 比较两个commit-id之间的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;]<br></code></pre></td></tr></table></figure><h3 id="8-版本穿梭"><a href="#8-版本穿梭" class="headerlink" title="8. 版本穿梭"></a>8. 版本穿梭</h3><h4 id="8-1-查看历史版本"><a href="#8-1-查看历史版本" class="headerlink" title="8.1 查看历史版本"></a>8.1 查看历史版本</h4><p>基本语法：</p><ul><li>  <code>git reflog</code> 查看版本信息</li><li>  <code>git log</code> 查看版本详细信息         加上<code>--graph</code>有图形表示。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p><strong>git log 与 git reflog 区别</strong></p><p><code>git log</code> 命令可以显示所有提交过的版本信息，如果感觉太繁琐，可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p><p><code>git reflog</code> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行 <code>git reset --hard HEAD~1</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的 commitid，用<code>git reflog</code>则可以看到被删除的 commitid，我们就可以买后悔药，恢复到被删除的那个版本。<a href="https://blog.csdn.net/u013252047/article/details/80230781">link</a></p><h4 id="8-2-版本穿梭"><a href="#8-2-版本穿梭" class="headerlink" title="8.2 版本穿梭"></a>8.2 版本穿梭</h4><p>基本语法：</p><p><code>git reset --hard 版本号</code>，**–hard** 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。</p><p><code>git reset HEAD</code> 、<code>git reset</code> 、<code>git reset --soft HEAD</code>或者<code>git reset --mixed</code><strong>–mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><p><strong>需要注意的是，上面两种用法，都可以填<code>版本号</code>和<code>HEAD ... HEAD^^</code>，唯一不同的是，–hard重写工作区和暂存区，其他只重写暂存区。</strong></p><p><strong>Git 切换版本， 底层其实是移动的 HEAD 指针，不会产生新的版本。</strong></p><h2 id="三、Git分支用法"><a href="#三、Git分支用法" class="headerlink" title="三、Git分支用法"></a>三、Git分支用法</h2><h3 id="1-分支概述和优点"><a href="#1-分支概述和优点" class="headerlink" title="1. 分支概述和优点"></a>1. 分支概述和优点</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bcad650a512a72097b3391e00ecb8bbe.png"></p><h4 id="1-1-什么是分支"><a href="#1-1-什么是分支" class="headerlink" title="1.1 什么是分支"></a>1.1 什么是分支</h4><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来， 开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f1d0659ed000e9dfa295fc696a58cf74.png"></p><h4 id="1-2分支的好处"><a href="#1-2分支的好处" class="headerlink" title="1.2分支的好处"></a>1.2分支的好处</h4><p>同时<strong>并行</strong>推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="2-分支基本操作"><a href="#2-分支基本操作" class="headerlink" title="2. 分支基本操作"></a>2. 分支基本操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h4 id="2-1-查看分支"><a href="#2-1-查看分支" class="headerlink" title="2.1 查看分支"></a>2.1 查看分支</h4><p>基本语法：<code>git branch -v</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fab3df037a60224caf0f127e53de4b1.png"></p><p><code>*</code>代表当前所在的分支</p><h4 id="2-2-创建分支"><a href="#2-2-创建分支" class="headerlink" title="2.2 创建分支"></a>2.2 创建分支</h4><p>基本语法：<code>git branch 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/47e47992b7ff1da878bbbfe9b87559c.png"></p><p><strong>刚创建的新的分支，并将主分支 master 的内容复制了一份</strong>。</p><h4 id="2-3-切换分支"><a href="#2-3-切换分支" class="headerlink" title="2.3 切换分支"></a>2.3 切换分支</h4><p>基本语法：<code>git checkout 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f6a55ec01908aa4b7a06b59b51bc26f.png"></p><h3 id="3-合并分支-正常合并"><a href="#3-合并分支-正常合并" class="headerlink" title="3. 合并分支 (正常合并)"></a>3. 合并分支 (正常合并)</h3><p>基本语法：<code>git merge 分支名</code></p><p>将<code>分支名</code>合并到当前分支。</p><p>在 master 分支上合并 hot-fix 分支（将 hot-fix 的合并到 master）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1e50945d4aa000d22dfca989fc7b0d2.png"></p><h3 id="4-合并分支-冲突合并"><a href="#4-合并分支-冲突合并" class="headerlink" title="4. 合并分支 (冲突合并)"></a>4. 合并分支 (冲突合并)</h3><h4 id="4-1-冲突产生的原因"><a href="#4-1-冲突产生的原因" class="headerlink" title="4.1 冲突产生的原因"></a>4.1 冲突产生的原因</h4><p>并分支时，<strong>多个分支修改了同一个文件(任何地方)或者多个分支修改了同一个文件的名称</strong>（从该文件第一行开始，最先开始不同的行到最后不同的行会括起来）。 Git 无法替我们决定使用哪一个，因此，必须<strong>人为决定</strong>新代码内容。</p><p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可。</p><h4 id="4-2-产生冲突"><a href="#4-2-产生冲突" class="headerlink" title="4.2 产生冲突"></a>4.2 产生冲突</h4><p>修改两个分支，中同一文件同一行，合并两个分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eda203702114339268b657212811c5f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/61073b71dfe7abee793f6b335747116.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9218cbf54fd3120e70da480441c654.png"></p><h4 id="4-3-解决冲突"><a href="#4-3-解决冲突" class="headerlink" title="4.3 解决冲突"></a>4.3 解决冲突</h4><p>编辑有冲突的文件，<strong>删除特殊符号</strong>，决定要使用的内容。随后<code>git add .</code> &amp; <code>git commit -m &quot;message&quot;</code>正式合并分支。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/73ccf068132905eee5e42c7ab2e0514.png"></p><h4 id="4-4-创建分支和切换分支"><a href="#4-4-创建分支和切换分支" class="headerlink" title="4.4 创建分支和切换分支"></a>4.4 创建分支和切换分支</h4><p>master、 hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。</p><ul><li>  HEAD 如果指向 master，那么我们现在就在 master 分支上。</li><li>  HEAD 如果执行 hot-fix，那么我们现在就在 hot-fix 分支上。</li></ul><p>所以切换分支的本质就是移动 HEAD 指针。</p><h3 id="5-远程分支"><a href="#5-远程分支" class="headerlink" title="5. 远程分支"></a>5. 远程分支</h3><h4 id="5-1-创建远程分支"><a href="#5-1-创建远程分支" class="headerlink" title="5.1 创建远程分支"></a>5.1 创建远程分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支<br>git push origin my-test:my-test  //将my-test分支推送到远程<br>或<br>git push origin my-test //本地分支和远程分支重名<br></code></pre></td></tr></table></figure><p><code>git push origin my-test:my-test</code>其中第一个<code>my-test</code>是本地分支名，第二个<code>my-test</code>是远程分支名</p><h4 id="5-2-建立本地分支与远程分支的联系"><a href="#5-2-建立本地分支与远程分支的联系" class="headerlink" title="5.2 建立本地分支与远程分支的联系"></a>5.2 建立本地分支与远程分支的联系</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch --set-upstream-to=origin/develop develop<br></code></pre></td></tr></table></figure><p>其中，<code>origin</code>是远程仓库的别名，第一个<code>develop</code>是远程分支名，第二个是<code>debelop</code>本地分支名</p><h4 id="5-3-查看所有分支"><a href="#5-3-查看所有分支" class="headerlink" title="5.3 查看所有分支"></a>5.3 查看所有分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -vv<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/98446cf13d8282318d8127c5e566a82.png"></p><blockquote><p>黄色框是本地分支名，绿色框是远程分支名。需要注意的是有些本地分支没有关联远程分支。</p></blockquote><h2 id="四、使用Github"><a href="#四、使用Github" class="headerlink" title="四、使用Github"></a>四、使用Github</h2><p>团队内协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c397bde00d728c4e41eca79f578d25c3.png"></p><p>跨团队协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p><a href="https://github.com/">GitHub 网址</a></p><h3 id="1-创建远程库"><a href="#1-创建远程库" class="headerlink" title="1. 创建远程库"></a>1. 创建远程库</h3><p>登陆后，点击在网页右上角的 “+” –&gt; “New repository”，创建远程库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3dfd6ad9419bfcef2635e08a5c02e86c.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3ddd9d9b5ec3b0ab8c238ef66a183d1.png"></p><h4 id="1-1-远程仓库操作"><a href="#1-1-远程仓库操作" class="headerlink" title="1.1 远程仓库操作"></a>1.1 远程仓库操作</h4><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td></tr></tbody></table><h3 id="2-关联远程库"><a href="#2-关联远程库" class="headerlink" title="2. 关联远程库"></a>2. 关联远程库</h3><p><strong>基本语法</strong>：</p><ul><li>  <code>git remote -v</code> 查看当前所有远程地址别名</li><li>  <code>git remote add 别名 远程地址</code></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/682725a20f0d99a4467e2a6cda04ad2.png"></p><p>这个地址在创建完远程仓库后生成的连接 ，如图所示</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/94534c6c6ba1d748bbfcc87338e38d7.png"></p><h3 id="3-推送本地库到远程库"><a href="#3-推送本地库到远程库" class="headerlink" title="3. 推送本地库到远程库"></a>3. 推送本地库到远程库</h3><p>基本语法：<code>git push 别名 分支</code>  将该分支推送上去</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7bec3b7357867896ea8f87838591b41.png"></p><h4 id="3-1-git-push详解"><a href="#3-1-git-push详解" class="headerlink" title="3.1 git push详解"></a>3.1 git push详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p>如果当前本地分支关联过远程分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br></code></pre></td></tr></table></figure><h3 id="4-拉取远程库到本地库"><a href="#4-拉取远程库到本地库" class="headerlink" title="4. 拉取远程库到本地库"></a>4. 拉取远程库到本地库</h3><p>需要注意的是，当远程库与本地库不相同时，需要先拉取远程库（如果直接push，会出错）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5eca728584bde973a8c9c109f26314c.png"></p><h4 id="4-1-git-pull详解"><a href="#4-1-git-pull详解" class="headerlink" title="4.1 git pull详解"></a>4.1 git pull详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f4b96f8b373b6e9ff02775e89050c9f.png"></p><p>主要注意的是，<code>git pull</code>之后查看本地库状态，发现本地库是干净的，说明<code>git pull</code>会自动<code>git add .</code>和<code>git push</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/110ae677e2075dabba3ba280b680768.png"></p><h3 id="5-克隆远程库到本地"><a href="#5-克隆远程库到本地" class="headerlink" title="5. 克隆远程库到本地"></a>5. 克隆远程库到本地</h3><p>基本语法：<code>git clone 远程地址</code>在远程库获取地址 URL</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bed545d3938cde21c57c8f86ffcfffd.png"></p><p>克隆完成后，查看远程仓库别名，和分支对应情况：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d75f5d9b4a0889a1f2aca32b259d3c3.png"></p><p>clone 会做如下操作：</p><ol><li> 拉取代码。</li><li> 初始化本地仓库。</li><li> 创建别名。</li><li> 创建对应分支</li></ol><h3 id="6-团队内协作"><a href="#6-团队内协作" class="headerlink" title="6. 团队内协作"></a>6. 团队内协作</h3><p>一、选择邀请合作者。（在仓库设置里操作）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/945f1ba6e29fb725ee0d852ff59c3851.png"></p><p>二、填入目标合作者。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ee1b6a6656efe2adbb740b38954529b9.png"></p><p>三、复制网址发送给你目标合作者 ， 复制内容如下：<a href="https://github.com/atguiguyueyue/git-shTest/invitations%E3%80%82">https://github.com/atguiguyueyue/git-shTest/invitations。</a></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0f5ec0155e64421d315594aa537fd187.png"></p><p>四、目标合作者接收到网址，用浏览器打开它，点击接受邀请。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/295a2398e0a3150d50530d5db21103aa.png"></p><p>五、接受邀请成功之后，可以在目标合作者 Github 账号上看到将来共同开发远程仓库。</p><p>六、目标合作者可以修改内容并 push 到远程仓库。</p><p>七、回到发送合作邀请者的 GitHub 远程仓库中可以看到，最后一次是目标合作者提交的。</p><h3 id="7-跨团队协作"><a href="#7-跨团队协作" class="headerlink" title="7. 跨团队协作"></a>7. 跨团队协作</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p>一、将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。</p><p>二、在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 网页右上方的 Fork 按钮，将项目叉到自己的本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4856e4845a7f0dbb54c79bd804892f5e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c641d9ba65f20ba58d3f98ec792ae0e5.png"></p><p>fork成功后可以看到当前仓库信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3078d75badb2fd393dbe172327dc094c.png"></p><p>三、东方不败就可以在线编辑fork过来的文件。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/40aa522895eb04a6c203a9bcbca25005.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb19249416069d158e2b4280a679063f.png"></p><p>四、编辑完毕后，填写描述信息并点击左下角绿色按钮提交。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c87379a8a91eb65e2961475129362da4.png"></p><p>五、接下来点击上方的 Pull 请求，并创建一个新的请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bdb52dc24df07d8d846a4fe19985908.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c2f07c7ba5586e3923ba870a37c856d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/996007e8e9fee91ef37af6818e164139.png"></p><p>六、回到岳岳 GitHub 账号可以看到有一个 Pull request 请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c634b139396001cb2fcb64b8e2a078e1.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d666e1f3544c07821e85b602d0beffc5.png"></p><p>进入到聊天室，可以讨论代码相关内容。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3d97452ea50fffca42ec29308c842692.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c477d95ea98448b966264bdae235b64.png"></p><p>七、如果代码没有问题，可以点击 Merge pull reque 合并代码。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/894bdb75678d7793e92f1099e5c1d080.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2964db9c2239859ee59c4bfb9fb25513.png"></p><h3 id="8-SSH-免密登录"><a href="#8-SSH-免密登录" class="headerlink" title="8. SSH 免密登录"></a>8. SSH 免密登录</h3><p><strong>ssh配置只是省去了输入github账号密码的这一步操作，所以跟github仓库关系不大，跟github账号关系大</strong></p><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/197d6964ccfb06f1eaf22f795061826d.png"></p><p>先到用户的主页目录，运行命令 ssh-keygen 生成. ssh 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;604713431@qq.com&quot;<br></code></pre></td></tr></table></figure><p><code>-t rsa</code>是使用非对称加密协议<code>rsa</code>，<code>-C &quot;****&quot;</code>是注释。</p><p>在家目录下生成了<code>id_rsa</code>是私钥，放在本地；<code>id_rsa.pub</code>是公钥，放在服务器。</p><p>然后，将生成的公钥添加至 Github 账号 SSH 设置</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2d213036d44d57f07ad75b23d20871ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0a6a75ce73adad73a535947dce7fa525.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0c2f4dd9ef30bdc8c47ae59e50b8851b.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f54c4dccd3d8a17e909042c28181fb6.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0ad893fd8447ac90ed0ee7ceafdf582e.png"></p><p>添加公钥后，使用ssh方法可不用输入 Github 账号密码便可<code>push</code>或者<code>pull</code>。</p><h2 id="五、IDEA集成Git"><a href="#五、IDEA集成Git" class="headerlink" title="五、IDEA集成Git"></a>五、IDEA集成Git</h2><p>在IDEA中，红色表示文件新创建并未被<code>add</code>提交到暂存区，绿色代表文件未被<code>commit</code>提交到本地版本库，蓝色代表文件被修改了，需要重新<code>add &amp; commit</code>(此处也可以直接<code>commit</code>)（但是之前被<code>add &amp; commit</code>过）。</p><p><code>git log</code>中绿色标签代表分支，黄色标签代表<code>HEAD</code>头指针。</p><h3 id="1-配置-Git-忽略文件"><a href="#1-配置-Git-忽略文件" class="headerlink" title="1. 配置 Git 忽略文件"></a>1. 配置 Git 忽略文件</h3><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。例如，Maven 工程根据 src 生成的 target。</p><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore），这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，<strong>建议</strong>也放在用户家目录下。</p><p>git.ignore 文件模版内容如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># Compiled class file</span><br>*<span class="hljs-string">.class</span><br><br><span class="hljs-comment"># Log file</span><br>*<span class="hljs-string">.log</span><br><br><span class="hljs-comment"># BlueJ files</span><br>*<span class="hljs-string">.ctxt</span><br><br><span class="hljs-comment"># Mobile Tools for Java (J2ME)</span><br><span class="hljs-string">.mtj.tmp/</span><br><br><span class="hljs-comment"># Package Files #</span><br>*<span class="hljs-string">.jar</span><br>*<span class="hljs-string">.war</span><br>*<span class="hljs-string">.nar</span><br>*<span class="hljs-string">.ear</span><br>*<span class="hljs-string">.zip</span><br>*<span class="hljs-string">.tar.gz</span><br>*<span class="hljs-string">.rar</span><br><br><span class="hljs-comment"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br>hs_err_pid*<br><span class="hljs-string">.classpath</span><br><span class="hljs-string">.project</span><br><span class="hljs-string">.settings</span><br>target<br><span class="hljs-string">.idea</span><br>*<span class="hljs-string">.iml</span><br><br></code></pre></td></tr></table></figure><p>在. gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[user]</span><br>    <span class="hljs-attr">name</span> = Layne<br>    <span class="hljs-attr">email</span> = Layne@atguigu.com<br><span class="hljs-section">[core]</span><br><span class="hljs-attr">excludesfile</span> = C:/Users/asus/git.ignore<br><br></code></pre></td></tr></table></figure><p>注意：这里要使用 “正斜线（/）”，不要使用 “反斜线（\）”</p><h3 id="2-在-IDEA-配置-Git-程序"><a href="#2-在-IDEA-配置-Git-程序" class="headerlink" title="2. 在 IDEA 配置 Git 程序"></a>2. 在 IDEA 配置 Git 程序</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 Git，配置 Git 的安装路径。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d86ae18c01b9a08bc73f02aa6c1b3708.png"></p><h3 id="3-IDEA初始化-Git"><a href="#3-IDEA初始化-Git" class="headerlink" title="3. IDEA初始化 Git"></a>3. IDEA初始化 Git</h3><p>先创建一个名叫 HelloGit 的 Maven 工程。</p><p>在菜单栏 VCS -&gt; Import into Version Control -&gt; Create Git Repository</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4bbfb1e76fb25655b3fe6900bb29ea47.png"></p><p>选择要创建 Git 本地仓库的工程，也就是 HelloGit 工程，然后添加 OK。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5dc609978787f3e5a83dbdf954a3e039.png"></p><h3 id="4-添加到暂存区-1"><a href="#4-添加到暂存区-1" class="headerlink" title="4. 添加到暂存区"></a>4. 添加到暂存区</h3><p>创建一个 HelloGit 类，将其添加 Git 暂存区。</p><p>右键点击 HelloGit 类，选择 Git-&gt;Add。可以右键点击 HelloGit项目根目录，更大范围地添加文件到暂存区。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9ec5087e543611c5ac99b171277f590.png"></p><p>添加成功后，文件名会从红色变成绿色。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ec95c2b0b99d1f3a0ac8ad3291fdde50.png"></p><h3 id="5-提交至本地库"><a href="#5-提交至本地库" class="headerlink" title="5. 提交至本地库"></a>5. 提交至本地库</h3><p>右键点击 HelloGit，选择 Git-&gt;Commit Directory。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a73d7bbac024bfe61951662f5bf6ded.png"></p><p>添加注释后提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/281c7f26319b59e7584103c2a3ee88dd.png"></p><p>添加成功后，后台打印相关信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3bdf7a9135d3ae80b9aad4d678626491.png"></p><h3 id="6-切换版本"><a href="#6-切换版本" class="headerlink" title="6. 切换版本"></a>6. 切换版本</h3><p>在 IDEA 的左下角，点击 Git，然后点击 Log 查看版本</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/69e6670ea5681781c173f1c86864ae1e.png"></p><p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5530ac3d829954cebd23ed15a681769f.png"></p><h3 id="7-创建分支"><a href="#7-创建分支" class="headerlink" title="7. 创建分支"></a>7. 创建分支</h3><p>右键点击 HelloGit，Git -&gt; Repository -&gt; Branches，或者点击 IDEA 的右下角，如图红圈所示部位：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3e31e84cd2f7b5b95bb2639abcb1804f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c7544c1bade118b3177907ad903a8082.png"></p><p>选择点击 New Branch：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9c18ec9924788adfa432b7b924308ce.png"></p><p>创建新分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8a4a5e7cf7511d086ddac0be704e850f.png"></p><h3 id="8-切换分支"><a href="#8-切换分支" class="headerlink" title="8. 切换分支"></a>8. 切换分支</h3><p>跟<strong>创建分支</strong>步骤相似，如点击 IDEA 的右下角（它显示项目正处在那条分支），如图红圈所示部位，选择你想要切换的分支，然后 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/6678ecf9283ace1783e83e184847a29.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/afbbe9a835629f522d0b02024fe2c11b.png"></p><p>或者在 log 窗口，右键点击分支，选择 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7ab6ab48e9b5a42009757b8b17b901f0.png"></p><h3 id="9-合并分支-正常合并"><a href="#9-合并分支-正常合并" class="headerlink" title="9. 合并分支 (正常合并)"></a>9. 合并分支 (正常合并)</h3><p>先在 hot-fix 分支修改 HelloGit 类，并将其提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/41667203b7e067b59d1310cce4d92b15.png"></p><p>然后切换到 master 分支，右下角的 hot-fix 会变为 master：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f183b86164b0e00e9d6e8c8c9a4a17da.png"></p><p>然后，点击 IDEA 窗口的右下角的 master，将 hot-fix 分支合并到当前 master 分支。选择 hot-fix-&gt;Merge into Current</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fff1d4e014223aa2cc70f0fdc237f350.png"></p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/271421c28750e86e69accd6ac687490c.png"></p><h3 id="10-合并分支-冲突合并"><a href="#10-合并分支-冲突合并" class="headerlink" title="10. 合并分支 (冲突合并)"></a>10. 合并分支 (冲突合并)</h3><p>分别在 master，hot-fix 分支修改 HelloGit 类同一行，并提交，故意制作冲突：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/53daad680bc796069dc1ce61682d4abc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f8fcf275169cdec742d31ce85ce20d7f.png"></p><p>切换到 master 分支，将 hot-fix 的合并到 master 分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1573ef3ec85b85c4215189d74065012.png"></p><p>冲突产生，需要人工解决：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb3804e00dccfa2658aa33c972d8996e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/511c531d359729b40f0850a4c9e0398.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eafebea94008b4f1f0ae15f8b2092919.png"></p><p>代码冲突解决，将代码提交本地库后，如图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/15a9058f7f35112b8605cd69aaf42e35.png"></p><h2 id="六、IDEA集成GitHub"><a href="#六、IDEA集成GitHub" class="headerlink" title="六、IDEA集成GitHub"></a>六、IDEA集成GitHub</h2><h3 id="1-设置-GitHub-账号"><a href="#1-设置-GitHub-账号" class="headerlink" title="1. 设置 GitHub 账号"></a>1. 设置 GitHub 账号</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 GitHub，添加 GitHub 账号：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/00572764f1ed257dbc2d0f668434e6a0.png"></p><p>由于网络问题，会时常登陆不了：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3084475acd640b1adf621688462a1504.png"></p><p>解决方法：可通过 Token 登陆。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/75ed9ef7614c18c244456c4089dfde6.png"></p><p>登陆 Github 网站，<strong>获取 Token</strong>，操作步骤看下图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1d162ac7e37a01549448032011f2a62.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9b2489e068b004bee03a227760248edb.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/200c556f6f0b6d44c442b58d6e8bb7ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/81a82fb47421c0a802cd1cfad7297e43.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f596f2f68d50d277eefe1a4e6035d2d.png"></p><p>将生成的 token 用来 IDEA 登录。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/704eafd9157658a0be35b081c3530ced.png"></p><h3 id="2-分享项目到-GitHub"><a href="#2-分享项目到-GitHub" class="headerlink" title="2. 分享项目到 GitHub"></a>2. 分享项目到 GitHub</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e057d2e660c2033ef9eae0c638aee2bc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a5ba3e09a890113b94420c3939dac239.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/44b2419dd2eebc2c053fb642188e8909.png"></p><h3 id="3-推送代码到GitHub远程库"><a href="#3-推送代码到GitHub远程库" class="headerlink" title="3. 推送代码到GitHub远程库"></a>3. 推送代码到GitHub远程库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/84baeaa175c6faa3ff538e0313187eff.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1ee51e1ed781404a93655f1ad10bd9ca.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bb9689e1fc2e1167e68ef39f73f28af7.png"></p><p>注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ <strong>因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！</strong></p><h3 id="4-拉取GitHub远程库代码合并本地库"><a href="#4-拉取GitHub远程库代码合并本地库" class="headerlink" title="4. 拉取GitHub远程库代码合并本地库"></a>4. 拉取GitHub远程库代码合并本地库</h3><p>右键点击项目，可以将远程仓库的内容 pull 到本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/193d00830bc1636e2ae2640b749b9899.png"></p><p>注意： pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p><h3 id="5-克隆代码到本地"><a href="#5-克隆代码到本地" class="headerlink" title="5. 克隆代码到本地"></a>5. 克隆代码到本地</h3><p>在菜单栏的 File-&gt;Close Project-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f436b8f9156e5e5ce8c0e2b3b5fe3639.png"></p><p>或者在菜单栏 VCS-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/63f9691dd0a7627bd44a125942be7f31.png"></p><h2 id="七、Gitee使用"><a href="#七、Gitee使用" class="headerlink" title="七、Gitee使用"></a>七、Gitee使用</h2><h3 id="1-Gitee简介-amp-创建远程库"><a href="#1-Gitee简介-amp-创建远程库" class="headerlink" title="1. Gitee简介 &amp; 创建远程库"></a>1. Gitee简介 &amp; 创建远程库</h3><h4 id="1-1-码云简介"><a href="#1-1-码云简介" class="headerlink" title="1.1 码云简介"></a>1.1 码云简介</h4><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况， 大家也可以使用国内的项目托管网站 - 码云。</p><p>码云是开源中国推出的基于 Git 的代码托管服务中心， 网址是 <a href="https://gitee.com/">https://gitee.com/</a> ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好，它是最好的选择。</p><p>而且，Gitee的操作和GitHub基本一样。</p><h4 id="1-2-创建远程库"><a href="#1-2-创建远程库" class="headerlink" title="1.2 创建远程库"></a>1.2 创建远程库</h4><p>跟 Github 的类似。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c8c01b7813e8578423ee2d790a580ee4.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/16341a72fa521e904f7b5a5489d4c693.png"></p><p>另外，可以从 GitHub 与 GitLab 中导入仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c5daf945afdd2f2836c1e9e20e8e389b.png"></p><p>点击刷新按钮，从GitHub获取更新</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3441eab01ee412c90cb4f2be908833f.png" alt="3441eab01ee412c90cb4f2be908833f"></p><h3 id="2-IDEA-集成-Gitee-码云"><a href="#2-IDEA-集成-Gitee-码云" class="headerlink" title="2. IDEA 集成 Gitee 码云"></a>2. IDEA 集成 Gitee 码云</h3><p>首先，要在 IDEA 安装 Gitee 插件。</p><p>在菜单栏选 File-&gt;Settings-&gt;Plugins，搜 Gitee。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0241b8536ebed6fb08dcf04804c62cb0.png"></p><p>安装插件成功后，重启 IDEA。</p><p>功能跟在 IDEA 的 Github 插件，功能类似，如添加 Gitee 账号等，可参考前文 IDEA 的 Github 插件，触类旁通。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/87e35b8ee0fd1fd4136f2b2727cbf02a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/89e7174170b4ecc1c4ba896e3f1c9ad9.png"></p><h2 id="八、GitLab"><a href="#八、GitLab" class="headerlink" title="八、GitLab"></a>八、GitLab</h2><h3 id="1-GitLab简介-amp-安装环境准备"><a href="#1-GitLab简介-amp-安装环境准备" class="headerlink" title="1. GitLab简介 &amp; 安装环境准备"></a>1. GitLab简介 &amp; 安装环境准备</h3><h4 id="1-1-GitLab-简介"><a href="#1-1-GitLab-简介" class="headerlink" title="1.1 GitLab 简介"></a>1.1 GitLab 简介</h4><p>GitLab 是由 GitLab Inc. 开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有 wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。（可搭建局域网 Git 仓库）。</p><p>GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM， Sony， JülichResearchCenter， NASA， Alibaba，Invincea， O’ReillyMedia， Leibniz-Rechenzentrum(LRZ)， CERN， SpaceX 等组织使用。</p><h4 id="1-2-GitLab-官网地址"><a href="#1-2-GitLab-官网地址" class="headerlink" title="1.2 GitLab 官网地址"></a>1.2 GitLab 官网地址</h4><p><a href="https://about.gitlab.com/">官网地址</a></p><p><a href="https://about.gitlab.com/installation/">安装说明</a></p><h4 id="1-3-GitLab-安装准备"><a href="#1-3-GitLab-安装准备" class="headerlink" title="1.3 GitLab 安装准备"></a>1.3 GitLab 安装准备</h4><ol><li> 准备一个系统为 CentOS7 以上版本的服务器， 要求内存 4G，磁盘 50G。</li><li> 关闭防火墙， 并且配置好主机名和 IP，保证服务器可以上网。</li><li> 此教程使用虚拟机：主机名： gitlab-server <code>修改/etc/hostname文件为gitlab-server</code>IP 地址： 192.168.6.200(修改相对应文件)</li><li> Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。<a href="https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm">下载地址</a>。注：资料里提供了此 rpm 包，直接将此包上传到服务器 / opt/module 目录下即可。</li></ol><h3 id="2-GitLab-安装-amp-初始化服务-amp-启动服务"><a href="#2-GitLab-安装-amp-初始化服务-amp-启动服务" class="headerlink" title="2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务"></a>2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务</h3><h4 id="2-1-编写安装脚本"><a href="#2-1-编写安装脚本" class="headerlink" title="2.1 编写安装脚本"></a>2.1 编写安装脚本</h4><p>安装 gitlab 步骤比较繁琐，因此我们可以参考<a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh">官网编写 gitlab 的安装脚本</a>。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@gitlab-server module]# <span class="hljs-keyword">vim</span> gitlab-install.<span class="hljs-keyword">sh</span><br>sudo rpm -ivh /<span class="hljs-keyword">opt</span>/module/gitlab-<span class="hljs-keyword">ce</span>-<span class="hljs-number">13.10</span>.<span class="hljs-number">2</span>-<span class="hljs-keyword">ce</span>.<span class="hljs-number">0</span>.el7.x86_64.rpm<br><br>sudo yum install -<span class="hljs-keyword">y</span> curl policycoreutils-<span class="hljs-keyword">python</span> openssh-server cronie<br><br>sudo lokkit -s http -s ssh<br><br>sudo yum install -<span class="hljs-keyword">y</span> postfix<br><br>sudo service postfix start<br><br>sudo chkconfig postfix <span class="hljs-keyword">on</span><br><br>curl http<span class="hljs-variable">s:</span>//packages.gitlab.<span class="hljs-keyword">com</span>/install/repositories/gitlab/gitlabce/script.rpm.<span class="hljs-keyword">sh</span> | sudo bash<br><br>sudo EXTERNAL_URL=<span class="hljs-string">&quot;http://gitlab.example.com&quot;</span> yum -<span class="hljs-keyword">y</span> install gitlabce<br><br></code></pre></td></tr></table></figure><p>给脚本增加执行权限</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@gitlab-server module]<span class="hljs-comment"># chmod +x gitlab-install.sh</span><br>[root@gitlab-server module]<span class="hljs-comment"># ll</span><br>总用量 403104<br>-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 412774002 </span>4 月<span class="hljs-number"> 7 </span>15:47 gitlab-ce-13.10.2-<br>ce.0.el7.x86_64.rpm<br>-rwxr-xr-x.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 416 </span>4 月<span class="hljs-number"> 7 </span>15:49 gitlab-install.sh<br><br></code></pre></td></tr></table></figure><p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@gitlab-server <span class="hljs-keyword">module</span>]# ./gitlab-install.sh<br>警告： /opt/<span class="hljs-keyword">module</span>/gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7.x86_64.rpm: 头 V4<br>RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY<br>准备中... #################################<br>[<span class="hljs-number">100</span>%]<br>正在升级/安装...<br><span class="hljs-number">1</span>:gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7<br>################################# [<span class="hljs-number">100</span>%]<br>。 。 。 。 。 。<br><br></code></pre></td></tr></table></figure><h4 id="2-2-初始化-GitLab-服务"><a href="#2-2-初始化-GitLab-服务" class="headerlink" title="2.2 初始化 GitLab 服务"></a>2.2 初始化 GitLab 服务</h4><p>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">[root<span class="hljs-variable">@gitlab</span><span class="hljs-operator">-</span>server <span class="hljs-keyword">module</span>]# gitlab<span class="hljs-operator">-</span>ctl reconfigure<br>。 。 。 。 。 。<br><span class="hljs-keyword">Running</span> handlers:<br><span class="hljs-keyword">Running</span> handlers complete<br>Chef Client finished, <span class="hljs-number">425</span><span class="hljs-operator">/</span><span class="hljs-number">608</span> resources updated <span class="hljs-keyword">in</span> <span class="hljs-number">03</span> minutes <span class="hljs-number">08</span><br>seconds<br>gitlab Reconfigured<span class="hljs-operator">!</span><br><br></code></pre></td></tr></table></figure><h4 id="2-3-启动-GitLab-服务"><a href="#2-3-启动-GitLab-服务" class="headerlink" title="2.3 启动 GitLab 服务"></a>2.3 启动 GitLab 服务</h4><p>执行以下命令启动 GitLab 服务，如需停止，执行 <code>gitlab-ctl stop</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@gitlab-server</span> <span class="hljs-string">module</span>]<span class="hljs-comment"># gitlab-ctl start</span><br><span class="hljs-attr">ok: run: alertmanager:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6812</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: gitaly:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6740</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-monitor:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6765</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-workhorse:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6722</span><span class="hljs-string">)</span> <span class="hljs-string">136s</span><br><span class="hljs-attr">ok: run: logrotate:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5994</span><span class="hljs-string">)</span> <span class="hljs-string">197s</span><br><span class="hljs-attr">ok: run: nginx:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5930</span><span class="hljs-string">)</span> <span class="hljs-string">203s</span><br><span class="hljs-attr">ok: run: node-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6234</span><span class="hljs-string">)</span> <span class="hljs-string">185s</span><br><span class="hljs-attr">ok: run: postgres-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6834</span><span class="hljs-string">)</span> <span class="hljs-string">133s</span><br><span class="hljs-attr">ok: run: postgresql:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5456</span><span class="hljs-string">)</span> <span class="hljs-string">257s</span><br><span class="hljs-attr">ok: run: prometheus:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6777</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: redis:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5327</span><span class="hljs-string">)</span> <span class="hljs-string">263s</span><br><span class="hljs-attr">ok: run: redis-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6391</span><span class="hljs-string">)</span> <span class="hljs-string">173s</span><br><span class="hljs-attr">ok: run: sidekiq:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5797</span><span class="hljs-string">)</span> <span class="hljs-string">215s</span><br><span class="hljs-attr">ok: run: unicorn:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5728</span><span class="hljs-string">)</span> <span class="hljs-string">221s</span><br><br></code></pre></td></tr></table></figure><h3 id="3-GitLab-登录-amp-创建远程库"><a href="#3-GitLab-登录-amp-创建远程库" class="headerlink" title="3. GitLab 登录 &amp; 创建远程库"></a>3. GitLab 登录 &amp; 创建远程库</h3><h4 id="3-1-登录-GitLab"><a href="#3-1-登录-GitLab" class="headerlink" title="3.1 登录 GitLab"></a>3.1 登录 GitLab</h4><p>使用主机名或者 IP 地址即可访问 GitLab 服务。可配一下 windows 的 hosts 文件（C:\Windows\System32\drivers\etc）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/048956890f1e644fb77e8d58092a8b6d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1870c658dcabcf08fbc3b5b9fa6b2243.png"></p><p>首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。</p><p>然后使用修改后的密码登录 GitLab。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5608650ec5e913d5ab549f30fbb477d3.png"></p><p>GitLab 登录成功。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3231f6dd1a07f90326ec0506eaae747f.png"></p><h4 id="3-2-创建远程库"><a href="#3-2-创建远程库" class="headerlink" title="3.2 创建远程库"></a>3.2 创建远程库</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2ab639dfaa57cd499133c2c4cde1222a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f135a7b76c745c3aeef9034a82c8afaf.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5ff82d173fe047244945c8cd255a4b33.png"></p><h3 id="4-IDEA-集成-GitLab"><a href="#4-IDEA-集成-GitLab" class="headerlink" title="4. IDEA 集成 GitLab"></a>4. IDEA 集成 GitLab</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f34175126922c56c158f466dd4d665c.png"></p><p>接下来插件配置，Git 操作等与 Github、Gitee 的 IDEA 插件大同小异，不再赘述，自己触类旁通吧！</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用方法</title>
    <link href="/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用方法"><a href="#Hexo使用方法" class="headerlink" title="Hexo使用方法"></a>Hexo使用方法</h1><h2 id="一、搭建Hexo博客"><a href="#一、搭建Hexo博客" class="headerlink" title="一、搭建Hexo博客"></a>一、搭建Hexo博客</h2><h3 id="1-下载Node-js"><a href="#1-下载Node-js" class="headerlink" title="1. 下载Node.js"></a>1. 下载Node.js</h3><p>去<a href="https://nodejs.org/en/">Node.js官网</a>下载Node.js稳定版本</p><h3 id="2-更换下载cnpm并更换淘宝源"><a href="#2-更换下载cnpm并更换淘宝源" class="headerlink" title="2. 更换下载cnpm并更换淘宝源"></a>2. 更换下载cnpm并更换淘宝源</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="3-Windows特殊操作"><a href="#3-Windows特殊操作" class="headerlink" title="3. Windows特殊操作"></a>3. Windows特殊操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set-ExecutionPolicy RemoteSigned<br></code></pre></td></tr></table></figure><p>更改策略，放行cnpm</p><h3 id="4-安装Hexo博客框架"><a href="#4-安装Hexo博客框架" class="headerlink" title="4. 安装Hexo博客框架"></a>4. 安装Hexo博客框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="5-建立博客文件夹"><a href="#5-建立博客文件夹" class="headerlink" title="5. 建立博客文件夹"></a>5. 建立博客文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir blog<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，从这里往下，所有步骤都是在<code>blog</code>文件夹下的。</strong></p><h3 id="6-生成Hexo博客"><a href="#6-生成Hexo博客" class="headerlink" title="6. 生成Hexo博客"></a>6. 生成Hexo博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hexo init<br></code></pre></td></tr></table></figure><h2 id="二、使用Hexo"><a href="#二、使用Hexo" class="headerlink" title="二、使用Hexo"></a>二、使用Hexo</h2><h3 id="1-本地启动博客"><a href="#1-本地启动博客" class="headerlink" title="1. 本地启动博客"></a>1. 本地启动博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>hexo start</p><h3 id="2-新建一篇文章"><a href="#2-新建一篇文章" class="headerlink" title="2. 新建一篇文章"></a>2. 新建一篇文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &quot;文章名&quot;<br></code></pre></td></tr></table></figure><p>然后就可以在<code>blog\source\_posts</code>路径下看见生成的文章。</p><h3 id="3-Hexo-清理"><a href="#3-Hexo-清理" class="headerlink" title="3. Hexo 清理"></a>3. Hexo 清理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo-生成"><a href="#4-Hexo-生成" class="headerlink" title="4. Hexo 生成"></a>4. Hexo 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>hexo generate</p><h2 id="三、将博客部署到Github上"><a href="#三、将博客部署到Github上" class="headerlink" title="三、将博客部署到Github上"></a>三、将博客部署到Github上</h2><p>将博客部署到Github上，这样不用备案也不用云服务器，比较方便。</p><h3 id="1-Github上新建仓库"><a href="#1-Github上新建仓库" class="headerlink" title="1. Github上新建仓库"></a>1. Github上新建仓库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b39cf6827134af18affb5fbc934318e.png"></p><p>需要注意的是，这里仓库名<strong>必须</strong>是<code>用户名.github.io</code>。</p><h3 id="2-安装Git部署插件"><a href="#2-安装Git部署插件" class="headerlink" title="2. 安装Git部署插件"></a>2. 安装Git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="3-在-config-yml更改配置"><a href="#3-在-config-yml更改配置" class="headerlink" title="3. 在_config.yml更改配置"></a>3. 在_config.yml更改配置</h3><p>在<code>_config.yml</code>的<code>deploy:</code>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">type: git<br>repo: https://github.com/JYGQAQ/JYGQAQ.github.io<br>branch: master<br></code></pre></td></tr></table></figure><h3 id="4-Hexo部署到远端"><a href="#4-Hexo部署到远端" class="headerlink" title="4. Hexo部署到远端"></a>4. Hexo部署到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>deploy : 部署</p><p><strong>若此处出现<code>Error： Spawn failed</code></strong></p><h4 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a>解决方法一：</h4><p><strong>可以尝试将<code>_config.yml</code>中的<code>repo</code>改为<code>ssh</code>方式</strong></p><p>原因如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git不再支持用户名密码验证了，其实改一下仓库地址就可以了。<br>原来用的https的仓库，改成ssh的仓库地址就行了。<br></code></pre></td></tr></table></figure><h4 id="解决方法二："><a href="#解决方法二：" class="headerlink" title="解决方法二："></a>解决方法二：</h4><ol><li><p>打开GitHub主页，点击头像找到Settings</p></li><li><p>在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请</p></li><li><p>Scopes那里可以全选</p></li><li><p>在mac上打开keychain access，搜索GitHub，输入刚刚的Token(需要注意的是token生成后一定要复制，刷新github就再也看不到了，需要重新生成)</p></li><li><p>执行以下命令<br> <code>$ git remote add origin https://“刚刚得到的Token“@github.com/“User名”/“仓库名（XXX.github.io）”.git</code></p></li><li><p>修改Hexo的 config.yml配置文件</p></li></ol>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">deploy:<br>  type: git<br>  repo: https:<span class="hljs-regexp">//</span><span class="hljs-string">&quot;Token&quot;</span>@github.com<span class="hljs-regexp">/“用户名”/</span>“仓库名（XXX.github.io）”.git<br>  branch: master<br></code></pre></td></tr></table></figure><h3 id="5-访问博客"><a href="#5-访问博客" class="headerlink" title="5. 访问博客"></a>5. 访问博客</h3><p>博客的网址就是仓库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jygqaq.github.io<br></code></pre></td></tr></table></figure><p>由于域名没有大小写，所以是小写。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><h3 id="1-克隆主题仓库"><a href="#1-克隆主题仓库" class="headerlink" title="1. 克隆主题仓库"></a>1. 克隆主题仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:jerryc127/hexo-theme-butterfly.git themes/butterfly<br></code></pre></td></tr></table></figure><p>把项目clone到themes目录下的butterfly文件夹</p><p>使用butterfly还需要安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-pug hexo-renderer-stylus --save<br></code></pre></td></tr></table></figure><h3 id="2-更改Hexo配置文件"><a href="#2-更改Hexo配置文件" class="headerlink" title="2. 更改Hexo配置文件"></a>2. 更改Hexo配置文件</h3><p>更改<code>_config.yml</code>配置文件中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: butterfly<br></code></pre></td></tr></table></figure><h3 id="3-清理Hexo"><a href="#3-清理Hexo" class="headerlink" title="3. 清理Hexo"></a>3. 清理Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo生成"><a href="#4-Hexo生成" class="headerlink" title="4. Hexo生成"></a>4. Hexo生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="5-Hexo-Start"><a href="#5-Hexo-Start" class="headerlink" title="5. Hexo Start"></a>5. Hexo Start</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>需要注意的是，如果使用<code>fluid</code>主题，那么<code>themes/fluid/_config.yml</code>比<code>themes/fluid/_config.fluid.yml</code>优先级要高。</p><h2 id="五、迁移博客"><a href="#五、迁移博客" class="headerlink" title="五、迁移博客"></a>五、迁移博客</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h3><p>根据本博客重新配置环境</p><h3 id="2-更换文件"><a href="#2-更换文件" class="headerlink" title="2. 更换文件"></a>2. 更换文件</h3><p>需要跟换以下文件：</p><ul><li><code>_config.yml</code></li><li><code>package.json</code></li><li><code>scaffolds</code></li><li><code>source</code></li><li><code>theme</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
