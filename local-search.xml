<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="一、Linux基本简介"><a href="#一、Linux基本简介" class="headerlink" title="一、Linux基本简介"></a>一、Linux基本简介</h2><h3 id="1-1-Linux的应用领域"><a href="#1-1-Linux的应用领域" class="headerlink" title="1.1 Linux的应用领域"></a>1.1 Linux的应用领域</h3><h4 id="1-1-1-个人桌面应用领域"><a href="#1-1-1-个人桌面应用领域" class="headerlink" title="1.1.1 个人桌面应用领域"></a>1.1.1 个人桌面应用领域</h4><p>此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora[fɪˈdɔ:rə] 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高。</p><h4 id="1-1-2-服务器应用领域"><a href="#1-1-2-服务器应用领域" class="headerlink" title="1.1.2 服务器应用领域"></a>1.1.2 服务器应用领域</h4><p>linux在服务器领域的应用是最强的。<br>linux免费、稳定、高效等特点在这里得到了很好的体现，近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛。</p><h4 id="1-1-3-嵌入式应用领域"><a href="#1-1-3-嵌入式应用领域" class="headerlink" title="1.1.3 嵌入式应用领域"></a>1.1.3 嵌入式应用领域</h4><p>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高。</p><p>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后在<strong>物联网</strong>中应用会更加广泛。</p><h3 id="1-2-学习LINUX的阶段"><a href="#1-2-学习LINUX的阶段" class="headerlink" title="1.2 学习LINUX的阶段"></a>1.2 学习LINUX的阶段</h3><p>linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux,很多软件公司考虑到开发成本都首选linux,在中国软件公司得到广泛的使用。</p><p>我个人认为学习linux流程为:<br>第 1 阶段：linux环境下的基本操作命令，包括 文件操作命令(rmmkdirchmod,chown) 编辑工具使用（vivim）linux用户管理(useradduserdelusermod)等<br>第 2 阶段：linux的各种配置（环境变量配置，网络配置，服务配置）<br>第 3 阶段：linux下如何搭建对应语言的开发环境（大数据，JavaEE,Python等）<br>第 4 阶段：能编写shell脚本，对Linux服务器进行维护。<br>第 5 阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。<br>第 6 阶段：深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法。</p><h3 id="1-3-LINUX的学习方法和建议"><a href="#1-3-LINUX的学习方法和建议" class="headerlink" title="1.3 LINUX的学习方法和建议"></a>1.3 LINUX的学习方法和建议</h3><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) 高效而愉快的学习<br><span class="hljs-symbol">2 </span>) 先建立一个整体框架，然后细节<br><span class="hljs-symbol">3 </span>) 不需要掌握所有的Linux指令，要学会查询手册和百度<br><span class="hljs-symbol">4 </span>) 先knowhow,再knowwhy<br><span class="hljs-symbol">5 </span>) 计算机是一门”做中学” 的学科 ,不是会了再做，而是做了才会.<br><span class="hljs-symbol">6 </span>) 适当的囫囵吞枣<br><span class="hljs-symbol">7 </span>) Linux不是编程，重点是实际操作，各种常用指令要玩的溜<br></code></pre></td></tr></table></figure><h2 id="二、LINUX-入门"><a href="#二、LINUX-入门" class="headerlink" title="二、LINUX 入门"></a>二、LINUX 入门</h2><h3 id="2-1-LINUX介绍"><a href="#2-1-LINUX介绍" class="headerlink" title="2.1 LINUX介绍"></a>2.1 LINUX介绍</h3><p>1 ) Linux怎么读 【里纽克斯，利尼克斯，里纳克斯】<br>2 ) Linux是一款操作系统，免费，开源，安全，高效，稳定， 处理高并发非常强悍，现在很多的企业级的项目都部署到Linux/unix服务器运行。<br>3 ) Linux创始人 </p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221172406244.png" alt="linus"></p><p>4 ) Linux的吉祥物</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221172234551.png" alt="Tux"></p><p>5 ) Linux的主要的发行版:Ubuntu、RedHat、CentOS等，<a href="https://www.kernel.org/">Linux内核源码下载地址</a>，可以将源码下载下来查看。</p><h3 id="2-2Unix与Linux的关系"><a href="#2-2Unix与Linux的关系" class="headerlink" title="2.2Unix与Linux的关系"></a>2.2Unix与Linux的关系</h3><h4 id="2-2-1-Unix来源"><a href="#2-2-1-Unix来源" class="headerlink" title="2.2.1 Unix来源"></a>2.2.1 Unix来源</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/unix%E6%9D%A5%E6%BA%90.jpg" alt="Unix来源"></p><h4 id="2-2-2-Linux来源"><a href="#2-2-2-Linux来源" class="headerlink" title="2.2.2 Linux来源"></a>2.2.2 Linux来源</h4><p>Richard提出了伟大的GNU计划，大大促进了开源事业。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E6%9D%A5%E6%BA%90.jpg" alt="Linux来源"></p><h4 id="2-2-3-Linux与Unix关系"><a href="#2-2-3-Linux与Unix关系" class="headerlink" title="2.2.3 Linux与Unix关系"></a>2.2.3 Linux与Unix关系</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E4%B8%8EUnix%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Unix关系"></p><h4 id="2-2-4-Linux与Windows关系"><a href="#2-2-4-Linux与Windows关系" class="headerlink" title="2.2.4 Linux与Windows关系"></a>2.2.4 Linux与Windows关系</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/Linux%E4%B8%8EWindows%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Windows关系"></p><h2 id="三、VM-和-LINUX-系统-CENTOS-安装"><a href="#三、VM-和-LINUX-系统-CENTOS-安装" class="headerlink" title="三、VM 和 LINUX 系统 (CENTOS) 安装"></a>三、VM 和 LINUX 系统 (CENTOS) 安装</h2><h3 id="3-1-安装VM和CENTOS"><a href="#3-1-安装VM和CENTOS" class="headerlink" title="3.1 安装VM和CENTOS"></a>3.1 安装VM和CENTOS</h3><p>学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。</p><p>1 )先安装virtual machine 15.5<br>2 )再安装Linux(CentOS 7.6 \ CentOS 8.1)<br>3 )原理示意图，这里我们画图说明一下 VM 和 CentOS的关系。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221184653303.png"></p><h3 id="3-2-安装步骤"><a href="#3-2-安装步骤" class="headerlink" title="3.2 安装步骤"></a>3.2 安装步骤</h3><p>1 ) 去BIOS里修改设置开启虚拟化设备支持<br>2 ) 安装虚拟机软件(VM 15.5)<br>3 ) 创建虚拟机(空间)<br>4 ) 安装系统(CentOS 6.8 )</p><h3 id="3-3-虚拟机网络连接三种方式"><a href="#3-3-虚拟机网络连接三种方式" class="headerlink" title="3.3 虚拟机网络连接三种方式"></a>3.3 虚拟机网络连接三种方式</h3><p>虚拟机网络连接有三种方式：桥接模式、NAT模式和主机模式。</p><p>1.桥接模式：虚拟机系统可以与外部系统互相通讯，但是由于桥接模式占用与物理机同一级的ip地址，所以如果当前局域网ip地址耗尽，容易造成ip冲突</p><p>2.NAT模式：网络地址转换模式，虚拟机系统可以向外部系统发消息，但是外部系统不可以向虚拟机系统发消息（如果没有内网穿透相关功能的话），NAT模式不会造成ip冲突。</p><p>3.主机模式：可以成为单机模式，不与外部系统连接网络，是一个独立的系统。</p><h3 id="3-4-虚拟机克隆"><a href="#3-4-虚拟机克隆" class="headerlink" title="3.4 虚拟机克隆"></a>3.4 虚拟机克隆</h3><p>如果已经安装了一台Linux操作系统，此时还需要更多，这时可以使用虚拟机克隆操作，有以下两种方式：</p><p>方式1：直接拷贝一份安装好的虚拟机文件</p><p>方式2：使用vmware的克隆操作(需要先关闭Linux系统)</p><h3 id="3-5-虚拟机快照"><a href="#3-5-虚拟机快照" class="headerlink" title="3.5 虚拟机快照"></a>3.5 虚拟机快照</h3><p>如果在使用虚拟机系统的时候（比如Linux），如果你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware特提供了这样的功能，叫快照管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">应用实例：<br>1.安装好系统以后，先做一个快照A<br>2.进入系统，创建一个文件夹，在保存一个快照B<br>3.回到系统刚刚安装好的状态，即快照A<br>4A试试看，是否还能再次回到快照B（答案是肯定的）<br></code></pre></td></tr></table></figure><p>需要注意的是，快照底层是使用指针实现的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221193015812.png"></p><h3 id="3-6-虚拟机迁移删除"><a href="#3-6-虚拟机迁移删除" class="headerlink" title="3.6 虚拟机迁移删除"></a>3.6 虚拟机迁移删除</h3><p>虚拟机系统的本质就是文件。因此虚拟机系统的迁移很方便，可以把安装好的虚拟机系统这个文件夹整体<strong>拷贝或者剪切</strong>到另外位置使用。同样地，虚拟机系统删除也很简单，用vmware进行移除（菜单 -&gt; 从磁盘删除），或者直接手动删除虚拟系统对应的文件夹即可。</p><h3 id="3-7-vmtools"><a href="#3-7-vmtools" class="headerlink" title="3.7 vmtools"></a>3.7 vmtools</h3><h4 id="3-7-1-vmtools作用"><a href="#3-7-1-vmtools作用" class="headerlink" title="3.7.1 vmtools作用"></a>3.7.1 vmtools作用</h4><ol><li>vmtools安装后，可以让我们在windows下跟好的管理vm虚拟机</li><li>可以设置windows和centos的共享文件夹</li></ol><h4 id="3-7-2-vmtools的安装步骤"><a href="#3-7-2-vmtools的安装步骤" class="headerlink" title="3.7.2 vmtools的安装步骤"></a>3.7.2 vmtools的安装步骤</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.进入centos<br><span class="hljs-number">2</span>.点击vm菜单的 -&gt; install vmwaretools<br><span class="hljs-number">3</span>.centos会出现一个vm的安装包，xx<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br><span class="hljs-number">4</span>.拷贝到/opt,使用解压命令tar -zxvf xx<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>, 得到一个安装文件<br><span class="hljs-number">5</span>.进入该vm解压的目录 ，该文件在/opt目录下<br><span class="hljs-number">6</span>.安装 ./vmware-install<span class="hljs-selector-class">.pl</span><br><span class="hljs-number">7</span>.全部使用默认设置即可<br><span class="hljs-number">8</span>.需要reboot重新启动即可生效<br><span class="hljs-number">9</span>.注意：安装vmtools，需要有gcc<br></code></pre></td></tr></table></figure><h4 id="3-7-3-使用vmtools来设置windows和linux的共享文件夹"><a href="#3-7-3-使用vmtools来设置windows和linux的共享文件夹" class="headerlink" title="3.7.3 使用vmtools来设置windows和linux的共享文件夹"></a>3.7.3 使用vmtools来设置windows和linux的共享文件夹</h4><p>1.在windows中新建一个文件夹</p><p>2.在vmware中设置共享文件夹</p><p>3.在Centos的/mnt/hgfs/下可以找到共享文件夹</p><h2 id="四、Linux-的目录结构"><a href="#四、Linux-的目录结构" class="headerlink" title="四、Linux 的目录结构"></a>四、Linux 的目录结构</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><p>linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p><p>深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下，记住一句经典的话：<strong>在Linux世界里，一切皆文件。</strong>硬件都当做文件来管理。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221203356156.png"></p><h3 id="4-2-目录结构的具体介绍"><a href="#4-2-目录结构的具体介绍" class="headerlink" title="4.2 目录结构的具体介绍"></a>4.2 目录结构的具体介绍</h3><ul><li><code>/bin：</code> 是Binary的缩写，这个目录存放着最经常使用的命令(命令其实就是一个个可执行文件)。</li><li><code>/sbin</code>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><code>/home：</code>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。(对应MacOS中的<code>/Users</code>目录)</li><li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><code>/lib</code>：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li><code>/lost+found</code>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><code>/etc</code>：所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库 my.conf。</li><li><code>/boot</code>:存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><code>/proc</code>：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。该目录不要动。</li><li><code>/srv</code>：service的缩写，该目录存放一些服务启动之后需要提供的数据。该目录不要动。</li><li><code>/sys</code>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。该目录不要动。</li><li><code>/tmp</code>：这个目录是用来存放一些临时文件的。</li><li><code>/dev</code>：类似windows的设备管理器，把所有的<strong>硬件</strong>用<strong>文件的形式存储</strong>。</li><li><code>/media</code>:linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下(Linux把这些设备映射成文件进行管理)。</li><li><code>/mnt</code>:系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</li><li><code>/opt</code>:这是给主机额外安装软件所<strong>摆放</strong>的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</li><li><code>/usr/local</code>：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li><li><code>/var</code>:这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li><li><code>/selinux</code>：SELinux是一种安全子系统，它能控制程序只能访问特定文件。</li></ul><h4 id="4-2-1-opt-amp-usr-local-amp-usr-区别"><a href="#4-2-1-opt-amp-usr-local-amp-usr-区别" class="headerlink" title="4.2.1 /opt &amp; /usr/local &amp; /usr 区别"></a>4.2.1 /opt &amp; /usr/local &amp; /usr 区别</h4><p><code>/opt</code>这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。<strong>相当于windows中的D:/Software。</strong></p><p><code>/usr/local</code>这里主要存放那些手动安装的软件，即不是通过apt-get等自动安装的软件，/usr/local目录下的一些子目录往往都是被加入到PATH环境变量中的。 <strong>相当于windows中的C:/Program Files</strong>。</p><p><code>/usr</code>：系统级的目录，可以理解为C:/Windows/，<code>/usr/lib</code>理解为C:/Windows/System32。</p><p><code>/usr/src</code>：系统级的源码目录。<code>/usr/local/src</code>：用户级的源码目录。</p><h3 id="4-3-Linux目录总结一下"><a href="#4-3-Linux目录总结一下" class="headerlink" title="4.3 Linux目录总结一下"></a>4.3 Linux目录总结一下</h3><ol><li>linux的目录中有且只要一个根目录 /</li><li>linux的各个目录存放的内容是规划好，不用乱放文件。</li><li>linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。</li></ol><p>linux的各个文件目录下存放什么内容，必须有一个认识，你脑海中应该有一颗linux目录树</p><h2 id="五、远程登录Linux系统"><a href="#五、远程登录Linux系统" class="headerlink" title="五、远程登录Linux系统"></a>五、远程登录Linux系统</h2><h3 id="5-1-SSH-三步解决免密登录"><a href="#5-1-SSH-三步解决免密登录" class="headerlink" title="5.1 SSH 三步解决免密登录"></a>5.1 SSH 三步解决免密登录</h3><h4 id="5-1-1-客户端生成公私钥"><a href="#5-1-1-客户端生成公私钥" class="headerlink" title="5.1.1 客户端生成公私钥"></a>5.1.1 客户端生成公私钥</h4><p>本地客户端生成公私钥：（一路回车默认即可）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>上面这个命令会在用户目录. ssh 文件夹下创建公私钥</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ls</span><br></code></pre></td></tr></table></figure><p>下创建两个密钥：</p><ol><li> id_rsa （私钥）</li><li> id_rsa.pub (公钥)</li></ol><h4 id="5-1-2-上传公钥到服务器"><a href="#5-1-2-上传公钥到服务器" class="headerlink" title="5.1.2 上传公钥到服务器"></a>5.1.2 上传公钥到服务器</h4><p>这里测试用的服务器地址为：192.168.235.22<br>用户为：root</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ssh-<span class="hljs-keyword">copy</span>-id -i ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub root@<span class="hljs-number">192.168</span>.<span class="hljs-number">235.22</span><br></code></pre></td></tr></table></figure><p>上面这条命令是写到服务器上的 ssh 目录下去了</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cat authorized_keys</span><br></code></pre></td></tr></table></figure><p>可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。</p><h4 id="5-1-3-测试免密登录"><a href="#5-1-3-测试免密登录" class="headerlink" title="5.1.3 测试免密登录"></a>5.1.3 测试免密登录</h4><p>客户端通过 ssh 连接远程服务器，就可以免密登录了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">192.168.235.22</span><br></code></pre></td></tr></table></figure><h3 id="5-2-管理多个私钥"><a href="#5-2-管理多个私钥" class="headerlink" title="5.2 管理多个私钥"></a>5.2 管理多个私钥</h3><p>在<code>~/.ssh/config</code>中进行配置，配置原则如下所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221210809219.png"></p><p><code>Host</code>是别名</p><p><code>HostName</code>是ip地址或者域名</p><p><code>User</code>是登录用户名</p><p><code>IdentityFile</code>是私钥地址</p><p><code>PerferredAuthentications</code>是首选身份验证方式</p><h2 id="六、Vi-和-Vim-编辑器"><a href="#六、Vi-和-Vim-编辑器" class="headerlink" title="六、Vi 和 Vim 编辑器"></a>六、Vi 和 Vim 编辑器</h2><h3 id="6-1-Vi和Vim的基本介绍"><a href="#6-1-Vi和Vim的基本介绍" class="headerlink" title="6.1 Vi和Vim的基本介绍"></a>6.1 Vi和Vim的基本介绍</h3><p>所有的 Linux 系统都会内建 vi 文本编辑器。</p><p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><h3 id="6-2-Vi和Vim的三种常见模式"><a href="#6-2-Vi和Vim的三种常见模式" class="headerlink" title="6.2 Vi和Vim的三种常见模式"></a>6.2 Vi和Vim的三种常见模式</h3><h4 id="6-2-1-正常模式"><a href="#6-2-1-正常模式" class="headerlink" title="6.2.1 正常模式"></a>6.2.1 正常模式</h4><p>在正常模式下，我们可以使用快捷键。<br>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。</p><h4 id="6-2-2-插入模式-编辑模式"><a href="#6-2-2-插入模式-编辑模式" class="headerlink" title="6.2.2 插入模式/编辑模式"></a>6.2.2 插入模式/编辑模式</h4><p>在模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式, 一般来说按i即可。</p><h4 id="6-2-3-命令行模式"><a href="#6-2-3-命令行模式" class="headerlink" title="6.2.3 命令行模式"></a>6.2.3 命令行模式</h4><p>在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！</p><h3 id="6-4-Vi和Vim三种模式的相互转化图"><a href="#6-4-Vi和Vim三种模式的相互转化图" class="headerlink" title="6.4 Vi和Vim三种模式的相互转化图"></a>6.4 Vi和Vim三种模式的相互转化图</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221212631089.png" alt="Vi和Vim三种模式的互相转换图"></p><h3 id="6-5-Vi和Vim的快捷键键盘一览图"><a href="#6-5-Vi和Vim的快捷键键盘一览图" class="headerlink" title="6.5 Vi和Vim的快捷键键盘一览图"></a>6.5 Vi和Vim的快捷键键盘一览图</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220221213558671.png" alt="Vi和Vim的快捷键键盘一览图"></p><p>Vi和Vim的快键键包罗万象，遇到具体需求可以查看<a href="https://vim.rtorr.com/lang/zh_cn">Vim Cheat Sheet</a></p><h2 id="七、关机、重启和用户登录注销"><a href="#七、关机、重启和用户登录注销" class="headerlink" title="七、关机、重启和用户登录注销"></a>七、关机、重启和用户登录注销</h2><h3 id="7-1-关机-amp-重启命令"><a href="#7-1-关机-amp-重启命令" class="headerlink" title="7.1 关机&amp;重启命令"></a>7.1 关机&amp;重启命令</h3><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">shutdown      </span>: 相当于 shutdown -h 1<br><span class="hljs-attribute">shutdown-h now</span>: 表示立即关机<br><span class="hljs-attribute">shutdown-h 1  </span>: 表示 1 分钟后关机<br><span class="hljs-attribute">shutdown-r now</span>: 立即重启<br><span class="hljs-attribute">halt          </span>: 效果等价于关机<br><span class="hljs-attribute">reboot        </span>: 就是重启系统。<br><span class="hljs-attribute">sync          :把内存的数据同步到磁盘</span><br></code></pre></td></tr></table></figure><p>注意细节：</p><p>1.当我们关机或者重启时，都应该先执行以下sync指令，把内存的数据写入磁盘，防止数据丢失。</p><p>2.目前的shutdown/reboot/halt等命令君已经在关机前进行了sync。</p><h3 id="7-2-用户登录和注销"><a href="#7-2-用户登录和注销" class="headerlink" title="7.2 用户登录和注销"></a>7.2 用户登录和注销</h3><p>1 ) 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用<code>su -s</code>命令来切换成系统管理员身份。</p><p>2 ) 在提示符下输入<code> logout</code> 即可注销用户。(在<code>root</code>用户下使用会退回到上次的普通用户上，在普通用户上使用会退出系统)</p><p>使用细节:<br>    1.logout 注销指令在图形运行级别无效，在 运行级别 3 下有效.<br>    2.运行级别这个概念，后面给大家介绍</p><h2 id="八、用户管理"><a href="#八、用户管理" class="headerlink" title="八、用户管理"></a>八、用户管理</h2><h3 id="8-1-基本介绍"><a href="#8-1-基本介绍" class="headerlink" title="8.1 基本介绍"></a>8.1 基本介绍</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。并且<strong>Linux的用户需要至少要属于一个组</strong>，每一个用户都对应一个自己的家目录。</p><h3 id="8-2-添加用户"><a href="#8-2-添加用户" class="headerlink" title="8.2 添加用户"></a>8.2 添加用户</h3><h4 id="8-2-1-基本语法"><a href="#8-2-1-基本语法" class="headerlink" title="8.2.1 基本语法"></a>8.2.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd [选项] 用户名<br></code></pre></td></tr></table></figure><h4 id="8-2-2-实际案例"><a href="#8-2-2-实际案例" class="headerlink" title="8.2.2 实际案例"></a>8.2.2 实际案例</h4><p>添加一个用户<code>jyg</code>,<code>useradd jyg</code>,并且默认该用户的家目录在<code>/home/jyg</code>。</p><h4 id="8-2-3-细节说明"><a href="#8-2-3-细节说明" class="headerlink" title="8.2.3 细节说明"></a>8.2.3 细节说明</h4><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>也可以通过 <code>useradd -d 指定目录 新的用户名</code>，给新创建的用户指定家目录</li><li>以什么用户身份登录，初始目录就在该用户的家目录下</li></ol><h3 id="8-3-给用户指定或者修改密码"><a href="#8-3-给用户指定或者修改密码" class="headerlink" title="8.3 给用户指定或者修改密码"></a>8.3 给用户指定或者修改密码</h3><h4 id="8-3-1-基本语法"><a href="#8-3-1-基本语法" class="headerlink" title="8.3.1 基本语法"></a>8.3.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd 用户名 #如果缺省用户名，则修改当前用户密码<br></code></pre></td></tr></table></figure><h4 id="8-2-2-实际案例-1"><a href="#8-2-2-实际案例-1" class="headerlink" title="8.2.2 实际案例"></a>8.2.2 实际案例</h4><p>给用户<code>jyg</code>更改密码，<code># passwd jyg</code></p><h3 id="8-4-删除用户"><a href="#8-4-删除用户" class="headerlink" title="8.4 删除用户"></a>8.4 删除用户</h3><h4 id="8-4-1-基本语法"><a href="#8-4-1-基本语法" class="headerlink" title="8.4.1 基本语法"></a>8.4.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel 用户名<br></code></pre></td></tr></table></figure><h4 id="8-4-2-应用案例"><a href="#8-4-2-应用案例" class="headerlink" title="8.4.2 应用案例"></a>8.4.2 应用案例</h4><ol><li><p>删除用户<code>jyg</code>，但是要保留家目录 <code>userdel jyg</code></p></li><li><p>删除用户<code>jyg</code>以及用户主目录 <code>userdel -r jyg</code></p></li></ol><p>主要注意的是，在删除用户时，我们一般不会将家目录删除。</p><h3 id="8-5-查询用户信息"><a href="#8-5-查询用户信息" class="headerlink" title="8.5 查询用户信息"></a>8.5 查询用户信息</h3><h4 id="8-5-1-基本语法"><a href="#8-5-1-基本语法" class="headerlink" title="8.5.1 基本语法"></a>8.5.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id 用户名<br></code></pre></td></tr></table></figure><h4 id="8-5-2-应用实例"><a href="#8-5-2-应用实例" class="headerlink" title="8.5.2 应用实例"></a>8.5.2 应用实例</h4><p>请查询root 信息 <code>id root</code></p><h4 id="8-5-3-细节说明"><a href="#8-5-3-细节说明" class="headerlink" title="8.5.3 细节说明"></a>8.5.3 细节说明</h4><p>当用户不存在时，返回<code>no such user</code></p><h3 id="8-6-切换用户"><a href="#8-6-切换用户" class="headerlink" title="8.6 切换用户"></a>8.6 切换用户</h3><h4 id="8-6-1-介绍"><a href="#8-6-1-介绍" class="headerlink" title="8.6.1 介绍"></a>8.6.1 介绍</h4><p>在操作Linux中，如果当前用户的权限不够，可以通过 <code>su - 用户名</code> 指令，切换到高权限用户，比如root</p><h4 id="8-6-2-基本语法"><a href="#8-6-2-基本语法" class="headerlink" title="8.6.2 基本语法"></a>8.6.2 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - 用户名<br></code></pre></td></tr></table></figure><h4 id="8-6-3-细节说明"><a href="#8-6-3-细节说明" class="headerlink" title="8.6.3 细节说明"></a>8.6.3 细节说明</h4><ol><li><p>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p></li><li><p>当需要返回到原来用户时，使用exit指令</p></li></ol><h3 id="8-7-查看当前用户-amp-登录信息"><a href="#8-7-查看当前用户-amp-登录信息" class="headerlink" title="8.7 查看当前用户 &amp; 登录信息"></a>8.7 查看当前用户 &amp; 登录信息</h3><h4 id="8-7-1-基本语法"><a href="#8-7-1-基本语法" class="headerlink" title="8.7.1 基本语法"></a>8.7.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whoami / who am i #两者不同，whoami是指当前用户，who am i是指登录信息（登录用户，登录信息，登录ip）<br></code></pre></td></tr></table></figure><h3 id="8-8-用户组"><a href="#8-8-用户组" class="headerlink" title="8.8 用户组"></a>8.8 用户组</h3><h4 id="8-8-1-介绍"><a href="#8-8-1-介绍" class="headerlink" title="8.8.1 介绍"></a>8.8.1 介绍</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><h4 id="8-8-2-增加组"><a href="#8-8-2-增加组" class="headerlink" title="8.8.2 增加组"></a>8.8.2 增加组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd 组名<br></code></pre></td></tr></table></figure><h4 id="8-8-3-删除组"><a href="#8-8-3-删除组" class="headerlink" title="8.8.3 删除组"></a>8.8.3 删除组</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupdel</span> 组名<br></code></pre></td></tr></table></figure><h3 id="8-9-增加用户时直接加上组"><a href="#8-9-增加用户时直接加上组" class="headerlink" title="8.9 增加用户时直接加上组"></a>8.9 增加用户时直接加上组</h3><h4 id="8-9-1-基本语法"><a href="#8-9-1-基本语法" class="headerlink" title="8.9.1 基本语法"></a>8.9.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -g 用户组 用户名<br></code></pre></td></tr></table></figure><p>需要注意的是，如果增加用户，但是没有指定用户组，那么系统会生成一个和该用户同名的用户组，并把该用户放入同名用户组中。</p><h4 id="8-9-2-案例演示"><a href="#8-9-2-案例演示" class="headerlink" title="8.9.2 案例演示"></a>8.9.2 案例演示</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">增加一个用户 zwj, 直接将他指定到 wudang<br>useradd -g wudang zwj<br></code></pre></td></tr></table></figure><h3 id="8-10-修改用户的组"><a href="#8-10-修改用户的组" class="headerlink" title="8.10 修改用户的组"></a>8.10 修改用户的组</h3><h4 id="8-10-1-基本语法"><a href="#8-10-1-基本语法" class="headerlink" title="8.10.1 基本语法"></a>8.10.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g 用户组 用户名<br></code></pre></td></tr></table></figure><h4 id="8-10-2-案例演示"><a href="#8-10-2-案例演示" class="headerlink" title="8.10.2 案例演示"></a>8.10.2 案例演示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">创建一个shaolin组，让将zwj 用户修改到shaolin<br>gourpadd shaolin<br>usermod -g shaolin zwj<br></code></pre></td></tr></table></figure><h3 id="8-11-用户和组相关文件"><a href="#8-11-用户和组相关文件" class="headerlink" title="8.11 用户和组相关文件"></a>8.11 用户和组相关文件</h3><h4 id="8-11-1-ETC-PASSWD-文件"><a href="#8-11-1-ETC-PASSWD-文件" class="headerlink" title="8.11.1 /ETC/PASSWD 文件"></a>8.11.1 /ETC/PASSWD 文件</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">用户（<span class="hljs-keyword">user</span>）的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令（被加密）:用户标识号:组标识号:注释性描述:主目录:登录<span class="hljs-keyword">Shell</span><br></code></pre></td></tr></table></figure><h4 id="8-11-2-ETC-SHADOW文件"><a href="#8-11-2-ETC-SHADOW文件" class="headerlink" title="8.11.2 /ETC/SHADOW文件"></a>8.11.2 /ETC/SHADOW文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">口令的配置文件<br><span class="hljs-section">每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></code></pre></td></tr></table></figure><h4 id="8-11-3-ETC-GROUP文件"><a href="#8-11-3-ETC-GROUP文件" class="headerlink" title="8.11.3 /ETC/GROUP文件"></a>8.11.3 /ETC/GROUP文件</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">组(<span class="hljs-keyword">group</span>)的配置文件，记录Linux包含的组的信息<br>每行含义：组名:口令:组标识号:组内用户列表<br></code></pre></td></tr></table></figure><p>组密码的作用：非本用户组的用户想切换到本用户组身份时，可以通过密码保证安全性。如果没有设置组密码，则只有属于本用户组的用户能够切换到本用户组的身份。</p><h2 id="九、实用指令"><a href="#九、实用指令" class="headerlink" title="九、实用指令"></a>九、实用指令</h2><h3 id="9-1-指定运行级别"><a href="#9-1-指定运行级别" class="headerlink" title="9.1 指定运行级别"></a>9.1 指定运行级别</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">运行级别说明：<br>0 ：关机<br>1 ：单用户【找回丢失密码】<br>2 ：多用户状态没有网络服务<br>3 ：多用户状态有网络服务<br>4 ：系统未使用保留给用户<br>5 ：图形界面<br>6 ：系统重启<br>常用运行级别是<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 5 </span><br></code></pre></td></tr></table></figure><p>要修改默认的运行级别:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">在centos7以前，可改文件/etc/inittab的id: 5 :initdefault:这一行中的数字<br><br>在Centos7以后，在/etc/inittab文件中，进行了简化，如下：<br>muti-user.target: analogous to runlevel 3<br>graphical.target: analogous to runlevel 5<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> To view current default target, run:</span><br>systemctl get-default<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> To <span class="hljs-built_in">set</span> a default target, run:</span><br>systemctl set-default [TARGET.target] # 例如：systemctl set-default graphical.target<br></code></pre></td></tr></table></figure><h3 id="9-2-切换到指定运行级别的指令"><a href="#9-2-切换到指定运行级别的指令" class="headerlink" title="9.2 切换到指定运行级别的指令"></a>9.2 切换到指定运行级别的指令</h3><h4 id="9-2-1-基本语法"><a href="#9-2-1-基本语法" class="headerlink" title="9.2.1 基本语法"></a>9.2.1 基本语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">init [012356]<br></code></pre></td></tr></table></figure><h4 id="9-2-2-应用实例"><a href="#9-2-2-应用实例" class="headerlink" title="9.2.2 应用实例"></a>9.2.2 应用实例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">案例 <span class="hljs-number">1</span> ： 通过<span class="hljs-keyword">init</span> 来切换不同的运行级别，比如动 <span class="hljs-number">5</span> - &gt; <span class="hljs-number">3</span> ， 然后关机<br><span class="hljs-keyword">init</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="9-2-3-面试题"><a href="#9-2-3-面试题" class="headerlink" title="9.2.3 面试题"></a>9.2.3 面试题</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">如何找<span class="hljs-built_in">回root</span>密码，如果我们不小心，忘<span class="hljs-built_in">记root</span>密码，怎么找回。<br>思路： 进入到单用户模式，然后修<span class="hljs-built_in">改root</span>密码。因为进入单用户模式<span class="hljs-built_in">，root</span>不需要密码就可以登录，随后使用passwd指令修<span class="hljs-built_in">改root</span>密码。<br></code></pre></td></tr></table></figure><h3 id="9-3-帮助指令"><a href="#9-3-帮助指令" class="headerlink" title="9.3 帮助指令"></a>9.3 帮助指令</h3><h4 id="9-3-1-介绍"><a href="#9-3-1-介绍" class="headerlink" title="9.3.1 介绍"></a>9.3.1 介绍</h4><p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p><h4 id="9-3-2-man-命令"><a href="#9-3-2-man-命令" class="headerlink" title="9.3.2 man 命令"></a>9.3.2 man 命令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man [命令或配置文件]（功能描述：获得帮助信息）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例：查看ls命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man ls<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222125127245.png"></p><p><code>-a : 不忽略以 . 开头的文件</code></p><p>主要注意的是，[]是可选项的意思，而且可以组合使用且无顺序要求</p><h4 id="9-3-3-help指令"><a href="#9-3-3-help指令" class="headerlink" title="9.3.3 help指令"></a>9.3.3 help指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help 命令 （功能描述：获得shell内置命令的帮助信息,只能用于内部命令，不能用于外部命令）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例：查看cd命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help cd<br></code></pre></td></tr></table></figure><h3 id="9-3-4-info命令"><a href="#9-3-4-info命令" class="headerlink" title="9.3.4 info命令"></a>9.3.4 info命令</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">info 命令 # info 得到的信息比 man 还要多<br></code></pre></td></tr></table></figure><p>注意：由于help支持命令少，推荐使用man或者info命令。</p><h3 id="9-4-文件目录类"><a href="#9-4-文件目录类" class="headerlink" title="9.4 文件目录类"></a>9.4 文件目录类</h3><h4 id="9-4-1-pwd-指令"><a href="#9-4-1-pwd-指令" class="headerlink" title="9.4.1 pwd 指令"></a>9.4.1 pwd 指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd (功能描述：显示当前工作目录的绝对路径)<br></code></pre></td></tr></table></figure><h4 id="9-4-2-ls指令"><a href="#9-4-2-ls指令" class="headerlink" title="9.4.2 ls指令"></a>9.4.2 ls指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [选项] [目录或是文件]<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>a ：显示当前目录所有的文件和目录，包括隐藏的。</li><li>l ：以列表的方式显示信息</li></ul><h4 id="9-4-3-cd-指令"><a href="#9-4-3-cd-指令" class="headerlink" title="9.4.3 cd 指令"></a>9.4.3 cd 指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd [参数] (功能描述：切换到指定目录)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>~ / <span class="hljs-built_in">cd</span> :回到自己的家目录<br><span class="hljs-built_in">cd</span>..     :回到当前目录的上一级目录<br></code></pre></td></tr></table></figure><h4 id="9-4-4-mkdir指令"><a href="#9-4-4-mkdir指令" class="headerlink" title="9.4.4 mkdir指令"></a>9.4.4 mkdir指令</h4><p>基本语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [选项] 要创建的目录<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>p ：创建多级目录</li></ul><h4 id="9-4-5-rmdir指令"><a href="#9-4-5-rmdir指令" class="headerlink" title="9.4.5 rmdir指令"></a>9.4.5 rmdir指令</h4><p>rmdir指令删除空目录</p><p>基本语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir [选项] 要删除的空目录<br></code></pre></td></tr></table></figure><p>需要注意的是：rmdir指令只能删除空目录，只能使用<code>rm -rf</code></p><h4 id="9-4-6-touch指令"><a href="#9-4-6-touch指令" class="headerlink" title="9.4.6 touch指令"></a>9.4.6 touch指令</h4><p>touch指令创建空文件</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 文件名<br></code></pre></td></tr></table></figure><h4 id="9-4-7-cp指令"><a href="#9-4-7-cp指令" class="headerlink" title="9.4.7 cp指令"></a>9.4.7 cp指令</h4><p>cp 指令拷贝文件到指定目录</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp [选项] source dest # source、dest可以是文件也可以是文件夹<br>\cp [选项] source dest # 直接覆盖，不提示是否覆盖<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>r ：递归复制整个文件夹</li></ul><h4 id="9-4-8-rm指令"><a href="#9-4-8-rm指令" class="headerlink" title="9.4.8 rm指令"></a>9.4.8 rm指令</h4><p>rm 指令移除文件或目录</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [选项] 要删除的文件或目录<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>r ：递归删除整个文件夹</li><li>f ： 强制删除不提示</li></ul><h4 id="9-4-9-mv指令"><a href="#9-4-9-mv指令" class="headerlink" title="9.4.9 mv指令"></a>9.4.9 mv指令</h4><p>mv <strong>移动</strong>文件与目录或<strong>重命名</strong></p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv oldNameFile           newNameFile          (功能描述：重命名)<br>mv /oldFolder/movefile  /targetFolder         (功能描述：移动文件)<br></code></pre></td></tr></table></figure><p>案例移动整个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv oldFolder /targetFolder<br></code></pre></td></tr></table></figure><h4 id="9-4-10-cat指令"><a href="#9-4-10-cat指令" class="headerlink" title="9.4.10 cat指令"></a>9.4.10 cat指令</h4><p>cat 查看文件内容，是以只读的方式打开。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat [选项] 要查看的文件<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>n ：显示行号</li></ul><p>使用细节<br>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名 | more<br></code></pre></td></tr></table></figure><h4 id="9-4-11-more指令"><a href="#9-4-11-more指令" class="headerlink" title="9.4.11 more指令"></a>9.4.11 more指令</h4><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">more 要查看的文件<br></code></pre></td></tr></table></figure><p>操作说明</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>space</td><td>向下翻一页</td></tr><tr><td>return</td><td>向下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>b</td><td>向上翻一页</td></tr><tr><td>z</td><td>向下翻一页</td></tr><tr><td>=</td><td>输出当前行号</td></tr><tr><td>：f</td><td>输出文件名和当前行号</td></tr></tbody></table><h4 id="9-4-12-less指令"><a href="#9-4-12-less指令" class="headerlink" title="9.4.12 less指令"></a>9.4.12 less指令</h4><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less 文件<br></code></pre></td></tr></table></figure><p>操作说明</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>space</td><td>向下翻一页</td></tr><tr><td>return</td><td>向下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>b</td><td>向上翻一页</td></tr><tr><td>z</td><td>向下翻一页</td></tr><tr><td>=</td><td>显示当前页面行号范围</td></tr><tr><td>:f</td><td>显示当前页面行号范围</td></tr></tbody></table><p>推荐使用<code>less</code>而不是<code>more</code></p><h4 id="9-4-13-gt-指令-和-gt-gt-指令"><a href="#9-4-13-gt-指令-和-gt-gt-指令" class="headerlink" title="9.4.13 &gt;指令 和 &gt;&gt;指令"></a>9.4.13 &gt;指令 和 &gt;&gt;指令</h4><p><code>&gt;</code>命令是输出重定向：会将原来的文件内容覆盖</p><p><code>&gt;&gt;</code>命令是追加：不会覆盖原来文件的内容，而是追加到文件的尾部。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l &gt; 文件      （功能描述：列表的内容写入文件a.txt中（覆盖写））<br>  说明：ls-l&gt;a.txt, 将ls-l 的显示的内容覆盖写入到a.txt文件，如果该文件不存在，就创建该文件。<br>ls -al &gt;&gt; 文件   （功能描述：列表的内容追加到文件aa.txt的末尾）<br>cat 文件1 &gt; 文件2 （功能描述：将文件 1 的内容覆盖到文件 2 ）<br>echo &quot;内容&quot; &gt;&gt; 文件<br></code></pre></td></tr></table></figure><h4 id="9-4-14-echo指令"><a href="#9-4-14-echo指令" class="headerlink" title="9.4.14 echo指令"></a>9.4.14 echo指令</h4><p>echo输出内容到控制台。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [选项] [输出内容]<br></code></pre></td></tr></table></figure><p>应用实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH        #输出环境变量<br>echo $HOSTNAME    #输出主机名<br>echo hello world  #输出hello world<br></code></pre></td></tr></table></figure><h4 id="9-4-15-head指令"><a href="#9-4-15-head指令" class="headerlink" title="9.4.15 head指令"></a>9.4.15 head指令</h4><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前 10 行内容</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">head 文件 (功能描述：查看文件头 10 行内容)<br>head-n 5 文件 (功能描述：查看文件头 5 行内容， 5 可以是任意行数)<br></code></pre></td></tr></table></figure><h4 id="9-4-16-tail指令"><a href="#9-4-16-tail指令" class="headerlink" title="9.4.16 tail指令"></a>9.4.16 tail指令</h4><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后 10 行内容。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail 文件       (功能描述：查看文件后 10 行内容）<br>tail -n 5 文件 （功能描述：查看文件后 5 行内容， 5 可以是任意行数）<br>tail -f 文件   （功能描述：实时追踪该文档的所有更新，工作经常使用）<br></code></pre></td></tr></table></figure><h4 id="9-4-17-ln指令"><a href="#9-4-17-ln指令" class="headerlink" title="9.4.17 ln指令"></a>9.4.17 ln指令</h4><p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 : 在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /root ./linkToRoot<br></code></pre></td></tr></table></figure><p>案例 2 : 删除软连接 linkToRoot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm ./linkToRoot<br></code></pre></td></tr></table></figure><p>细节说明<br>当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。</p><h4 id="9-4-18-history指令"><a href="#9-4-18-history指令" class="headerlink" title="9.4.18 history指令"></a>9.4.18 history指令</h4><p>查看已经执行过历史命令,也可以执行历史指令</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history （功能描述：查看已经执行过历史命令）<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 : 显示所有的历史命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history<br></code></pre></td></tr></table></figure><p>案例 2 : 显示最近使用过的 10 个指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history 10<br></code></pre></td></tr></table></figure><p>案例 3 ：执行历史编号为 5 的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!5<br></code></pre></td></tr></table></figure><h3 id="9-5-时间日期类"><a href="#9-5-时间日期类" class="headerlink" title="9.5 时间日期类"></a>9.5 时间日期类</h3><h4 id="9-5-1-date指令-显示当前日期"><a href="#9-5-1-date指令-显示当前日期" class="headerlink" title="9.5.1 date指令-显示当前日期"></a>9.5.1 date指令-显示当前日期</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">date     （功能描述：显示当前时间）<br>date +%Y （功能描述：显示当前年份）<br>date +%m （功能描述：显示当前月份）<br>date +%d （功能描述：显示当前是哪一天）<br>date &quot;+%Y-%m-%d%H:%M:%S&quot;（功能描述：显示年月日时分秒）<br></code></pre></td></tr></table></figure><h4 id="9-5-2-date指令-设置日期"><a href="#9-5-2-date指令-设置日期" class="headerlink" title="9.5.2 date指令-设置日期"></a>9.5.2 date指令-设置日期</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">date -s 字符串时间     (字符串时间格式为：“2018-10-10 11:22:22”，此时日期和时间用双引号引起来)<br>date -s 14:31:00     (设置时间)<br>date -s 20100405    （设置日期）<br></code></pre></td></tr></table></figure><h4 id="9-5-3-cal指令"><a href="#9-5-3-cal指令" class="headerlink" title="9.5.3 cal指令"></a>9.5.3 cal指令</h4><p>查看日历指令</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cal [选项] （功能描述：不加选项，显示本月日历）<br>cal 2020   (功能描述：显示2020年日历)<br></code></pre></td></tr></table></figure><h3 id="9-6-搜索查找类"><a href="#9-6-搜索查找类" class="headerlink" title="9.6 搜索查找类"></a>9.6 搜索查找类</h3><h4 id="9-6-1-find指令"><a href="#9-6-1-find指令" class="headerlink" title="9.6.1 find指令"></a>9.6.1 find指令</h4><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [搜索范围] [选项]<br></code></pre></td></tr></table></figure><p>选项</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name &lt;文件名&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user &lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size &lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><p>应用实例<br>案例 1 : 按文件名：根据名称查找/home 目录下的hello.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name hello.txt<br></code></pre></td></tr></table></figure><p>案例 2 ：按拥有者：查找/opt目录下，属于nobody的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /opt -user nobody<br></code></pre></td></tr></table></figure><p>案例 3 ：查找整个linux系统下大于 20 m的文件（+n 大于 -n小于 n等于）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -size +200M<br></code></pre></td></tr></table></figure><p>案例 4：查询 / 目录下，所有 .txt的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name *.txt<br></code></pre></td></tr></table></figure><h4 id="9-6-2-locate指令"><a href="#9-6-2-locate指令" class="headerlink" title="9.6.2 locate指令"></a>9.6.2 locate指令</h4><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locate 搜索文件<br></code></pre></td></tr></table></figure><p>特别说明<br>由于locate指令基于数据库进行查询，所以第一次运行前，<strong>必须使用<code>updatedb</code>指令创建locate数据库</strong>。</p><p>应用实例<br>案例 1 : 请使用locate 指令快速定位 hello.txt 文件所在目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">updatedb<br>locate hello.txt<br></code></pre></td></tr></table></figure><h4 id="9-6-3-which指令"><a href="#9-6-3-which指令" class="headerlink" title="9.6.3 which指令"></a>9.6.3 which指令</h4><p>which指令可以查看某个指令在哪个目录下。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which 指令<br></code></pre></td></tr></table></figure><h4 id="9-6-4-grep指令-和-管道符号"><a href="#9-6-4-grep指令-和-管道符号" class="headerlink" title="9.6.4 grep指令 和 管道符号 |"></a>9.6.4 grep指令 和 管道符号 |</h4><p>grep 过滤查找 ， 管道符“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [选项] 查找内容 源文件<br></code></pre></td></tr></table></figure><p>常用选项</p><ul><li>-n : 显示匹配行及行号</li><li>-i ：忽略字母大小写</li></ul><p>应用实例<br>案例 1 : 请在 hello.txt 文件中，查找 “yes” 所在行，并且显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /home/hello.txt | grep -n yes<br>grep -n yes hello.txt<br></code></pre></td></tr></table></figure><h3 id="9-7-压缩和解压类"><a href="#9-7-压缩和解压类" class="headerlink" title="9.7 压缩和解压类"></a>9.7 压缩和解压类</h3><h4 id="9-7-1-gzip-gunzip-指令"><a href="#9-7-1-gzip-gunzip-指令" class="headerlink" title="9.7.1 gzip/gunzip 指令"></a>9.7.1 gzip/gunzip 指令</h4><p>gzip 用于压缩文件， gunzip 用于解压的</p><p>基本语法</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gzip 文件      （功能描述：压缩文件，只能将文件压缩为*<span class="hljs-string">.gz</span>文件）<br>gunzip 文件<span class="hljs-string">.gz</span> （功能描述：解压缩文件命令）<br></code></pre></td></tr></table></figure><p>细节说明<br>当我们使用gzip 对文件进行压缩后，不会保留原来的文件。</p><h4 id="9-7-2-zip-unzip-指令"><a href="#9-7-2-zip-unzip-指令" class="headerlink" title="9.7.2 zip/unzip 指令"></a>9.7.2 zip/unzip 指令</h4><p>zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip   [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）<br>unzip [选项] XXX.zip（功能描述：解压缩文件）<br></code></pre></td></tr></table></figure><p>zip常用选项</p><ul><li>r：递归压缩，即压缩目录</li></ul><p>unzip的常用选项</p><ul><li>d&lt;目录&gt;：指定解压后文件的存放目录</li></ul><p>应用实例<br>案例 1 : 将 /home本身及下的所有文件进行压缩成 mypackage.zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r mypackage.zip /home<br></code></pre></td></tr></table></figure><p>案例 2 : 将 mypackage.zip 解压到 /opt/tmp 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip -d /opt/tmp mypackage.zip<br></code></pre></td></tr></table></figure><h4 id="9-7-3-tar-指令"><a href="#9-7-3-tar-指令" class="headerlink" title="9.7.3 tar 指令"></a>9.7.3 tar 指令</h4><p>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)<br></code></pre></td></tr></table></figure><p>选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩 (压缩成.gz文件需要加上，同时解压.gz文件也需要加上。如果文件是.tar结尾，不能加z选项)</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table><p>应用实例</p><p>案例 1 : 压缩多个文件，将 /home/pig.txt 和 /home/cat.txt 压缩成 pc.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt<br></code></pre></td></tr></table></figure><p>案例 2 : 将/home 的文件夹 压缩成 myhome.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf myhome.tar.gz /home<br></code></pre></td></tr></table></figure><p>案例 3 : 将 pc.tar.gz 解压到当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf pc.tar.gz<br></code></pre></td></tr></table></figure><p>案例 4 : 将myhome.tar.gz 解压到 /opt/ 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf myhome.tar.gz -C /opt # -C 选项代表解压到指定目录，指定解压到的那个目录，事先要存在才能成功，否则会报错。<br></code></pre></td></tr></table></figure><h2 id="十、组管理和权限管理"><a href="#十、组管理和权限管理" class="headerlink" title="十、组管理和权限管理"></a>十、组管理和权限管理</h2><h3 id="10-1-Linux组基本介绍"><a href="#10-1-Linux组基本介绍" class="headerlink" title="10.1 Linux组基本介绍"></a>10.1 Linux组基本介绍</h3><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</p><h3 id="10-2-文件-目录所有者"><a href="#10-2-文件-目录所有者" class="headerlink" title="10.2 文件/目录所有者"></a>10.2 文件/目录所有者</h3><p>一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者（当然随后可以更改文件的所有者）。</p><h4 id="10-2-1-查看文件的所有者"><a href="#10-2-1-查看文件的所有者" class="headerlink" title="10.2.1 查看文件的所有者"></a>10.2.1 查看文件的所有者</h4><p>基本语法</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -ahl  <span class="hljs-comment"># -a 显示所有文件</span><br> <span class="hljs-comment"># -l 显示文件详细信息，以行的形式显示</span><br> <span class="hljs-comment"># -h 以人类的习惯，显示文件大小</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222161844053.png"></p><h4 id="10-2-2-修改文件所有者"><a href="#10-2-2-修改文件所有者" class="headerlink" title="10.2.2 修改文件所有者"></a>10.2.2 修改文件所有者</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown 用户名 文件名<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例：使用root 创建一个文件apple.txt ，然后将其所有者修改成 tom</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown tom apple.txt<br></code></pre></td></tr></table></figure><h3 id="10-3-文件-目录-所在组"><a href="#10-3-文件-目录-所在组" class="headerlink" title="10.3 文件/目录 所在组"></a>10.3 文件/目录 所在组</h3><p>当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。</p><h4 id="10-3-1-查看文件-目录所在组"><a href="#10-3-1-查看文件-目录所在组" class="headerlink" title="10.3.1 查看文件/目录所在组"></a>10.3.1 查看文件/目录所在组</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lah<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220222161945221.png"></p><h4 id="10-3-2-修改文件-目录所在的组"><a href="#10-3-2-修改文件-目录所在的组" class="headerlink" title="10.3.2 修改文件/目录所在的组"></a>10.3.2 修改文件/目录所在的组</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp 组名 文件名/目录<br></code></pre></td></tr></table></figure><p>应用实例<br>实例：使用root用户创建文件 orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到fruit组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp fruit orange.txt<br></code></pre></td></tr></table></figure><h3 id="10-4-其它组"><a href="#10-4-其它组" class="headerlink" title="10.4 其它组"></a>10.4 其它组</h3><p>除文件所在组外，系统其他组都是文件的其它组.</p><h3 id="10-5-改变用户所在组"><a href="#10-5-改变用户所在组" class="headerlink" title="10.5 改变用户所在组"></a>10.5 改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。</p><h4 id="10-5-1-改变用户所在组"><a href="#10-5-1-改变用户所在组" class="headerlink" title="10.5.1 改变用户所在组"></a>10.5.1 改变用户所在组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod –g 组名 用户名<br>usermod –d 目录名 用户名 # 改变该用户登陆的初始目录，当然该用户必须有进入该目录的权限<br></code></pre></td></tr></table></figure><p>应用实例</p><p>实例：创建一个土匪组（bandit）将 tom 这个用户从原来所在的police组，修改到 bandit(土匪) 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd bandit<br>usermod -g bandit tom<br></code></pre></td></tr></table></figure><h3 id="10-6-权限的基本介绍"><a href="#10-6-权限的基本介绍" class="headerlink" title="10.6 权限的基本介绍"></a>10.6 权限的基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l 中显示的内容如下：<br>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure><p>0 - 9 位说明</p><ul><li><p>第 0 位确定文件类型(d,-,l,c,b)</p><ul><li>l是连接，相当于windows的快捷方式</li><li>d是目录，相当于windows的文件夹</li><li>c是字符设备文件，比如鼠标、键盘等</li><li>b是块设备，比如硬盘 </li><li><code>-</code>是文件</li></ul></li><li><p>第 1 - 3 位确定所有者（该文件的所有者）拥有该文件的权限。—User</p></li><li><p>第 4 - 6 位确定所属组（同用户组的）拥有该文件的权限，—Group</p></li><li><p>第 7 - 9 位确定其他用户拥有该文件的权限 —Other</p></li></ul><h3 id="10-7-RWX权限详解"><a href="#10-7-RWX权限详解" class="headerlink" title="10.7 RWX权限详解"></a>10.7 RWX权限详解</h3><h4 id="10-7-1-rwx作用到文件"><a href="#10-7-1-rwx作用到文件" class="headerlink" title="10.7.1 rwx作用到文件"></a>10.7.1 rwx作用到文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[r]代表可读(read): 可以读取,查看<br>[w]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>[x]代表可执行(execute):可以被执行<br></code></pre></td></tr></table></figure><h4 id="10-7-2-rwx作用到目录"><a href="#10-7-2-rwx作用到目录" class="headerlink" title="10.7.2 rwx作用到目录"></a>10.7.2 rwx作用到目录</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[r]</span>代表可读(read): 可以读取，<span class="hljs-selector-tag">ls</span>查看目录内容<br><span class="hljs-selector-attr">[w]</span>代表可写(write): 可以修改,目录内创建+删除+重命名目录<br><span class="hljs-selector-attr">[x]</span>代表可执行(execute):可以进入该目录<br></code></pre></td></tr></table></figure><h3 id="10-8-文件及目录权限实际案例"><a href="#10-8-文件及目录权限实际案例" class="headerlink" title="10.8 文件及目录权限实际案例"></a>10.8 文件及目录权限实际案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l <br>-rwxrw-r-- 1 rootroot 1213 Feb 2 09 : 39 abc<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gcode">-rwxrw-r-- <span class="hljs-number">10</span>个字符确定不同用户能对文件干什么<br>第一个字符代表文件类型：文件 <span class="hljs-comment">(-)</span>,目录<span class="hljs-comment">(d)</span>,链接<span class="hljs-comment">(l)</span>,字符设备文件<span class="hljs-comment">(c)</span>,块设备<span class="hljs-comment">(b)</span><br>其余字符每 <span class="hljs-number">3</span> 个一组<span class="hljs-comment">(rwx)</span> 读<span class="hljs-comment">(r)</span> 写<span class="hljs-comment">(w)</span> 执行<span class="hljs-comment">(x)</span><br>第一组rwx: 文件拥有者的权限是读、写和执行<br>第二组rw-: 与文件拥有者同一组的用户的权限是读、写但不能执行<br>第三组r--: 不与文件拥有者同组的其他用户的权限是读不能写和执行<br>可用数字表示为:r= <span class="hljs-number">4</span> ,w= <span class="hljs-number">2</span> ,x= <span class="hljs-number">1</span> 因此rwx= <span class="hljs-number">4</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">7</span><br><br><span class="hljs-number">1</span>           文件：硬连接数或 目录：子目录数（该目录下一级的子目录数,注意空目录下也有 . 和 .. 代表当前目录和上一级目录）<br>root 所属用户<br>root        所属组<br><span class="hljs-number">1213</span> 文件大小<span class="hljs-comment">(字节)</span>，如果是文件夹，显示 <span class="hljs-number">4096</span> 字节<br>Feb <span class="hljs-number">2</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span> 最后修改日期<br>abc         文件名<br></code></pre></td></tr></table></figure><h3 id="10-9-修改权限"><a href="#10-9-修改权限" class="headerlink" title="10.9 修改权限"></a>10.9 修改权限</h3><p>基本说明：通过chmod指令，可以修改文件或者目录的权限</p><h4 id="10-9-1-第一种方式：-、-、-变更权限"><a href="#10-9-1-第一种方式：-、-、-变更权限" class="headerlink" title="10.9.1 第一种方式：+、-、=变更权限"></a>10.9.1 第一种方式：+、-、=变更权限</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)<br><span class="hljs-number">1</span> )<span class="hljs-keyword">chmod</span> u=rwx,g=rx,o=<span class="hljs-keyword">x</span> 文件目录名<br><span class="hljs-number">2</span> )<span class="hljs-keyword">chmod</span> o+w 文件目录名<br><span class="hljs-number">3</span> )<span class="hljs-keyword">chmod</span> a-<span class="hljs-keyword">x</span> 文件目录名<br></code></pre></td></tr></table></figure><p>案例演示<br>案例1： 给abc文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=rx abc<br></code></pre></td></tr></table></figure><p>案例2： 给abc文件的所有者除去执行的权限，增加组写的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u-x,g+w abc<br></code></pre></td></tr></table></figure><p>案例3： 给abc文件的所有用户添加读的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod a+r abc<br></code></pre></td></tr></table></figure><h4 id="10-9-2-第二种方式：通过数字变更权限"><a href="#10-9-2-第二种方式：通过数字变更权限" class="headerlink" title="10.9.2 第二种方式：通过数字变更权限"></a>10.9.2 第二种方式：通过数字变更权限</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">规则：r=<span class="hljs-number"> 4 </span>w=<span class="hljs-number"> 2 </span>x=<span class="hljs-number"> 1 </span>,rwx=<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 7<br>chmodu=rwx,g=rx,o=x 文件目录名<br>相当于 chmod<span class="hljs-number"> 751 </span>文件目录名<br></code></pre></td></tr></table></figure><p>案例演示</p><p>案例：将 /home/abc.txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现：<br>            rwx= 4 + 2 + 1 = 7<br>            r-x= 4 + 1 = 5<br>            r-x= 4 + 1 = 5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 /home/abc.txt<br></code></pre></td></tr></table></figure><h3 id="10-10-修改文件-目录所有者"><a href="#10-10-修改文件-目录所有者" class="headerlink" title="10.10 修改文件/目录所有者"></a>10.10 修改文件/目录所有者</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown newowner file           #改变文件/目录的所有者<br>chown newowner:newgroup file  #改变文件/目录的所有者和所有组<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>-R 如果是目录 则使其下所有子文件或目录递归生效</li></ul><p>案例演示：</p><p>案例1：请将 /home/abc.txt 文件的所有者修改成 tom</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod tom abc.txt<br></code></pre></td></tr></table></figure><p>案例2：请将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom，首选我们应该使用root操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R tom /home/kkk<br></code></pre></td></tr></table></figure><h3 id="10-11-修改文件-目录所在组"><a href="#10-11-修改文件-目录所在组" class="headerlink" title="10.11 修改文件/目录所在组"></a>10.11 修改文件/目录所在组</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp newgroup file 改变文件/目录的所在组<br></code></pre></td></tr></table></figure><p>案例演示：</p><p>案例1：请将 /home/abc.txt 文件的所在组修改成 bandit(土匪)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp bandit /home/abc.txt<br></code></pre></td></tr></table></figure><p>案例2：请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp -R bandit /home/kkk<br></code></pre></td></tr></table></figure><h3 id="10-12-最佳实践-警察和土匪游戏"><a href="#10-12-最佳实践-警察和土匪游戏" class="headerlink" title="10.12 最佳实践-警察和土匪游戏"></a>10.12 最佳实践-警察和土匪游戏</h3><p>police ,bandit<br>jack,jerry: 警察<br>xh,xq: 土匪<br>( 1 )创建组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd police<br>groupadd bandit<br></code></pre></td></tr></table></figure><p>( 2 )创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -g police jack<br>useradd -g police jerry<br>useradd -g bandit xh<br>useradd -g bandit xq<br></code></pre></td></tr></table></figure><p>( 3 ) jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - jack<br>touch jack.txt<br>chmod 640 jack.txt<br></code></pre></td></tr></table></figure><p>( 4 )jack 修改该文件，让其它组人可以读, 本组人可以读写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 664 jack.txt<br></code></pre></td></tr></table></figure><p>( 5 )xh 投靠警察，看看是否可以读写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g police xh<br></code></pre></td></tr></table></figure><h3 id="10-13-课后练习"><a href="#10-13-课后练习" class="headerlink" title="10.13 课后练习"></a>10.13 课后练习</h3><p>建立两个组（神仙,妖怪）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd shenxian <br>groupadd yaoguai<br></code></pre></td></tr></table></figure><p>建立四个用户(唐僧,悟空，八戒，沙僧)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd tang<br>useradd wu<br>useradd ba<br>useradd sha<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd tang<br>passwd wu<br>passwd ba<br>passwd sha<br></code></pre></td></tr></table></figure><p>把悟空，八戒放入妖怪 唐僧 沙僧 在神仙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g yaoguai wu<br>usermod -g yaoguai ba<br>usermod -g shenxian tang<br>usermod -g shenxian sha<br></code></pre></td></tr></table></figure><p>用悟空建立一个文件 （monkey.java 该文件要输出 iammonkey）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - wu<br>touch monkey.java<br>echo ianmonkey &gt; monkey.java<br></code></pre></td></tr></table></figure><p>给八戒一个可以rw 的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 760 monkey.java<br>chmod 777 /home/wu<br></code></pre></td></tr></table></figure><p>八戒修改monkey.java 加入一句话(iampig)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo iampig &gt;&gt; monkey.java<br></code></pre></td></tr></table></figure><p>唐僧 沙僧 对该文件没有权限,把 沙僧 放入妖怪组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g yaoguai sha<br>reboot #重新登录，刷新登录信息<br></code></pre></td></tr></table></figure><p>让沙僧 修改 该文件 monkey, 加入一句话 (“我是沙僧，我是妖怪!”);</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;我是沙僧，我是妖怪！&quot; &gt;&gt; monkey.java<br></code></pre></td></tr></table></figure><h2 id="十一、crond-任务调度"><a href="#十一、crond-任务调度" class="headerlink" title="十一、crond 任务调度"></a>十一、crond 任务调度</h2><h3 id="11-1-原理示意图"><a href="#11-1-原理示意图" class="headerlink" title="11.1 原理示意图"></a>11.1 原理示意图</h3><p>crontab 进行定时任务的设置。</p><p>任务调度：是指系统在某个时间执行的特定的命令或程序。<br>任务调度分类：</p><p>1 .系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>2 .个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p><p>基本语法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab [选项]<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>-e: 编辑crontab定时任务</li><li>-l: 查询crontab任务</li><li>-r: 删除当前用户所有的crontab任务</li></ul><h3 id="11-2-快速入门"><a href="#11-2-快速入门" class="headerlink" title="11.2 快速入门"></a>11.2 快速入门</h3><h4 id="11-2-1-任务的要求"><a href="#11-2-1-任务的要求" class="headerlink" title="11.2.1 任务的要求"></a>11.2.1 任务的要求</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">设置任务调度文件：<span class="hljs-regexp">/etc/</span>crontab<br>设置个人任务调度。执行crontab –e命令。<br>接着输入任务到调度文件<br>如：ls –l <span class="hljs-regexp">/etc/</span> &gt; <span class="hljs-regexp">/tmp/</span>to.txt<br>意思说每小时的每分钟执行ls –l<span class="hljs-regexp">/etc &gt; /</span>tmp/to.txt命令<br></code></pre></td></tr></table></figure><h4 id="11-2-2-步骤如下"><a href="#11-2-2-步骤如下" class="headerlink" title="11.2.2 步骤如下"></a>11.2.2 步骤如下</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) crontab -e<br><span class="hljs-symbol">2 </span>) */ <span class="hljs-number">1</span> * * * * ls -l /etc &gt; /tmp/<span class="hljs-keyword">to</span>.txt<br><span class="hljs-symbol">3 </span>) 当保存退出后就程序。<br><span class="hljs-symbol">4 </span>) 在每一分钟都会自动的调用 ls -l /etc &gt; /tmp/<span class="hljs-keyword">to</span>.txt<br></code></pre></td></tr></table></figure><h4 id="11-2-3-参数细节说明"><a href="#11-2-3-参数细节说明" class="headerlink" title="11.2.3 参数细节说明"></a>11.2.3 参数细节说明</h4><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个 “*”</td><td>一个小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个 ”*“</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个 ”*“</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个 ”*“</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个 ”*“</td><td>一周当中的星期几</td><td>0-7（0和7代表星期日）</td></tr></tbody></table><h4 id="11-2-4-特殊符号的说明"><a href="#11-2-4-特殊符号的说明" class="headerlink" title="11.2.4 特殊符号的说明"></a>11.2.4 特殊符号的说明</h4><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间。比如第一个”*“就代表一小时中每分钟都执行一次的意思</td></tr><tr><td>,</td><td>代表不连续的时间。比如<code>0 8,12,16 * * * </code>命令，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围。比如<code>0 5 * * 1-6</code>命令，代表在周一到周六的凌晨5点0分执行命令</td></tr><tr><td>*/n</td><td>代表每个多久执行一次。比如<code>*/10 * * * *</code>命令，代表每个10分钟就执行一遍命令</td></tr></tbody></table><h4 id="11-2-5-特定时间执行任务案例"><a href="#11-2-5-特定时间执行任务案例" class="headerlink" title="11.2.5 特定时间执行任务案例"></a>11.2.5 特定时间执行任务案例</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>45 22 * * * </code></td><td>每天22点45分执行任务</td></tr><tr><td><code>0 17 * * 1</code></td><td>每周星期一0点17分执行任务</td></tr><tr><td><code>0 5 1,15 * * </code></td><td>每月1号和15号的5点0分执行任务</td></tr><tr><td><code>40 4 * * 1-5</code></td><td>每周一到周五的4点40分执行任务</td></tr><tr><td><code>*/10 4 * * * </code></td><td>每天4点每隔10分钟执行任务</td></tr><tr><td><code>0 0 1,15 * 1</code></td><td>每月1号和5号，每周一的0点0分执行任务。（这里1号15号与周一取并集）</td></tr></tbody></table><p>注意：星期几和几号最好不要同时出现，因为他们定义的都是天，非常容易让管理员混乱。</p><p><a href="https://tool.lu/crontab/">crontab定时任务解析网站</a></p><h4 id="11-2-4-任务调度的几个应用实例"><a href="#11-2-4-任务调度的几个应用实例" class="headerlink" title="11.2.4 任务调度的几个应用实例"></a>11.2.4 任务调度的几个应用实例</h4><p>案例 1 ：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate文件中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">crontab -e<br>*<span class="hljs-regexp">/1 * * * * date &gt;&gt; /</span>tmp/mydate<br></code></pre></td></tr></table></figure><p>案例 2 ：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal文件中</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs qml">vim my.sh<br><span class="hljs-built_in">date</span> &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br>cal &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br><br>chmod <span class="hljs-number">777</span> home/my.sh<br><br>crontab -e<br>*<span class="hljs-regexp">/1 * * * * home/my</span>.sh<br></code></pre></td></tr></table></figure><p>案例 3 : 每天凌晨 2 : 00 将mysql数据库testdb ，备份到文件中 mydb.bak。提示：指令为<code>mysqldump -u root -p密码 数据库 &gt; /home/db.bak</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">crontab -e<br><span class="hljs-number">0</span> <span class="hljs-number">2</span> * * * mysqldump -u root -proot testdb &gt; <span class="hljs-regexp">/home/</span>db.bak<br></code></pre></td></tr></table></figure><h3 id="11-3-crond-相关指令"><a href="#11-3-crond-相关指令" class="headerlink" title="11.3 crond 相关指令"></a>11.3 crond 相关指令</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>) conrtab –r：终止任务调度(就是删除任务）。<br><span class="hljs-symbol">2 </span>) crontab –l：列出当前有那些任务调度<br><span class="hljs-symbol">3 </span>) service crond restart   [重启任务调度]<br></code></pre></td></tr></table></figure><h3 id="11-4-at定时任务"><a href="#11-4-at定时任务" class="headerlink" title="11.4 at定时任务"></a>11.4 at定时任务</h3><p>基本介绍：</p><ol><li>at命令是一次性定时计划任务，at的守护进行atd会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，atd守护进行每60秒检查<strong>作业队列</strong>，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li><li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看。<code>ps -ef | grep atd</code>可以检测atd是否在运行。</li></ol><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at [选项] [时间]<br>Ctrl + D 结束at命令的输入(两次按Ctrl + D)<br></code></pre></td></tr></table></figure><p>选项说明：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td></tr><tr><td><code>-I</code></td><td>atq的别名（查询）</td></tr><tr><td>-d</td><td>atrm的别名（删除）</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-q &lt;队列&gt;</td><td>使用指定的队列</td></tr><tr><td>-f &lt;文件&gt;</td><td>从指定文件读入任务而不是从标准输入读入</td></tr><tr><td>-t &lt;时间参数&gt;</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table><p>at时间定义：</p><ol><li>接受在当天hh:mm（小时：分钟）式的时间指定。假如该时间已经过去，那么就放在第二天执行。例如：04:00</li><li>使用midnight（深夜)，noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间。</li><li>采用12小时计时制，即在时间后面加上AM（上午）或者PM（下午）来说明是上午还是下午。例如12PM</li><li>指定命令执行的具体日期，指定格式为month day （月 日）或者 mm/dd/yy（月/日/年） 或者 dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。例如：04:00 2021-03-01</li><li>使用相对计时法。指定格式为： now + count time-units，now就是当前时间，time-units是时间单位，几天，几小时。例如：now + 5 minutes</li><li>直接使用today（今天）、tomorrow（明天）来制定完成命令的时间。</li></ol><p>应用实例：</p><p>实例1:2天后的下午5点执行 /bin/ls /home</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at 5pm + 2 days<br><span class="hljs-meta">at&gt;</span><span class="bash"> /bin/ls /home</span><br></code></pre></td></tr></table></figure><p>案例2：atq命令来查看系统中没有执行的工作任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">atq<br></code></pre></td></tr></table></figure><p>案例3：明天17点钟，输出时间到指定文件内，比如/root/date100.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at 5pm tomorrow<br>date &gt;&gt; /root/date100.log<br></code></pre></td></tr></table></figure><p>案例4：2分钟后，输出时间到指定文件内，比如/root/date200.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">at now + 2 minutes<br>date &gt;&gt; /root/date200.log<br></code></pre></td></tr></table></figure><p>案例5：删除已经设置的任务，artm编号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">atrm 1<br></code></pre></td></tr></table></figure><h2 id="十二、Linux-磁盘分区、挂载"><a href="#十二、Linux-磁盘分区、挂载" class="headerlink" title="十二、Linux 磁盘分区、挂载"></a>十二、Linux 磁盘分区、挂载</h2><h3 id="12-1-LINUX分区"><a href="#12-1-LINUX分区" class="headerlink" title="12.1 LINUX分区"></a>12.1 LINUX分区</h3><h4 id="12-1-1-原理介绍"><a href="#12-1-1-原理介绍" class="headerlink" title="12.1.1 原理介绍"></a>12.1.1 原理介绍</h4><ol><li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 ,Linux中每个分区都是用来组成整个文件系统的一部分。</p></li><li><p>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p></li><li><p>示意图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223162138373.png"></p></li></ol><h4 id="12-1-2-硬盘说明"><a href="#12-1-2-硬盘说明" class="headerlink" title="12.1.2 硬盘说明"></a>12.1.2 硬盘说明</h4><ol><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda 3 表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb 2 表示为第二个IDE硬盘上的第二个主分区或扩展分区。</li><li>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</li></ol><p>分区的方式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>)mbr分区:<br><span class="hljs-symbol">1 </span>.最多支持四个主分区<br><span class="hljs-symbol">2 </span>.系统只能安装在主分区<br><span class="hljs-symbol">3 </span>.扩展分区要占一个主分区<br><span class="hljs-symbol">4 </span>.MBR最大只支持 <span class="hljs-number">2</span> TB，但拥有最好的兼容性<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>)gtp分区:<br><span class="hljs-symbol">1 </span>.支持无限多个主分区（但操作系统可能限制，比如 windows下最多 <span class="hljs-number">128</span> 个分区）<br><span class="hljs-symbol">2 </span>.最大支持 <span class="hljs-number">18</span> EB的大容量（ <span class="hljs-number">1</span> EB= <span class="hljs-number">1024</span> PB， <span class="hljs-number">1</span> PB= <span class="hljs-number">1024</span> TB ）<br><span class="hljs-symbol">3 </span>.windows <span class="hljs-number">7</span> <span class="hljs-number">64</span> 位以后支持gtp<br></code></pre></td></tr></table></figure><h4 id="12-1-3-使用lsblk指令查看当前系统的分区情况"><a href="#12-1-3-使用lsblk指令查看当前系统的分区情况" class="headerlink" title="12.1.3 使用lsblk指令查看当前系统的分区情况"></a>12.1.3 使用lsblk指令查看当前系统的分区情况</h4><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsblk 或者 lsblk -f<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223163636480.png"></p><h3 id="12-2-挂载的经典案例"><a href="#12-2-挂载的经典案例" class="headerlink" title="12.2 挂载的经典案例"></a>12.2 挂载的经典案例</h3><p>需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> )虚拟机添加硬盘<br><span class="hljs-number">2</span> )分区 fdisk<span class="hljs-regexp">/dev/</span>sdb<br><span class="hljs-number">3</span> )格式化 mkfs -text <span class="hljs-number">4</span> <span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span><br><span class="hljs-number">4</span> )挂载 先创建一个 <span class="hljs-regexp">/home/</span>newdisk , 挂载 mount <span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span> <span class="hljs-regexp">/home/</span>newdisk<br><span class="hljs-number">5</span> )设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 <span class="hljs-regexp">/home/</span>newdisk) 。<br>vim <span class="hljs-regexp">/etc/</span>fstab<br><span class="hljs-regexp">/dev/</span>sdb <span class="hljs-number">1</span> <span class="hljs-regexp">/home/</span>newdisk ext <span class="hljs-number">4</span> defaults <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h4 id="12-2-1-虚拟机增加硬盘步骤-1"><a href="#12-2-1-虚拟机增加硬盘步骤-1" class="headerlink" title="12.2.1 虚拟机增加硬盘步骤 1"></a>12.2.1 虚拟机增加硬盘步骤 1</h4><p>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！</p><h4 id="12-2-2-虚拟机增加硬盘步骤-2"><a href="#12-2-2-虚拟机增加硬盘步骤-2" class="headerlink" title="12.2.2 虚拟机增加硬盘步骤 2"></a>12.2.2 虚拟机增加硬盘步骤 2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">分区命令 fdisk <span class="hljs-regexp">/dev/</span>sdb<br>开始对/sdb分区<br></code></pre></td></tr></table></figure><ul><li>m 显示命令列表</li><li>p 显示磁盘分区 同 <code>fdisk –l</code></li><li>n 新增分区</li><li>d 删除分区</li><li>w 写入并退出<br>说明： 开始分区后输入n，新增分区，然后选择p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。</li></ul><h4 id="12-2-3-虚拟机增加硬盘步骤-3"><a href="#12-2-3-虚拟机增加硬盘步骤-3" class="headerlink" title="12.2.3 虚拟机增加硬盘步骤 3"></a>12.2.3 虚拟机增加硬盘步骤 3</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">格式化磁盘<br>分区命令:mkfs -t ext4 <span class="hljs-regexp">/dev/</span>sdb1<br>其中 ext4 是分区类型<br></code></pre></td></tr></table></figure><h4 id="12-2-4-虚拟机增加硬盘步骤-4"><a href="#12-2-4-虚拟机增加硬盘步骤-4" class="headerlink" title="12.2.4 虚拟机增加硬盘步骤 4"></a>12.2.4 虚拟机增加硬盘步骤 4</h4><p>挂载: 将一个分区与一个目录联系起来。</p><p>挂载基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount 设备名称 挂载目录<br>例如： mount /dev/sdb1 /newdisk<br></code></pre></td></tr></table></figure><p>卸载基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount 设备名称 或者 挂载目录<br>例如： umount /dev/sdb1 或者 umount /newdisk<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，使用命令行挂载，在重启后会失效。</strong></p><h4 id="12-2-5-虚拟机增加硬盘步骤-5"><a href="#12-2-5-虚拟机增加硬盘步骤-5" class="headerlink" title="12.2.5 虚拟机增加硬盘步骤 5"></a>12.2.5 虚拟机增加硬盘步骤 5</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">永久挂载: 通过修改 <span class="hljs-regexp">/etc/</span>fstab 实现挂载<br>添加完成后 执行 mount –a 即刻生效<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223170740749.png"></p><p>字段解释</p><p><strong>/etc/fstab文件主要包括6段，依次是：</strong></p><p><strong><file system>　　<dir>　　<type>　　<options>　　<dump>　　<pass></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;file system&gt; 要挂载的分区或存储设备<br>&lt;dir&gt;  挂载的目录位置<br>&lt;type&gt; 挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap<br>&lt;options&gt; 挂载使用的参数有哪些。举例如下：<br>auto - 在启动时或键入了 mount -a 命令时自动挂载。<br>noauto - 只在你的命令下被挂载。<br>exec - 允许执行此分区的二进制文件。<br>noexec - 不允许执行此文件系统上的二进制文件。<br>ro - 以只读模式挂载文件系统。<br>rw - 以读写模式挂载文件系统。<br>user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。<br>users - 允许所有 users 组中的用户挂载文件系统.<br>nouser - 只能被 root 挂载。<br>owner - 允许设备所有者挂载.<br>sync - I/O 同步进行。<br>async - I/O 异步进行。<br>dev - 解析文件系统上的块特殊设备。<br>nodev - 不解析文件系统上的块特殊设备。<br>suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。<br>nosuid - 禁止 suid 操作和设定 sgid 位。<br>noatime - 不更新文件系统上 inode 访问记录，可以提升性能。<br>nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。<br>relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。<br>flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。<br>defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.<br><br>&lt;dump&gt;  dump 工具通过它决定何时作备份. dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言 &lt;dump&gt; 应设为 0。<br><br>&lt;pass&gt; fsck 读取 &lt;pass&gt; 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2. 0 表示设备不会被 fsck 所检查。<br></code></pre></td></tr></table></figure><h3 id="12-3-磁盘情况查询"><a href="#12-3-磁盘情况查询" class="headerlink" title="12.3 磁盘情况查询"></a>12.3 磁盘情况查询</h3><h4 id="12-3-1-查询系统整体磁盘使用情况"><a href="#12-3-1-查询系统整体磁盘使用情况" class="headerlink" title="12.3.1 查询系统整体磁盘使用情况"></a>12.3.1 查询系统整体磁盘使用情况</h4><p>基本语法</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">df -h</span><br></code></pre></td></tr></table></figure><p>应用实例<br>实例1：查询系统整体磁盘使用情况</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223171558366.png"></p><h4 id="12-3-2-查询指定目录的磁盘占用情况"><a href="#12-3-2-查询指定目录的磁盘占用情况" class="headerlink" title="12.3.2 查询指定目录的磁盘占用情况"></a>12.3.2 查询指定目录的磁盘占用情况</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -h 目录   #查询指定目录的磁盘占用情况，默认为当前目录<br></code></pre></td></tr></table></figure><p>选项说明：</p><ul><li>-s 指定目录占用大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>–max-depth=1 子目录深度为1</li></ul><ul><li>-c 列出明细的同时，增加汇总值</li></ul><p>应用实例<br>案例1：查询 /opt 目录的磁盘占用情况，深度为 2</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223172209906.png"></p><h3 id="12-4-磁盘情况-工作实用指令"><a href="#12-4-磁盘情况-工作实用指令" class="headerlink" title="12.4 磁盘情况-工作实用指令"></a>12.4 磁盘情况-工作实用指令</h3><ol><li>统计/home文件夹下文件的个数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><ol start="2"><li>统计/home文件夹下目录的个数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /home | grep &quot;^d&quot; | wc -l<br></code></pre></td></tr></table></figure><p>3 统计/home文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lR /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><p>4 ) 统计文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lR /home | grep &quot;^-&quot; | wc -l<br></code></pre></td></tr></table></figure><p>5 ) 以树状显示/home目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tree /home<br></code></pre></td></tr></table></figure><h2 id="十三、网络配置"><a href="#十三、网络配置" class="headerlink" title="十三、网络配置"></a>十三、网络配置</h2><h3 id="13-1-Linux网络配置原理图-含虚拟机"><a href="#13-1-Linux网络配置原理图-含虚拟机" class="headerlink" title="13.1 Linux网络配置原理图(含虚拟机)"></a>13.1 Linux网络配置原理图(含虚拟机)</h3><p>目前我们的网络配置采用的是NAT。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223193808182.png"></p><h3 id="13-2-查看网络IP和网关"><a href="#13-2-查看网络IP和网关" class="headerlink" title="13.2 查看网络IP和网关"></a>13.2 查看网络IP和网关</h3><p> 在windows环境下，查看ip配置，基本语法：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ipconfig</span><br></code></pre></td></tr></table></figure><p>在linux环境下，查看ip配置，基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h3 id="13-3-Ping测试主机之间网络连通"><a href="#13-3-Ping测试主机之间网络连通" class="headerlink" title="13.3 Ping测试主机之间网络连通"></a>13.3 Ping测试主机之间网络连通</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：测试当前服务器是否可以连接百度</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.baidu.com<br></code></pre></td></tr></table></figure><h3 id="13-4-Linux网络环境配置"><a href="#13-4-Linux网络环境配置" class="headerlink" title="13.4 Linux网络环境配置"></a>13.4 Linux网络环境配置</h3><h4 id="13-4-1-第一种方法-自动获取"><a href="#13-4-1-第一种方法-自动获取" class="headerlink" title="13.4.1 第一种方法(自动获取)"></a>13.4.1 第一种方法(自动获取)</h4><p>说明：登录以后，通过界面来设置自动获取ip，特点：linux启动后会自动获取ip。</p><p>缺点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip需要时固定的。</p><p>可以多了解一些<strong>DHCP</strong>（动态路由选择协议）。</p><h4 id="13-4-2-第二种方法-指定固定的ip"><a href="#13-4-2-第二种方法-指定固定的ip" class="headerlink" title="13.4.2 第二种方法(指定固定的ip)"></a>13.4.2 第二种方法(指定固定的ip)</h4><p>说明：直接修改配置文件来指定ip，并可以连接到外网(程序员推荐)，要求：将ip地址配置的静态的，ip地址为 192.168.184.130</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223200552506.png"></p><p>修改后，一定要重启服务/重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network restart<br>reboot <br></code></pre></td></tr></table></figure><h3 id="13-5-设置主机名和hosts映射"><a href="#13-5-设置主机名和hosts映射" class="headerlink" title="13.5 设置主机名和hosts映射"></a>13.5 设置主机名和hosts映射</h3><h4 id="13-5-1-设置主机名"><a href="#13-5-1-设置主机名" class="headerlink" title="13.5.1 设置主机名"></a>13.5.1 设置主机名</h4><ol><li>为了方便记忆，可以给linux系统设置<strong>主机名</strong>，也可以根据需要修改主机名</li><li>指令 <code>hostname</code>:查看主机名</li><li>修改文件在<code>/etc/hostname</code>指定</li><li>修改后，重启生效</li></ol><h4 id="13-5-2-设置hosts映射"><a href="#13-5-2-设置hosts映射" class="headerlink" title="13.5.2 设置hosts映射"></a>13.5.2 设置hosts映射</h4><p>通过 <strong>主机名</strong> 能够找到（比如ping）某个linux系统。</p><p>在windows系统下，修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件指定即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.200.130 jyg<br></code></pre></td></tr></table></figure><p>在linux系统下，修改<code>/etc/hosts</code>文件指定即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.200.1 jyg<br></code></pre></td></tr></table></figure><h3 id="13-6-主机名解析过程分析（Hosts、DNS）"><a href="#13-6-主机名解析过程分析（Hosts、DNS）" class="headerlink" title="13.6 主机名解析过程分析（Hosts、DNS）"></a>13.6 主机名解析过程分析（Hosts、DNS）</h3><h4 id="13-6-1-Hosts是什么"><a href="#13-6-1-Hosts是什么" class="headerlink" title="13.6.1 Hosts是什么"></a>13.6.1 Hosts是什么</h4><p>一个文本文件，用来记录ip和Hostname（主机名）的映射关系</p><h4 id="13-6-2-DNS"><a href="#13-6-2-DNS" class="headerlink" title="13.6.2 DNS"></a>13.6.2 DNS</h4><ol><li>DNS，就是Domain Name System的缩写，翻译过来就是域名系统</li><li>DNS是互联网上作为域名和ip地址相互映射的一个分布式数据库</li></ol><h4 id="13-6-3-当用户在浏览器输入www-baidu-com，系统如何解析的ip地址"><a href="#13-6-3-当用户在浏览器输入www-baidu-com，系统如何解析的ip地址" class="headerlink" title="13.6.3 当用户在浏览器输入www.baidu.com，系统如何解析的ip地址"></a>13.6.3 当用户在浏览器输入<a href="http://www.baidu.com,系统如何解析的ip地址/">www.baidu.com，系统如何解析的ip地址</a></h4><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址，如果有就先返回这个IP完成解析；如果没有，就检查操作系统DNS解析器缓存，如果有就直接返回这个IP完成解析。这两个缓存，可以理解为本地解析器缓存。</p><p>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存该域名的IP地址（DNS解析记录），例如在cmd窗口中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipconfig /displaydns   #DNS域名解析缓存<br>ipconfig /flushdns     #手动清理DNS缓存<br></code></pre></td></tr></table></figure></li><li><p>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中，有没有配置对应的域名IP映射，如果有，则完成解析病返回该IP</p><p><strong>所以，修改系统<code>hosts</code>文件，可以做到域名劫持。</strong></p></li><li><p>如果本地DNS解析器缓存和hosts文件中均没有找到哦啊对应的IP，则到域名服务器DNS进行解析域名。</p></li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223203658890.png"></p><h2 id="十四、进程管理"><a href="#十四、进程管理" class="headerlink" title="十四、进程管理"></a>十四、进程管理</h2><h3 id="14-1-进程的基本介绍"><a href="#14-1-进程的基本介绍" class="headerlink" title="14.1 进程的基本介绍"></a>14.1 进程的基本介绍</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-number">1</span>)在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号（<span class="hljs-keyword">pid</span>，进程号）。<br><span class="hljs-number">2</span>)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。<br><span class="hljs-number">3</span>)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。<br><span class="hljs-number">4</span>)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。<br></code></pre></td></tr></table></figure><h3 id="14-2-显示系统执行的进程"><a href="#14-2-显示系统执行的进程" class="headerlink" title="14.2 显示系统执行的进程"></a>14.2 显示系统执行的进程</h3><h4 id="14-2-1-ps命令基本介绍"><a href="#14-2-1-ps命令基本介绍" class="headerlink" title="14.2.1 ps命令基本介绍"></a>14.2.1 ps命令基本介绍</h4><p><code>ps</code>命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以加任何参数。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223211635045.png"></p><h4 id="14-2-2-ps现实的信息选项："><a href="#14-2-2-ps现实的信息选项：" class="headerlink" title="14.2.2 ps现实的信息选项："></a>14.2.2 ps现实的信息选项：</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程识别号</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程所消耗CPU时间</td></tr><tr><td>CMD</td><td>正在执行的命令或进程名</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a #显示当前终端的所有进程信息<br>ps -u #以用户格式显示进程信息<br>ps -x #显示后台进程运行的参数<br></code></pre></td></tr></table></figure><p>一般组合使用<code>ps -aux</code></p><h4 id="14-2-3-ps指令详解"><a href="#14-2-3-ps指令详解" class="headerlink" title="14.2.3 ps指令详解"></a>14.2.3 ps指令详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223212209393.png"></p><p>各字段解释：</p><ul><li><p>USER：    用户名称</p></li><li><p>PID：进程号</p></li><li><p>%CPU：进程占用CPU的百分比</p></li><li><p>%MEM：进程占用物理内存的百分比</p></li><li><p>VSZ：进程占用的虚拟内存大小（单位：KB）</p></li><li><p>RSS：进程占用的物理内存大小（单位：KB）</p></li><li><p>TTY：终端名称,太长就缩写为<code>?</code>.</p></li><li><p>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p></li><li><p>START：进程的启动时间</p></li><li><p>TIME：CPU时间，即进程使用CPU的总时间</p></li><li><p>COMMAND：进程名或者执行进程所用的命令和参数，如果过长会被截断显示</p></li></ul><p>应用实例：</p><p>实例1：查看有没有sshd服务进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux | grep sshd<br></code></pre></td></tr></table></figure><p>实例2：以全格式显示当前所有的进程，查看sshd进程的父进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #以全格式显示当前所有的进程<br></code></pre></td></tr></table></figure><p>选项解释：</p><ul><li>-e:显示所有进程</li><li>-f:全格式</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220223213643683.png"></p><p>各字段解释：</p><ul><li><p>UID：用户ID</p></li><li><p>PID：进程ID</p></li><li><p>PPID：父进程ID</p></li><li><p>C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</p></li><li><p>STIME：进程启动的时间</p></li><li><p>TTY：完整的终端名称</p></li><li><p>TIME：CPU时间</p></li><li><p>CMD：启动进程所用的命令和参数<br>思考题，如果我们希望查看 sshd进程的父进程号是多少，应该怎样查询 ？</p></li></ul><h3 id="14-3-终止进程kill和killall"><a href="#14-3-终止进程kill和killall" class="headerlink" title="14.3 终止进程kill和killall"></a>14.3 终止进程kill和killall</h3><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><p>基本语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> [选项] 进程号 （功能描述：通过进程号杀死进程）<br>killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）<br></code></pre></td></tr></table></figure><p>常用选项:</p><ul><li>-9 :表示强迫进程立即停止</li></ul><p>应用实践：</p><p>案例 1 ：踢掉某个非法登录用户<code>tom</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #查询tom登录的PID<br>kill [tom用户登录对应的进程号]<br></code></pre></td></tr></table></figure><p>案例 2 : 终止远程登录服务sshd, 在适当时候再次重启sshd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd #查询sshd服务的PID<br>kill [sshd服务的PID]<br>/bin/systemctl start sshd.service #重启sshd服务<br></code></pre></td></tr></table></figure><p>案例 3 : 终止多个gedit 编辑器 【killall, 通过进程名称来终止进程】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall gedit<br></code></pre></td></tr></table></figure><p>案例 4 ：强制杀掉一个终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep bash<br>kill [bash的PID] #这种情况系统有保护，不能杀掉<br>kill -9 [bash的PID] #强制杀掉<br></code></pre></td></tr></table></figure><h3 id="14-4-查看进程树pstree"><a href="#14-4-查看进程树pstree" class="headerlink" title="14.4 查看进程树pstree"></a>14.4 查看进程树pstree</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pstree [选项] #可以更加直观的来看进程信息<br></code></pre></td></tr></table></figure><p>常用选项：</p><ul><li>-p:显示进程的PID</li><li>-u:显示进程的所属用户</li></ul><p>应用实例：</p><p>案例 1 ：请你树状的形式显示进程的pid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pstree -p<br></code></pre></td></tr></table></figure><p>案例 2 ：请你树状的形式进程的用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -u</span><br></code></pre></td></tr></table></figure><h3 id="14-5-服务-service-管理"><a href="#14-5-服务-service-管理" class="headerlink" title="14.5 服务(service)管理"></a>14.5 服务(service)管理</h3><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld,sshd,防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224193420932.png"></p><h4 id="14-5-1-service管理指令"><a href="#14-5-1-service管理指令" class="headerlink" title="14.5.1 service管理指令"></a>14.5.1 service管理指令</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">service 服务名 [start|<span class="hljs-type">stop</span>|<span class="hljs-type">restart</span>|<span class="hljs-type">reload</span>|<span class="hljs-type">status</span>]<br>在CentOS <span class="hljs-number">7.0</span> 后,不再使用service,而是 systemctl(ubuntu也是使用systemctl)<br></code></pre></td></tr></table></figure><p>在<code>/etc/init.d</code>下，可以查看service指令管理的服务。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224193758012.png"></p><p>使用实例：</p><p>实例1：使用<code>service</code>指令，查看、关闭、启动network。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network status<br>service network stop<br>service network start  <br></code></pre></td></tr></table></figure><h4 id="14-5-2-查看服务名"><a href="#14-5-2-查看服务名" class="headerlink" title="14.5.2 查看服务名"></a>14.5.2 查看服务名</h4><p>方式 1 ：使用setup-&gt; 系统服务 就可以看到（可以查看全部服务，许多发行版不支持了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setup<br></code></pre></td></tr></table></figure><p>方式 2 : /etc/init.d/服务名称（只能查看一部分）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /etc/init.d<br></code></pre></td></tr></table></figure><h4 id="14-5-3-服务的运行级别-runlevel"><a href="#14-5-3-服务的运行级别-runlevel" class="headerlink" title="14.5.3 服务的运行级别(runlevel)"></a>14.5.3 服务的运行级别(runlevel)</h4><p>Linux系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5</p><ul><li>运行级别 0 ：系统停机状态，系统默认运行级别不能设为 0 ，否则不能正常启动</li><li>运行级别 1 ：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别 2 ：多用户状态(没有NFS)，不支持网络</li><li>运行级别 3 ：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别 4 ：系统未使用，保留</li><li>运行级别 5 ：X 11 控制台，登陆后进入图形GUI模式</li><li>运行级别 6 ：系统正常关闭并重启，默认运行级别不能设为 6 ，否则不能正常启动</li></ul><h4 id="14-5-4-Linux开机的流程说明"><a href="#14-5-4-Linux开机的流程说明" class="headerlink" title="14.5.4 Linux开机的流程说明"></a>14.5.4 Linux开机的流程说明</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224194756970.png"></p><h4 id="14-5-5-chkconfig指令"><a href="#14-5-5-chkconfig指令" class="headerlink" title="14.5.5 chkconfig指令"></a>14.5.5 chkconfig指令</h4><p>介绍：</p><ol><li>通过chkconfig命令可以给服务的各个运行级别设置自 启动/关闭</li><li>chkconfig命令管理的服务在<code>/etc/init.d</code>查看</li><li>注意：centos7.0后，很多服务使用<code>systemctl</code>管理</li></ol><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chkconfig --list [| grep xxx] #查看chkconfig管理的服务以及各个运行级别下自启动情况<br>chkconfig --level 5 服务名 on/off   #将某个服务在运行级别5下，自启动on还是off<br></code></pre></td></tr></table></figure><p>使用细节：chkconfig重新设置服务后自动启动或关闭，需要重启机器生效。</p><h4 id="14-5-6-systemctl管理指令"><a href="#14-5-6-systemctl管理指令" class="headerlink" title="14.5.6 systemctl管理指令"></a>14.5.6 systemctl管理指令</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status] 服务名<br></code></pre></td></tr></table></figure><p>systemctl指令管理的服务在<code>/usr/lib/systemd/system</code>查看。</p><p>systemctl设置服务的自启动状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl list-unit-files [ | grep 服务名] #查看所有服务以及其自启动状态,grep可以进行过滤<br>systemctl enable 服务名 #设置服务开机启动<br>systemctl disable 服务名 #关闭服务开机启动<br>systemctl is-enable 服务名 #查询某个服务是否是自启动的<br>这里不指定运行级别，是因为Centos将运行级别简化为了3和5，这里都是针对3和5说的<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：查看防火墙当前状态，关闭防火墙和重启防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status firewalld<br>systemctl stop firewalld<br>systemtl restart firewalld<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224202132630.png"></p><p>细节讨论：</p><ol><li><p>关闭或者启动防火墙后，立即生效。使用telnet查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet ip:port<br></code></pre></td></tr></table></figure></li><li><p>这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。</p></li><li><p>如果希望设置某个服务自启动或关闭永久生效，要使用<code>systemctl [enable | disable] 服务名</code></p></li></ol><h4 id="14-5-7-telnet命令"><a href="#14-5-7-telnet命令" class="headerlink" title="14.5.7 telnet命令"></a>14.5.7 telnet命令</h4><p>Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet 主机名称|ip<br>或者<br>telnet 主机名称|ip:port<br></code></pre></td></tr></table></figure><h4 id="14-5-8-firewall命令"><a href="#14-5-8-firewall命令" class="headerlink" title="14.5.8 firewall命令"></a>14.5.8 firewall命令</h4><p>在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=端口号/协议   #打开端口<br>firewall-cmd --permanent --remove-port=端口号/协议 #关闭端口<br>firewall-cmd --reload#重新载入，才能生效<br>firewall-cmd --query-port=端口号/协议#查询端口是否开放<br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：开放111端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=111/tcp<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>案例2：关闭111端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --remove-port=111/tcp<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h3 id="14-6-动态监控进程"><a href="#14-6-动态监控进程" class="headerlink" title="14.6 动态监控进程"></a>14.6 动态监控进程</h3><p>介绍：</p><p>top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。</p><p>基本语法： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top [选项]<br></code></pre></td></tr></table></figure><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新，默认是3秒。</td></tr><tr><td>-i</td><td>是top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控进程id来仅仅金控某个进程的状态</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220224205016495.png"></p><p>各项解释：</p><p>top：系统时间；up：登录用户数；load average：负载均衡</p><p>Tasks：进程数；running：运行进程数；sleeping：睡眠进程数；stopped：停止进程；zombie：僵死进程数(进程已死，内存未释放)</p><p>%Cpu（s）：us：用户占用Cpu比率；sy：系统占用Cpu比率；ni:用户进程空间内改变过优先级的进程占用Cpu比率；id：空闲Cpu比率；wa：等待输入输出的cpu时间占比；si：软终端占用百分比；st：虚拟机占用百分比</p><p>KiB Mem：total：物理内存总量；used：使用的物理内存总量；free：空闲内存总量；buffers：用作内核缓冲的内存量</p><p>KiB Swap：total：交换区总量；used：使用的交换区总量；free：空闲交换区总量；cached：缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过得交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小，相应的内存再次被换出是可不必再对交换区写入。</p><p>PR:优先级;NI:nice值。负值代表高优先级，正值代表低优先级;VIRT:进程使用的虚拟内存总量，单位kb。VIRT = SWAP + RES;RES:进程使用的、未被换出的物理内存大小，单位kb。RES = CODE + DATA;SHR:共享内存大小，单位kb;S:进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/通知，Z=僵尸进程）</p><p>交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><p>应用实例：</p><p>案例1：监视特定用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">top <br>u 用户名<br></code></pre></td></tr></table></figure><p>top：输入此命令，按回车键，查看执行的进程。<br>u：然后输入“u”回车，再输入用户名，即可。</p><p>案例 2 ：终止指定的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br>k PID<br></code></pre></td></tr></table></figure><p>top：输入此命令，按回车键，查看执行的进程。</p><p>k：然后输入“k”回车，再输入要结束的进程ID号</p><p>案例 3 :指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">top -d 10<br></code></pre></td></tr></table></figure><h3 id="14-7-查看系统网络情况netstat-重要"><a href="#14-7-查看系统网络情况netstat-重要" class="headerlink" title="14.7 查看系统网络情况netstat(重要)"></a>14.7 查看系统网络情况netstat(重要)</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat [选项]<br>netstat -anp<br></code></pre></td></tr></table></figure><p>选项说明</p><p>​    -a (all)显示所有选项，默认不显示LISTEN相关<br>​    -t (tcp)仅显示tcp相关选项<br>​    -u (udp)仅显示udp相关选项<br>​    -n 拒绝显示别名，能显示数字的全部转化成数字。<br>​    -l 仅列出有在 Listen (监听) 的服務状态</p><p>​    -p 显示建立相关链接的进程<br>​    -r 显示路由信息，路由表<br>​    -e 显示扩展信息，例如uid等<br>​    -s 按各个协议进行统计<br>​    -c 每隔一个固定时间，执行该netstat命令。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225131410928.png"></p><p>应用案例<br>案例1：查看系统所有的网络服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp<br></code></pre></td></tr></table></figure><p>案例2：请查看服务名为 sshd 的服务的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp | grep sshd<br></code></pre></td></tr></table></figure><h2 id="十五、RPM-和-YUM"><a href="#十五、RPM-和-YUM" class="headerlink" title="十五、RPM 和 YUM"></a>十五、RPM 和 YUM</h2><h3 id="15-1-RPM包的管理"><a href="#15-1-RPM包的管理" class="headerlink" title="15.1 RPM包的管理"></a>15.1 RPM包的管理</h3><h4 id="15-1-1介绍"><a href="#15-1-1介绍" class="headerlink" title="15.1.1介绍"></a>15.1.1介绍</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmp一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。<br>它生成具有.RPM扩展名的文件。RPM是RedHatPackageManager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。<br>Linux的分发版本都有采用（suse,redhat,centos等等），可以算是公认的行业标准了。<br></code></pre></td></tr></table></figure><h4 id="15-1-2-rpm包的简单查询指令"><a href="#15-1-2-rpm包的简单查询指令" class="headerlink" title="15.1.2 rpm包的简单查询指令"></a>15.1.2 rpm包的简单查询指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查询已安装的rpm列表</span> <br>rpm –qa | grep xx<br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：请查询看一下，当前的Linux有没有安装 firefox.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa | grep firefox<br></code></pre></td></tr></table></figure><h4 id="15-1-3-rpm包名基本格式"><a href="#15-1-3-rpm包名基本格式" class="headerlink" title="15.1.3 rpm包名基本格式"></a>15.1.3 rpm包名基本格式</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">一个rpm包名：firefox-<span class="hljs-number">45.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span><span class="hljs-selector-class">.el6</span><span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.x86_64</span><span class="hljs-selector-class">.rpm</span><br>名称:         firefox<br>版本号：        <span class="hljs-number">45.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span><br>适用操作系统:    el6<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.x86_64</span><br>表示centos <span class="hljs-number">6</span>.x的<span class="hljs-number">64</span>位系统<br>如果是i686 、i386 表示 <span class="hljs-number">32</span> 位系统，noarch表示通用。<br></code></pre></td></tr></table></figure><h4 id="15-1-4-rpm包的其它查询指令："><a href="#15-1-4-rpm包的其它查询指令：" class="headerlink" title="15.1.4 rpm包的其它查询指令："></a>15.1.4 rpm包的其它查询指令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa #查询所安装的所有rpm软件包<br>rpm -qa | more#[分页显示]<br>rpm -qa | grep X[rpm-qa|grepfirefox]<br>rpm -q 软件包名  #查询软件包是否安装，例如：rpm -q firefox<br>rpm -qi 软件包名  #查询软件包信息，例如：rpm -qi firefox<br>rpm -ql 软件报名 #查询软件包中的文件，例如rpm -ql firefox<br>rpm -qf 文件全路径名   #查询文件所属软件包,例如rpm -qf /etc/passwd;rpm -qf /root/install.log<br></code></pre></td></tr></table></figure><h4 id="15-1-5-卸载rpm包："><a href="#15-1-5-卸载rpm包：" class="headerlink" title="15.1.5 卸载rpm包："></a>15.1.5 卸载rpm包：</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e RPM包的名称  #e是erase删除的意思<br></code></pre></td></tr></table></figure><p>应用案例<br>案例1： 删除firefox 软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e firefox<br></code></pre></td></tr></table></figure><p>细节问题</p><ol><li><p>如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e foo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">error:<br>removing these packages would break dependencies: foo is needed by bar-1.0-1<br></code></pre></td></tr></table></figure></li><li><p>如果我们就是要删除 foo这个rpm 包，可以增加参数 –nodeps,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -e --nodeps foo #带上 --nodeps 就是强制删除。<br></code></pre></td></tr></table></figure></li></ol><h4 id="15-1-6-安装rpm包："><a href="#15-1-6-安装rpm包：" class="headerlink" title="15.1.6 安装rpm包："></a>15.1.6 安装rpm包：</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh RPM包全路径名称<br></code></pre></td></tr></table></figure><p>参数说明<br>    i=install 安装<br>    v=verbose 提示<br>    h=hash 进度条</p><p>应用实例<br>实例1： 演示安装firefox浏览器<br>步骤先找到firefox的安装rpm 包,你需要挂载上我们安装centos的iso文件，然后到/media/下去找rpm 找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm<br></code></pre></td></tr></table></figure><h3 id="15-2-YUM"><a href="#15-2-YUM" class="headerlink" title="15.2 YUM"></a>15.2 YUM</h3><h4 id="15-2-1-介绍："><a href="#15-2-1-介绍：" class="headerlink" title="15.2.1 介绍："></a>15.2.1 介绍：</h4><p>Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系，并且一次安装所有依赖的软件包</strong>。使用yum的前提是可以联网。</p><h4 id="15-2-2-yum的基本指令"><a href="#15-2-2-yum的基本指令" class="headerlink" title="15.2.2 yum的基本指令"></a>15.2.2 yum的基本指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep xx #查询yum服务器是否有需要安装的软件<br>yum install xx     #安装指定的yum包<br></code></pre></td></tr></table></figure><h4 id="15-2-3-yum应用实例"><a href="#15-2-3-yum应用实例" class="headerlink" title="15.2.3 yum应用实例"></a>15.2.3 yum应用实例</h4><p>案例1：请使用yum的方式来安装firefox</p><ol><li><p>先查看一下 firefox rpm 在yum服务器有没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep firefox<br></code></pre></td></tr></table></figure></li><li><p>安装yuminstallfirefox会安装最新版本的软件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install firefox<br></code></pre></td></tr></table></figure></li></ol><h2 id="十六、搭建-JAVAEE-环境"><a href="#十六、搭建-JAVAEE-环境" class="headerlink" title="十六、搭建 JAVAEE 环境"></a>十六、搭建 JAVAEE 环境</h2><h3 id="16-1-概述"><a href="#16-1-概述" class="headerlink" title="16.1 概述"></a>16.1 概述</h3><p>如果需要在Linux下进行JavaEE的开发，我们需要安装如下软件：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225150900800.png"></p><h3 id="16-2-安装JDK"><a href="#16-2-安装JDK" class="headerlink" title="16.2 安装JDK"></a>16.2 安装JDK</h3><h4 id="16-2-1-安装步骤"><a href="#16-2-1-安装步骤" class="headerlink" title="16.2.1 安装步骤"></a>16.2.1 安装步骤</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/opt/</span>jdk<br>wget [下载链接]  <span class="hljs-comment">#下载JKD安装包</span><br>tar -zxvf 安装包<br>mkdir <span class="hljs-regexp">/usr/</span>local/java<br>mv 文件夹 <span class="hljs-regexp">/usr/</span>local/java<br><br>而配置环境变量,vim <span class="hljs-regexp">/etc/</span>profile<br>export JAVA_HOME=<span class="hljs-regexp">/opt/</span>jdk1.<span class="hljs-number">7.0</span>_79<br>export PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><br>需要注销用户，环境变量才能生效。<br>如果是在 <span class="hljs-number">3</span> 运行级别， logout<br>如果是在 <span class="hljs-number">5</span> 运行级别， source <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><h4 id="16-2-1-测试是否安装成功"><a href="#16-2-1-测试是否安装成功" class="headerlink" title="16.2.1 测试是否安装成功"></a>16.2.1 测试是否安装成功</h4><p>随意找一个目录，输入<code>javac --version &amp; java --version</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac --version<br>java --version<br></code></pre></td></tr></table></figure><h3 id="16-3-安装TOMCAT"><a href="#16-3-安装TOMCAT" class="headerlink" title="16.3 安装TOMCAT"></a>16.3 安装TOMCAT</h3><h4 id="16-3-1-步骤"><a href="#16-3-1-步骤" class="headerlink" title="16.3.1 步骤"></a>16.3.1 步骤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.上传安装文件，并解压缩到/opt/tomcat<br>2.进入解压目录/bin,启动tomcat（./startup.sh)<br>3.开放8080端口<br></code></pre></td></tr></table></figure><h4 id="16-3-2-测试是否安装成功"><a href="#16-3-2-测试是否安装成功" class="headerlink" title="16.3.2 测试是否安装成功"></a>16.3.2 测试是否安装成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">在windows、Linux下访问 http://ip:8080<br></code></pre></td></tr></table></figure><h3 id="16-4-安装IDEA"><a href="#16-4-安装IDEA" class="headerlink" title="16.4 安装IDEA"></a>16.4 安装IDEA</h3><h4 id="16-4-1-步骤"><a href="#16-4-1-步骤" class="headerlink" title="16.4.1 步骤"></a>16.4.1 步骤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. wget https://download.jetbrains.com/idea/ideaIU-2021.3.2.tar.gz?_gl=1*empi04*_ga*MTg0OTIyNTYuMTY0MzI1OTQ0Mw..*_ga_V0XZL7QHEB*MTY0NTc3NDI2OC40LjEuMTY0NTc3NDMwMy4w&amp;_ga=2.141732210.1541181338.1645774269-18492256.1643259443<br>2. tar -zxvf 安装包 #解压缩到/opt/idea<br>3. cd /opt/idea/bin<br>4. ./idea.sh<br>5. 配置jdk<br></code></pre></td></tr></table></figure><h3 id="16-5-MYSQL5-7的安装和配置"><a href="#16-5-MYSQL5-7的安装和配置" class="headerlink" title="16.5 MYSQL5.7的安装和配置"></a>16.5 MYSQL5.7的安装和配置</h3><h4 id="16-5-1-安装的步骤和文档"><a href="#16-5-1-安装的步骤和文档" class="headerlink" title="16.5.1 安装的步骤和文档"></a>16.5.1 安装的步骤和文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs linux">1. mkdir /opt/mysql<br>2. wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar<br>3. tar -zxvf mysql-5.7.26-1.el7.x86-64.rpm-bundle.tar<br>4. rpm -qa | grep mari<br>5. rpm -e --nodep mariadb-libs #Centos7.6自带mariadb数据库，会与mysql冲突，需要先删除<br>6. 按顺序执行：<br>rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm<br>7. systemctl start mysqld.service<br>8. grep &quot;password&quot; /var/log/mysqld.log #查看当前密码<br>9. mysql -u root -p#root用户登录<br>10. set global validate_password_policy=0; #提示密码设置策略<br>11. set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;mimamima&#x27;); #设置密码mimamima<br>12. flush privileges； #使密码设置生效<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225155613228.png"></p><h2 id="十七、Shell-编程"><a href="#十七、Shell-编程" class="headerlink" title="十七、Shell 编程"></a>十七、Shell 编程</h2><p>为什么要学习SHELL编程</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.Linux运维工程师在进行服务器集群管理时，需要编写<span class="hljs-keyword">Shell</span>程序来进行服务器管理。<br><span class="hljs-number">2</span>.对于JavaEE和Python程序员来说，工作的需要，你的老大会要求你编写一些<span class="hljs-keyword">Shell</span>脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。<br><span class="hljs-number">3</span>.对于大数据程序员来说，需要编写<span class="hljs-keyword">Shell</span>程序来管理集群。<br></code></pre></td></tr></table></figure><p>SHELL是什么?</p><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序.</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220225202923215.png"></p><h3 id="17-1-SHELL脚本的执行方式"><a href="#17-1-SHELL脚本的执行方式" class="headerlink" title="17.1 SHELL脚本的执行方式"></a>17.1 SHELL脚本的执行方式</h3><h4 id="17-1-1-脚本格式要求"><a href="#17-1-1-脚本格式要求" class="headerlink" title="17.1.1 脚本格式要求"></a>17.1.1 脚本格式要求</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.脚本以#!/bin/bash开头 (或者不用指定解释器，直接使用bash xxx.sh执行)<br>2.脚本需要有可执行权限<br></code></pre></td></tr></table></figure><h4 id="17-1-2-编写第一个Shell脚本"><a href="#17-1-2-编写第一个Shell脚本" class="headerlink" title="17.1.2 编写第一个Shell脚本"></a>17.1.2 编写第一个Shell脚本</h4><p>需求说明：创建一个Shell脚本，输出helloworld!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim helloworld.sh #(也可以不以.sh为结尾，但是为了规范建议以.sh为结尾)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo helloworld<br><br>chmod u+x helloworld.sh<br>./helloworld.sh<br></code></pre></td></tr></table></figure><h4 id="17-1-3-脚本的常用执行方式"><a href="#17-1-3-脚本的常用执行方式" class="headerlink" title="17.1.3 脚本的常用执行方式"></a>17.1.3 脚本的常用执行方式</h4><p>方式 1 (输入脚本的绝对路径或相对路径)<br>1 )首先要赋予helloworld.sh 脚本的+x权限<br>2 )执行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chomd u+x helloworld.sh<br>./helloworld.sh #或者 ~/shcode/helloworld.sh<br></code></pre></td></tr></table></figure><p>方式 2 (sh+脚本的绝对路径或者相对路径)，不推荐<br>说明：不用赋予脚本+x权限，直接执行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash helloworld.sh<br></code></pre></td></tr></table></figure><h3 id="17-2-Shell的变量"><a href="#17-2-Shell的变量" class="headerlink" title="17.2 Shell的变量"></a>17.2 Shell的变量</h3><p>Shell的变量的介绍</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>）LinuxShell中的变量分为，系统变量和用户自定义变量。<br><span class="hljs-symbol">2 </span>）系统变量：$HOME、$PWD、$<span class="hljs-keyword">SHELL</span>、$USER等等。比如：echo$HOME 等等..<br><span class="hljs-symbol">3 </span>）显示当前<span class="hljs-keyword">shell</span>中所有变量：使用命令set来查看<br></code></pre></td></tr></table></figure><h4 id="17-2-1-shell变量的定义"><a href="#17-2-1-shell变量的定义" class="headerlink" title="17.2.1 shell变量的定义"></a>17.2.1 shell变量的定义</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 )定义变量：变量=值<br>2 )撤销变量：unset 变量<br>3 ) 声明静态变量：readonly变量，注意：不能unset<br></code></pre></td></tr></table></figure><p>应用案例：</p><p>案例 1 ：定义变量A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100<br>echo A = $A<br>echo &quot;A = %A&quot;<br></code></pre></td></tr></table></figure><p>案例 2 ：撤销变量A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100<br>unset A<br></code></pre></td></tr></table></figure><p>案例 3 ：声明静态的变量B= 2 ，不能unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>readonly B=200<br>echo &quot;B = $B&quot;<br></code></pre></td></tr></table></figure><p>案例 4 ：可把变量提升为全局环境变量，可供其他shell程序使用【一会举例。】</p><h4 id="17-2-2定义变量的规则"><a href="#17-2-2定义变量的规则" class="headerlink" title="17.2.2定义变量的规则"></a>17.2.2定义变量的规则</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。<br><span class="hljs-bullet">2.</span> 等号两侧不能有空格<br><span class="hljs-bullet">3.</span> 变量名称一般习惯为大写,当然小写不出错，但是大写是规范<br></code></pre></td></tr></table></figure><h4 id="17-2-3-将命令的返回值赋给变量（重点）"><a href="#17-2-3-将命令的返回值赋给变量（重点）" class="headerlink" title="17.2.3 将命令的返回值赋给变量（重点）"></a>17.2.3 将命令的返回值赋给变量（重点）</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1. <span class="hljs-attribute">A</span>=`ls-la` 反引号，运行里面的命令，并把结果返回给变量A<br>2. <span class="hljs-attribute">A</span>=$(ls-la) 等价于反引号<br>否则，就是将字符串赋值给变量<br></code></pre></td></tr></table></figure><h3 id="17-3-设置环境变量"><a href="#17-3-设置环境变量" class="headerlink" title="17.3 设置环境变量"></a>17.3 设置环境变量</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. <span class="hljs-built_in">export</span> 变量名=变量值 （功能描述：将shell变量输出为环境变量/全局变量）<br>2. <span class="hljs-built_in">source</span> 配置文件 （功能描述：让修改后的配置信息立即生效）<br>3. <span class="hljs-built_in">echo</span> $变量名 （功能描述：查询环境变量的值）<br></code></pre></td></tr></table></figure><p>应用案例：</p><p>案例1：在/etc/profile文件中定义TOMCAT_HOME环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br><br>export TOMCAT_HOME=/opt/tomcat<br></code></pre></td></tr></table></figure><p>案例2：查看环境变量TOMCAT_HOME的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $TOMCAT_HOME<br></code></pre></td></tr></table></figure><p>案例3：在另外一个shell程序中使用TOMCAT_HOME。注意：在输出TOMCAT_HOME 环境变量前，需要让其生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h3 id="17-4-Shell的注释"><a href="#17-4-Shell的注释" class="headerlink" title="17.4 Shell的注释"></a>17.4 Shell的注释</h3><p>单行注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;[字符]  #这里的字符可以是数字或者是字符都可以<br>语句1<br>语句2<br>[字符]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">比如</span><br>:&lt;&lt;!<br>语句1<br>语句2<br>!<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">或者</span><br>:&lt;&lt;0<br>语句1<br>语句2<br>0<br></code></pre></td></tr></table></figure><h3 id="17-5-位置参数变量"><a href="#17-5-位置参数变量" class="headerlink" title="17.5 位置参数变量"></a>17.5 位置参数变量</h3><p>介绍：</p><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量，比如 ：<code>./myshell.sh 100 200</code> , 这个就是一个执行shell的命令行，可以在myshell 脚本中获取到</p><p>基本语法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$n</span> （功能描述：n为数字，<span class="hljs-variable">$0</span> 代表命令本身，<span class="hljs-variable">$1</span>-<span class="hljs-variable">$9</span> 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<span class="hljs-variable">$</span>&#123;<span class="hljs-number">10</span>&#125;）<br><span class="hljs-variable">$</span>* （功能描述：这个变量代表命令行中所有的参数，<span class="hljs-variable">$</span>*把所有的参数看成一个整体）<br><span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span> （功能描述：这个变量也代表命令行中所有的参数，不过<span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>把每个参数区分对待）<br><span class="hljs-variable">$</span><span class="hljs-comment"># （功能描述：这个变量代表命令行中所有参数的个数）</span><br></code></pre></td></tr></table></figure><p>应用实例：</p><p>案例1：编写一个shell脚本 positionPara.sh ， 在脚本中获取到命令行的各个参数信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim myshell.sh<br><br>echo 第一个参数 = $1 第二个参数 = $2<br></code></pre></td></tr></table></figure><h3 id="17-6-预定义变量"><a href="#17-6-预定义变量" class="headerlink" title="17.6 预定义变量"></a>17.6 预定义变量</h3><p>基本介绍</p><p>预定义变量就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用。</p><p>基本语法</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> （功能描述：当前进程的进程号（PID））<br><span class="hljs-symbol">$</span>! （功能描述：后台运行的最后一个进程的进程号（PID））<br><span class="hljs-symbol">$</span>？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 <span class="hljs-number">0</span> ，证明上一个命令正确执行；如果这个变量的值为非 <span class="hljs-number">0</span> （具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：在一个shell脚本中简单使用一下预定义变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo 当前进程的进程号$$<br>bash ~/shcode/myshell.sh &amp; #次数加上&amp;，说明让该命令后台运行<br>echo 最后一个后台运行的进程ID$!<br>echo 最后一次执行的命令的返回状态$?<br></code></pre></td></tr></table></figure><h3 id="17-7-运算符"><a href="#17-7-运算符" class="headerlink" title="17.7 运算符"></a>17.7 运算符</h3><p>基本介绍</p><p>学习如何在shell中进行各种运算操作。</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">“$((运算式))” 或者 “$[运算式]”  #*不需要转义，运算符间也不需要空格<br>expr m + n #注意expr运算符间要有空格，如果希望将expr结果赋值给某个变量，需要使用‘’引起来，例如`expr m + n`<br>expr \*,/,% 乘，除，取余 #需要注意的是*，需要转义<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例 1 ：计算（ 2 + 3 ）X 4 的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=$(((2 + 3) * 4)) #注意只有expr运算符才需要将*转义<br>A=$[(2 + 3) * 4]<br>A=`expr (2 + 3) \* 4` #这种做法是错误的，应该分步走<br>A=`expr 2 + 3`<br>A=`expr 4 \* $A`<br></code></pre></td></tr></table></figure><p>案例 2 ：请求出命令行的两个参数[整数]的和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=$[$1 + $2]<br>echo 和为 $A<br></code></pre></td></tr></table></figure><h3 id="17-8-条件判断"><a href="#17-8-条件判断" class="headerlink" title="17.8 条件判断"></a>17.8 条件判断</h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ condition ]   #注意condition前后要有空格<br>  #非空返回true，可使用$?验证（ 0 为true，&gt; 1 为false）<br></code></pre></td></tr></table></figure><p>应用实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ atguigu ] 返回true<br>[ ] 返回false<br>[ condition ] &amp;&amp; echo OK || echo notok #条件满足，执行后面的语句，相当于三目运算<br></code></pre></td></tr></table></figure><p>常用判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">= 字符串比较<br><span class="hljs-meta">#</span><span class="bash">两个整数的比较</span><br>- lt 小于<br>- le 小于等于<br>- eq 等于<br>- gt 大于<br>- ge 大于等于<br>- ne 不等于<br><span class="hljs-meta">#</span><span class="bash">按照文件权限进行判断</span><br>- r 有读的权限 [-r 文件 ]<br>- w 有写的权限<br>- x 有执行的权限<br><span class="hljs-meta">#</span><span class="bash">按照文件类型进行判断</span><br>- f 文件存在并且是一个常规的文件<br>- e 文件存在<br>- d 文件存在并是一个目录<br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例1：”ok”是否等于”ok”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ok = ok<br></code></pre></td></tr></table></figure><p>案例2： 23 是否大于等于 22</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">23 -ge 22<br></code></pre></td></tr></table></figure><p>案例 3 ：/root/install.log目录中的文件是否存在</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-f <span class="hljs-regexp">/root/i</span>nstall.log<br></code></pre></td></tr></table></figure><h3 id="17-9-流程控制"><a href="#17-9-流程控制" class="headerlink" title="17.9 流程控制"></a>17.9 流程控制</h3><h4 id="17-9-1-if-判断"><a href="#17-9-1-if-判断" class="headerlink" title="17.9.1 if 判断"></a>17.9.1 if 判断</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sehll">if [ 条件判断式 ]<br>then<br>  程序<br>fi<br><br>或者<br><br>if [ 条件判断式 ]<br>then<br>     程序<br>elif [ 条件判断式 ]<br>then<br>程序<br>fi<br><br>或者<br><br>if [ 条件判断式 ]<br>then<br>程序<br>else<br>程序<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">注意事项：<span class="hljs-selector-attr">[ 条件判断式 ]</span>中括号和条件判断式之间必须有空格<br></code></pre></td></tr></table></figure><p>应用实例<br>案例1：请编写一个shell程序，如果输入的参数，大于等于 60 ，则输出 “及格了”，如果小于 60 ,则输出 “不及格”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 -ge 60 ]<br>then<br>        echo 及格了<br>elif [ $1 -lt 60 ]<br>then<br>        echo 不及格<br>fi<br></code></pre></td></tr></table></figure><h4 id="17-9-2-case语句"><a href="#17-9-2-case语句" class="headerlink" title="17.9.2 case语句"></a>17.9.2 case语句</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;值 1 &quot;）<br>如果变量的值等于值 1 ，则执行程序 1<br>;;<br>&quot;值 2 &quot;）<br>如果变量的值等于值 2 ，则执行程序 2<br>;;<br>*）<br>如果变量的值都不是以上的值，则执行此程序<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：当命令行参数是 1 时，输出 “周一”, 是 2 时，就输出”周二”，其它情况输出 “other”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>case $1 in<br>&quot;1&quot;)<br>echo 周一<br>;;<br>&quot;2&quot;)<br>echo 周二<br>;;<br>*)<br>echo other...<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="17-9-3-for循环"><a href="#17-9-3-for循环" class="headerlink" title="17.9.3 for循环"></a>17.9.3 for循环</h3><p>基本语法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3 ...<br>do<br>程序/代码<br>done<br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：打印命令行输入的参数 【会使用到$*  $@，体会$* 与 $@的区别】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>for i in &quot;$*&quot;<br>do<br>        echo num is $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash for.sh 1 2 3 4 5<br>输出：<br>num is 1 2 3 4 5<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>for i in &quot;$@&quot;<br>do<br>        echo num is $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash for.sh 1 2 3 4 5<br>输出：<br>num is 1<br>num is 2<br>num is 3<br>num is 4<br>num is 5<br></code></pre></td></tr></table></figure><p>基本语法 </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for<span class="hljs-comment">(( 初始值 ; 循环控制条件 ; 变量变化 )</span>)<br><span class="hljs-keyword">do</span><br>程序<br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure><p>应用实例</p><p>案例 1 ：从 1 加到 100 的值输出显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>SUM=0<br>for (( i=1; i&lt;=100; i++))<br>do<br>        SUM=$[$SUM+$i]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><h4 id="17-9-4-while循环"><a href="#17-9-4-while循环" class="headerlink" title="17.9.4 while循环"></a>17.9.4 while循环</h4><p>基本语法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">while[ 条件判断式 ]<br>do<br>      程序<br>done<br><span class="hljs-meta">#</span><span class="bash">注意：<span class="hljs-keyword">while</span>和[有空格，条件判断式和[也有空格</span><br></code></pre></td></tr></table></figure><p>应用实例<br>案例 1 ：从命令行输入一个数n，统计从 1 +..+n 的值是多少？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>SUM=0<br>i=0<br>while [ $i -le $1 ]<br>do<br>        SUM=$[$SUM+$i]<br>        i=$[$i+1]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><h3 id="17-10-READ读取控制台输入"><a href="#17-10-READ读取控制台输入" class="headerlink" title="17.10 READ读取控制台输入"></a>17.10 READ读取控制台输入</h3><p>基本语法</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">read</span> <span class="hljs-params">(选项)</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></table></figure><p>选项：</p><ul><li>-p：指定读取值时的提示符；</li><li>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。。<br>参数<br>变量：指定读取值的变量名</li></ul><p>应用实例</p><p>案例 1 ：读取控制台输入一个num值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>read -p 请输入一个数 NUM<br>echo $NUM<br></code></pre></td></tr></table></figure><p>案例 2 ：读取控制台输入一个num值，在 10 秒内输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>read -t 10 -p 输入一个数 NUM<br>echo $NUM<br></code></pre></td></tr></table></figure><h3 id="17-11-函数"><a href="#17-11-函数" class="headerlink" title="17.11 函数"></a>17.11 函数</h3><p>函数介绍：</p><p>shell编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。</p><h4 id="17-11-1-系统函数"><a href="#17-11-1-系统函数" class="headerlink" title="17.11.1 系统函数"></a>17.11.1 系统函数</h4><p>basename基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">basename [pathname] [suffix] #功能：返回完整路径最后 / 的部分，常用于获取文件名<br></code></pre></td></tr></table></figure><p>选项：</p><p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>案例 1 ：请返回 /home/aaa/test.txt 的 “test.txt” 部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">basename /home/aaa/test.txt<br>basename /home/aaa/test.txt .txt<br></code></pre></td></tr></table></figure><p>dirname基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dirname 文件绝对路径 #（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））<br></code></pre></td></tr></table></figure><p>案例 2 ：请返回 /home/aaa/test.txt 的 /home/aaa</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dirname /home/aaa/test.txt<br></code></pre></td></tr></table></figure><h4 id="17-11-2-自定义函数"><a href="#17-11-2-自定义函数" class="headerlink" title="17.11.2 自定义函数"></a>17.11.2 自定义函数</h4><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[function]funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br><span class="hljs-meta">#</span><span class="bash">在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <span class="hljs-variable">$n</span> 的形式来获取参数的值，例如，<span class="hljs-variable">$1</span>表示第一个参数，<span class="hljs-variable">$2</span>表示第二个参数...</span><br></code></pre></td></tr></table></figure><p>调用直接写函数名：funname [值]</p><p>应用实例<br>案例 1 ：计算输入两个参数的和（read）， getSum</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">function getSum() &#123;<br>        SUM=$[$n1+$n2]<br>        echo 和是$SUM<br>&#125;<br>read -p 输入两个值 n1 n2<br>getSum <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Shell 变量的作用域可以分为三种：<br>有的变量只能在函数内部使用，这叫做局部变量（local variable）；除非定义时使用local限定，否则都是全局变量<br>有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；正常定义都是全局变量<br>而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。需要使用export导出环境变量。<br><br></code></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/773.html">Shell作用域细节</a></p><h3 id="17-12-SHELL编程综合案例"><a href="#17-12-SHELL编程综合案例" class="headerlink" title="17.12 SHELL编程综合案例"></a>17.12 SHELL编程综合案例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">需求分析<br><span class="hljs-number">1</span> )每天凌晨 <span class="hljs-number">2</span> : <span class="hljs-number">10</span> 备份 数据库 atguiguDB 到 /data/backup/db<br><span class="hljs-number">2</span> )备份开始和备份结束能够给出相应的提示信息<br><span class="hljs-number">3</span> )备份后的文件要求以备份时间为文件名，并打包成 <span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 的形式，比如：<span class="hljs-number">2018</span>-<span class="hljs-number">03</span>-<span class="hljs-number">12</span>_230201<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br><span class="hljs-number">4</span> ) 在备份的同时，检查是否有 <span class="hljs-number">10</span> 天前备份的数据库文件，如果有就将其删除。<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. cd/usr/sbin #root用户的系统管理程序<br>vim mysqlbd_backup.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">备份目录</span><br>BACKUP=/data/backup/bd<br><span class="hljs-meta">#</span><span class="bash">当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br>echo $DATETIME<br><span class="hljs-meta">#</span><span class="bash">数据库地址</span><br>HOST=localhost<br><span class="hljs-meta">#</span><span class="bash">数据库用户名</span><br>DB_USER=root<br><span class="hljs-meta">#</span><span class="bash">数据库密码</span><br>DB_PW=hspedu100<br><span class="hljs-meta">#</span><span class="bash">备份的数据库名</span><br>DATABASE=hspedu<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">备份数据库</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$&#123;DATETIME&#125;.sql.gz<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">将文件处理成.tar.gz</span><br>cd $&#123;BACKUP&#125;<br>tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta">#</span><span class="bash">删除对应的备份目录</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除十天前备份文件</span><br>find $&#123;BACKUP&#125; -atime + 10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br>echo &quot;备份数据库$&#123;DATABASE&#125;&quot;<br><br><br>crond -e<br>30 2 * * * /usr/sbin/mysqlbd_backup.sh<br></code></pre></td></tr></table></figure><h2 id="十八、Ubuntu"><a href="#十八、Ubuntu" class="headerlink" title="十八、Ubuntu"></a>十八、Ubuntu</h2><p>Ubuntu介绍</p><p>Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu是基于GNU/Linux，支持x 86 、amd 64 （即x 64 ）和ppc架构，由全球化的专业开发团队（CanonicalLtd）打造的。</p><p>专业的Python开发者一般会选择 Ubuntu 这款Linux系统作为生产平台.<br>温馨提示：<br>Ubuntu 和 Centos 都是基于 GNU/Linux 内核的，因此基本使用和Centos是几乎一样的，它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在前面学习CentOS都使用过。只是界面和预安装的软件有所差别。</p><p>Ubuntu下载地址：<a href="http://cn.ubuntu.com/download/">http://cn.ubuntu.com/download/</a></p><h3 id="18-1-设置Ubuntu支持中文"><a href="#18-1-设置Ubuntu支持中文" class="headerlink" title="18.1 设置Ubuntu支持中文"></a>18.1 设置Ubuntu支持中文</h3><p>默认安装的ubuntu 中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。</p><p>安装中文支持步骤：</p><p>1 .单击左侧图标栏打开 SystemSettings（系统设置）菜单，点击打开 LanguageSupport（语言支持）选项卡。</p><p>2 .点击 Install/RemoveLanguages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击ApplyChanges 提交，系统会自动联网下载中文语言包。（保证ubuntu 是联网的）。</p><p>3 .这时“汉语（中国）”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语（中国）”设置为第一位。设置方法是拖动，鼠标单击“汉语（中国）”，当底色变化（表示选中了）后，按住鼠标左键不松手，向上拖动放置到第一位。</p><p>4 .设置后不会即刻生效，需要下一次登录时才会生效。</p><h3 id="18-2-Ubuntu的root用户"><a href="#18-2-Ubuntu的root用户" class="headerlink" title="18.2 Ubuntu的root用户"></a>18.2 Ubuntu的root用户</h3><p>安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上 sudo 。有的时候感觉很麻烦。</p><p>我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码，就会抛出 su:Authenticationfailure 这样的问题。所以，我们只要给root用户设置一个初始密码就好了。</p><h4 id="18-2-1-给root用户设置密码并使用"><a href="#18-2-1-给root用户设置密码并使用" class="headerlink" title="18.2.1 给root用户设置密码并使用"></a>18.2.1 给root用户设置密码并使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 ) 输入 sudo passwd 命令，输入一般用户密码并设定root用户密码。<br>2 ) 设定root密码成功后，输入 su 命令，并输入刚才设定的root密码，就可以切换成root了。# 提示符$代表一般用户，提示符#代表root用户。<br>3 ) 输入 exit 命令，退出root并返回一般用户<br>4 ) 以后就可以使用root用户了 <br></code></pre></td></tr></table></figure><p>需要注意的是，<code>sudo</code>是允许当前用户以root身份执行命令，但是本身还是普通用户；而<code>su root</code>是切换到root用户，家目录变成<code>/root</code>。</p><h2 id="十九、Ubuntu-软件管理和远程登录"><a href="#十九、Ubuntu-软件管理和远程登录" class="headerlink" title="十九、Ubuntu 软件管理和远程登录"></a>十九、Ubuntu 软件管理和远程登录</h2><p>APT介绍</p><p>apt是AdvancedPackagingTool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令可用于软件包的安装、删除、清理等，类似于Windows中的软件管理工具。</p><p>ubuntu 软件管理的原理示意图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227150334400.png"></p><h3 id="19-1-Ubuntu软件操作的相关命令"><a href="#19-1-Ubuntu软件操作的相关命令" class="headerlink" title="19.1 Ubuntu软件操作的相关命令"></a>19.1 Ubuntu软件操作的相关命令</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> update 更新源<br>sudo apt-<span class="hljs-builtin-name">get</span> install package 安装包<br>sudo apt-<span class="hljs-builtin-name">get</span> <span class="hljs-builtin-name">remove</span> package 删除包<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo apt-cache search <span class="hljs-keyword">package</span> <span class="hljs-title">搜索软件包</span><br>sudo apt-cache show <span class="hljs-keyword">package</span> <span class="hljs-title">获取包的相关信息，如说明、大小、版本等</span><br>sudo apt-get install <span class="hljs-keyword">package</span> <span class="hljs-title">--reinstall 重新安装包</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> -f install 修复安装<br>sudo apt-<span class="hljs-builtin-name">get</span> <span class="hljs-builtin-name">remove</span> package --purge 删除包，包括配置文件等<br>sudo apt-<span class="hljs-builtin-name">get</span> build-dep package 安装相关的编译环境<br></code></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">sudo apt-<span class="hljs-built_in">get</span> upgrade 更新已安装的包<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">dist</span>-upgrade 升级系统<br>sudo apt-cache depends <span class="hljs-keyword">package</span> 了解使用该包依赖那些包<br>sudo apt-cache rdepends <span class="hljs-keyword">package</span> 查看该包被哪些包依赖<br>sudo apt-<span class="hljs-built_in">get</span> source <span class="hljs-keyword">package</span> 下载该包的源代码<br></code></pre></td></tr></table></figure><h3 id="19-2-更新UBUNTU软件下载地址"><a href="#19-2-更新UBUNTU软件下载地址" class="headerlink" title="19.2 更新UBUNTU软件下载地址"></a>19.2 更新UBUNTU软件下载地址</h3><h4 id="19-2-1-寻找国内镜像源"><a href="#19-2-1-寻找国内镜像源" class="headerlink" title="19.2.1 寻找国内镜像源"></a>19.2.1 寻找国内镜像源</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore</p><h4 id="19-2-2-备份Ubuntu默认的源地址"><a href="#19-2-2-备份Ubuntu默认的源地址" class="headerlink" title="19.2.2 备份Ubuntu默认的源地址"></a>19.2.2 备份Ubuntu默认的源地址</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br></code></pre></td></tr></table></figure><h4 id="19-2-3-更新源服务器列表"><a href="#19-2-3-更新源服务器列表" class="headerlink" title="19.2.3 更新源服务器列表"></a>19.2.3 更新源服务器列表</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227151112006.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/apt/souces.list #更新镜像源地址文件<br>sudo apt-get update #更新源地址<br></code></pre></td></tr></table></figure><h3 id="19-3-Ubuntu软件安装与卸载"><a href="#19-3-Ubuntu软件安装与卸载" class="headerlink" title="19.3 Ubuntu软件安装与卸载"></a>19.3 Ubuntu软件安装与卸载</h3><p>使用apt完成安装和卸载vim 软件，并查询 vim软件的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove vim<br>sudo apt-get install vim<br>sudo apt-cache show vim<br></code></pre></td></tr></table></figure><p>需要注意的是，现在官方主推apt命令，apt相当于apt-get + apt-cache + apt-config</p><h3 id="19-4-使用SSH远程登录Ubuntu"><a href="#19-4-使用SSH远程登录Ubuntu" class="headerlink" title="19.4 使用SSH远程登录Ubuntu"></a>19.4 使用SSH远程登录Ubuntu</h3><p>ssh介绍</p><p>SSH为SecureShell的缩写，由 IETF 的网络工作小组（NetworkWorkingGroup）所制定；SSH为建立在应用层和传输层基础上的安全协议。</p><p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。</p><p>使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。和CentOS不一样，Ubuntu默认没有安装SSHD服务(netstat -anp 查看是否有进程监听22号端口，如果连netstat命令都没有安装，可以使用apt install net-tools先安装netstat命令)，因此，我们不能进行远程登录。</p><h4 id="19-4-1-原理示意图"><a href="#19-4-1-原理示意图" class="headerlink" title="19.4.1 原理示意图"></a>19.4.1 原理示意图</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227152239100.png"></p><h3 id="19-5-使用SSH远程登录Ubuntu"><a href="#19-5-使用SSH远程登录Ubuntu" class="headerlink" title="19.5 使用SSH远程登录Ubuntu"></a>19.5 使用SSH远程登录Ubuntu</h3><h4 id="19-5-1-安装SSH和启用"><a href="#19-5-1-安装SSH和启用" class="headerlink" title="19.5.1 安装SSH和启用"></a>19.5.1 安装SSH和启用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install openssh-server #执行上面指令后，在当前这台Linux上就安装了SSH服务端和客户端。<br>service sshd restart #执行上面的指令，就启动了 sshd 服务。会监听端口 22<br></code></pre></td></tr></table></figure><h4 id="19-5-2-从linux系统客户机远程登陆linux系统服务机"><a href="#19-5-2-从linux系统客户机远程登陆linux系统服务机" class="headerlink" title="19.5.2 从linux系统客户机远程登陆linux系统服务机"></a>19.5.2 从linux系统客户机远程登陆linux系统服务机</h4><p>首先，我们需要在linux的系统客户机也要安装<code>openssh-server</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227152741432.png"></p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 用户名@IP<br><span class="hljs-meta">#</span><span class="bash">例如：sshatguigu@192.168.188.131</span><br><span class="hljs-meta">#</span><span class="bash">使用ssh访问，如访问出现错误。可查看是否有该文件 ～/.ssh/known_ssh 尝试删除该文件解决。</span><br></code></pre></td></tr></table></figure><p>登出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br><span class="hljs-meta">#</span><span class="bash">或者</span><br>logout<br></code></pre></td></tr></table></figure><h2 id="二十、CentOS8-0-Vs-CentOS7-0"><a href="#二十、CentOS8-0-Vs-CentOS7-0" class="headerlink" title="二十、CentOS8.0 Vs CentOS7.0"></a>二十、CentOS8.0 Vs CentOS7.0</h2><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227180614734.png"></p><p>可惜，由于红帽的政策，Centos会逐渐变成上游不稳定版本，而且Centos7和Centos8也会很快不被维护。</p><h2 id="二十一、日志管理"><a href="#二十一、日志管理" class="headerlink" title="二十一、日志管理"></a>二十一、日志管理</h2><p>基本介绍</p><ol><li>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。</li><li>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。</li><li>可以这样理解日志是用来记录重大事件的工具</li></ol><h3 id="21-1-系统常用日志"><a href="#21-1-系统常用日志" class="headerlink" title="21.1 系统常用日志"></a>21.1 系统常用日志</h3><p><code>/var/log</code>目录就是系统日志文件的保存位置：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227181515157.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227182650989.png"></p><p>应用案例</p><p>案例1：使用root用户通过xshell6登陆,第一次使用错误的密码，第二次使用正确的密码登录成功看看在日志文件/var/log/secure里有没有记录相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/secure<br></code></pre></td></tr></table></figure><h3 id="21-2-日志管理服务rsyslogd"><a href="#21-2-日志管理服务rsyslogd" class="headerlink" title="21.2 日志管理服务rsyslogd"></a>21.2 日志管理服务rsyslogd</h3><p>​        CentOS7.6日志服务是rsyslogd，CentOS6.x日志服务是syslogd。rsyslogd功能更强大。rsyslogd的使用、日志文件的格式，和syslogd服务兼容的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227183859819.png"></p><p><code>/etc/rsyslog.conf</code>中记录了，各种服务应该写入日志的目录。</p><p>应用案例</p><p>案例1：查询Linux中的rsyslogd服务是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux | grep rsyslogd | grep -v grep  # grep -v 是指选择不含匹配串的行<br></code></pre></td></tr></table></figure><p>案例2：查询rsyslogd服务的自启动状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl list-unit-files | grep rsyslogd<br></code></pre></td></tr></table></figure><h4 id="21-2-1-配置文件-etc-rsyslog-conf"><a href="#21-2-1-配置文件-etc-rsyslog-conf" class="headerlink" title="21.2.1 配置文件 /etc/rsyslog.conf"></a>21.2.1 配置文件 /etc/rsyslog.conf</h4><p>编辑文件时的格式为：*.*, 存放日志文件</p><p>其中第一个*代表日志类型，第二个*代表日志级别</p><ol><li><p>日志类型分为：</p><p>auth：pam产生的日志</p><p>authpriv：ssh、ftp等登录信息的验证信息</p><p>corn：时间任务相关</p><p>kern：内核</p><p>lpr：打印</p><p>mail：邮件</p><p>mark(syslog)-rsyslog:服务内部的信息，时间标识</p><p>news：新闻组</p><p>user：用户程序产生的相关信息</p><p>uucp：unix to unix copy主机之间相关的通信</p><p>local 1-7：自定义的日志设备</p></li><li><p>日志级别：</p><p>debug：有调试信息的，日志通信最多</p><p>info：一般信息日志，最常用</p><p>notice：最具有重要性的普通条件的信息</p><p>warning：警告级别</p><p>err：错误级别，阻止某个功能或者模块不能正常工作的信息</p><p>crit：严重级别，阻止整个系统或者整个软件不能正常工作的信息</p><p>alert：需要立刻修改的信息</p><p>emerg：内核崩溃等重要信息</p><p>none：什么都不记录</p><p>注意：从上到下，级别从低到高，记录信息越来越少</p></li></ol><p>由日志服务rsyslogd记录的日志文件，日志文件的格式包含以下4列：</p><ol><li><p>事件产生的时间</p></li><li><p>产生事件的服务器的主机名</p></li><li><p>产生事件的服务名或程序名</p></li><li><p>事件的具体信息</p></li></ol><p>应用案例</p><p>案例1：查看一下/var/log/secure日志，这个日志中记录的是用户验证和授权方面的信息，来分析如何查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/secure<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227185605784.png"></p><p>案例2：在/etc/rsyslog.conf中添加一个日志文件/var/log/hsp.log,当有事件发送时(比如sshd服务相关事件)，该文件会接收到信息并保存.给小伙伴演示重启，登录的情况，看看是否有日志保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/rsyslog.conf<br><br>*.*/var/log/hsp.log<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/hsp.log #就可以看到相关服务时间的日志<br></code></pre></td></tr></table></figure><h3 id="21-3-日志轮替"><a href="#21-3-日志轮替" class="headerlink" title="21.3 日志轮替"></a>21.3 日志轮替</h3><p>基本介绍</p><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。</p><h4 id="21-3-1-日志轮替文件命名"><a href="#21-3-1-日志轮替文件命名" class="headerlink" title="21.3.1 日志轮替文件命名"></a>21.3.1 日志轮替文件命名</h4><ol><li>centos7使用logrotate进行日志轮替管理，要想改变日志轮替文件名字，通过/etc/logrotate.conf配置文件中“dateext”参数</li><li>如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。</li><li> 如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。</li></ol><h4 id="21-3-2-logrotate配置文件"><a href="#21-3-2-logrotate配置文件" class="headerlink" title="21.3.2 logrotate配置文件"></a>21.3.2 logrotate配置文件</h4><p><code>/etc/logrotate.conf</code>为logrotate的全局配置文件</p><p>#rotate log files weekly,每周对日志文件进行一次轮替</p><p>weekly</p><p>#keep 4 weeks worth of backlogs,共保存4份日志文件，当建立新的日志文件时，旧的将会被删除</p><p>rotate4</p><p>#create new (empty) log files after rotating old ones,创建新的空的日志文件，在日志轮替后</p><p>create</p><p>#use date as a suffix of the rotated file,使用日期作为日志轮替文件的后缀</p><p>dateext</p><p>#uncomment this if you want your log files compressed,日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩#compress</p><p>#RPM packages drop log rotation information into this directory </p><p>include /etc/logrotate.d/</p><p>#包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，</p><p>#下面是单独设置，优先级更高。</p><p>#no packages own wtmp and btmp – we’ll rotate them here</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/log/wtmp &#123;<br><span class="hljs-meta">monthly#</span><span class="bash">每月对日志文件进行一次轮替</span><br>create 0664 root utmp #建立的新日志文件，权限是0664，所有者是root，所属组是utmp组<br>minsize 1M #日志文件最小轮替大小是1MB，也就是日志一定要超过1MB才会被轮替，否则就算时间达到一个月，也不进行日志转储<br>rotate 1 #仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/log/btmp &#123;<br>missingok #如果日志不存在，则忽略该日志的警告信息<br>monthly<br>create 0600 root utmp<br>rotate 1<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="21-3-3-logroate配置文件的参数说明"><a href="#21-3-3-logroate配置文件的参数说明" class="headerlink" title="21.3.3 logroate配置文件的参数说明"></a>21.3.3 logroate配置文件的参数说明</h4><table><thead><tr><th>daily</th><th>日志的轮替周期是每天</th></tr></thead><tbody><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日后在的轮替周期是每月</td></tr><tr><td>rotate 数字</td><td>保留的日志文件个数。0指每月备份</td></tr><tr><td>compress</td><td>日志轮替是，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组</td></tr><tr><td>mail address</td><td>当日志轮替是，输出内容通过邮件发送到指定的邮件地址</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值，也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀</td></tr><tr><td>sharedscripts</td><td>再次关键字之后的监本只执行一次</td></tr><tr><td>prerotate/endscript</td><td>在日志轮替前执行脚本命令</td></tr><tr><td>postroate/endscript</td><td>在日志轮替后执行脚本命令</td></tr></tbody></table><p>应用案例</p><p>案例1：把自己的日志加入日志轮替</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">可以写入到/etc/logrotate.d/下，vim hsp<br><br>/var/log/hsp.log &#123;<br>missingok<br>daily<br>copytruncate<br>rotate 7<br>notifempty<br>&#125;<br><span class="hljs-meta">#</span><span class="bash">同样也可以直接写入到主配置文件中，/etc/logrotate.conf中</span><br></code></pre></td></tr></table></figure><h4 id="21-3-4-日志轮替机制原理"><a href="#21-3-4-日志轮替机制原理" class="headerlink" title="21.3.4 日志轮替机制原理"></a>21.3.4 日志轮替机制原理</h4><p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在/etc/cron.daily/目录，就会发现这个目录中是有logrotate文件(可执行)，logrotate通过这个文件依赖定时任务执行的。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227183859819.png"></p><h3 id="21-4-查看内存日志"><a href="#21-4-查看内存日志" class="headerlink" title="21.4 查看内存日志"></a>21.4 查看内存日志</h3><p>journalctl可以查看内存日志，这里我们看看常用的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">journalctl #查看全部<br>journalctl -n 3 #查看最新3条<br>journalctl --since 19:00 --until 19:10:10 #查看起始时间到结束时间的日志可加日期<br>journalctl -p err #报错日志<br>journalctl -o varbose #日志详细内容<br>journalctl _PID=1245 _COMM=sshd #查看包含这些参数的日志<br>或者 journalctl | grep sshd<br></code></pre></td></tr></table></figure><p>注意：journalctl查看的事内存日志，重启清空</p><p>应用案例：</p><p>案例1：使用 journalctl | grep sshd来看看用户登录清空,重启系统，再次查询，看看日志有什么变化没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">journalctl | grep sshd<br></code></pre></td></tr></table></figure><h2 id="二十二、定制自己的Linux系统"><a href="#二十二、定制自己的Linux系统" class="headerlink" title="二十二、定制自己的Linux系统"></a>二十二、定制自己的Linux系统</h2><h3 id="22-1-基本介绍"><a href="#22-1-基本介绍" class="headerlink" title="22.1 基本介绍"></a>22.1 基本介绍</h3><p>通过裁剪现有Linux系统(CentOS7.6)，创建属于自己的minLinux小系统，可以加深我们对linux的理解。</p><h3 id="22-2-启动流程介绍"><a href="#22-2-启动流程介绍" class="headerlink" title="22.2 启动流程介绍"></a>22.2 启动流程介绍</h3><p>制作Linux小系统之前，再了解一下Linux的启动流程：</p><p>1、首先Linux要通过自检，检查硬件设备有没有故障</p><p>2、如果有多块启动盘的话，需要在BIOS中选择启动磁盘</p><p>3、启动MBR中的bootloader引导程序</p><p>4、加载内核文件</p><p>5、执行所有进程的父进程、老祖宗systemd</p><p>6、欢迎界面</p><p>在Linux的启动流程中，加载内核文件时关键文件：</p><p>1）kernel文件:vmlinuz-3.10.0-957.el7.x86_64</p><p>2）initrd文件:initramfs-3.10.0-957.el7.x86_64.img</p><h3 id="22-3-制作minlinux思路分析"><a href="#22-3-制作minlinux思路分析" class="headerlink" title="22.3 制作minlinux思路分析"></a>22.3 制作minlinux思路分析</h3><p>1)在现有的Linux系统(centos7.6)上加一块硬盘/dev/sdb，在硬盘上分两个分区，一个是/boot，一个是/，并将其格式化。需要明确的是，现在加的这个硬盘在现有的Linux系统中是/dev/sdb，但是，当我们把东西全部设置好时，要把这个硬盘拔除，放在新系统上，此时，就是/dev/sda</p><p>2)在/dev/sdb硬盘上，将其打造成独立的Linux系统，里面的所有文件是需要拷贝进去的</p><p>3)作为能独立运行的Linux系统，内核是一定不能少，要把内核文件和initramfs文件也一起拷到/dev/sdb上</p><p>4)以上步骤完成，我们的自制Linux就完成,创建一个新的linux虚拟机，将其硬盘指向我们创建的硬盘，启动即可</p><h2 id="二十三、Linux内核源码介绍-amp-内核升级"><a href="#二十三、Linux内核源码介绍-amp-内核升级" class="headerlink" title="二十三、Linux内核源码介绍&amp;内核升级"></a>二十三、Linux内核源码介绍&amp;内核升级</h2><p>为什么要阅读linux内核?</p><p>1)爱好，就是喜欢linux(黑客精神)</p><p>2)想深入理解linux底层运行机制，对操作系统有深入理解</p><p>3)阅读Linux内核，你会对整个计算机体系有一个更深刻的认识。作为开发者，不管你从事的是驱动开发，应用开发还是后台开发，你都需要了解操作系统内核的运行机制，这样才能写出更好的代码。</p><p>4)作为开发人员不应该只局限在自己的领域，你设计的模块看起来小，但是你不了解进程的调用机制，你不知道进程为什么会阻塞、就绪、执行几个状态。那么很难写出优质的代码。</p><p>5)作为有追求的程序员，还是应该深入的了解一个操作系统的底层机制,(比如linux/unix)最好是源码级别的，这样你写多线程高并发程序，包括架构，优化，算法等，高度不一样的，当然老韩也不是要求小伙伴儿把一个非常庞大的Linux内核每一行都读懂。我觉得。你至少能看几个核心的模块。</p><h4 id="23-1-linux0-01内核源码"><a href="#23-1-linux0-01内核源码" class="headerlink" title="23.1 linux0.01内核源码"></a>23.1 linux0.01内核源码</h4><p>Linux的内核源代码可以从网上下载,解压缩后文件一般也都位于linux目录下。内核源代码有很多版本，可以从linux0.01内核入手，总共的代码1w行左右，最新版本5.9.8总共代码超过700w行，非常庞大.<a href="https://www.kernel.org/">Linux内核下载地址</a></p><h4 id="23-1-1-内核源码阅读技巧"><a href="#23-1-1-内核源码阅读技巧" class="headerlink" title="23.1.1 内核源码阅读技巧"></a>23.1.1 内核源码阅读技巧</h4><p>1)linux0.01的阅读需要懂c语言</p><p>2)阅读源码前，应知道Linux内核源码的整体分布情况。现代的操作系统一般由进程管理、内存管理、文件系统、驱动程序和网络等组成。Linux内核源码的各个目录大致与此相对应.</p><p>3)在阅读方法或顺序上，有纵向与横向之分。所谓纵向就是顺着程序的执行顺序逐步进行；所谓横向，就是按模块进行。它们经常结合在一起进行</p><p>4)对于Linux启动的代码可顺着Linux的启动顺序一步步来阅读；对于像内存管理部分，可以单独拿出来进行阅读分析。实际上这是一个反复的过程，不可能读一遍就理解</p><h4 id="23-1-2-linux目录说明"><a href="#23-1-2-linux目录说明" class="headerlink" title="23.1.2 linux目录说明"></a>23.1.2 linux目录说明</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227214906739.png"></p><h4 id="23-1-3-main-c初探"><a href="#23-1-3-main-c初探" class="headerlink" title="23.1.3 main.c初探"></a>23.1.3 main.c初探</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220227215620318.png"></p><h3 id="23-2-内核升级"><a href="#23-2-内核升级" class="headerlink" title="23.2 内核升级"></a>23.2 内核升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -a #查看当前的内核版本<br>yum info kernel -q #检测内核版本，显示可以升级的内核<br>yum update kernel #升级内核<br>yum list kernel -q #查看已经安装的内核<br></code></pre></td></tr></table></figure><h3 id="二十四、备份与恢复"><a href="#二十四、备份与恢复" class="headerlink" title="二十四、备份与恢复"></a>二十四、备份与恢复</h3><p>基本介绍：</p><p>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，还会造成数据丢失。所以我们可以使用备份和恢复技术linux的备份和恢复很简单，有两种方式：</p><p>1)把需要的文件(或者分区)用<code>tar</code>打包就行，下次需要恢复的时候，再解压开覆盖即可</p><p>2)使用dump和restore命令</p><h4 id="24-1-安装dump和restore"><a href="#24-1-安装dump和restore" class="headerlink" title="24.1 安装dump和restore"></a>24.1 安装dump和restore</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install dump<br>yum -y install restore<br></code></pre></td></tr></table></figure><h3 id="24-2-使用dump完成备份"><a href="#24-2-使用dump完成备份" class="headerlink" title="24.2 使用dump完成备份"></a>24.2 使用dump完成备份</h3><p>基本介绍</p><p>dump支持分卷和增量备份（所谓增量备份是指备份上次备份后修改/增加过的文件，也称差异备份）。</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump [-cu] [-f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [目录或文件系统]<br>dump [-wW]<br></code></pre></td></tr></table></figure><p>选项解释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-c :创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头（c就是下面0-9的数字)<br>-0123456789： 备份的层级。0为最完整备份，会被分所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替<br>-f &lt;备份后文件名&gt;: 指定备份后文件名<br>-j: 调用bzlib库压缩备份文件，也就是将备份后的文件压缩成bz2格式，让文件更小<br>-T &lt;日期&gt;: 指定开始备份的时间与日期<br>-u: 备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期与时间等。<br>-t: 指定文件若改文件已存在备份文件中，则列出名称<br>-W: 显示需要备份的文件及其最后一次备份的层级，时间，日期<br>-w：与-W类似，但仅显示需要备份的文件。<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：将/boot分区所有内容备份到/opt/boot.bak0.bz2文件中，备份层级为“0”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -0uj -f /opt/book.bak0.bz2 /boot<br></code></pre></td></tr></table></figure><p>案例2：在/boot目录下增加新文件，备份层级为“1”(只备份上次使用层次“0”备份后发生过改变的数据),注意比较看看这次生成的备份文件boot1.bak有多大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -1uj -f /opt/boot.bak1.bz2 /boot<br></code></pre></td></tr></table></figure><p>通过dump命令在配合crontab可以实现无人值守备份</p><p>案例3：显示需要备份的文件及其最后一次备份的层级，时间，日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -W<br></code></pre></td></tr></table></figure><p>案例4：查看备份时间文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/dumpdates<br></code></pre></td></tr></table></figure><p><strong>dump备份文件或者目录前面我们在备份分区时，是可以支持增量备份的，如果备份文件或者目录，不再支持增量备份,即只能使用0级别备份案例</strong>,也不支持-u选项。</p><p>使用dump备份/etc整个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dump -0j -f /opt/etc.bak.bz2 /etc/#下面这条语句会报错，提示DUMP:Only level 0 dumps are allowed on a subdirectory dump -1j -f /opt/etc.bak.bz2 /etc/<br></code></pre></td></tr></table></figure><h3 id="24-3-使用restore完成恢复"><a href="#24-3-使用restore完成恢复" class="headerlink" title="24.3 使用restore完成恢复"></a>24.3 使用restore完成恢复</h3><p>基本介绍</p><p>restore命令用来恢复已备份的文件，可以从dump生成的备份文件中恢复原文件，一般是恢复到当前目录</p><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore [模式选项] [选项]<br></code></pre></td></tr></table></figure><p>说明下面四个模式，不能混用，再一次命令中，只能指定一种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-C: 使用对比模式，将备份的文件与已存在的文件相互对比。<br>-i: 使用交互模式，在进行还原操作时，restore指令将依序询问用户<br>-r: 进行还原模式<br>-t: 查看模式，看备份文件有哪些文件<br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-f &lt;备份设备&gt;: 从指定的文件中读取备份数据，进行还原操作<br></code></pre></td></tr></table></figure><p>应用案例</p><p>案例1：restore命令比较模式，比较备份文件和原文件的区别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /boot/hello.java /boot/hello100.java<br>restore -C -f boot.bak1.bz2 #注意和最新的文件比较<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228164134772.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /boot/hello100.java /boot/hello.java<br>restore -C -f boot.bak1.bz2<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228164214084.png"></p><p>案例2：restore命令查看模式，看备份文件有哪些数据/文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -t -f boot.bak0.bz2<br></code></pre></td></tr></table></figure><p>案例3：restore命令还原模式,注意细节：如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件，就要恢复几个，按顺序来恢复即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -r -f /opt/boot.bak0.bz2 #恢复到第一次完全备份状态<br>restore -r -f /opt/boot.bak1.bz2 #恢复到第二次完全备份状态<br></code></pre></td></tr></table></figure><p>案例4：restore命令恢复备份的文件，或者整个目录的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore -r -f 备份好的文件<br></code></pre></td></tr></table></figure><h2 id="二十五、Linux可视化管理"><a href="#二十五、Linux可视化管理" class="headerlink" title="二十五、Linux可视化管理"></a>二十五、Linux可视化管理</h2><h3 id="25-1-webmin"><a href="#25-1-webmin" class="headerlink" title="25.1 webmin"></a>25.1 webmin</h3><h4 id="25-1-1-基本介绍"><a href="#25-1-1-基本介绍" class="headerlink" title="25.1.1 基本介绍"></a>25.1.1 基本介绍</h4><p>Webmin是功能强大的基于Web的Unix/linux系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理操作。除了各版本的linux以外还可用于：AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等系统</p><h4 id="25-1-2-安装webmin-amp-配置"><a href="#25-1-2-安装webmin-amp-配置" class="headerlink" title="25.1.2 安装webmin&amp;配置"></a>25.1.2 安装webmin&amp;配置</h4><p>1)下载地址:<a href="http://download.webmin.com/download/yum/,%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF">http://download.webmin.com/download/yum/,用下载工具下载即可</a></p><p>或者<code>wgethttp://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm</code></p><p>2)安装：<code>rpm -ivh webmin-1.700-1.noarch.rpm</code></p><p>3)重置密码:<code>/usr/libexec/webmin/changepass.pl /etc/webminroot test root</code>是webmin的用户名，不是OS的,这里就是把webmin的root用户密码改成了test</p><p>4)修改webmin服务的端口号（默认是10000出于安全目的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/webmin/miniserv.conf#修改端口<br><br>将port=10000修改为其他端口号，如port=6666<br>将listen=10000修改为listen=6666<br></code></pre></td></tr></table></figure><p>5)重启webmin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">/etc/webmin/restart#</span><span class="bash">重启</span><br><span class="hljs-meta">/etc/webmin/start#</span><span class="bash">启动</span><br><span class="hljs-meta">/etc/webmin/stop#</span><span class="bash">停止</span><br></code></pre></td></tr></table></figure><p>6)防火墙放开6666端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall -cmd--zone=public --add-port=6666/tcp --permanent#配置防火墙开放6666端口<br>firewall -cmd--reload#更新防火墙配置<br>firewall -cmd--zone=public --list-ports#查看已经开放的端口号<br></code></pre></td></tr></table></figure><p>7)登录webmin</p><p><a href="http://ip:6666可以访问了">http://ip:6666可以访问了</a></p><p>用root账号和重置的新密码test</p><h3 id="25-2-bt-宝塔"><a href="#25-2-bt-宝塔" class="headerlink" title="25.2 bt(宝塔)"></a>25.2 bt(宝塔)</h3><h4 id="25-2-1基本介绍"><a href="#25-2-1基本介绍" class="headerlink" title="25.2.1基本介绍"></a>25.2.1基本介绍</h4><p>bt宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等多项服务器管理功能。</p><h4 id="25-2-2-安装使用"><a href="#25-2-2-安装使用" class="headerlink" title="25.2.2 安装使用"></a>25.2.2 安装使用</h4><p>1)安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></td></tr></table></figure><p>&amp;&amp;代表先执行前面的命令，在执行后面的命令。</p><p>2)安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录，</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228180112466.png"></p><h4 id="25-2-3-如果bt的用户名，密码忘记了，使用btdefault可以查看"><a href="#25-2-3-如果bt的用户名，密码忘记了，使用btdefault可以查看" class="headerlink" title="25.2.3 如果bt的用户名，密码忘记了，使用btdefault可以查看"></a>25.2.3 如果bt的用户名，密码忘记了，使用btdefault可以查看</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">by default<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228180222987.png"></p><h2 id="二十六、Linux应用实例"><a href="#二十六、Linux应用实例" class="headerlink" title="二十六、Linux应用实例"></a>二十六、Linux应用实例</h2><p>案例1：分析日志t.log(访问量)，将各个ip地址截取，并统计出现次数,并按从大到小排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">t.txt<br>http://192.168.200.10/index1.html<br>http://192.168.200.10/index2.html<br>http://192.168.200.20/index1.html<br>http://192.168.200.30/index1.html<br>http://192.168.200.40/index1.html<br>http://192.168.200.30/order.html<br>http://192.168.200.10/order.html<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat t.txt | cut -d &#x27;/&#x27; -f 3 | sort | uniq -c | sort -nr<br></code></pre></td></tr></table></figure><p><strong>cut是split命令，-d是指定分割符号(不可以是空格），-f是取出第几列</strong>,<strong>uniq -c 统计命令是统计相邻行相同的数量</strong></p><p>案例2：统计连接到服务器的各个ip情况，并按连接数从大到小排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -an | grep ESTABLISHED | awk -F &quot; &quot; &#x27;&#123;print $5&#125;&#x27; | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr<br></code></pre></td></tr></table></figure><p>案例3：如忘记了mysql5.7数据库的ROOT用户的密码，如何找回?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/my.cnf<br><br>skip-grant-tables #加上一行，跳过密码<br><br>service mysqld.service #重启mysqld服务<br>mysql -u root -p #登录<br>show databases;<br>use mysql;<br>show tables;<br>desc users;<br>update user set authentication_string=password(&quot;xinmima&quot;) where user=&#x27;root&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>案例4：统计ip访问情况，要求分析nginx访问日志(access.log)，找出访问页面数量在前2位的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat access.log | awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr | head -2<br></code></pre></td></tr></table></figure><p>案例5：使用tcpdump监听本机,将来自ip192.168.200.1，tcp端口为22的数据，保存输出到tcpdump.log,用做将来数据分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcpdump -i ens33 host 192.168.200.1 and port 22 &gt;&gt; /opt/tcpdump.log<br></code></pre></td></tr></table></figure><p>监听网络设备ens33</p><p>案例6：常用的Nginx模块，用来做什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">rewrite模块，实现重写功能<br>access模块：来源控制<br>ssl模块：安全加密<br>ngx_http_gzip_module：网络传输压缩模块<br>ngx_http_proxy_module:模块实现代理<br>ngx_http_upstream_module:模块实现定义后端服务器列表<br>ngx_cache_purge:实现缓存清除功能<br></code></pre></td></tr></table></figure><p>案例7：如果你是系统管理员，在进行Linux系统权限划分时,应考虑哪些因素?</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/image-20220228193525894.png"></p><ol><li><p>注意权限分离，比如:工作中，Linux系统权限和数据库权限不要在同一个部门</p></li><li><p>权限最小原则(即:在满足使用的情况下最少优先)</p></li><li><p>减少使用root用户，尽量用普通用户+sudo提权进行日常操作。</p></li><li><p>重要的系统文件，比如/etc/passwd,/etc/shadowetc/fstab，/etc/sudoers等,日常建议使用chattr(change attribute)锁定,需要操作时再打开。【演示比如:锁定/etc/passwd让任何用户都不能随意useradd,除非解除锁定】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chattr +i /etc/passwd #锁定文件<br></code></pre></td></tr></table></figure></li><li><p>使用SUID,SGID,Sticky设置特殊权限。</p></li><li><p>可以利用工具，比如chkrootkit或者rootkit hunter检测rootkit脚本（rootkit是入侵者使用工具,在不察觉的建立了入侵系统途径）[演示使用wget <a href="ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz]">ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz]</a></p></li><li><p>利用工具Tripwire检测文件系统完整性</p></li></ol><p>案例8：权限操作思考题</p><p>（1）用户tom对目录/home/test有执行x和读r写w权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗?(ok)</p><p>（2）用户tom对目录/home/test只有读写权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(no)?能修改吗(no)？能删除吗(no)?</p><p>（3）用户tom对目录/home/test只有执行权限x，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗(no)?</p><p>（4）用户tom对目录/home/test只有执行x和写w权限，/home/test/hello.java是只读文件，问tom对hello.java文件能读吗(ok)?能修改吗(no)？能删除吗(ok)?</p><p>案例9：列举Linux高级命令，至少6个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat #网络状态监控<br>top #系统运行状态<br>lsblk #查看硬盘分区<br>find<br>ps -aux #查看运行进程<br>chkconfig #查看服务启动状态<br>systemctl #管理系统服务器<br></code></pre></td></tr></table></figure><p>案例10：Linux查看内存、io读写、磁盘存储、端口占用、进程查看命令是什么?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top,iotop,df -lh,netstat -tunlp,ps -aux | grep 关心的进程<br></code></pre></td></tr></table></figure><p>案例11：使用Linux命令计算t2.txt第二列的和并输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat t2.txt | awk -F &quot; &quot; &#x27;&#123;sum+=$2&#125; END &#123;print sum&#125;&#x27;<br></code></pre></td></tr></table></figure><p>案例12：Shell脚本里如何检查一个文件是否存在？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ -f 文件名 ] then echo &quot;存在&quot; else echo &quot;不存在&quot; fi<br></code></pre></td></tr></table></figure><p>案例13：用shell写一个脚本，对文本t3.txt中无序的一列数字排序,并将总和输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort -nr t3.txt | awk &#x27;&#123;sum+=$0; print $0&#125; END &#123;print &quot;和=&quot;sum&#125;&#x27;<br></code></pre></td></tr></table></figure><p>案例14：请用指令写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符“cat”的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1<br></code></pre></td></tr></table></figure><p>案例15：请写出统计/home目录下所有文件个数和所有文件总行数的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name &quot;*.*&quot; | wc -l<br>find /home -name &quot;*.*&quot; | xargs wc -l<br></code></pre></td></tr></table></figure><p>案例16：每天晚上10点30分，打包站点目录/var/spool/mail备份到/home目录下（每次备份按时间生成不同的备份包比如按照年月日时分秒）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e<br><br>30 22 * * * test.sh<br><br>vim test.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>cd /var/spool/ &amp;&amp; /bin/tar zcf /home/mail-`date +%Y-%m-%d_%H%M%S`.tar.gz mail<br><br>chomd 777 test.sh<br></code></pre></td></tr></table></figure><p>案例17：如何优化Linux系统，说出你的方法</p><p>(1)不用root,使用sudo提示权限</p><p>(2)定时的自动更新服务时间,使用nptdate npt1.aliyun.com,让croud定时更新</p><p>(3)配置yum源，指向国内镜像(清华，163)</p><p>(4)配置合理的防火墙策略,打开必要的端口，关闭不必要的端口</p><p>(5)打开最大文件数(调整文件的描述的数量)vim /etc/profile ulimit -SHn 65535</p><p>(6)配置合理的监控策略</p><p>(7)配置合理的系统重要文件的备份策略</p><p>(8)对安装的软件进行优化，比如nginx,apache</p><p>(9)内核参数进行优化/etc/sysctl.conf</p><p>(10)锁定一些重要的系统文件chattr/etc/passwd /ect/shadow /etc/inittab</p><p>(11)禁用不必要的服务setup,ntsysv</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/25/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="一、Git基础学习"><a href="#一、Git基础学习" class="headerlink" title="一、Git基础学习"></a>一、Git基础学习</h2><h3 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1. Git常用命令"></a>1. Git常用命令</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a628594255e4d238d24b4a1276dbbf8tplv-k3u1fbpfcp-watermark.awebp"></p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>安装与配置</strong></td><td align="left"></td></tr><tr><td align="left">sudo apt-get install git</td><td align="left">Ubuntu 上安装 Git 命令</td></tr><tr><td align="left">git config --global user.name 用户名</td><td align="left">设置用户签名<br>（安装 Git 后务必设置）</td></tr><tr><td align="left">git config --global user.email email 地址</td><td align="left">设置用户 email 地址<br>（安装 Git 后务必设置）</td></tr><tr><td align="left"><strong>获取与创建项目</strong></td><td align="left"></td></tr><tr><td align="left">git init</td><td align="left">初始化本地库</td></tr><tr><td align="left">git clone 远程库地址</td><td align="left">从远程库克隆到本地</td></tr><tr><td align="left"><strong>基本快照</strong></td><td align="left"></td></tr><tr><td align="left">git status</td><td align="left">查看本地库状态</td></tr><tr><td align="left">git add 文件名</td><td align="left">添加变动文件到暂存区</td></tr><tr><td align="left">git add .</td><td align="left">添加当前目录下所有变动文件到暂存区</td></tr><tr><td align="left">git restore --staged 文件名</td><td align="left">复位在暂存区的文件（add 反悔药）</td></tr><tr><td align="left">git rm --cached 文件名</td><td align="left">移除在暂存区的文件（add 反悔药）（同上一条）</td></tr><tr><td align="left">git commit -m “备注文本” 文件名</td><td align="left">提交暂存区文件到本地库<br>（文件名缺省时，将暂存区所有文件提交）</td></tr><tr><td align="left">git commit --amend</td><td align="left">修改上次提交的备注文本</td></tr><tr><td align="left">git revert 版本号 (7 位)</td><td align="left">撤销指定的提交（commit 反悔药）(慎用)</td></tr><tr><td align="left">git reset --hard 版本号 (7 位)</td><td align="left">版本间穿梭（配合 git reflog 使用）</td></tr><tr><td align="left">git reset --hard HEAD^</td><td align="left">穿梭到上一个版本</td></tr><tr><td align="left"><strong>分支与合并</strong></td><td align="left"></td></tr><tr><td align="left">git branch</td><td align="left">列出所有分支</td></tr><tr><td align="left">git branch 分支名</td><td align="left">创建分支</td></tr><tr><td align="left">git checkout 分支名</td><td align="left">切换分支</td></tr><tr><td align="left">git merge 分支名 B</td><td align="left">分支 B 合并到 A<br>（A 为当前工作目录所处分支）</td></tr><tr><td align="left">git branch -d 分支名</td><td align="left">删除分支</td></tr><tr><td align="left">git tag</td><td align="left">列出所有本地标签</td></tr><tr><td align="left">git tag -l 通配模式文本 (*)</td><td align="left">根据符合通配模式文本，列出所有本地标签</td></tr><tr><td align="left">git tag 标签名</td><td align="left">为最新提交创建<strong>轻量</strong>标签</td></tr><tr><td align="left">git tag 标签名 版本号 (7 位)</td><td align="left">为对应版本号提交创建<strong>轻量</strong>标签（在后期打标签）</td></tr><tr><td align="left">git tag -a 标签名 -m 备注文本</td><td align="left">为最新提交创建<strong>附注</strong>标签</td></tr><tr><td align="left">git tag -d 标签名</td><td align="left">删除指定标签</td></tr><tr><td align="left"><strong>共享与更新项目</strong></td><td align="left"></td></tr><tr><td align="left">git remote add 别名 远程仓库地址</td><td align="left">添加远程库</td></tr><tr><td align="left">git remote -v</td><td align="left">查看添加过的远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 分支名</td><td align="left">推送到远程库</td></tr><tr><td align="left">git push 远程库地址或其别名 --tags</td><td align="left">推送所有标签到远程库</td></tr><tr><td align="left">git fetch</td><td align="left">将远程库的最新内容拉到本地</td></tr><tr><td align="left">git pull 远程库地址或其别名 分支名</td><td align="left">将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并，<br>相当于 git fetch + git merge，这样可能会产生冲突，需要手动解决</td></tr><tr><td align="left"><strong>检查与比较</strong></td><td align="left"></td></tr><tr><td align="left">git show 标签名</td><td align="left">显示标签信息和与之对应的提交信息</td></tr><tr><td align="left">git show 版本号 (7 位)</td><td align="left">显示对应版本对应的提交信息</td></tr><tr><td align="left">git log</td><td align="left">显示当前分支所有提交过的版本信息</td></tr><tr><td align="left">git log --follow 文件名</td><td align="left">显示当前分支所有提交过的关于指定文件版本信息</td></tr><tr><td align="left">git log --pretty=oneline</td><td align="left">显示当前分支所有提交过的版本信息（精简）</td></tr><tr><td align="left">git log --graph</td><td align="left">显示当前分支所有提交过的版本信息（附有分支合并图）</td></tr><tr><td align="left">git diff 分支一 分支二</td><td align="left">显示两分支差异</td></tr><tr><td align="left">git diff 版本号一 (7 位) 版本号二 (7 位)</td><td align="left">显示同一分支两版本差异</td></tr><tr><td align="left"><strong>管理</strong></td><td align="left"></td></tr><tr><td align="left">git reflog</td><td align="left">可以查看所有分支的所有操作记录<br>（包括已被删除的 commit 记录和 reset 的操作，git log 所不能）</td></tr></tbody></table><h3 id="2-官网介绍"><a href="#2-官网介绍" class="headerlink" title="2. 官网介绍"></a>2. 官网介绍</h3><p><a href="https://git-scm.com/">Git 官网</a></p><p><a href="http://git-scm.com/docs">Git 官方文档</a></p><p><a href="https://git-scm.com/book/zh/v2">Git 官方书</a></p><p><a href="https://git-scm.com/downloads">Git 下载页面</a></p><p><a href="https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/">Github Git Cheat Sheets - 中文版</a></p><p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</p><h3 id="3-版本控制介绍"><a href="#3-版本控制介绍" class="headerlink" title="3. 版本控制介绍"></a>3. 版本控制介绍</h3><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2abc5f18d46afc2d50cee7db484a460f.png"></p><p>为什么需要版本控制？因为要从个人开发过渡到团队协作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2bcf55bc8f1e6cda16fc048ed30e12fc.png"></p><h3 id="4-分布式版本控制-VS-集中式版本控制"><a href="#4-分布式版本控制-VS-集中式版本控制" class="headerlink" title="4. 分布式版本控制 VS 集中式版本控制"></a>4. 分布式版本控制 VS 集中式版本控制</h3><h4 id="4-1-集中式版本控制工具"><a href="#4-1-集中式版本控制工具" class="headerlink" title="4.1  集中式版本控制工具"></a>4.1  集中式版本控制工具</h4><p>集中化的版本控制系统诸如 CVS、 SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统， 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做显而易见的<strong>缺点</strong>是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f0cc7f6f1eb57316f7f8fce8e2f03f45.png"></p><h4 id="4-2-分布式版本控制工具"><a href="#4-2-分布式版本控制工具" class="headerlink" title="4.2 分布式版本控制工具"></a>4.2 分布式版本控制工具</h4><p>Git、 Mercurial、 Bazaar、 Darcs……</p><p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后, 解决了集中式版本控制系统的缺陷：</p><ol><li> 服务器断网的情况下也可以进行开发（因为版本控制是在<strong>本地</strong>进行的）</li><li> 每个客户端保存的也都是整个<strong>完整的项目</strong>（包含历史记录， 更加安全）</li></ol><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/340e9b3bc50013b61f0e83e96b99f86a.png"></p><h3 id="5-Git发展历史"><a href="#5-Git发展历史" class="headerlink" title="5. Git发展历史"></a>5. Git发展历史</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f25cba01665ab8dcb63fcc79d05f04f.png"></p><h3 id="6-工作机制和代码托管中心"><a href="#6-工作机制和代码托管中心" class="headerlink" title="6. 工作机制和代码托管中心"></a>6. 工作机制和代码托管中心</h3><h4 id="6-1-Git-工作机制"><a href="#6-1-Git-工作机制" class="headerlink" title="6.1 Git 工作机制"></a>6.1 Git 工作机制</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1706b3553447ac9f8d95377d965d4fd2.png"></p><h4 id="6-2-Git-代码托管中心"><a href="#6-2-Git-代码托管中心" class="headerlink" title="6.2 Git 代码托管中心"></a>6.2 Git 代码托管中心</h4><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li>局域网<ul><li>  GitLab</li></ul></li><li>互联网<ul><li>  GitHub（外网）</li><li>  Gitee 码云（国内网站）</li></ul></li></ul><h3 id="7-Git安装和客户端的使用"><a href="#7-Git安装和客户端的使用" class="headerlink" title="7. Git安装和客户端的使用"></a>7. Git安装和客户端的使用</h3><p>在 <a href="https://git-scm.com/downloads">Git 下载页面</a>，选择下载 Windows 64 位版的 Git 安装软件。</p><p>安装步骤按照安装软件的安装向导安装即可，无需过多配置。</p><p>安装成功后，通常在文件浏览器空白处单击击鼠标右键，弹出菜单栏有 Git 的选项。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/72adc78acc2344ab51285dae2c4776ad.png"></p><h2 id="二、Git-基本使用"><a href="#二、Git-基本使用" class="headerlink" title="二、Git 基本使用"></a>二、Git 基本使用</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config --global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config --global user.email 邮箱</td><td>设置用户 email 地址</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset --hard 版本号</td><td>版本穿梭</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1352126739_7909.jpg"></p><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当执行 <strong>git rm –cached &lt;file&gt;</strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（<strong>git commit</strong>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。<strong>版本库 -&gt; 暂存区</strong></li><li>当执行<strong>git reset HEAD –hard</strong>，暂存区和工作区都会被版本库重写，相当于HEAD指针移动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – &lt;file&gt;</strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。<strong>暂存区 -&gt; 工作区</strong></li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD &lt;file&gt;</strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。<strong>版本库 -&gt; 暂存区 &amp; 工作区</strong></li></ul><h3 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1. 设置用户签名"></a>1. 设置用户签名</h3><h4 id="1-1-设置系统级用户签名"><a href="#1-1-设置系统级用户签名" class="headerlink" title="1.1  设置系统级用户签名"></a>1.1  设置系统级用户签名</h4><figure class="highlight autoit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name abc <span class="hljs-meta">#用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email abc<span class="hljs-symbol">@123</span>.com<br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>在用户目录下的<code>./gitconfig</code>中查看设置过用户签名</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">abc@</span>DESKTOP-R85C9HV MINGW64 ~/Desktop<br>$ cat ~/.gitconfig<br><span class="hljs-string">[user]</span><br>        name = abc<br>        email = <span class="hljs-symbol">abc@</span><span class="hljs-number">123.</span>com<br><span class="hljs-string">[core]</span><br>        quotepath = <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="1-2-设置仓库级用户签名"><a href="#1-2-设置仓库级用户签名" class="headerlink" title="1.2 设置仓库级用户签名"></a>1.2 设置仓库级用户签名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config user.name abc</span><br><span class="hljs-meta">$</span><span class="bash"> git config user.email abc@163.com</span><br></code></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身份，签名邮箱可以是不存在的，Git也不会去验证邮箱是否真实存在</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： <strong>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</strong></p><p>创建成功，用户签名信息会保存在本地工作区 <code>./.git/config</code> 文件中，你可以使用 <code>cat</code> 命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/笔记 (master)<br><span class="hljs-meta">$</span><span class="bash"> cat .git/config</span><br>[core]<br>        repositoryformatversion = 0<br>        filemode = false<br>        bare = false<br>        logallrefupdates = true<br>        symlinks = false<br>        ignorecase = true<br>[remote &quot;origin&quot;]<br>        url = git@github.com:JYGQAQ/Notebook.git<br>        fetch = +refs/heads/*:refs/remotes/origin/*<br>[user]<br>        name = JYGQAQ<br>        email = 604713431@qq.com<br></code></pre></td></tr></table></figure><p>需要注意的是，签名的作用是区分不同的不同的操作者身份，所以一般只用设置系统级的用户签名。如果两个级别同时存在，那么依照就近原则，仓库级别要大于系统级别。如果两个级别都不存在，则无法完成 Git 一些命令，会提示验证身份。</p><h3 id="2-初始化本地库"><a href="#2-初始化本地库" class="headerlink" title="2. 初始化本地库"></a>2. 初始化本地库</h3><p>基本语法：<code>git init</code></p><p>案例实操：</p><ul><li>创建项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir gitLearn<br></code></pre></td></tr></table></figure><ul><li>进入项目目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd gitLearn/<br></code></pre></td></tr></table></figure><ul><li>初始化本地库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in E:/gitLearn/.git/<br></code></pre></td></tr></table></figure><p>Git自动创建了一个名为. git 非空隐藏文件夹。</p><h3 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3. 查看本地库状态"></a>3. 查看本地库状态</h3><p>基本语法：<code>git status</code></p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master <br><br>No commits yet<br><br>nothing to commit (create/copy files and use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>第一行：目前处于哪个本地分支</p><p>第二行：从来没有<code>commit</code>过，本地库没有版本信息。</p><p>第三行：没有更改需要<code>commit</code></p><ul><li>新建文件后，查看本地库状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Administrator@DESKTOP-4054V76 MINGW32 /e/gitLearn (master)<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        newfile.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/image-20220121000221864.png"></p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标红</strong>），意思是需要<code>git add</code>来提交到暂存区追踪。</p><p>有被<strong>标红</strong>的文件，说明该文件<strong>新创建或者和相对于暂存区有更改</strong>需要被<code>git add</code>提交到暂存区追踪。</p><h3 id="4-添加到暂存区"><a href="#4-添加到暂存区" class="headerlink" title="4.添加到暂存区"></a>4.添加到暂存区</h3><p>基本语法：<code>git add 文件名</code> 或者 <code>git add .</code>代表添加所有有更改的文件到暂存区</p><p>案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add newfile.txt<br>或者<br>git add .<br></code></pre></td></tr></table></figure><p>接下来使用<code>git status</code>查看本地库状态</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e666e7de96c9def5042f595dd04805e.png"></p><p>注意上面的提示：</p><p>可以使用<code>git rm --cached newfile.txt</code>来从索引中删除文件。但是本地文件还存在， 只是不希望这个文件被版本控制，意思是从暂存区中删除<code>newfile.txt</code>。</p><p>若使用<code>git rm newfile.txt</code>同时从工作区和索引中删除文件。即本地的文件也被删除了。</p><p>此处，有一个未被追踪的文件<code>newfile.txt</code>（<strong>被标绿</strong>），意思是需要<code>git commit</code>来提交到本地库，来进行版本控制。</p><p>有被<strong>标绿</strong>的文件，说明该文件<strong>未被提交到本地库或者本文件相对于本地库有更改</strong>需要被<code>git commit</code>来提交到本地库，来进行版本控制。</p><p> <code> git commit -a -m “massage“</code></p><p>​      其他功能如-m参数，加的-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。建议一般不要使用-a参数，正常的提交还是使用git add先将要改动的文件添加到暂存区，再用git commit 提交到本地版本库。</p><p>  <code>git commit --amend</code></p><p>​      如果我们不小心提交了一版我们不满意的代码，并且给它推送到服务器了，在代码没被merge之前我们希望再修改一版满意的，而如果我们不想在服务器上abondon，那么我们怎么做呢？git commit –amend //也叫追加提交，它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中，使得版本库更加清爽。</p><h3 id="5-提交本地库"><a href="#5-提交本地库" class="headerlink" title="5. 提交本地库"></a>5. 提交本地库</h3><p>基本语法：<code>git commit -m &quot;日志信息&quot; 文件名</code> 或者 <code>git commit -m &quot;message&quot;</code>提交所有暂存区内容到本地库。</p><p>git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫<strong>commit-id</strong>，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里。</p><p>案例实操：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bbc4110ceb47c9dba34e612aef1167f.png"></p><p>查看本地库状态：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/139f25276d55d99e9197b2570a65bff.png"></p><p>发现没有<strong>绿名</strong>和<strong>红名</strong>文件被标注，说明没有文件需要被<strong>commit</strong>和<strong>add</strong>。</p><h4 id="5-1-查看本地库版本信息"><a href="#5-1-查看本地库版本信息" class="headerlink" title="5.1 查看本地库版本信息"></a>5.1 查看本地库版本信息</h4><p>查看本地库版本信息，使用<code>git reflog</code>查看引用日志信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p>说明：开头是的哈希值是<strong>commit-id</strong>，最后是<strong>commit</strong>的message信息。<code>HEAD</code>是指针，指向了<code>master</code>分支。</p><p>查看本地库版本的详细信息，使用<code>git log</code>。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p>说明：第一行是<strong>commit-id</strong>的准确值，第二行是提交者的用户签名，第三行是提交时间，第四行是<code>commit</code>的<code>message</code>。</p><h4 id="5-2-Commit-Message-规范"><a href="#5-2-Commit-Message-规范" class="headerlink" title="5.2 Commit Message 规范"></a>5.2 Commit Message 规范</h4><p><code>git commit</code>命令要求编写<code>commit message</code>，不然无法提交，关于<code>commit message</code>的编写，我们往往容易忽略规范，整体来讲，<code>commit message</code>应该清晰简洁，能够提现本次提交目的。</p><p>关于<code>commit message</code>的编写规范，社区有很多种，<code>Angular规范</code>是目前使用最广的写法，本文就简单介绍一下。</p><p><code>commit message</code>的构成包括三部分： <code>Header, Body 和 Footer</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;type&gt;</span> (<span class="hljs-params">&lt;scope&gt;</span>): <span class="hljs-params">&lt;subject&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;body&gt;</span><br><span class="hljs-comment">// 空行</span><br><span class="hljs-params">&lt;footer&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>其中，<code>Header</code>是必需的，<code>Body</code>和<code>Footer</code>可以省略。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">注意：任何一布行都不得超过 <span class="hljs-number">72</span><span class="hljs-comment">(或100)</span> 个字符，避免自动换行影响美观<br>复制代码<br><br></code></pre></td></tr></table></figure><h5 id="5-2-1Header"><a href="#5-2-1Header" class="headerlink" title="5.2.1Header"></a>5.2.1Header</h5><p><code>Header</code>占一行，包括三个字段：<code>type, scope, subject</code></p><p><strong>(1) type</strong></p><p><code>type</code> 用于说明 <code>commit</code>类别，只允许以下 7 个标识：</p><ul><li>  feat: 新功能 (feature)</li><li>  fix: 修补 bug</li><li>  docs: 文档 (documentation)</li><li>  style: 格式 (比如去除空行)</li><li>  refactor: 重构 (不是新增功能，也不是修补 bug)</li><li>  test: 增加测试</li><li>  chore: 构建过程或辅助工具的变动</li></ul><p><strong>(2) scope</strong></p><p><code>scope</code> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等 (很少用到)</p><p><strong>(3) subject</strong></p><p>描述本次提交的目的，不超过 50 个字符</p><ul><li>  以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li><li>  第一个字母小写</li><li>  结尾不加句号</li></ul><h5 id="5-2-2-Body"><a href="#5-2-2-Body" class="headerlink" title="5.2.2 Body"></a>5.2.2 Body</h5><p><code>Body</code>部分是对本次 <code>commit</code> 的详细描述，可以分为多行描述，要求使用第一人称现在时，说明代码变动原因以及前后行为对比。</p><h5 id="5-2-3-Footer"><a href="#5-2-3-Footer" class="headerlink" title="5.2.3 Footer"></a>5.2.3 Footer</h5><p><code>Footer</code> 只适用于两种情况：</p><ul><li>  (1) 不兼容变动</li></ul><p>当前代码与上一个版本不兼容，则 <code>Footer</code> 部分以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、变动理由和迁移方法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">BREAKING CHANGE:</span> <span class="hljs-string">isolate</span> <span class="hljs-string">scope</span> <span class="hljs-string">bindings</span> <span class="hljs-string">definition</span> <span class="hljs-string">has</span> <span class="hljs-string">changed.</span><br><br>    <span class="hljs-attr">To migrate the code follow the example below:</span><br><br>    <span class="hljs-attr">Before:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;attribute&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-attr">After:</span><br><br>    <span class="hljs-attr">scope:</span> &#123;<br>      <span class="hljs-attr">myAttr:</span> <span class="hljs-string">&#x27;@&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-string">The</span> <span class="hljs-string">removed</span> <span class="hljs-string">`inject`</span> <span class="hljs-string">wasn&#x27;t</span> <span class="hljs-string">generaly</span> <span class="hljs-string">useful</span> <span class="hljs-string">for</span> <span class="hljs-string">directives</span> <span class="hljs-string">so</span> <span class="hljs-string">there</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-literal">no</span> <span class="hljs-string">code</span> <span class="hljs-string">using</span> <span class="hljs-string">it.</span><br></code></pre></td></tr></table></figure><ul><li>  (2) 关闭 <code>Issue</code></li></ul><p>如果当前 <code>commit</code> 针对某个 <code>issue</code>，那么可以在 <code>Footer</code> 部分关闭这个 <code>issue</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Closes</span> #<span class="hljs-number">123</span>, #<span class="hljs-number">234</span>, #<span class="hljs-number">345</span><br></code></pre></td></tr></table></figure><h3 id="6-修改文件"><a href="#6-修改文件" class="headerlink" title="6. 修改文件"></a>6. 修改文件</h3><p>修改 <code>newfile.txt</code> 内容，<code>git status</code>会提示该文件修改过（会被<strong>标红</strong>，跟暂存区相比有更改），如下：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bf87fdbd981c5d3e8d12843be4647e.png"></p><p><code>git checkout -- file</code>是指根据暂存区的<code>file</code>文件来覆盖工作区的<code>file</code>文件，也就是放弃更改。</p><p>需要注意的是，Git是以<strong>行</strong>来管理文件的，最小单位是行。</p><h3 id="7-查看版本之间的不同"><a href="#7-查看版本之间的不同" class="headerlink" title="7. 查看版本之间的不同"></a>7. 查看版本之间的不同</h3><h4 id="7-1-比较工作区与暂存区"><a href="#7-1-比较工作区与暂存区" class="headerlink" title="7.1 比较工作区与暂存区"></a>7.1 比较工作区与暂存区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff<br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区</p><h4 id="7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"><a href="#7-2-比较暂存区与最新本地版本库（本地库中最近一次commit的内容）" class="headerlink" title="7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）"></a>7.2 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;path&gt;...] <br></code></pre></td></tr></table></figure><p>git diff 不加参数即默认比较工作区与暂存区2.7.1比较工作区与暂存区</p><h4 id="7-3-比较工作区与最新本地版本库"><a href="#7-3-比较工作区与最新本地版本库" class="headerlink" title="7.3 比较工作区与最新本地版本库"></a>7.3 比较工作区与最新本地版本库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff HEAD [&lt;path&gt;...] #如果HEAD指向的是master分支，那么HEAD还可以换成master<br></code></pre></td></tr></table></figure><h4 id="7-4-比较工作区域指定commit-id的差异"><a href="#7-4-比较工作区域指定commit-id的差异" class="headerlink" title="7.4 比较工作区域指定commit-id的差异"></a>7.4 比较工作区域指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff commit-id [&lt;path&gt; ...]<br></code></pre></td></tr></table></figure><h4 id="7-5-比较暂存区与指定commit-id的差异"><a href="#7-5-比较暂存区与指定commit-id的差异" class="headerlink" title="7.5 比较暂存区与指定commit-id的差异"></a>7.5 比较暂存区与指定commit-id的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [&lt;commit-id&gt;][&lt;path&gt;...]<br></code></pre></td></tr></table></figure><h4 id="7-6-比较两个commit-id之间的差异"><a href="#7-6-比较两个commit-id之间的差异" class="headerlink" title="7.6 比较两个commit-id之间的差异"></a>7.6 比较两个commit-id之间的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;]<br></code></pre></td></tr></table></figure><h3 id="8-版本穿梭"><a href="#8-版本穿梭" class="headerlink" title="8. 版本穿梭"></a>8. 版本穿梭</h3><h4 id="8-1-查看历史版本"><a href="#8-1-查看历史版本" class="headerlink" title="8.1 查看历史版本"></a>8.1 查看历史版本</h4><p>基本语法：</p><ul><li>  <code>git reflog</code> 查看版本信息</li><li>  <code>git log</code> 查看版本详细信息         加上<code>--graph</code>有图形表示。</li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/dba0007b3c4df902e87585dd7b38769.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a09103f44b288329021af4dd79da2df.png"></p><p><strong>git log 与 git reflog 区别</strong></p><p><code>git log</code> 命令可以显示所有提交过的版本信息，如果感觉太繁琐，可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p><p><code>git reflog</code> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行 <code>git reset --hard HEAD~1</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的 commitid，用<code>git reflog</code>则可以看到被删除的 commitid，我们就可以买后悔药，恢复到被删除的那个版本。<a href="https://blog.csdn.net/u013252047/article/details/80230781">link</a></p><h4 id="8-2-版本穿梭"><a href="#8-2-版本穿梭" class="headerlink" title="8.2 版本穿梭"></a>8.2 版本穿梭</h4><p>基本语法：</p><p><code>git reset --hard 版本号</code>，**–hard** 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。</p><p><code>git reset HEAD</code> 、<code>git reset</code> 、<code>git reset --soft HEAD</code>或者<code>git reset --mixed</code><strong>–mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><p><strong>需要注意的是，上面两种用法，都可以填<code>版本号</code>和<code>HEAD ... HEAD^^</code>，唯一不同的是，–hard重写工作区和暂存区，其他只重写暂存区。</strong></p><p><strong>Git 切换版本， 底层其实是移动的 HEAD 指针，不会产生新的版本。</strong></p><h2 id="三、Git分支用法"><a href="#三、Git分支用法" class="headerlink" title="三、Git分支用法"></a>三、Git分支用法</h2><h3 id="1-分支概述和优点"><a href="#1-分支概述和优点" class="headerlink" title="1. 分支概述和优点"></a>1. 分支概述和优点</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bcad650a512a72097b3391e00ecb8bbe.png"></p><h4 id="1-1-什么是分支"><a href="#1-1-什么是分支" class="headerlink" title="1.1 什么是分支"></a>1.1 什么是分支</h4><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来， 开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f1d0659ed000e9dfa295fc696a58cf74.png"></p><h4 id="1-2分支的好处"><a href="#1-2分支的好处" class="headerlink" title="1.2分支的好处"></a>1.2分支的好处</h4><p>同时<strong>并行</strong>推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="2-分支基本操作"><a href="#2-分支基本操作" class="headerlink" title="2. 分支基本操作"></a>2. 分支基本操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h4 id="2-1-查看分支"><a href="#2-1-查看分支" class="headerlink" title="2.1 查看分支"></a>2.1 查看分支</h4><p>基本语法：<code>git branch -v</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fab3df037a60224caf0f127e53de4b1.png"></p><p><code>*</code>代表当前所在的分支</p><h4 id="2-2-创建分支"><a href="#2-2-创建分支" class="headerlink" title="2.2 创建分支"></a>2.2 创建分支</h4><p>基本语法：<code>git branch 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/47e47992b7ff1da878bbbfe9b87559c.png"></p><p><strong>刚创建的新的分支，并将主分支 master 的内容复制了一份</strong>。</p><h4 id="2-3-切换分支"><a href="#2-3-切换分支" class="headerlink" title="2.3 切换分支"></a>2.3 切换分支</h4><p>基本语法：<code>git checkout 分支名</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f6a55ec01908aa4b7a06b59b51bc26f.png"></p><h3 id="3-合并分支-正常合并"><a href="#3-合并分支-正常合并" class="headerlink" title="3. 合并分支 (正常合并)"></a>3. 合并分支 (正常合并)</h3><p>基本语法：<code>git merge 分支名</code></p><p>将<code>分支名</code>合并到当前分支。</p><p>在 master 分支上合并 hot-fix 分支（将 hot-fix 的合并到 master）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1e50945d4aa000d22dfca989fc7b0d2.png"></p><h3 id="4-合并分支-冲突合并"><a href="#4-合并分支-冲突合并" class="headerlink" title="4. 合并分支 (冲突合并)"></a>4. 合并分支 (冲突合并)</h3><h4 id="4-1-冲突产生的原因"><a href="#4-1-冲突产生的原因" class="headerlink" title="4.1 冲突产生的原因"></a>4.1 冲突产生的原因</h4><p>并分支时，<strong>多个分支修改了同一个文件(任何地方)或者多个分支修改了同一个文件的名称</strong>（从该文件第一行开始，最先开始不同的行到最后不同的行会括起来）。 Git 无法替我们决定使用哪一个，因此，必须<strong>人为决定</strong>新代码内容。</p><p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可。</p><h4 id="4-2-产生冲突"><a href="#4-2-产生冲突" class="headerlink" title="4.2 产生冲突"></a>4.2 产生冲突</h4><p>修改两个分支，中同一文件同一行，合并两个分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eda203702114339268b657212811c5f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/61073b71dfe7abee793f6b335747116.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9218cbf54fd3120e70da480441c654.png"></p><h4 id="4-3-解决冲突"><a href="#4-3-解决冲突" class="headerlink" title="4.3 解决冲突"></a>4.3 解决冲突</h4><p>编辑有冲突的文件，<strong>删除特殊符号</strong>，决定要使用的内容。随后<code>git add .</code> &amp; <code>git commit -m &quot;message&quot;</code>正式合并分支。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/73ccf068132905eee5e42c7ab2e0514.png"></p><h4 id="4-4-创建分支和切换分支"><a href="#4-4-创建分支和切换分支" class="headerlink" title="4.4 创建分支和切换分支"></a>4.4 创建分支和切换分支</h4><p>master、 hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。</p><ul><li>  HEAD 如果指向 master，那么我们现在就在 master 分支上。</li><li>  HEAD 如果执行 hot-fix，那么我们现在就在 hot-fix 分支上。</li></ul><p>所以切换分支的本质就是移动 HEAD 指针。</p><h3 id="5-远程分支"><a href="#5-远程分支" class="headerlink" title="5. 远程分支"></a>5. 远程分支</h3><h4 id="5-1-创建远程分支"><a href="#5-1-创建远程分支" class="headerlink" title="5.1 创建远程分支"></a>5.1 创建远程分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支<br>git push origin my-test:my-test  //将my-test分支推送到远程<br>或<br>git push origin my-test //本地分支和远程分支重名<br></code></pre></td></tr></table></figure><p><code>git push origin my-test:my-test</code>其中第一个<code>my-test</code>是本地分支名，第二个<code>my-test</code>是远程分支名</p><h4 id="5-2-建立本地分支与远程分支的联系"><a href="#5-2-建立本地分支与远程分支的联系" class="headerlink" title="5.2 建立本地分支与远程分支的联系"></a>5.2 建立本地分支与远程分支的联系</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch --set-upstream-to=origin/develop develop<br></code></pre></td></tr></table></figure><p>其中，<code>origin</code>是远程仓库的别名，第一个<code>develop</code>是远程分支名，第二个是<code>debelop</code>本地分支名</p><h4 id="5-3-查看所有分支"><a href="#5-3-查看所有分支" class="headerlink" title="5.3 查看所有分支"></a>5.3 查看所有分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -vv<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/98446cf13d8282318d8127c5e566a82.png"></p><blockquote><p>黄色框是本地分支名，绿色框是远程分支名。需要注意的是有些本地分支没有关联远程分支。</p></blockquote><h2 id="四、使用Github"><a href="#四、使用Github" class="headerlink" title="四、使用Github"></a>四、使用Github</h2><p>团队内协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c397bde00d728c4e41eca79f578d25c3.png"></p><p>跨团队协作</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p><a href="https://github.com/">GitHub 网址</a></p><h3 id="1-创建远程库"><a href="#1-创建远程库" class="headerlink" title="1. 创建远程库"></a>1. 创建远程库</h3><p>登陆后，点击在网页右上角的 “+” –&gt; “New repository”，创建远程库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3dfd6ad9419bfcef2635e08a5c02e86c.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3ddd9d9b5ec3b0ab8c238ef66a183d1.png"></p><h4 id="1-1-远程仓库操作"><a href="#1-1-远程仓库操作" class="headerlink" title="1.1 远程仓库操作"></a>1.1 远程仓库操作</h4><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td></tr></tbody></table><h3 id="2-关联远程库"><a href="#2-关联远程库" class="headerlink" title="2. 关联远程库"></a>2. 关联远程库</h3><p><strong>基本语法</strong>：</p><ul><li>  <code>git remote -v</code> 查看当前所有远程地址别名</li><li>  <code>git remote add 别名 远程地址</code></li></ul><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/682725a20f0d99a4467e2a6cda04ad2.png"></p><p>这个地址在创建完远程仓库后生成的连接 ，如图所示</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/94534c6c6ba1d748bbfcc87338e38d7.png"></p><h3 id="3-推送本地库到远程库"><a href="#3-推送本地库到远程库" class="headerlink" title="3. 推送本地库到远程库"></a>3. 推送本地库到远程库</h3><p>基本语法：<code>git push 别名 分支</code>  将该分支推送上去</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7bec3b7357867896ea8f87838591b41.png"></p><h4 id="3-1-git-push详解"><a href="#3-1-git-push详解" class="headerlink" title="3.1 git push详解"></a>3.1 git push详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p>如果当前本地分支关联过远程分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br></code></pre></td></tr></table></figure><h3 id="4-拉取远程库到本地库"><a href="#4-拉取远程库到本地库" class="headerlink" title="4. 拉取远程库到本地库"></a>4. 拉取远程库到本地库</h3><p>需要注意的是，当远程库与本地库不相同时，需要先拉取远程库（如果直接push，会出错）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5eca728584bde973a8c9c109f26314c.png"></p><h4 id="4-1-git-pull详解"><a href="#4-1-git-pull详解" class="headerlink" title="4.1 git pull详解"></a>4.1 git pull详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f4b96f8b373b6e9ff02775e89050c9f.png"></p><p>主要注意的是，<code>git pull</code>之后查看本地库状态，发现本地库是干净的，说明<code>git pull</code>会自动<code>git add .</code>和<code>git push</code></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/110ae677e2075dabba3ba280b680768.png"></p><h3 id="5-克隆远程库到本地"><a href="#5-克隆远程库到本地" class="headerlink" title="5. 克隆远程库到本地"></a>5. 克隆远程库到本地</h3><p>基本语法：<code>git clone 远程地址</code>在远程库获取地址 URL</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bed545d3938cde21c57c8f86ffcfffd.png"></p><p>克隆完成后，查看远程仓库别名，和分支对应情况：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d75f5d9b4a0889a1f2aca32b259d3c3.png"></p><p>clone 会做如下操作：</p><ol><li> 拉取代码。</li><li> 初始化本地仓库。</li><li> 创建别名。</li><li> 创建对应分支</li></ol><h3 id="6-团队内协作"><a href="#6-团队内协作" class="headerlink" title="6. 团队内协作"></a>6. 团队内协作</h3><p>一、选择邀请合作者。（在仓库设置里操作）</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/945f1ba6e29fb725ee0d852ff59c3851.png"></p><p>二、填入目标合作者。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ee1b6a6656efe2adbb740b38954529b9.png"></p><p>三、复制网址发送给你目标合作者 ， 复制内容如下：<a href="https://github.com/atguiguyueyue/git-shTest/invitations%E3%80%82">https://github.com/atguiguyueyue/git-shTest/invitations。</a></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0f5ec0155e64421d315594aa537fd187.png"></p><p>四、目标合作者接收到网址，用浏览器打开它，点击接受邀请。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/295a2398e0a3150d50530d5db21103aa.png"></p><p>五、接受邀请成功之后，可以在目标合作者 Github 账号上看到将来共同开发远程仓库。</p><p>六、目标合作者可以修改内容并 push 到远程仓库。</p><p>七、回到发送合作邀请者的 GitHub 远程仓库中可以看到，最后一次是目标合作者提交的。</p><h3 id="7-跨团队协作"><a href="#7-跨团队协作" class="headerlink" title="7. 跨团队协作"></a>7. 跨团队协作</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e3069f865cc2d9760801b7a06c9d213b.png"></p><p>一、将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。</p><p>二、在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 网页右上方的 Fork 按钮，将项目叉到自己的本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4856e4845a7f0dbb54c79bd804892f5e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c641d9ba65f20ba58d3f98ec792ae0e5.png"></p><p>fork成功后可以看到当前仓库信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3078d75badb2fd393dbe172327dc094c.png"></p><p>三、东方不败就可以在线编辑fork过来的文件。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/40aa522895eb04a6c203a9bcbca25005.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb19249416069d158e2b4280a679063f.png"></p><p>四、编辑完毕后，填写描述信息并点击左下角绿色按钮提交。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c87379a8a91eb65e2961475129362da4.png"></p><p>五、接下来点击上方的 Pull 请求，并创建一个新的请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8bdb52dc24df07d8d846a4fe19985908.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c2f07c7ba5586e3923ba870a37c856d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/996007e8e9fee91ef37af6818e164139.png"></p><p>六、回到岳岳 GitHub 账号可以看到有一个 Pull request 请求。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c634b139396001cb2fcb64b8e2a078e1.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d666e1f3544c07821e85b602d0beffc5.png"></p><p>进入到聊天室，可以讨论代码相关内容。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3d97452ea50fffca42ec29308c842692.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9c477d95ea98448b966264bdae235b64.png"></p><p>七、如果代码没有问题，可以点击 Merge pull reque 合并代码。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/894bdb75678d7793e92f1099e5c1d080.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2964db9c2239859ee59c4bfb9fb25513.png"></p><h3 id="8-SSH-免密登录"><a href="#8-SSH-免密登录" class="headerlink" title="8. SSH 免密登录"></a>8. SSH 免密登录</h3><p><strong>ssh配置只是省去了输入github账号密码的这一步操作，所以跟github仓库关系不大，跟github账号关系大</strong></p><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/197d6964ccfb06f1eaf22f795061826d.png"></p><p>先到用户的主页目录，运行命令 ssh-keygen 生成. ssh 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;604713431@qq.com&quot;<br></code></pre></td></tr></table></figure><p><code>-t rsa</code>是使用非对称加密协议<code>rsa</code>，<code>-C &quot;****&quot;</code>是注释。</p><p>在家目录下生成了<code>id_rsa</code>是私钥，放在本地；<code>id_rsa.pub</code>是公钥，放在服务器。</p><p>然后，将生成的公钥添加至 Github 账号 SSH 设置</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2d213036d44d57f07ad75b23d20871ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0a6a75ce73adad73a535947dce7fa525.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0c2f4dd9ef30bdc8c47ae59e50b8851b.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f54c4dccd3d8a17e909042c28181fb6.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0ad893fd8447ac90ed0ee7ceafdf582e.png"></p><p>添加公钥后，使用ssh方法可不用输入 Github 账号密码便可<code>push</code>或者<code>pull</code>。</p><h2 id="五、IDEA集成Git"><a href="#五、IDEA集成Git" class="headerlink" title="五、IDEA集成Git"></a>五、IDEA集成Git</h2><p>在IDEA中，红色表示文件新创建并未被<code>add</code>提交到暂存区，绿色代表文件未被<code>commit</code>提交到本地版本库，蓝色代表文件被修改了，需要重新<code>add &amp; commit</code>(此处也可以直接<code>commit</code>)（但是之前被<code>add &amp; commit</code>过）。</p><p><code>git log</code>中绿色标签代表分支，黄色标签代表<code>HEAD</code>头指针。</p><h3 id="1-配置-Git-忽略文件"><a href="#1-配置-Git-忽略文件" class="headerlink" title="1. 配置 Git 忽略文件"></a>1. 配置 Git 忽略文件</h3><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。例如，Maven 工程根据 src 生成的 target。</p><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore），这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，<strong>建议</strong>也放在用户家目录下。</p><p>git.ignore 文件模版内容如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># Compiled class file</span><br>*<span class="hljs-string">.class</span><br><br><span class="hljs-comment"># Log file</span><br>*<span class="hljs-string">.log</span><br><br><span class="hljs-comment"># BlueJ files</span><br>*<span class="hljs-string">.ctxt</span><br><br><span class="hljs-comment"># Mobile Tools for Java (J2ME)</span><br><span class="hljs-string">.mtj.tmp/</span><br><br><span class="hljs-comment"># Package Files #</span><br>*<span class="hljs-string">.jar</span><br>*<span class="hljs-string">.war</span><br>*<span class="hljs-string">.nar</span><br>*<span class="hljs-string">.ear</span><br>*<span class="hljs-string">.zip</span><br>*<span class="hljs-string">.tar.gz</span><br>*<span class="hljs-string">.rar</span><br><br><span class="hljs-comment"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br>hs_err_pid*<br><span class="hljs-string">.classpath</span><br><span class="hljs-string">.project</span><br><span class="hljs-string">.settings</span><br>target<br><span class="hljs-string">.idea</span><br>*<span class="hljs-string">.iml</span><br><br></code></pre></td></tr></table></figure><p>在. gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[user]</span><br>    <span class="hljs-attr">name</span> = Layne<br>    <span class="hljs-attr">email</span> = Layne@atguigu.com<br><span class="hljs-section">[core]</span><br><span class="hljs-attr">excludesfile</span> = C:/Users/asus/git.ignore<br><br></code></pre></td></tr></table></figure><p>注意：这里要使用 “正斜线（/）”，不要使用 “反斜线（\）”</p><h3 id="2-在-IDEA-配置-Git-程序"><a href="#2-在-IDEA-配置-Git-程序" class="headerlink" title="2. 在 IDEA 配置 Git 程序"></a>2. 在 IDEA 配置 Git 程序</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 Git，配置 Git 的安装路径。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/d86ae18c01b9a08bc73f02aa6c1b3708.png"></p><h3 id="3-IDEA初始化-Git"><a href="#3-IDEA初始化-Git" class="headerlink" title="3. IDEA初始化 Git"></a>3. IDEA初始化 Git</h3><p>先创建一个名叫 HelloGit 的 Maven 工程。</p><p>在菜单栏 VCS -&gt; Import into Version Control -&gt; Create Git Repository</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/4bbfb1e76fb25655b3fe6900bb29ea47.png"></p><p>选择要创建 Git 本地仓库的工程，也就是 HelloGit 工程，然后添加 OK。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5dc609978787f3e5a83dbdf954a3e039.png"></p><h3 id="4-添加到暂存区-1"><a href="#4-添加到暂存区-1" class="headerlink" title="4. 添加到暂存区"></a>4. 添加到暂存区</h3><p>创建一个 HelloGit 类，将其添加 Git 暂存区。</p><p>右键点击 HelloGit 类，选择 Git-&gt;Add。可以右键点击 HelloGit项目根目录，更大范围地添加文件到暂存区。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9ec5087e543611c5ac99b171277f590.png"></p><p>添加成功后，文件名会从红色变成绿色。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/ec95c2b0b99d1f3a0ac8ad3291fdde50.png"></p><h3 id="5-提交至本地库"><a href="#5-提交至本地库" class="headerlink" title="5. 提交至本地库"></a>5. 提交至本地库</h3><p>右键点击 HelloGit，选择 Git-&gt;Commit Directory。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9a73d7bbac024bfe61951662f5bf6ded.png"></p><p>添加注释后提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/281c7f26319b59e7584103c2a3ee88dd.png"></p><p>添加成功后，后台打印相关信息。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3bdf7a9135d3ae80b9aad4d678626491.png"></p><h3 id="6-切换版本"><a href="#6-切换版本" class="headerlink" title="6. 切换版本"></a>6. 切换版本</h3><p>在 IDEA 的左下角，点击 Git，然后点击 Log 查看版本</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/69e6670ea5681781c173f1c86864ae1e.png"></p><p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5530ac3d829954cebd23ed15a681769f.png"></p><h3 id="7-创建分支"><a href="#7-创建分支" class="headerlink" title="7. 创建分支"></a>7. 创建分支</h3><p>右键点击 HelloGit，Git -&gt; Repository -&gt; Branches，或者点击 IDEA 的右下角，如图红圈所示部位：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3e31e84cd2f7b5b95bb2639abcb1804f.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c7544c1bade118b3177907ad903a8082.png"></p><p>选择点击 New Branch：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b9c18ec9924788adfa432b7b924308ce.png"></p><p>创建新分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/8a4a5e7cf7511d086ddac0be704e850f.png"></p><h3 id="8-切换分支"><a href="#8-切换分支" class="headerlink" title="8. 切换分支"></a>8. 切换分支</h3><p>跟<strong>创建分支</strong>步骤相似，如点击 IDEA 的右下角（它显示项目正处在那条分支），如图红圈所示部位，选择你想要切换的分支，然后 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/6678ecf9283ace1783e83e184847a29.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/afbbe9a835629f522d0b02024fe2c11b.png"></p><p>或者在 log 窗口，右键点击分支，选择 checkout：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/7ab6ab48e9b5a42009757b8b17b901f0.png"></p><h3 id="9-合并分支-正常合并"><a href="#9-合并分支-正常合并" class="headerlink" title="9. 合并分支 (正常合并)"></a>9. 合并分支 (正常合并)</h3><p>先在 hot-fix 分支修改 HelloGit 类，并将其提交：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/41667203b7e067b59d1310cce4d92b15.png"></p><p>然后切换到 master 分支，右下角的 hot-fix 会变为 master：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f183b86164b0e00e9d6e8c8c9a4a17da.png"></p><p>然后，点击 IDEA 窗口的右下角的 master，将 hot-fix 分支合并到当前 master 分支。选择 hot-fix-&gt;Merge into Current</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/fff1d4e014223aa2cc70f0fdc237f350.png"></p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/271421c28750e86e69accd6ac687490c.png"></p><h3 id="10-合并分支-冲突合并"><a href="#10-合并分支-冲突合并" class="headerlink" title="10. 合并分支 (冲突合并)"></a>10. 合并分支 (冲突合并)</h3><p>分别在 master，hot-fix 分支修改 HelloGit 类同一行，并提交，故意制作冲突：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/53daad680bc796069dc1ce61682d4abc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f8fcf275169cdec742d31ce85ce20d7f.png"></p><p>切换到 master 分支，将 hot-fix 的合并到 master 分支：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1573ef3ec85b85c4215189d74065012.png"></p><p>冲突产生，需要人工解决：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eb3804e00dccfa2658aa33c972d8996e.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/511c531d359729b40f0850a4c9e0398.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/eafebea94008b4f1f0ae15f8b2092919.png"></p><p>代码冲突解决，将代码提交本地库后，如图所示：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/15a9058f7f35112b8605cd69aaf42e35.png"></p><h2 id="六、IDEA集成GitHub"><a href="#六、IDEA集成GitHub" class="headerlink" title="六、IDEA集成GitHub"></a>六、IDEA集成GitHub</h2><h3 id="1-设置-GitHub-账号"><a href="#1-设置-GitHub-账号" class="headerlink" title="1. 设置 GitHub 账号"></a>1. 设置 GitHub 账号</h3><p>在菜单栏 File-&gt;Setting-&gt; 搜索栏搜 GitHub，添加 GitHub 账号：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/00572764f1ed257dbc2d0f668434e6a0.png"></p><p>由于网络问题，会时常登陆不了：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3084475acd640b1adf621688462a1504.png"></p><p>解决方法：可通过 Token 登陆。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/75ed9ef7614c18c244456c4089dfde6.png"></p><p>登陆 Github 网站，<strong>获取 Token</strong>，操作步骤看下图：</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1d162ac7e37a01549448032011f2a62.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/9b2489e068b004bee03a227760248edb.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/200c556f6f0b6d44c442b58d6e8bb7ea.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/81a82fb47421c0a802cd1cfad7297e43.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3f596f2f68d50d277eefe1a4e6035d2d.png"></p><p>将生成的 token 用来 IDEA 登录。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/704eafd9157658a0be35b081c3530ced.png"></p><h3 id="2-分享项目到-GitHub"><a href="#2-分享项目到-GitHub" class="headerlink" title="2. 分享项目到 GitHub"></a>2. 分享项目到 GitHub</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/e057d2e660c2033ef9eae0c638aee2bc.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/a5ba3e09a890113b94420c3939dac239.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/44b2419dd2eebc2c053fb642188e8909.png"></p><h3 id="3-推送代码到GitHub远程库"><a href="#3-推送代码到GitHub远程库" class="headerlink" title="3. 推送代码到GitHub远程库"></a>3. 推送代码到GitHub远程库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/84baeaa175c6faa3ff538e0313187eff.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1ee51e1ed781404a93655f1ad10bd9ca.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/bb9689e1fc2e1167e68ef39f73f28af7.png"></p><p>注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ <strong>因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！</strong></p><h3 id="4-拉取GitHub远程库代码合并本地库"><a href="#4-拉取GitHub远程库代码合并本地库" class="headerlink" title="4. 拉取GitHub远程库代码合并本地库"></a>4. 拉取GitHub远程库代码合并本地库</h3><p>右键点击项目，可以将远程仓库的内容 pull 到本地仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/193d00830bc1636e2ae2640b749b9899.png"></p><p>注意： pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p><h3 id="5-克隆代码到本地"><a href="#5-克隆代码到本地" class="headerlink" title="5. 克隆代码到本地"></a>5. 克隆代码到本地</h3><p>在菜单栏的 File-&gt;Close Project-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f436b8f9156e5e5ce8c0e2b3b5fe3639.png"></p><p>或者在菜单栏 VCS-&gt;Get from Version Control。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/63f9691dd0a7627bd44a125942be7f31.png"></p><h2 id="七、Gitee使用"><a href="#七、Gitee使用" class="headerlink" title="七、Gitee使用"></a>七、Gitee使用</h2><h3 id="1-Gitee简介-amp-创建远程库"><a href="#1-Gitee简介-amp-创建远程库" class="headerlink" title="1. Gitee简介 &amp; 创建远程库"></a>1. Gitee简介 &amp; 创建远程库</h3><h4 id="1-1-码云简介"><a href="#1-1-码云简介" class="headerlink" title="1.1 码云简介"></a>1.1 码云简介</h4><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况， 大家也可以使用国内的项目托管网站 - 码云。</p><p>码云是开源中国推出的基于 Git 的代码托管服务中心， 网址是 <a href="https://gitee.com/">https://gitee.com/</a> ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好，它是最好的选择。</p><p>而且，Gitee的操作和GitHub基本一样。</p><h4 id="1-2-创建远程库"><a href="#1-2-创建远程库" class="headerlink" title="1.2 创建远程库"></a>1.2 创建远程库</h4><p>跟 Github 的类似。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c8c01b7813e8578423ee2d790a580ee4.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/16341a72fa521e904f7b5a5489d4c693.png"></p><p>另外，可以从 GitHub 与 GitLab 中导入仓库。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/c5daf945afdd2f2836c1e9e20e8e389b.png"></p><p>点击刷新按钮，从GitHub获取更新</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3441eab01ee412c90cb4f2be908833f.png" alt="3441eab01ee412c90cb4f2be908833f"></p><h3 id="2-IDEA-集成-Gitee-码云"><a href="#2-IDEA-集成-Gitee-码云" class="headerlink" title="2. IDEA 集成 Gitee 码云"></a>2. IDEA 集成 Gitee 码云</h3><p>首先，要在 IDEA 安装 Gitee 插件。</p><p>在菜单栏选 File-&gt;Settings-&gt;Plugins，搜 Gitee。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/0241b8536ebed6fb08dcf04804c62cb0.png"></p><p>安装插件成功后，重启 IDEA。</p><p>功能跟在 IDEA 的 Github 插件，功能类似，如添加 Gitee 账号等，可参考前文 IDEA 的 Github 插件，触类旁通。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/87e35b8ee0fd1fd4136f2b2727cbf02a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/89e7174170b4ecc1c4ba896e3f1c9ad9.png"></p><h2 id="八、GitLab"><a href="#八、GitLab" class="headerlink" title="八、GitLab"></a>八、GitLab</h2><h3 id="1-GitLab简介-amp-安装环境准备"><a href="#1-GitLab简介-amp-安装环境准备" class="headerlink" title="1. GitLab简介 &amp; 安装环境准备"></a>1. GitLab简介 &amp; 安装环境准备</h3><h4 id="1-1-GitLab-简介"><a href="#1-1-GitLab-简介" class="headerlink" title="1.1 GitLab 简介"></a>1.1 GitLab 简介</h4><p>GitLab 是由 GitLab Inc. 开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有 wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。（可搭建局域网 Git 仓库）。</p><p>GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM， Sony， JülichResearchCenter， NASA， Alibaba，Invincea， O’ReillyMedia， Leibniz-Rechenzentrum(LRZ)， CERN， SpaceX 等组织使用。</p><h4 id="1-2-GitLab-官网地址"><a href="#1-2-GitLab-官网地址" class="headerlink" title="1.2 GitLab 官网地址"></a>1.2 GitLab 官网地址</h4><p><a href="https://about.gitlab.com/">官网地址</a></p><p><a href="https://about.gitlab.com/installation/">安装说明</a></p><h4 id="1-3-GitLab-安装准备"><a href="#1-3-GitLab-安装准备" class="headerlink" title="1.3 GitLab 安装准备"></a>1.3 GitLab 安装准备</h4><ol><li> 准备一个系统为 CentOS7 以上版本的服务器， 要求内存 4G，磁盘 50G。</li><li> 关闭防火墙， 并且配置好主机名和 IP，保证服务器可以上网。</li><li> 此教程使用虚拟机：主机名： gitlab-server <code>修改/etc/hostname文件为gitlab-server</code>IP 地址： 192.168.6.200(修改相对应文件)</li><li> Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。<a href="https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm">下载地址</a>。注：资料里提供了此 rpm 包，直接将此包上传到服务器 / opt/module 目录下即可。</li></ol><h3 id="2-GitLab-安装-amp-初始化服务-amp-启动服务"><a href="#2-GitLab-安装-amp-初始化服务-amp-启动服务" class="headerlink" title="2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务"></a>2. GitLab 安装 &amp; 初始化服务 &amp; 启动服务</h3><h4 id="2-1-编写安装脚本"><a href="#2-1-编写安装脚本" class="headerlink" title="2.1 编写安装脚本"></a>2.1 编写安装脚本</h4><p>安装 gitlab 步骤比较繁琐，因此我们可以参考<a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh">官网编写 gitlab 的安装脚本</a>。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@gitlab-server module]# <span class="hljs-keyword">vim</span> gitlab-install.<span class="hljs-keyword">sh</span><br>sudo rpm -ivh /<span class="hljs-keyword">opt</span>/module/gitlab-<span class="hljs-keyword">ce</span>-<span class="hljs-number">13.10</span>.<span class="hljs-number">2</span>-<span class="hljs-keyword">ce</span>.<span class="hljs-number">0</span>.el7.x86_64.rpm<br><br>sudo yum install -<span class="hljs-keyword">y</span> curl policycoreutils-<span class="hljs-keyword">python</span> openssh-server cronie<br><br>sudo lokkit -s http -s ssh<br><br>sudo yum install -<span class="hljs-keyword">y</span> postfix<br><br>sudo service postfix start<br><br>sudo chkconfig postfix <span class="hljs-keyword">on</span><br><br>curl http<span class="hljs-variable">s:</span>//packages.gitlab.<span class="hljs-keyword">com</span>/install/repositories/gitlab/gitlabce/script.rpm.<span class="hljs-keyword">sh</span> | sudo bash<br><br>sudo EXTERNAL_URL=<span class="hljs-string">&quot;http://gitlab.example.com&quot;</span> yum -<span class="hljs-keyword">y</span> install gitlabce<br><br></code></pre></td></tr></table></figure><p>给脚本增加执行权限</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@gitlab-server module]<span class="hljs-comment"># chmod +x gitlab-install.sh</span><br>[root@gitlab-server module]<span class="hljs-comment"># ll</span><br>总用量 403104<br>-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 412774002 </span>4 月<span class="hljs-number"> 7 </span>15:47 gitlab-ce-13.10.2-<br>ce.0.el7.x86_64.rpm<br>-rwxr-xr-x.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 416 </span>4 月<span class="hljs-number"> 7 </span>15:49 gitlab-install.sh<br><br></code></pre></td></tr></table></figure><p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@gitlab-server <span class="hljs-keyword">module</span>]# ./gitlab-install.sh<br>警告： /opt/<span class="hljs-keyword">module</span>/gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7.x86_64.rpm: 头 V4<br>RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY<br>准备中... #################################<br>[<span class="hljs-number">100</span>%]<br>正在升级/安装...<br><span class="hljs-number">1</span>:gitlab-ce<span class="hljs-number">-13.10</span><span class="hljs-number">.2</span>-ce<span class="hljs-number">.0</span>.el7<br>################################# [<span class="hljs-number">100</span>%]<br>。 。 。 。 。 。<br><br></code></pre></td></tr></table></figure><h4 id="2-2-初始化-GitLab-服务"><a href="#2-2-初始化-GitLab-服务" class="headerlink" title="2.2 初始化 GitLab 服务"></a>2.2 初始化 GitLab 服务</h4><p>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">[root<span class="hljs-variable">@gitlab</span><span class="hljs-operator">-</span>server <span class="hljs-keyword">module</span>]# gitlab<span class="hljs-operator">-</span>ctl reconfigure<br>。 。 。 。 。 。<br><span class="hljs-keyword">Running</span> handlers:<br><span class="hljs-keyword">Running</span> handlers complete<br>Chef Client finished, <span class="hljs-number">425</span><span class="hljs-operator">/</span><span class="hljs-number">608</span> resources updated <span class="hljs-keyword">in</span> <span class="hljs-number">03</span> minutes <span class="hljs-number">08</span><br>seconds<br>gitlab Reconfigured<span class="hljs-operator">!</span><br><br></code></pre></td></tr></table></figure><h4 id="2-3-启动-GitLab-服务"><a href="#2-3-启动-GitLab-服务" class="headerlink" title="2.3 启动 GitLab 服务"></a>2.3 启动 GitLab 服务</h4><p>执行以下命令启动 GitLab 服务，如需停止，执行 <code>gitlab-ctl stop</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@gitlab-server</span> <span class="hljs-string">module</span>]<span class="hljs-comment"># gitlab-ctl start</span><br><span class="hljs-attr">ok: run: alertmanager:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6812</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: gitaly:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6740</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-monitor:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6765</span><span class="hljs-string">)</span> <span class="hljs-string">135s</span><br><span class="hljs-attr">ok: run: gitlab-workhorse:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6722</span><span class="hljs-string">)</span> <span class="hljs-string">136s</span><br><span class="hljs-attr">ok: run: logrotate:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5994</span><span class="hljs-string">)</span> <span class="hljs-string">197s</span><br><span class="hljs-attr">ok: run: nginx:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5930</span><span class="hljs-string">)</span> <span class="hljs-string">203s</span><br><span class="hljs-attr">ok: run: node-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6234</span><span class="hljs-string">)</span> <span class="hljs-string">185s</span><br><span class="hljs-attr">ok: run: postgres-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6834</span><span class="hljs-string">)</span> <span class="hljs-string">133s</span><br><span class="hljs-attr">ok: run: postgresql:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5456</span><span class="hljs-string">)</span> <span class="hljs-string">257s</span><br><span class="hljs-attr">ok: run: prometheus:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6777</span><span class="hljs-string">)</span> <span class="hljs-string">134s</span><br><span class="hljs-attr">ok: run: redis:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5327</span><span class="hljs-string">)</span> <span class="hljs-string">263s</span><br><span class="hljs-attr">ok: run: redis-exporter:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">6391</span><span class="hljs-string">)</span> <span class="hljs-string">173s</span><br><span class="hljs-attr">ok: run: sidekiq:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5797</span><span class="hljs-string">)</span> <span class="hljs-string">215s</span><br><span class="hljs-attr">ok: run: unicorn:</span> <span class="hljs-string">(pid</span> <span class="hljs-number">5728</span><span class="hljs-string">)</span> <span class="hljs-string">221s</span><br><br></code></pre></td></tr></table></figure><h3 id="3-GitLab-登录-amp-创建远程库"><a href="#3-GitLab-登录-amp-创建远程库" class="headerlink" title="3. GitLab 登录 &amp; 创建远程库"></a>3. GitLab 登录 &amp; 创建远程库</h3><h4 id="3-1-登录-GitLab"><a href="#3-1-登录-GitLab" class="headerlink" title="3.1 登录 GitLab"></a>3.1 登录 GitLab</h4><p>使用主机名或者 IP 地址即可访问 GitLab 服务。可配一下 windows 的 hosts 文件（C:\Windows\System32\drivers\etc）。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/048956890f1e644fb77e8d58092a8b6d.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1870c658dcabcf08fbc3b5b9fa6b2243.png"></p><p>首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。</p><p>然后使用修改后的密码登录 GitLab。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5608650ec5e913d5ab549f30fbb477d3.png"></p><p>GitLab 登录成功。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/3231f6dd1a07f90326ec0506eaae747f.png"></p><h4 id="3-2-创建远程库"><a href="#3-2-创建远程库" class="headerlink" title="3.2 创建远程库"></a>3.2 创建远程库</h4><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/2ab639dfaa57cd499133c2c4cde1222a.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/f135a7b76c745c3aeef9034a82c8afaf.png"></p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/5ff82d173fe047244945c8cd255a4b33.png"></p><h3 id="4-IDEA-集成-GitLab"><a href="#4-IDEA-集成-GitLab" class="headerlink" title="4. IDEA 集成 GitLab"></a>4. IDEA 集成 GitLab</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/1f34175126922c56c158f466dd4d665c.png"></p><p>接下来插件配置，Git 操作等与 Github、Gitee 的 IDEA 插件大同小异，不再赘述，自己触类旁通吧！</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用方法</title>
    <link href="/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/18/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用方法"><a href="#Hexo使用方法" class="headerlink" title="Hexo使用方法"></a>Hexo使用方法</h1><h2 id="一、搭建Hexo博客"><a href="#一、搭建Hexo博客" class="headerlink" title="一、搭建Hexo博客"></a>一、搭建Hexo博客</h2><h3 id="1-下载Node-js"><a href="#1-下载Node-js" class="headerlink" title="1. 下载Node.js"></a>1. 下载Node.js</h3><p>去<a href="https://nodejs.org/en/">Node.js官网</a>下载Node.js稳定版本</p><h3 id="2-更换下载cnpm并更换淘宝源"><a href="#2-更换下载cnpm并更换淘宝源" class="headerlink" title="2. 更换下载cnpm并更换淘宝源"></a>2. 更换下载cnpm并更换淘宝源</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="3-Windows特殊操作"><a href="#3-Windows特殊操作" class="headerlink" title="3. Windows特殊操作"></a>3. Windows特殊操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set-ExecutionPolicy RemoteSigned<br></code></pre></td></tr></table></figure><p>更改策略，放行cnpm</p><h3 id="4-安装Hexo博客框架"><a href="#4-安装Hexo博客框架" class="headerlink" title="4. 安装Hexo博客框架"></a>4. 安装Hexo博客框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="5-建立博客文件夹"><a href="#5-建立博客文件夹" class="headerlink" title="5. 建立博客文件夹"></a>5. 建立博客文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir blog<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，从这里往下，所有步骤都是在<code>blog</code>文件夹下的。</strong></p><h3 id="6-生成Hexo博客"><a href="#6-生成Hexo博客" class="headerlink" title="6. 生成Hexo博客"></a>6. 生成Hexo博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hexo init<br></code></pre></td></tr></table></figure><h2 id="二、使用Hexo"><a href="#二、使用Hexo" class="headerlink" title="二、使用Hexo"></a>二、使用Hexo</h2><h3 id="1-本地启动博客"><a href="#1-本地启动博客" class="headerlink" title="1. 本地启动博客"></a>1. 本地启动博客</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>hexo start</p><h3 id="2-新建一篇文章"><a href="#2-新建一篇文章" class="headerlink" title="2. 新建一篇文章"></a>2. 新建一篇文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &quot;文章名&quot;<br></code></pre></td></tr></table></figure><p>然后就可以在<code>blog\source\_posts</code>路径下看见生成的文章。</p><h3 id="3-Hexo-清理"><a href="#3-Hexo-清理" class="headerlink" title="3. Hexo 清理"></a>3. Hexo 清理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo-生成"><a href="#4-Hexo-生成" class="headerlink" title="4. Hexo 生成"></a>4. Hexo 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>hexo generate</p><h3 id="5-一篇文章配置多个分类"><a href="#5-一篇文章配置多个分类" class="headerlink" title="5. 一篇文章配置多个分类"></a>5. 一篇文章配置多个分类</h3><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> Java<br><span class="hljs-bullet">  -</span> Servlet<br></code></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">categories</span>:<span class="hljs-meta"> [Java, Servlet]</span><br></code></pre></td></tr></table></figure><p>上面两种方法最终效果一样，都是将文章放在了一个子分类的目录下，效果如图。</p><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/uPic/12972816-cc5be43b9b70f040.png"> </p><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> [Java]<br><span class="hljs-bullet">  -</span> [Servlet]<br></code></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。<strong>此处需要特别注意的是，- 与 [ 之间有空格。</strong></p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> [Java, Servlet]<br><span class="hljs-bullet">  -</span> [Programming]<br></code></pre></td></tr></table></figure><h3 id="6-一篇文章配置多个标签"><a href="#6-一篇文章配置多个标签" class="headerlink" title="6. 一篇文章配置多个标签"></a>6. 一篇文章配置多个标签</h3><p>配置格式如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">tag:<br><span class="hljs-bullet">    -</span> 前端<br><span class="hljs-bullet">    -</span> Hexo<br><span class="hljs-bullet">    -</span> HTML<br><span class="hljs-bullet">    -</span> JavaScript<br></code></pre></td></tr></table></figure><h2 id="三、将博客部署到Github上"><a href="#三、将博客部署到Github上" class="headerlink" title="三、将博客部署到Github上"></a>三、将博客部署到Github上</h2><p>将博客部署到Github上，这样不用备案也不用云服务器，比较方便。</p><h3 id="1-Github上新建仓库"><a href="#1-Github上新建仓库" class="headerlink" title="1. Github上新建仓库"></a>1. Github上新建仓库</h3><p><img src="https://raw.githubusercontent.com/JYGQAQ/PicGo/master/b39cf6827134af18affb5fbc934318e.png"></p><p>需要注意的是，这里仓库名<strong>必须</strong>是<code>用户名.github.io</code>。</p><h3 id="2-安装Git部署插件"><a href="#2-安装Git部署插件" class="headerlink" title="2. 安装Git部署插件"></a>2. 安装Git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="3-在-config-yml更改配置"><a href="#3-在-config-yml更改配置" class="headerlink" title="3. 在_config.yml更改配置"></a>3. 在_config.yml更改配置</h3><p>在<code>_config.yml</code>的<code>deploy:</code>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">type: git<br>repo: https://github.com/JYGQAQ/JYGQAQ.github.io<br>branch: master<br></code></pre></td></tr></table></figure><h3 id="4-Hexo部署到远端"><a href="#4-Hexo部署到远端" class="headerlink" title="4. Hexo部署到远端"></a>4. Hexo部署到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>deploy : 部署</p><p><strong>若此处出现<code>Error： Spawn failed</code></strong></p><h4 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a>解决方法一：</h4><p><strong>可以尝试将<code>_config.yml</code>中的<code>repo</code>改为<code>ssh</code>方式</strong></p><p>原因如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git不再支持用户名密码验证了，其实改一下仓库地址就可以了。<br>原来用的https的仓库，改成ssh的仓库地址就行了。<br></code></pre></td></tr></table></figure><h4 id="解决方法二："><a href="#解决方法二：" class="headerlink" title="解决方法二："></a>解决方法二：</h4><ol><li><p>打开GitHub主页，点击头像找到Settings</p></li><li><p>在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请</p></li><li><p>Scopes那里可以全选</p></li><li><p>在mac上打开keychain access，搜索GitHub，输入刚刚的Token(需要注意的是token生成后一定要复制，刷新github就再也看不到了，需要重新生成)</p></li><li><p>执行以下命令<br> <code>$ git remote add origin https://“刚刚得到的Token“@github.com/“User名”/“仓库名（XXX.github.io）”.git</code></p></li><li><p>修改Hexo的 config.yml配置文件</p></li></ol>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">deploy:<br>  type: git<br>  repo: https:<span class="hljs-regexp">//</span><span class="hljs-string">&quot;Token&quot;</span>@github.com<span class="hljs-regexp">/“用户名”/</span>“仓库名（XXX.github.io）”.git<br>  branch: master<br></code></pre></td></tr></table></figure><h3 id="5-访问博客"><a href="#5-访问博客" class="headerlink" title="5. 访问博客"></a>5. 访问博客</h3><p>博客的网址就是仓库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jygqaq.github.io<br></code></pre></td></tr></table></figure><p>由于域名没有大小写，所以是小写。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><h3 id="1-克隆主题仓库"><a href="#1-克隆主题仓库" class="headerlink" title="1. 克隆主题仓库"></a>1. 克隆主题仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:jerryc127/hexo-theme-butterfly.git themes/butterfly<br></code></pre></td></tr></table></figure><p>把项目clone到themes目录下的butterfly文件夹</p><p>使用butterfly还需要安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-pug hexo-renderer-stylus --save<br></code></pre></td></tr></table></figure><h3 id="2-更改Hexo配置文件"><a href="#2-更改Hexo配置文件" class="headerlink" title="2. 更改Hexo配置文件"></a>2. 更改Hexo配置文件</h3><p>更改<code>_config.yml</code>配置文件中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: butterfly<br></code></pre></td></tr></table></figure><h3 id="3-清理Hexo"><a href="#3-清理Hexo" class="headerlink" title="3. 清理Hexo"></a>3. 清理Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><h3 id="4-Hexo生成"><a href="#4-Hexo生成" class="headerlink" title="4. Hexo生成"></a>4. Hexo生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="5-Hexo-Start"><a href="#5-Hexo-Start" class="headerlink" title="5. Hexo Start"></a>5. Hexo Start</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>需要注意的是，如果使用<code>fluid</code>主题，那么<code>themes/fluid/_config.yml</code>比<code>themes/fluid/_config.fluid.yml</code>优先级要高。</p><h2 id="五、迁移博客"><a href="#五、迁移博客" class="headerlink" title="五、迁移博客"></a>五、迁移博客</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h3><p>根据本博客重新配置环境</p><h3 id="2-更换文件"><a href="#2-更换文件" class="headerlink" title="2. 更换文件"></a>2. 更换文件</h3><p>需要跟换以下文件：</p><ul><li><code>_config.yml</code></li><li><code>package.json</code></li><li><code>scaffolds</code></li><li><code>source</code></li><li><code>theme</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
